<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h": {"id": "/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h", "filePath": "/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n/**@file\n * Various utilities. Used by other nx_kit components.\n *\n * This unit can be compiled in the context of any C++ project. If Qt headers are included before\n * this one, some Qt support is enabled via &quot;#if defined(QT_CORE_LIB)&quot;.\n */\n\n#include &lt;cstddef&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\n#if defined(QT_CORE_LIB)\n    // To be supported in toString().\n    #include &lt;QtCore/QByteArray&gt;\n    #include &lt;QtCore/QString&gt;\n    #include &lt;QtCore/QUrl&gt;\n#endif\n\n#if !defined(NX_KIT_API)\n    #define NX_KIT_API /*empty*/\n#endif\n\nnamespace nx {\nnamespace kit {\nnamespace utils {\n\n//-------------------------------------------------------------------------------------------------\n// Strings.\n\ninline bool isAsciiPrintable(int c)\n{\n    return c &gt;= 32 &amp;&amp; c &lt;= 126;\n}\n\ninline bool isSpaceOrControlChar(char c)\n{\n    // NOTE: Chars 128..255 should be treated as non-whitespace, thus, isprint() will not do.\n    return (((unsigned char) c) &lt;= 32) || (c == 127);\n}\n\n/**\n * Decodes a string encoded using C/C++ string literal rules: enquoted, potentially containing\n * escape sequences. Supports concatenation of consecutive literals, thus, fully compatible with\n * strings encoded by nx::kit::utils::toString().\n *\n * @param outErrorMessage In case of any error in the encoded string, the function attempts to\n *     recover using the most obvious way, still producing the result, and reports all such cases\n *     via this argument if it is not null.\n */\nNX_KIT_API std::string decodeEscapedString(\n    const std::string&amp; s, std::string* outErrorMessage = nullptr);\n\n/**\n * Converts a value to its report-friendly text representation; for strings it being a quoted and\n * C-style-escaped string. Non-printable chars in a string are represented as hex escape sequences\n * like `\\xFF&quot;&quot;` - note that the two quotes after it are inserted to indicate the end of the hex\n * number, because according to the C/C++ standards, `\\x` consumes as much hex digits as possible.\n */\ntemplate&lt;typename T&gt;\nstd::string toString(T value);\n\n/**\n * ATTENTION: std::string is not supported as one of `args`, and will cause undefined behavior.\n */\ntemplate&lt;typename... Args&gt;\nstd::string format(const std::string&amp; formatStr, Args... args)\n{\n    const int size = snprintf(nullptr, 0, formatStr.c_str(), args...) + /*space for \\0*/ 1;\n    if (size &lt;= 0)\n        return formatStr; //&lt; No better way to handle out-of-memory-like errors.\n    std::string result(size, &#x27;\\0&#x27;);\n    snprintf(&amp;result[0], size, formatStr.c_str(), args...);\n    result.resize(size - /*terminating \\0*/ 1);\n    return result;\n}\n\nNX_KIT_API bool fromString(const std::string&amp; s, int* value);\nNX_KIT_API bool fromString(const std::string&amp; s, double* value);\nNX_KIT_API bool fromString(const std::string&amp; s, float* value);\nNX_KIT_API bool fromString(const std::string&amp; s, bool* value);\n\nNX_KIT_API void stringReplaceAllChars(std::string* s, char sample, char replacement);\nNX_KIT_API void stringInsertAfterEach(std::string* s, char sample, const char* insertion);\nNX_KIT_API void stringReplaceAll(\n    std::string* s, const std::string&amp; sample, const std::string&amp; replacement);\n\n// TODO: Remove when migrating to C++20 - it has std::string::starts_with()/ends_with().\nNX_KIT_API bool stringStartsWith(const std::string&amp; s, const std::string&amp; prefix);\nNX_KIT_API bool stringEndsWith(const std::string&amp; s, const std::string&amp; suffix);\n\n// TODO: Remove when migrating to C++23 - it has std::string::contains().\nNX_KIT_API bool stringContains(const std::string&amp; s, const std::string&amp; substring);\n\nNX_KIT_API std::string trimString(const std::string&amp; s);\n\n//-------------------------------------------------------------------------------------------------\n// OS support.\n\nconstexpr char kPathSeparator =\n    #if defined(_WIN32)\n        &#x27;\\\\&#x27;;\n    #else\n        &#x27;/&#x27;;\n    #endif\n\n/**\n * @return Last path component: text after the last path separator. On Windows, possible `&lt;drive&gt;:`\n * prefix is excluded and both `/` and `\\` are supported. If path is empty, the result is empty.\n */\nNX_KIT_API std::string baseName(std::string path);\n\n/**\n * If the specified path is absolute, just return it, otherwise, convert it to an absolute path\n * using the specified origin dir. On Windows, both `/` and `\\` are supported, and paths without\n * a drive letter but started with `/` or `\\` are treated as absolute.\n */\nNX_KIT_API std::string absolutePath(\n    const std::string&amp; originDir, const std::string&amp; path);\n\n/**\n * @return Process name, without .exe in Windows.\n */\nNX_KIT_API std::string getProcessName();\n\n/**\n * @return Command line arguments of the process, cached after the first call. If arguments are\n *     not available, then returns a single empty string.\n */\nNX_KIT_API const std::vector&lt;std::string&gt;&amp; getProcessCmdLineArgs();\n\n/**\n * @return Absolute path to the executable file, cached after the first call. If the path cannot be\n *     determined, returns an empty string.\n */\nNX_KIT_API std::string getPathToExecutable();\n\nNX_KIT_API bool fileExists(const char* filename);\n\n//-------------------------------------------------------------------------------------------------\n// Aligned allocation.\n\n/**\n * Aligns value up to alignment boundary.\n * @param alignment If zero, value is returned unchanged.\n */\ninline size_t alignUp(size_t value, size_t alignment)\n{\n    if (alignment == 0)\n        return value;\n    const size_t remainder = value % alignment;\n    if (remainder == 0)\n        return value;\n    return value + alignment - remainder;\n}\n\n/** Shifts the pointer up to deliberately misalign it to an odd address - intended for tests. */\ninline uint8_t* misalignedPtr(void* data)\n{\n    return (uint8_t*) (17 + alignUp((uintptr_t) data, 32));\n}\n\n/**\n * Allocates size bytes of data, aligned to alignment boundary.\n *\n * NOTE: Allocated memory must be freed with a call to freeAligned().\n * NOTE: This function is as safe as malloc().\n *\n * @param mallocFunc Function with the signature void*(size_t), which is called to allocate memory.\n */\ntemplate&lt;class MallocFunc&gt;\nvoid* mallocAligned(size_t size, size_t alignment, MallocFunc mallocFunc)\n{\n    if (alignment == 0)\n        return nullptr;\n    const auto ptr = (char*) mallocFunc(size + alignment + sizeof(alignment));\n    if (!ptr) //&lt; allocation error\n        return ptr;\n\n    char* const alignedPtr = ptr + sizeof(alignment); //&lt; Leaving place to save misalignment.\n    const size_t misalignment = alignment - (uintptr_t) alignedPtr % alignment;\n    memcpy(ptr + misalignment, &amp;misalignment, sizeof(misalignment)); //&lt; Save misalignment.\n    return alignedPtr + misalignment;\n}\n\n/** Calls mallocAligned() passing standard malloc() as mallocFunc. */\ninline void* mallocAligned(size_t size, size_t alignment)\n{\n    // NOTE: Lambda is used to suppress a warning that some ::malloc() implementations are using\n    // deprecated exception specification.\n    return mallocAligned&lt;&gt;(size, alignment, [](size_t size) { return ::malloc(size); });\n}\n\n/**\n * Free ptr allocated with a call to mallocAligned().\n *\n * NOTE: This function is as safe as ::free().\n *\n * @param freeFunc Function with the signature void(void*), which is called to free the memory.\n */\ntemplate&lt;class FreeFunc&gt;\nvoid freeAligned(void* ptr, FreeFunc freeFunc)\n{\n    if (!ptr)\n        return freeFunc(ptr);\n\n    ptr = (char*) ptr - sizeof(size_t);\n    size_t misalignment = 0;\n    memcpy(&amp;misalignment, ptr, sizeof(misalignment)); //&lt; Retrieve saved misalignment.\n    ptr = (char*) ptr - misalignment;\n\n    freeFunc(ptr);\n}\n\n/** Calls freeAligned() passing standard free() as freeFunc. */\ninline void freeAligned(void* ptr)\n{\n    // NOTE: Lambda is used to suppress a warning that some ::free() implementations are using\n    // deprecated exception specification.\n    return freeAligned&lt;&gt;(ptr, [](void* ptr) { return ::free(ptr); });\n}\n\n//-------------------------------------------------------------------------------------------------\n// Implementation.\n\n// The order of overloads below is important - it defines which will be chosen by inline functions.\nNX_KIT_API std::string toString(bool b);\nNX_KIT_API std::string toString(const void* ptr);\ninline std::string toString(void* ptr) { return toString(const_cast&lt;const void*&gt;(ptr)); }\ninline std::string toString(std::nullptr_t ptr) { return toString((const void*) ptr); }\ninline std::string toString(uint8_t i) { return toString((int) i); } //&lt; Avoid matching as char.\ninline std::string toString(int8_t i) { return toString((int) i); } //&lt; Avoid matching as char.\nNX_KIT_API std::string toString(char c);\nNX_KIT_API std::string toString(const char* s);\ninline std::string toString(char* s) { return toString(const_cast&lt;const char*&gt;(s)); }\nNX_KIT_API std::string toString(wchar_t c);\nNX_KIT_API std::string toString(const wchar_t* w);\ninline std::string toString(wchar_t* w) { return toString(const_cast&lt;const wchar_t*&gt;(w)); }\n\n// std::string can contain &#x27;\\0&#x27; inside, hence a dedicated implementation.\nNX_KIT_API std::string toString(const std::string&amp; s);\nNX_KIT_API std::string toString(const std::wstring&amp; w);\n\n\n/** For unknown types, use their operator&lt;&lt;(). */\ntemplate&lt;typename T&gt;\nstd::string toString(T value)\n{\n    std::ostringstream outputString;\n    outputString &lt;&lt; value;\n    return outputString.str();\n}\n\n#if defined(QT_CORE_LIB)\n\nstatic inline std::string toString(QByteArray b) //&lt; By value to avoid calling the template impl.\n{\n    return toString(b.toStdString());\n}\n\nstatic inline std::string toString(QString s) //&lt; By value to avoid calling the template impl.\n{\n    return toString(s.toUtf8().constData());\n}\n\nstatic inline std::string toString(QUrl u) //&lt; By value to avoid calling the template impl.\n{\n    return toString(u.toEncoded().toStdString());\n}\n\n#endif // defined(QT_CORE_LIB)\n\ntemplate&lt;typename P&gt;\nstd::string toString(P* ptr)\n{\n    return toString((const void*) ptr);\n}\n\n//-------------------------------------------------------------------------------------------------\n// Configuration file parsing.\n\nNX_KIT_API bool parseNameValueFile(\n    const std::string&amp; nameValueFilePath,\n    std::map&lt;std::string, std::string&gt;* nameValueMap,\n    const std::string&amp; errorPrefix,\n    std::ostream* out,\n    bool* isFileEmpty);\n\n//-------------------------------------------------------------------------------------------------\n// String conversions.\n\n/** Converts ASCII characters from the input string to the upper case. */\nNX_KIT_API std::string toUpper(const std::string&amp; str);\n\n#if defined(_WIN32)\n\n/** Converts a UTF-16 string via WinAPI to a UTF-8 std::string. */\nNX_KIT_API std::string wideCharToStdString(const wchar_t* str);\n\n#endif // defined(_WIN32)\n\n} // namespace utils\n} // namespace kit\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h": {"id": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "filePath": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_FUSION_KEYS_H\n#define QN_FUSION_KEYS_H\n\n#ifndef Q_MOC_RUN\n    #include &lt;boost/preprocessor/cat.hpp&gt;\n#endif\n\n/**\n * This macro defines a new fusion key. It must be used in global namespace.\n * Defined key can then be accessed from the QnFusion namespace.\n *\n * \\param KEY                           Key to define.\n */\n#define QN_FUSION_DEFINE_KEY(KEY)                                               \\\nnamespace QnFusion {                                                            \\\n    struct BOOST_PP_CAT(KEY, _type) {};                                         \\\n    namespace {                                                                 \\\n        const BOOST_PP_CAT(KEY, _type) KEY = {};                                \\\n    }                                                                           \\\n}\n\n/**\n * \\param KEY                           Fusion key.\n * \\returns                             C++ type of the provided fusion key.\n */\n#define QN_FUSION_KEY_TYPE(KEY)                                                 \\\n    QnFusion::BOOST_PP_CAT(KEY, _type)\n\nQN_FUSION_DEFINE_KEY(base)\nQN_FUSION_DEFINE_KEY(member_index)\nQN_FUSION_DEFINE_KEY(member_count)\nQN_FUSION_DEFINE_KEY(object_declval)\nQN_FUSION_DEFINE_KEY(getter)\nQN_FUSION_DEFINE_KEY(setter)\nQN_FUSION_DEFINE_KEY(setter_tag)\nQN_FUSION_DEFINE_KEY(checker)\nQN_FUSION_DEFINE_KEY(name)\nQN_FUSION_DEFINE_KEY(c_name)\nQN_FUSION_DEFINE_KEY(sql_placeholder_name)\nQN_FUSION_DEFINE_KEY(classname)\nQN_FUSION_DEFINE_KEY(c_classname)\nQN_FUSION_DEFINE_KEY(optional)\nQN_FUSION_DEFINE_KEY(brief)\n\n#define QN_FUSION_PROPERTY_IS_EXTENDED_FOR_base true\n#define QN_FUSION_PROPERTY_EXTENSION_FOR_base(KEY, VALUE) (base, std::declval&lt;VALUE&gt;())\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_name true\n#define QN_FUSION_PROPERTY_TYPE_FOR_name QString\n#define QN_FUSION_PROPERTY_IS_EXTENDED_FOR_name true\n#define QN_FUSION_PROPERTY_EXTENSION_FOR_name(KEY, VALUE) (name, QStringLiteral(VALUE))(c_name, VALUE)(sql_placeholder_name, QStringLiteral(&quot;:&quot; VALUE))\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_c_name true\n#define QN_FUSION_PROPERTY_TYPE_FOR_c_name const char *\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_sql_placeholder_name true\n#define QN_FUSION_PROPERTY_TYPE_FOR_sql_placeholder_name QString\n\n#define QN_FUSION_PROPERTY_IS_EXTENDED_FOR_setter true\n#define QN_FUSION_PROPERTY_EXTENSION_FOR_setter(KEY, VALUE) (setter, VALUE)(setter_tag, QnFusionDetail::make_access_setter_category(access_type()))\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_classname true\n#define QN_FUSION_PROPERTY_TYPE_FOR_classname QString\n#define QN_FUSION_PROPERTY_IS_EXTENDED_FOR_classname true\n#define QN_FUSION_PROPERTY_EXTENSION_FOR_classname(KEY, VALUE) (classname, QStringLiteral(VALUE))(c_classname, VALUE)\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_c_classname true\n#define QN_FUSION_PROPERTY_TYPE_FOR_c_classname const char *\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_optional true\n#define QN_FUSION_PROPERTY_TYPE_FOR_optional bool\n\n#define QN_FUSION_PROPERTY_IS_TYPED_FOR_brief true\n#define QN_FUSION_PROPERTY_TYPE_FOR_brief bool\n\n/**\n * \\internal\n *\n * Produces a &lt;tt&gt;QStringLiteral&lt;/tt&gt; from the given character literals.\n * Works around a MSVC pre-2015 bug that prevents us to simply use &lt;tt&gt;QStringLiteral(&quot;a&quot; &quot;b&quot;)&lt;/tt&gt;.\n */\n#define QN_FUSION_LIT_CAT(A, B) \\\n    QN_FUSION_LIT_CAT_I(A, B)\n\n#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900 //&lt; MSVC pre-2015\n#   define QN_FUSION_LIT_CAT_I(A, B) QStringLiteral(A BOOST_PP_CAT(L, B))\n#else\n#   define QN_FUSION_LIT_CAT_I(A, B) QStringLiteral(A B)\n#endif\n\n#endif // QN_FUSION_KEYS_H\n"}, "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h": {"id": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h", "filePath": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;optional&gt;\n#include &lt;typeinfo&gt;\n#include &lt;unordered_set&gt;\n\n#include &lt;QtCore/QJsonDocument&gt;\n#include &lt;QtCore/QJsonObject&gt;\n\n#include &lt;nx/fusion/serialization/serialization.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/json/exceptions.h&gt;\n#include &lt;nx/utils/log/log_main.h&gt;\n\n#include &quot;json_fwd.h&quot;\n\nclass QnJsonSerializer;\n\ntemplate&lt;typename Type, typename Enable = void&gt;\nstruct HasDirectObjectKeySerializer: std::false_type\n{\n};\n\n// Should have key serializers for all enum values\ntemplate&lt;typename Type&gt;\nstruct HasDirectObjectKeySerializer&lt;Type, std::enable_if_t&lt;std::is_enum_v&lt;Type&gt;&gt;&gt;: std::true_type\n{\n};\n\nnamespace QJsonDetail {\n\nNX_FUSION_API void serialize_json(const QJsonValue&amp; value, QByteArray* outTarget,\n    QJsonDocument::JsonFormat format = QJsonDocument::Compact);\n\nNX_FUSION_API bool deserialize_json(\n    const QByteArray&amp; value, QJsonValue* outTarget, QString* errorMessage = nullptr);\n\nstruct StorageInstance\n{\n    NX_FUSION_API QnSerializerStorage&lt;QnJsonSerializer&gt;* operator()() const;\n};\n\nNX_FUSION_API QJsonObject::const_iterator findField(\n    const QJsonObject&amp; jsonObject,\n    const QString&amp; fieldName,\n    DeprecatedFieldNames* deprecatedFieldNames,\n    const std::type_info&amp; structTypeInfo,\n    bool optional);\n\n} // namespace QJsonDetail\n\nclass QnJsonContext: public QnSerializationContext&lt;QnJsonSerializer&gt;\n{\npublic:\n    bool areSomeFieldsNotFound() const { return m_someFieldsNotFound; }\n    void setSomeFieldsNotFound(bool value) { m_someFieldsNotFound = value; }\n\n    bool trackUnparsed() const { return m_trackUnparsed; }\n    void setTrackUnparsed(bool value) { m_trackUnparsed = value; }\n\n    bool serializeMapToObject() const { return m_serializeMapToObject; }\n    void setSerializeMapToObject(bool value) { m_serializeMapToObject = value; }\n\n    bool isMapKeyDeserializationMode() const { return m_isMapKeyDeserializationMode; }\n    void setIsMapKeyDeserializationMode(bool value) { m_isMapKeyDeserializationMode = value; }\n\n    bool areStringConversionsAllowed() const { return m_allowStringConversions; }\n    void setAllowStringConversions(bool value) { m_allowStringConversions = value; }\n\n    template&lt;typename T&gt;\n    bool isOptionalDefaultSerialization() const\n    {\n        auto type = std::type_index(typeid(T));\n        return m_optionalDefaultSerialization &amp;&amp; m_typeRecursions.find(type) == m_typeRecursions.end();\n    }\n\n    template&lt;typename T&gt;\n    void addTypeToProcessed()\n    {\n        auto type = std::type_index(typeid(T));\n        m_typeRecursions.insert(type);\n    }\n\n    template&lt;typename T&gt;\n    void removeTypeFromProcessed()\n    {\n        auto type = std::type_index(typeid(T));\n        m_typeRecursions.extract(type);\n    }\n\n    void setOptionalDefaultSerialization(bool value)\n    {\n        m_optionalDefaultSerialization = value;\n    }\n\n    bool doesDeserializeReplaceExistingOptional() const\n    {\n        return m_deserializeReplacesExistingOptional;\n    }\n\n    void deserializeReplacesExistingOptional(bool value)\n    {\n        m_deserializeReplacesExistingOptional = value;\n    }\n\n    bool isStrictMode() const { return m_strictMode; }\n    void setStrictMode(bool value) { m_strictMode = value; }\n\n    bool isChronoSerializedAsDouble() const { return m_chronoSerializedAsDouble; }\n    void setChronoSerializedAsDouble(bool value) { m_chronoSerializedAsDouble = value; }\n\n    bool serializeUuidWithBraces() const { return m_serializeUuidWithBraces; }\n    void setSerializeUuidWithBraces(bool value) { m_serializeUuidWithBraces = value; }\n\n    void resetFailedKeyValue() { m_failed = {}; }\n    const std::pair&lt;QString, QString&gt;&amp; getFailedKeyValue() const { return m_failed; }\n    void setFailedKeyValue(const std::pair&lt;QString, QString&gt;&amp; failed)\n    {\n        if (m_failed.first.isEmpty())\n            m_failed = failed;\n        else\n            m_failed.first.prepend(failed.first + &#x27;.&#x27;);\n    }\n\nprivate:\n    bool m_someFieldsNotFound{false};\n    bool m_trackUnparsed{false};\n    bool m_serializeMapToObject{false};\n    bool m_isMapKeyDeserializationMode{false};\n    bool m_allowStringConversions{false};\n    bool m_optionalDefaultSerialization = false;\n    bool m_strictMode = false;\n    bool m_deserializeReplacesExistingOptional = true;\n\n    // TODO: #ekarpov Make `m_chronoSerializedAsDouble = true` after version 4.0 support is dropped.\n    bool m_chronoSerializedAsDouble = false;\n\n    // TODO: #ekarpov Make `m_serializeUuidWithBraces = false` after REST v3 support is dropped.\n    bool m_serializeUuidWithBraces = true;\n\n    std::pair&lt;QString, QString&gt; m_failed;\n    mutable std::unordered_set&lt;std::type_index&gt; m_typeRecursions;\n};\n\nclass QnJsonSerializer:\n    public QnContextSerializer&lt;QJsonValue, QnJsonContext&gt;,\n    public QnStaticSerializerStorage&lt;QnJsonSerializer, QJsonDetail::StorageInstance&gt;\n{\n    typedef QnContextSerializer&lt;QJsonValue, QnJsonContext&gt; base_type;\npublic:\n    QnJsonSerializer(QMetaType type): base_type(type) {}\n};\n\ntemplate&lt;class T&gt;\nclass QnDefaultJsonSerializer: public QnDefaultContextSerializer&lt;T, QnJsonSerializer&gt;\n{\n};\n\nnamespace QJson {\n\ninline QByteArray serialize(const QJsonValue &amp;value)\n{\n    QByteArray result;\n    QJsonDetail::serialize_json(value, &amp;result);\n    return result;\n}\n\n/**\n * Serialize the given value into intermediate JSON representation.\n * @param ctx JSON context to use.\n * @param value Value to serialize.\n * @param[out] outTarget Target JSON value, must not be nullptr.\n */\ntemplate&lt;class T&gt;\nvoid serialize(QnJsonContext* ctx, const T&amp; value, QJsonValue* outTarget)\n{\n    QnSerialization::serialize(ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(QnJsonContext* ctx, const T&amp; value, QJsonValueRef* outTarget)\n{\n    NX_ASSERT(outTarget);\n\n    QJsonValue jsonValue;\n    QnSerialization::serialize(ctx, value, &amp;jsonValue);\n    *outTarget = jsonValue;\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(QnJsonContext* ctx, const T&amp; value, const QString&amp; key, QJsonObject* outTarget)\n{\n    NX_ASSERT(outTarget);\n\n    QJsonValueRef jsonValue = (*outTarget)[key];\n    QJson::serialize(ctx, value, &amp;jsonValue);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(\n    QnJsonContext* ctx,\n    const std::optional&lt;T&gt;&amp; value,\n    const QString&amp; key,\n    QJsonObject* outTarget)\n{\n    NX_ASSERT(outTarget);\n\n    QJsonValue jsonValue(QJsonValue::Undefined);\n    QJson::serialize(ctx, value, &amp;jsonValue);\n    if (!jsonValue.isUndefined())\n        (*outTarget)[key] = jsonValue;\n}\n\n/**\n * Serialize the given value into a JSON string.\n * @param ctx JSON context to use.\n * @param value Value to serialize.\n * @param[out] outTarget Target JSON string, must not be nullptr.\n */\ntemplate&lt;class T&gt;\nvoid serialize(QnJsonContext* ctx, const T&amp; value, QByteArray* outTarget)\n{\n    NX_ASSERT(outTarget);\n\n    QJsonValue jsonValue;\n    QJson::serialize(ctx, value, &amp;jsonValue);\n    QJsonDetail::serialize_json(jsonValue, outTarget);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(const T&amp; value, QJsonValue* outTarget)\n{\n    QnJsonContext ctx;\n    QJson::serialize(&amp;ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(const T&amp; value, QJsonValueRef* outTarget)\n{\n    QnJsonContext ctx;\n    QJson::serialize(&amp;ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(const T&amp; value, const QString&amp; key, QJsonObject* outTarget)\n{\n    QnJsonContext ctx;\n    QJson::serialize(&amp;ctx, value, key, outTarget);\n}\n\ntemplate&lt;class T&gt;\nvoid serialize(const T&amp; value, QByteArray* outTarget)\n{\n    QnJsonContext ctx;\n    QJson::serialize(&amp;ctx, value, outTarget);\n}\n\n/**\n * Deserialize the given intermediate representation of a JSON object.\n * @param ctx JSON context to use.\n * @param value Intermediate JSON representation to deserialize.\n * @param[out] outTarget Deserialization target, must not be nullptr.\n * @return Whether the deserialization was successful.\n */\ntemplate&lt;class T&gt;\nbool deserialize(QnJsonContext* ctx, const QJsonValue&amp; value, T* outTarget)\n{\n    return QnSerialization::deserialize(ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(QnJsonContext* ctx, const QJsonValueRef&amp; value, T* outTarget)\n{\n    return QnSerialization::deserialize(ctx, static_cast&lt;QJsonValue&gt;(value), outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(\n    QnJsonContext* ctx,\n    const QJsonObject&amp; value,\n    const QString&amp; key,\n    T* outTarget,\n    bool optional = false,\n    bool* outFound = nullptr,\n    DeprecatedFieldNames* deprecatedFieldNames = nullptr,\n    const std::type_info&amp; structTypeInfo = typeid(std::nullptr_t))\n{\n    QJsonObject::const_iterator pos = QJsonDetail::findField(\n        value, key, deprecatedFieldNames, structTypeInfo, optional);\n    if (pos == value.end())\n    {\n        if (outFound != nullptr)\n            *outFound = false;\n        return optional;\n    }\n\n    if (outFound != nullptr)\n        *outFound = true;\n\n    if (QJson::deserialize(ctx, *pos, outTarget))\n        return true;\n\n    const auto failed = std::pair&lt;QString, QString&gt;(key, QJson::serialized(pos.value()));\n    NX_WARNING(\n        NX_SCOPE_TAG, &quot;Can&#x27;t deserialize field `%1` from value `%2`&quot;, failed.first, failed.second);\n    ctx-&gt;setFailedKeyValue(failed);\n    return optional &amp;&amp; !ctx-&gt;isStrictMode();\n}\n\n/**\n * Deserialize a value from a JSON string.\n * @param ctx JSON context to use.\n * @param value JSON string to deserialize.\n * @param outTarget Deserialization target, must not be null.\n * @return Whether the deserialization was successful.\n */\ntemplate&lt;class T&gt;\nbool deserialize(QnJsonContext* ctx, const QByteArray&amp; value, T* outTarget)\n{\n    NX_ASSERT(outTarget);\n\n    QJsonValue jsonValue;\n\n    bool hasDirectSerializer = HasDirectObjectKeySerializer&lt;T&gt;::value;\n    if (hasDirectSerializer &amp;&amp; ctx-&gt;isMapKeyDeserializationMode())\n    {\n        jsonValue = QString::fromUtf8(value);\n    }\n    else if (QString errorMessage;\n        !QJsonDetail::deserialize_json(value, &amp;jsonValue, &amp;errorMessage))\n    {\n        ctx-&gt;setFailedKeyValue(std::make_pair(QString(), errorMessage));\n        return false;\n    }\n\n    return QJson::deserialize(ctx, jsonValue, outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(const QJsonValue&amp; value, T* outTarget)\n{\n    QnJsonContext ctx;\n    return QJson::deserialize(&amp;ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(const QJsonValueRef&amp; value, T* outTarget)\n{\n    QnJsonContext ctx;\n    return QJson::deserialize(&amp;ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(const QJsonObject&amp; value, const QString&amp; key, T* outTarget, bool optional = false)\n{\n    QnJsonContext ctx;\n    return QJson::deserialize(&amp;ctx, value, key, outTarget, optional);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(const QByteArray&amp; value, T* outTarget)\n{\n    QnJsonContext ctx;\n    return QJson::deserialize(&amp;ctx, value, outTarget);\n}\n\ntemplate&lt;class T&gt;\nbool deserialize(const nx::ConstBufferRefType&amp; value, T* outTarget)\n{\n    QnJsonContext ctx;\n    return deserialize(\n        &amp;ctx,\n        QByteArray::fromRawData(value.data(), (int) value.size()),\n        outTarget);\n}\n\n/**\n * NOTE: This overload is required since otherwise QString will be converted to QJsonValue,\n * corresponding overload will be called and deserialize will fail.\n */\ntemplate&lt;class T&gt;\nbool deserialize(const QString&amp; value, T* outTarget)\n{\n    return deserialize(value.toUtf8(), outTarget);\n}\n\n\ntemplate&lt;class T&gt;\nbool deserializeAllowingOmittedValues(const QJsonValue&amp; value, T* target,\n    std::optional&lt;QJsonValue&gt;* outIncompleteJsonValue)\n{\n    QnJsonContext ctx;\n    const bool result = QJson::deserialize(&amp;ctx, value, target);\n    if (ctx.areSomeFieldsNotFound())\n        *outIncompleteJsonValue = value;\n    else\n        *outIncompleteJsonValue = std::nullopt;\n    return result;\n}\n\n/**\n * Deserialize a value from a JSON utf-8-encoded string, allowing for omitted values.\n * @param value JSON string to deserialize.\n * @param outIncompleteJsonValue Returned when some values were omitted.\n * @return Whether no deserialization errors occurred, except for possible omitted values.\n */\ntemplate&lt;class T&gt;\nbool deserializeAllowingOmittedValues(const QByteArray&amp; value, T* target,\n    std::optional&lt;QJsonValue&gt;* outIncompleteJsonValue)\n{\n    QJsonValue jsonValue;\n    if (!QJsonDetail::deserialize_json(value, &amp;jsonValue))\n        return false;\n    return deserializeAllowingOmittedValues(jsonValue, target, outIncompleteJsonValue);\n}\n\ntemplate&lt;class T&gt;\nT deserializeOrThrow(QnJsonContext* ctx, const QJsonValue&amp; value)\n{\n    T result;\n    if (QJson::deserialize(ctx, value, &amp;result))\n        return result;\n    throw nx::json::InvalidParameterException(ctx-&gt;getFailedKeyValue());\n}\n\ntemplate&lt;class T&gt;\nT deserializeOrThrow(\n    const QJsonValue&amp; value, bool allowStringConversions = false)\n{\n    if (value.isUndefined())\n        throw nx::json::InvalidJsonException(&quot;No JSON provided.&quot;);\n    QnJsonContext ctx;\n    ctx.setStrictMode(true);\n    ctx.setAllowStringConversions(allowStringConversions);\n    return QJson::deserializeOrThrow&lt;T&gt;(&amp;ctx, value);\n}\n\ntemplate&lt;class T&gt;\nT deserializeOrThrow(const QByteArray&amp; value)\n{\n    QJsonValue jsonValue;\n    QString error;\n    if (!QJsonDetail::deserialize_json(value, &amp;jsonValue, &amp;error))\n        throw nx::json::InvalidJsonException(error);\n    QnJsonContext ctx;\n    ctx.setStrictMode(true);\n    return QJson::deserializeOrThrow&lt;T&gt;(&amp;ctx, jsonValue);\n}\n\ntemplate&lt;class T&gt;\nT deserializeOrThrow(const nx::ConstBufferRefType&amp; value)\n{\n    return deserializeOrThrow&lt;T&gt;(QByteArray::fromRawData(value.data(), value.size()));\n}\n\n/**\n * Serialize the given value into a JSON string and returns it in the utf-8 format.\n * @param value Value to serialize.\n * @return Result JSON data.\n */\ntemplate&lt;class T&gt;\nQByteArray serialized(const T&amp; value)\n{\n    QByteArray result;\n    QJson::serialize(value, &amp;result);\n    return result;\n}\n\n/**\n * Deserialize a value from a JSON utf-8-encoded string.\n * @param value JSON string to deserialize.\n * @param defaultValue Value to return in case of deserialization failure.\n * @param[out] success Deserialization status.\n * @return Deserialization target.\n */\ntemplate&lt;class T&gt;\nT deserialized(const QByteArray&amp; value, const T&amp; defaultValue, bool* success)\n{\n    T target;\n    const bool result = QJson::deserialize(value, &amp;target);\n    if (success)\n        *success = result;\n\n    if (result)\n    {\n        T local; // Enforcing NRVO, which is blocked by address-taking operator above.\n        std::swap(local, target);\n        return local;\n    }\n\n    return defaultValue;\n}\n\ntemplate&lt;class T&gt;\nT deserialized(const nx::ConstBufferRefType&amp; value, const T&amp; defaultValue, bool* success)\n{\n    return deserialized(\n        QByteArray::fromRawData(value.data(), (int) value.size()),\n        defaultValue,\n        success);\n}\n\ntemplate&lt;class T&gt;\nT deserialized(const char* value, const T&amp; defaultValue, bool* success)\n{\n    return deserialized(\n        QByteArray::fromRawData(value, (int) std::strlen(value)),\n        defaultValue,\n        success);\n}\n\nNX_FUSION_API QString toString(QJsonValue::Type jsonType);\n\n} // namespace QJson\n"}, "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h": {"id": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h", "filePath": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;limits&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#ifndef Q_MOC_RUN\n    #include &lt;boost/preprocessor/tuple/enum.hpp&gt;\n#endif\n\n#include &lt;collection.h&gt;\n\n#include &lt;QtCore/QBitArray&gt;\n#include &lt;QtCore/QDateTime&gt;\n#include &lt;QtCore/QJsonArray&gt;\n#include &lt;QtCore/QPair&gt;\n#include &lt;QtCore/QPoint&gt;\n#include &lt;QtCore/QPointF&gt;\n#include &lt;QtCore/QRect&gt;\n#include &lt;QtCore/QRectF&gt;\n#include &lt;QtCore/QSize&gt;\n#include &lt;QtCore/QSizeF&gt;\n#include &lt;QtCore/QUrl&gt;\n#include &lt;QtCore/QtNumeric&gt;\n\n#include &lt;nx/reflect/from_string.h&gt;\n#include &lt;nx/reflect/to_string.h&gt;\n#include &lt;nx/reflect/type_utils.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/json/qt_containers_reflect.h&gt;\n#include &lt;nx/utils/latin1_array.h&gt;\n#include &lt;nx/utils/scope_guard.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\n#include &quot;collection_fwd.h&quot;\n#include &quot;json.h&quot;\n#include &quot;json_macros.h&quot;\n#include &quot;lexical_functions.h&quot;\n\nQN_FUSION_DECLARE_FUNCTIONS(qint32, (json)) /* Needed for (de)serialize_numeric_enum below. */\n\ninline void serialize(QnJsonContext *, const QJsonValue &amp;value, QJsonValue *target) {\n    *target = value;\n}\n\ninline bool deserialize(QnJsonContext *, const QJsonValue &amp;value, QJsonValue *target) {\n    *target = value;\n    return true;\n}\n\n/* Situation with doubles is more complicated than with other built-in types\n * as we have to take non-finite numbers into account. */\ninline void serialize(QnJsonContext *, const double &amp;value, QJsonValue *target) {\n    *target = QJsonValue(value);\n}\n\ninline bool deserialize(QnJsonContext *context, const QJsonValue &amp;value, double *target) {\n    if(value.type() == QJsonValue::Double) {\n        *target = value.toDouble();\n        return true;\n    } else if(value.type() == QJsonValue::Null) {\n        /* Strictly speaking, that&#x27;s either a nan, or a +-inf,\n         * but at this point we cannot say what it really was. */\n        *target = qQNaN();\n        return true;\n    } else if(value.type() == QJsonValue::String &amp;&amp; context-&gt;areStringConversionsAllowed()){\n        bool isOk = false;\n        *target = value.toString().toDouble(&amp;isOk);\n        return isOk;\n    } else {\n        return false;\n    }\n}\n\n/* Floats are (de)serialized via conversion to/from double.\n * Note that we don&#x27;t do any additional boundary checks for floats as we do for\n * integers as it doesn&#x27;t really make much sense. */\ninline void serialize(QnJsonContext *ctx, const float &amp;value, QJsonValue *target) {\n    ::serialize(ctx, static_cast&lt;double&gt;(value), target); /* Note the direct call instead of invocation through QJson. */\n}\n\ninline bool deserialize(QnJsonContext *ctx, const QJsonValue &amp;value, float *target) {\n    double tmp;\n    if(!::deserialize(ctx, value, &amp;tmp)) /* Note the direct call instead of invocation through QJson. */\n        return false;\n\n    *target = tmp;\n    return true;\n}\n\ninline void serialize(QnJsonContext* ctx, const QVariant&amp; value, QJsonValue* target)\n{\n    if (value == QVariant())\n    {\n        *target = QJsonValue();\n        return;\n    }\n\n    auto serializer = QnJsonSerializer::serializer(value.userType());\n    if (!NX_ASSERT(serializer,\n        &quot;Unregistered serializer for type %1 named \\&quot;%2\\&quot;&quot;, value.userType(), value.typeName()))\n    {\n        return;\n    }\n\n    serializer-&gt;serialize(ctx, value, target);\n}\n\nnamespace QJsonDetail {\n\n    template&lt;class Element, class Tag&gt;\n    void serialize_collection_element(QnJsonContext *ctx, const Element &amp;element, QJsonValue *target, const Tag &amp;) {\n        QJson::serialize(ctx, element, target);\n    }\n\n    template&lt;class Element&gt;\n    void serialize_collection_element(QnJsonContext *ctx, const Element &amp;element, QJsonValue *target, const QnCollection::map_tag &amp;) {\n        QJsonObject map;\n        QJson::serialize(ctx, element.first, QLatin1String(&quot;key&quot;), &amp;map);\n        QJson::serialize(ctx, element.second, QLatin1String(&quot;value&quot;), &amp;map);\n        *target = map;\n    }\n\n    template&lt;class Collection&gt;\n    void serialize_collection(QnJsonContext *ctx, const Collection &amp;value, QJsonValue *target) {\n        QJsonArray result;\n\n        for(auto pos = boost::begin(value); pos != boost::end(value); ++pos) {\n            QJsonValue element;\n            serialize_collection_element(ctx, *pos, &amp;element, typename QnCollection::collection_category&lt;Collection&gt;::type());\n            result.push_back(element);\n        }\n\n        if (result.isEmpty() &amp;&amp; ctx-&gt;isOptionalDefaultSerialization&lt;Collection&gt;())\n        {\n            using Item = std::decay_t&lt;decltype(*boost::begin(value))&gt;;\n            using Tag = typename QnCollection::collection_category&lt;Collection&gt;::type;\n            ctx-&gt;addTypeToProcessed&lt;Collection&gt;();\n            if constexpr (std::is_same_v&lt;Tag, QnCollection::map_tag&gt;)\n            {\n                if (ctx-&gt;isOptionalDefaultSerialization&lt;std::decay_t&lt;typename Item::first_type&gt;&gt;()\n                    || ctx-&gt;isOptionalDefaultSerialization&lt;std::decay_t&lt;typename Item::second_type&gt;&gt;())\n                {\n                    QJsonObject map;\n                    ctx-&gt;addTypeToProcessed&lt;std::decay_t&lt;typename Item::first_type&gt;()&gt;();\n                    QJson::serialize(ctx, std::decay_t&lt;typename Item::first_type&gt;(), &quot;key&quot;, &amp;map);\n                    ctx-&gt;removeTypeFromProcessed&lt;std::decay_t&lt;typename Item::first_type&gt;()&gt;();\n                    ctx-&gt;addTypeToProcessed&lt;std::decay_t&lt;typename Item::second_type&gt;()&gt;();\n                    QJson::serialize(ctx, std::decay_t&lt;typename Item::second_type&gt;(), &quot;value&quot;, &amp;map);\n                    ctx-&gt;removeTypeFromProcessed&lt;std::decay_t&lt;typename Item::second_type&gt;()&gt;();\n                    result.push_back(map);\n                }\n            }\n            else if (ctx-&gt;isOptionalDefaultSerialization&lt;Item&gt;())\n            {\n                QJsonValue item;\n                ctx-&gt;addTypeToProcessed&lt;Item&gt;();\n                QJson::serialize(ctx, Item(), &amp;item);\n                ctx-&gt;removeTypeFromProcessed&lt;Item&gt;();\n                result.push_back(item);\n            }\n            ctx-&gt;removeTypeFromProcessed&lt;Collection&gt;();\n        }\n\n        *target = result;\n    }\n\n    inline QString convertQJsonValueToString(const QJsonValue&amp; jsonValue)\n    {\n        if (jsonValue.type() == QJsonValue::String)\n            return jsonValue.toString();\n\n        return QString::fromUtf8(QJson::serialized(jsonValue));\n    }\n\n    template&lt;typename Map&gt;\n    void serialize_generic_map_to_object(QnJsonContext* ctx, const Map&amp; map, QJsonValue* target)\n    {\n        static_assert(\n            std::is_same_v&lt;\n                typename QnCollection::collection_category&lt;Map&gt;::type,\n                typename QnCollection::map_tag&gt;);\n\n        QJsonObject result;\n\n        for (const auto&amp; [key, value]: map)\n        {\n            QJsonValue serializedValue;\n            QJson::serialize(ctx, value, &amp;serializedValue);\n\n            QJsonValue serializedKey;\n            QJson::serialize(ctx, key, &amp;serializedKey);\n\n            result.insert(convertQJsonValueToString(serializedKey), serializedValue);\n        }\n\n        *target = result;\n    }\n\n    template&lt;typename Map&gt;\n    void serialize_generic_map(QnJsonContext *ctx, const Map &amp;value, QJsonValue *target)\n    {\n        if (ctx-&gt;serializeMapToObject())\n            serialize_generic_map_to_object(ctx, value, target);\n        else\n            serialize_collection(ctx, value, target);\n\n    }\n\n    template&lt;class Collection, class Element&gt;\n    bool deserialize_collection_element(QnJsonContext *ctx, const QJsonValue &amp;value, Collection *target, const Element *, const QnCollection::list_tag &amp;) {\n        return QJson::deserialize(ctx, value, &amp;*QnCollection::insert(*target, boost::end(*target), Element()));\n    }\n\n    template&lt;class Collection, class Element&gt;\n    bool deserialize_collection_element(QnJsonContext *ctx, const QJsonValue &amp;value, Collection *target, const Element *, const QnCollection::set_tag &amp;) {\n        Element element;\n        if(!QJson::deserialize(ctx, value, &amp;element))\n            return false;\n\n        QnCollection::insert(*target, boost::end(*target), std::move(element));\n        return true;\n    }\n\n    template&lt;class Collection, class Element&gt;\n    bool deserialize_collection_element(QnJsonContext *ctx, const QJsonValue &amp;value, Collection *target, const Element *, const QnCollection::map_tag &amp;) {\n        if(value.type() != QJsonValue::Object)\n            return false;\n        QJsonObject element = value.toObject();\n\n        typename Collection::key_type key;\n        if(!QJson::deserialize(ctx, element, QLatin1String(&quot;key&quot;), &amp;key))\n            return false;\n\n        if(!QJson::deserialize(ctx, element, QLatin1String(&quot;value&quot;), &amp;(*target)[key]))\n            return false;\n\n        return true;\n    }\n\n    template&lt;class Collection&gt;\n    bool deserialize_collection(QnJsonContext *ctx, const QJsonValue &amp;value, Collection *target) {\n        typedef typename std::iterator_traits&lt;typename boost::range_mutable_iterator&lt;Collection&gt;::type&gt;::value_type value_type;\n\n        if(value.type() != QJsonValue::Array)\n            return false;\n        QJsonArray array = value.toArray();\n\n        QnCollection::clear(*target);\n        QnCollection::reserve(*target, array.size());\n\n        for(auto pos = array.begin(); pos != array.end(); pos++)\n            if(!deserialize_collection_element(ctx, *pos, target, static_cast&lt;const value_type *&gt;(NULL), typename QnCollection::collection_category&lt;Collection&gt;::type()))\n                return false;\n\n        return true;\n    }\n\n    template&lt;typename Map&gt;\n    bool deserialize_generic_map_from_object(\n        QnJsonContext* ctx,\n        const QJsonObject&amp; value,\n        Map* target)\n    {\n        QnCollection::clear(*target);\n        QnCollection::reserve(*target, value.size());\n\n        for (auto it = value.begin(); it != value.end(); ++it)\n        {\n            typename Map::key_type deserializedKey;\n\n            {\n                nx::utils::ScopeGuard ctxGuard(\n                    [ctx]() { ctx-&gt;setIsMapKeyDeserializationMode(false); });\n                ctx-&gt;setIsMapKeyDeserializationMode(true);\n                if (!QJson::deserialize(ctx, it.key().toUtf8(), &amp;deserializedKey))\n                    return false;\n            }\n\n            if (!QJson::deserialize(ctx, it.value(), &amp;(*target)[deserializedKey]))\n                return false;\n        }\n\n        return true;\n    }\n\n    template&lt;typename Map&gt;\n    bool deserialize_generic_map(QnJsonContext* ctx, const QJsonValue&amp; value, Map* target)\n    {\n        static_assert(\n            std::is_same_v&lt;\n                typename QnCollection::collection_category&lt;Map&gt;::type,\n                typename QnCollection::map_tag&gt;);\n\n        switch (value.type())\n        {\n            case QJsonValue::Object:\n                return deserialize_generic_map_from_object(ctx, value.toObject(), target);\n            case QJsonValue::Array:\n                return deserialize_collection(ctx, value, target);\n            default:\n                return false;\n        }\n    }\n\n    template&lt;typename String&gt;\n    String fromQString(const QString&amp; str)\n    {\n        if constexpr (std::is_same_v&lt;String, std::string&gt;)\n            return str.toStdString();\n        else\n            return str;\n    }\n\n    template&lt;typename String&gt;\n    QString toQString(const String&amp; str)\n    {\n        if constexpr (std::is_same_v&lt;std::decay_t&lt;String&gt;, std::string&gt;)\n            return QString::fromStdString(str);\n        else\n            return str;\n    }\n\n    template&lt;class Map&gt;\n    void serialize_string_map(QnJsonContext *ctx, const Map &amp;value, QJsonValue *target) {\n        QJsonObject result;\n\n        ctx-&gt;addTypeToProcessed&lt;Map&gt;();\n        for(auto pos = boost::begin(value); pos != boost::end(value); pos++) {\n            QJsonValue jsonValue;\n            QJson::serialize(ctx, pos-&gt;second, &amp;jsonValue);\n            result.insert(toQString(pos-&gt;first), jsonValue);\n        }\n        ctx-&gt;removeTypeFromProcessed&lt;Map&gt;();\n\n        using Item = std::decay_t&lt;decltype(*boost::begin(value))&gt;;\n        if (result.isEmpty() &amp;&amp; ctx-&gt;isOptionalDefaultSerialization&lt;Item&gt;())\n        {\n            QJsonValue jsonValue;\n            ctx-&gt;addTypeToProcessed&lt;Item&gt;();\n            QJson::serialize(ctx, std::decay_t&lt;typename Item::second_type&gt;(), &amp;jsonValue);\n            ctx-&gt;removeTypeFromProcessed&lt;Item&gt;();\n            result.insert(toQString(std::decay_t&lt;typename Item::first_type&gt;()), jsonValue);\n        }\n        *target = result;\n    }\n\n    template&lt;class Map&gt;\n    bool deserialize_string_map(QnJsonContext *ctx, const QJsonValue &amp;value, Map *target) {\n        if(value.type() != QJsonValue::Object)\n            return false;\n        QJsonObject map = value.toObject();\n\n        QnCollection::clear(*target);\n        QnCollection::reserve(*target, map.size());\n\n        for(auto pos = map.begin(); pos != map.end(); pos++)\n            if(!QJson::deserialize(ctx, pos.value(), &amp;(*target)[fromQString&lt;typename Map::key_type&gt;(pos.key())]))\n                return false;\n\n        return true;\n    }\n\n    template&lt;class T&gt;\n    void serialize_integer(QnJsonContext *ctx, const T &amp;value, QJsonValue *target) {\n        ::serialize(ctx, static_cast&lt;double&gt;(value), target); /* Note the direct call instead of invocation through QJson. */\n    }\n\n    template&lt;class T&gt;\n    bool deserialize_integer(QnJsonContext *ctx, const QJsonValue &amp;value, T *target) {\n        double tmp;\n        if(!::deserialize(ctx, value, &amp;tmp)) /* Note the direct call instead of invocation through QJson. */\n            return false;\n        if(tmp &lt; static_cast&lt;double&gt;(std::numeric_limits&lt;T&gt;::min()) || tmp &gt; static_cast&lt;double&gt;(std::numeric_limits&lt;T&gt;::max()))\n            return false;\n\n        *target = static_cast&lt;T&gt;(tmp);\n        return true;\n    }\n\n    template&lt;class T&gt;\n    void serialize_integer_string(QnJsonContext *, const T &amp;value, QJsonValue *target) {\n        *target = QJsonValue(QnLexical::serialized(value));\n    }\n\n    template&lt;class T&gt;\n    bool deserialize_integer_string(QnJsonContext *ctx, const QJsonValue &amp;value, T *target) {\n        /* Support both strings and doubles during deserialization, just to feel safe. */\n        if(value.type() == QJsonValue::Double) {\n            return QJsonDetail::deserialize_integer&lt;T&gt;(ctx, value, target);\n        } else if(value.type() == QJsonValue::String) {\n            return QnLexical::deserialize(value.toString(), target);\n        } else {\n            return false;\n        }\n    }\n\n    template&lt;typename T, typename... Args&gt;\n    inline bool deserializeVariantType(\n        QnJsonContext* ctx,\n        const QJsonValue&amp; value,\n        std::variant&lt;Args...&gt;* target)\n    {\n        ctx-&gt;resetFailedKeyValue();\n        static_assert(!nx::utils::Is&lt;std::optional, T&gt;());\n        if constexpr (std::is_same&lt;std::nullptr_t, T&gt;::value)\n        {\n            if (value.isNull())\n            {\n                *target = std::nullptr_t{};\n                return true;\n            }\n        }\n\n        T typedTarget;\n        if (!value.isObject())\n        {\n            if (!deserialize(ctx, value, &amp;typedTarget))\n                return false;\n\n            *target = typedTarget;\n            return true;\n        }\n\n        const bool areSomeFieldsNotFound = ctx-&gt;areSomeFieldsNotFound();\n        const bool trackUnparsed = ctx-&gt;trackUnparsed();\n        ctx-&gt;setSomeFieldsNotFound(false);\n        ctx-&gt;setTrackUnparsed(true);\n\n        if (!deserialize(ctx, value, &amp;typedTarget))\n        {\n            ctx-&gt;setSomeFieldsNotFound(areSomeFieldsNotFound);\n            ctx-&gt;setTrackUnparsed(trackUnparsed);\n            return false;\n        }\n\n        ctx-&gt;setTrackUnparsed(trackUnparsed);\n        *target = typedTarget;\n        return true;\n    }\n\n} // namespace QJsonDetail\n\n/* Free-standing (de)serialization functions are picked up via ADL by\n * the actual implementation. Feel free to add them for your own types. */\n\n#ifndef Q_MOC_RUN\n#define QN_DEFINE_DIRECT_JSON_SERIALIZATION_FUNCTIONS(TYPE, JSON_TYPE, JSON_GETTER)  \\\ninline void serialize(QnJsonContext *, const TYPE &amp;value, QJsonValue *target) { \\\n    *target = QJsonValue(value);                                                \\\n}                                                                               \\\n                                                                                \\\ninline bool deserialize(QnJsonContext *, const QJsonValue &amp;value, TYPE *target) { \\\n    if(value.type() != QJsonValue::JSON_TYPE)                                   \\\n        return false;                                                           \\\n                                                                                \\\n    *target = value.JSON_GETTER();                                              \\\n    return true;                                                                \\\n}\n\nQN_DEFINE_DIRECT_JSON_SERIALIZATION_FUNCTIONS(QString,      String, toString)\nQN_DEFINE_DIRECT_JSON_SERIALIZATION_FUNCTIONS(QJsonArray,   Array,  toArray)\nQN_DEFINE_DIRECT_JSON_SERIALIZATION_FUNCTIONS(QJsonObject,  Object, toObject)\n#undef QN_DEFINE_DIRECT_JSON_SERIALIZATION_FUNCTIONS\n\ninline void serialize(QnJsonContext *, const bool &amp;value, QJsonValue *target) {\n    *target = QJsonValue(value);\n}\n\ninline bool deserialize(QnJsonContext *context, const QJsonValue &amp;value, bool *target) {\n    if(value.type() == QJsonValue::Bool) {\n        *target = value.toBool();\n        return true;\n    }\n\n    if (value.type() == QJsonValue::String &amp;&amp; context-&gt;areStringConversionsAllowed()) {\n        const auto stringValue = value.toString();\n        for (const auto&amp; key: {QStringLiteral(&quot;1&quot;), QStringLiteral(&quot;true&quot;), QStringLiteral(&quot;on&quot;)}) {\n            if (QString::compare(stringValue, key, Qt::CaseInsensitive) == 0) {\n                *target = true;\n                return true;\n            }\n        }\n\n        for (const auto&amp; key: {QStringLiteral(&quot;0&quot;), QStringLiteral(&quot;false&quot;), QStringLiteral(&quot;off&quot;)}) {\n            if (QString::compare(stringValue, key, Qt::CaseInsensitive) == 0) {\n                *target = false;\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\ninline void serialize(QnJsonContext *, const std::string &amp;value, QJsonValue *target) {\n    *target = QJsonValue(QString::fromStdString(value));\n}\n\ninline bool deserialize(QnJsonContext *, const QJsonValue &amp;value, std::string *target) {\n    if(value.type() != QJsonValue::String)\n        return false;\n\n    *target = value.toString().toStdString();\n    return true;\n}\n\n#define QN_DEFINE_JSON_CHRONO_SERIALIZATION_FUNCTIONS(TYPE) \\\n    inline void serialize( \\\n        QnJsonContext* jsonContext, const std::chrono::TYPE&amp; value, QJsonValue* target) \\\n    { \\\n        *target = jsonContext-&gt;isChronoSerializedAsDouble() \\\n            ? QJsonValue((double) value.count()) \\\n            : QJsonValue(QString::number(value.count())); \\\n    } \\\n    \\\n    inline bool deserialize(QnJsonContext*, const QJsonValue&amp; value, std::chrono::TYPE* target) \\\n    { \\\n        if (value.type() != QJsonValue::String &amp;&amp; value.type() != QJsonValue::Double) \\\n            return false; \\\n        *target = std::chrono::TYPE(value.toVariant().value&lt;std::chrono::TYPE::rep&gt;()); \\\n        return true; \\\n    }\n\nQN_DEFINE_JSON_CHRONO_SERIALIZATION_FUNCTIONS(seconds)\nQN_DEFINE_JSON_CHRONO_SERIALIZATION_FUNCTIONS(milliseconds)\nQN_DEFINE_JSON_CHRONO_SERIALIZATION_FUNCTIONS(microseconds)\n\n#undef QN_DEFINE_JSON_CHRONO_SERIALIZATION_FUNCTIONS\n\n/**\n * Representing system_clock::time_point in json as milliseconds since epoch (1970-01-01T00:00).\n */\ninline void serialize(\n    QnJsonContext* jsonContext,\n    const std::chrono::system_clock::time_point&amp; value,\n    QJsonValue* target)\n{\n    using namespace std::chrono;\n\n    const auto millisSinceEpoch =\n        duration_cast&lt;milliseconds&gt;(value.time_since_epoch()).count();\n    *target = jsonContext-&gt;isChronoSerializedAsDouble()\n        ? QJsonValue((double) millisSinceEpoch)\n        : QJsonValue(QString::number(millisSinceEpoch));\n}\n\ninline bool deserialize(\n    QnJsonContext*,\n    const QJsonValue&amp; value,\n    std::chrono::system_clock::time_point* target)\n{\n    if (value.type() != QJsonValue::String &amp;&amp; value.type() != QJsonValue::Double)\n        return false;\n\n    const auto millisSinceEpoch = value.toVariant().toULongLong();\n    // Initializing with epoch.\n    *target = std::chrono::system_clock::time_point();\n    // Adding milliseconds since epoch.\n    *target += std::chrono::milliseconds(millisSinceEpoch);\n    return true;\n}\n\ntemplate&lt;typename T&gt;\ninline void serialize(\n    QnJsonContext* ctx,\n    const std::optional&lt;T&gt;&amp; value,\n    QJsonValue* target)\n{\n    if (!value)\n    {\n        *target = QJsonValue(QJsonValue::Undefined);\n        return;\n    }\n\n    QJson::serialize&lt;T&gt;(ctx, *value, target);\n}\n\ntemplate&lt;typename T&gt;\ninline bool deserialize(\n    QnJsonContext* ctx,\n    const QJsonValue&amp; value,\n    std::optional&lt;T&gt;* target)\n{\n    if (!ctx-&gt;doesDeserializeReplaceExistingOptional() &amp;&amp; *target)\n    {\n        using namespace nx::reflect;\n        if constexpr ((IsAssociativeContainerV&lt;T&gt; &amp;&amp; !IsSetContainerV&lt;T&gt;)\n            || (IsUnorderedAssociativeContainerV&lt;T&gt; &amp;&amp; !IsUnorderedSetContainerV&lt;T&gt;)\n            || IsQtAssociativeContainerV&lt;T&gt;\n            || std::is_same_v&lt;T, QJsonObject&gt;)\n        {\n            return true;\n        }\n    }\n\n    if (value.isUndefined())\n    {\n        target-&gt;reset();\n        return true;\n    }\n\n    *target = T();\n    return QJson::deserialize&lt;T&gt;(ctx, value, &amp;**target);\n}\n\ninline void serialize(QnJsonContext* /*ctx*/, const std::nullptr_t&amp; /*value*/, QJsonValue* target)\n{\n    *target = QJsonValue();\n}\n\ninline bool deserialize(QnJsonContext* /*ctx*/, const QJsonValue&amp; value, std::nullptr_t* target)\n{\n    *target = nullptr;\n    return value.isNull();\n}\n\ntemplate&lt;typename... Args&gt;\ninline void serialize(QnJsonContext* ctx, const std::variant&lt;Args...&gt;&amp; value, QJsonValue* target)\n{\n    if (ctx-&gt;isOptionalDefaultSerialization&lt;void&gt;())\n    {\n        *target = QJsonValue();\n        return;\n    }\n    std::visit(\n        [ctx, target](auto&amp;&amp; arg) { QJson::serialize(ctx, std::move(arg), target); }, value);\n}\n\ntemplate&lt;typename... Args&gt;\ninline bool deserialize(QnJsonContext* ctx, const QJsonValue&amp; value, std::variant&lt;Args...&gt;* target)\n{\n    return (... || QJsonDetail::deserializeVariantType&lt;Args&gt;(ctx, value, target));\n}\n\n#define QN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(TYPE)                    \\\ninline void serialize(QnJsonContext *ctx, const TYPE &amp;value, QJsonValue *target) { \\\n    QJsonDetail::serialize_integer&lt;TYPE&gt;(ctx, value, target);                   \\\n}                                                                               \\\n                                                                                \\\ninline bool deserialize(QnJsonContext *ctx, const QJsonValue &amp;value, TYPE *target) { \\\n    return QJsonDetail::deserialize_integer&lt;TYPE&gt;(ctx, value, target);          \\\n}\n\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(char);\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(signed char); /* char, signed char and unsigned char are distinct types. */\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(unsigned char);\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(short);\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(unsigned short);\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(int);\nQN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS(unsigned int);\n#undef QN_DEFINE_INTEGER_JSON_SERIALIZATION_FUNCTIONS\n\n#define QN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS(TYPE)             \\\ninline void serialize(QnJsonContext *ctx, const TYPE &amp;value, QJsonValue *target) { \\\n    QJsonDetail::serialize_integer_string&lt;TYPE&gt;(ctx, value, target);            \\\n}                                                                               \\\n                                                                                \\\ninline bool deserialize(QnJsonContext *ctx, const QJsonValue &amp;value, TYPE *target) { \\\n    return QJsonDetail::deserialize_integer_string&lt;TYPE&gt;(ctx, value, target);   \\\n}\n\nQN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS(long)\nQN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS(unsigned long)\nQN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS(long long)\nQN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS(unsigned long long)\n#undef QN_DEFINE_INTEGER_STRING_JSON_SERIALIZATION_FUNCTIONS\n\ntemplate&lt;typename A, typename B&gt;\ninline void serialize(\n    QnJsonContext* ctx,\n    const QPair&lt;A, B&gt;&amp; value,\n    QJsonValue* target)\n{\n    *target = QJsonArray{{}, {}};\n    QJson::serialize&lt;A&gt;(ctx, value.first, &amp;target[0]);\n    QJson::serialize&lt;B&gt;(ctx, value.second, &amp;target[1]);\n}\n\ntemplate&lt;typename A, typename B&gt;\ninline bool deserialize(\n    QnJsonContext* ctx,\n    const QJsonValue&amp; value,\n    QPair&lt;A, B&gt;* target)\n{\n    if (!value.isArray())\n        return false;\n\n    const auto array = value.toArray();\n    if (array.size() != 2)\n        return false;\n\n    *target = QPair&lt;A, B&gt;();\n    return QJson::deserialize&lt;A&gt;(ctx, array[0], &amp;target-&gt;first)\n        &amp;&amp; QJson::deserialize&lt;B&gt;(ctx, array[1], &amp;target-&gt;second);\n}\n\n#define QN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(TYPE, TPL_DEF, TPL_ARG, IMPL) \\\ntemplate&lt;BOOST_PP_TUPLE_ENUM(TPL_DEF)&gt;                                          \\\nvoid serialize(QnJsonContext *ctx, const TYPE&lt;BOOST_PP_TUPLE_ENUM(TPL_ARG)&gt; &amp;value, QJsonValue *target) { \\\n    QJsonDetail::BOOST_PP_CAT(serialize_, IMPL)(ctx, value, target);            \\\n}                                                                               \\\n                                                                                \\\ntemplate&lt;BOOST_PP_TUPLE_ENUM(TPL_DEF)&gt;                                          \\\nbool deserialize(QnJsonContext *ctx, const QJsonValue &amp;value, TYPE&lt;BOOST_PP_TUPLE_ENUM(TPL_ARG)&gt; *target) { \\\n    return QJsonDetail::BOOST_PP_CAT(deserialize_, IMPL)(ctx, value, target);   \\\n}                                                                               \\\n\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QSet, (class T), (T), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QList, (class T), (T), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QLinkedList, (class T), (T), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QVarLengthArray, (class T, qsizetype N), (T, N), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QMap, (class Key, class T), (Key, T), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QHash, (class Key, class T), (Key, T), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(std::vector, (class T, class Allocator), (T, Allocator), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(std::list, (class T, class Allocator), (T, Allocator), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(std::set, (class Key, class Predicate, class Allocator), (Key, Predicate, Allocator), collection);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(std::map, (class Key, class T, class Predicate, class Allocator), (Key, T, Predicate, Allocator), generic_map);\n\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QMap, (class T), (QString, T), string_map);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(QHash, (class T), (QString, T), string_map);\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(std::map, (class T, class Predicate, class Allocator), (QString, T, Predicate, Allocator), string_map);\n\nQN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS(\n    std::map,\n    (class T, class Predicate, class Allocator),\n    (std::string, T, Predicate, Allocator),\n    string_map);\n\n#undef QN_DEFINE_COLLECTION_JSON_SERIALIZATION_FUNCTIONS\n#endif // Q_MOC_RUN\n\ntemplate&lt;typename T, size_t N&gt;\ninline void serialize(QnJsonContext* ctx, const std::array&lt;T, N&gt;&amp; value, QJsonValue* target)\n{\n    QJsonDetail::serialize_collection(ctx, value, target);\n}\n\ntemplate&lt;typename T, size_t N&gt;\ninline bool deserialize(QnJsonContext* ctx, const QJsonValue&amp; value, std::array&lt;T, N&gt;* target)\n{\n    std::vector&lt;T&gt; vector;\n    if (!QJsonDetail::deserialize_collection(ctx, value, &amp;vector) || vector.size() != N)\n        return false;\n\n    auto targetIt = target-&gt;begin();\n    for (auto&amp; vectorIt: vector)\n        *(targetIt++) = std::move(vectorIt);\n\n    return true;\n}\n\ntemplate&lt;typename T&gt;\nvoid serialize(QnJsonContext* ctx,\n    const T&amp; value,\n    QJsonValue* target,\n    typename std::enable_if&lt;QnSerialization::IsEnumOrFlags&lt;T&gt;::value&gt;::type* = nullptr)\n{\n    if constexpr (QnSerialization::IsInstrumentedEnumOrFlags&lt;T&gt;::value)\n    {\n        const std::string tmp = nx::reflect::toString(value);\n        // Note the direct call instead of invocation through QJson.\n        ::serialize(ctx, tmp, target);\n    }\n    else\n    {\n        QString tmp;\n        QnLexical::serialize(value, &amp;tmp);\n        // Note the direct call instead of invocation through QJson.\n        ::serialize(ctx, tmp, target);\n    }\n}\n\ntemplate&lt;typename T&gt;\nbool deserialize(QnJsonContext* ctx,\n    const QJsonValue&amp; value,\n    T* target,\n    typename std::enable_if&lt;QnSerialization::IsEnumOrFlags&lt;T&gt;::value&gt;::type* = nullptr)\n{\n    if (value.type() == QJsonValue::String)\n    {\n        if constexpr (QnSerialization::IsInstrumentedEnumOrFlags&lt;T&gt;::value)\n            return nx::reflect::fromString(value.toString().toStdString(), target);\n        else\n            return QnLexical::deserialize(value.toString(), target);\n    }\n\n    if (value.type() == QJsonValue::Double)\n    {\n        qint32 tmp;\n        // Note the direct call instead of invocation through QJson.\n        if (::deserialize(ctx, value, &amp;tmp))\n        {\n            *target = static_cast&lt;T&gt;(tmp);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nQN_FUSION_DECLARE_FUNCTIONS(QByteArray, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(nx::Buffer, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QnLatin1Array, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QBitArray, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QSize, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QSizeF, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QRect, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QRectF, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QPointF, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QPoint, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(nx::Uuid, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QUrl, (json), NX_FUSION_API)\nQN_FUSION_DECLARE_FUNCTIONS(QDateTime, (json), NX_FUSION_API)\n\n#define QN_FUSION_REGISTER_DIRECT_OBJECT_KEY_SERIALIZER(TYPE)\\\ntemplate&lt;&gt; \\\nstruct HasDirectObjectKeySerializer&lt;TYPE&gt;: public std::true_type \\\n{ \\\n};\n\nQN_FUSION_REGISTER_DIRECT_OBJECT_KEY_SERIALIZER(nx::Uuid)\n\nvoid qnJsonFunctionsUnitTest();\n"}, "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_macros.h": {"id": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_macros.h", "filePath": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_macros.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;typeinfo&gt;\n\n#include &lt;nx/fusion/fusion/fusion_serialization.h&gt;\n\n#include &quot;json.h&quot;\n#include &quot;lexical.h&quot;\n\nnamespace QJsonDetail {\n\n/**\n * @return true if the field must be serialized. Used as a default checker if no QnFusion::checker\n * option is provided for the given class.\n */\nstruct AlwaysTrueChecker\n{\n    template&lt;class T&gt;\n    bool operator()(const T &amp;) const { return true; }\n};\n\n/**\n * @return true if value must be omitted in brief mode.\n */\nstruct BriefChecker\n{\n    template&lt;class T&gt;\n    bool operator()(const T&amp; value) const\n    {\n        if constexpr (std::is_same&lt;T, std::string&gt;::value)\n            return value.empty();\n        else if constexpr (std::is_same&lt;T, QString&gt;::value)\n            return value.isEmpty();\n        else if constexpr (std::is_same&lt;T, nx::Uuid&gt;::value)\n            return value.isNull();\n        else\n            return false;\n    }\n\n    template&lt;class U&gt;\n    bool operator()(const std::vector&lt;U&gt;&amp; value) const { return value.empty(); }\n\n    template&lt;class U&gt;\n    bool operator()(const std::set&lt;U&gt;&amp; value) const { return value.empty(); }\n\n    template&lt;class U&gt;\n    bool operator()(const QList&lt;U&gt;&amp; value) const { return value.empty(); }\n};\n\nclass SerializationVisitor\n{\npublic:\n    SerializationVisitor(QnJsonContext *ctx, QJsonValue &amp;target):\n        m_ctx(ctx),\n        m_target(target)\n    {\n    }\n\n    template&lt;class T, class Access&gt;\n    bool operator()(const T &amp;value, const Access &amp;access)\n    {\n        using namespace QnFusion;\n\n        // Custom QnFusion::checker may be provided for the field.\n        if (!invoke(access(/*QnFusion::key*/ checker, /*defaultValue*/ AlwaysTrueChecker()), value))\n            return true;\n\n        // In brief mode we can skip empty structure fields.\n        if (access(/*QnFusion::key*/ brief, /*defaultValue*/ false))\n        {\n            const auto&amp; realValue = invoke(access(getter), value);\n            if (BriefChecker()(realValue))\n                return true;\n        }\n\n        QJson::serialize(m_ctx, invoke(access(getter), value), access(name), &amp;m_object);\n        return true;\n    }\n\n    ~SerializationVisitor()\n    {\n        m_target = std::move(m_object);\n    }\n\nprivate:\n    QnJsonContext* m_ctx;\n    QJsonValue&amp; m_target;\n    QJsonObject m_object;\n};\n\nstruct DeserializationVisitor\n{\npublic:\n    DeserializationVisitor(QnJsonContext* ctx, const QJsonValue&amp; value):\n        m_ctx(ctx),\n        m_value(value),\n        m_object(value.toObject())\n    {\n    }\n\n    template&lt;class T, class Access&gt;\n    bool operator()(const T&amp;, const Access&amp;, const QnFusion::start_tag&amp;)\n    {\n        return m_value.isObject();\n    }\n\n    template&lt;class T, class Access&gt;\n    bool operator()(T&amp; target, const Access&amp; access)\n    {\n        using namespace QnFusion;\n\n        return operator()(target, access, access(setter_tag));\n    }\n\n    template&lt;class T, class Access&gt;\n    bool operator()(const T&amp;, const Access&amp;, const QnFusion::end_tag&amp;)\n    {\n        if (m_ctx-&gt;trackUnparsed() &amp;&amp; !m_object.isEmpty())\n        {\n            m_ctx-&gt;setFailedKeyValue({m_object.begin().key(), &quot;unexpected&quot;});\n            return false;\n        }\n        return true;\n    }\n\nprivate:\n    /**\n     * Retrieve map of deprecated field names, if it is available. If T provides\n     * getDeprecatedFields(), return its result, otherwise, return null.\n     * Sfinae wrapper.\n     */\n    template&lt;class T&gt;\n    static DeprecatedFieldNames* getDeprecatedFieldNames(const T&amp; target)\n    {\n        return getDeprecatedFieldNamesSfinae(target, /*enable_if_member_exists*/ nullptr);\n    }\n\n    /**\n     * Sfinae: Called when T provides getDeprecatedFields().\n     */\n    template&lt;class T&gt;\n    static DeprecatedFieldNames* getDeprecatedFieldNamesSfinae(const T&amp; target,\n        decltype(&amp;T::getDeprecatedFieldNames) /*enable_if_member_exists*/)\n    {\n        return target.getDeprecatedFieldNames();\n    }\n\n    /**\n     * Sfinae: Called when T does not provide getDeprecatedFields().\n     */\n    template&lt;class T&gt;\n    static DeprecatedFieldNames* getDeprecatedFieldNamesSfinae(const T&amp; /*target*/,\n        ... /*enable_if_member_exists*/)\n    {\n        return nullptr;\n    }\n\n    template&lt;class T, class Access&gt;\n    bool operator()(T&amp; target, const Access&amp; access,\n        const QnFusion::member_setter_tag&amp;)\n    {\n        using namespace QnFusion;\n\n        bool found = false;\n        const auto key = access(/*QnFusion::key*/ name);\n        if (!QJson::deserialize(\n            m_ctx,\n            m_object,\n            key,\n            &amp;(target.*access(/*QnFusion::key*/ setter)),\n            access(/*QnFusion::key*/ optional, /*defaultValue*/ true),\n            &amp;found,\n            getDeprecatedFieldNames(target),\n            typeid(target)))\n        {\n            return false;\n        }\n\n        if (found)\n        {\n            if (m_ctx-&gt;trackUnparsed())\n                m_object.remove(key);\n        }\n        else\n        {\n            m_ctx-&gt;setSomeFieldsNotFound(true);\n        }\n        return true;\n    }\n\n    template&lt;class T, class Access, class Member&gt;\n    bool operator()(T&amp; target, const Access&amp; access,\n        const QnFusion::typed_function_setter_tag&lt;Member&gt;&amp;)\n    {\n        using namespace QnFusion;\n\n        bool found = false;\n        const auto key = access(/*QnFusion::key*/ name);\n        Member member;\n        if (!QJson::deserialize(\n            m_ctx,\n            m_object,\n            key,\n            &amp;member,\n            access(/*QnFusion::key*/ optional, /*defaultValue*/ true),\n            &amp;found,\n            getDeprecatedFieldNames(target),\n            typeid(target)))\n        {\n            return false;\n        }\n\n        if (found)\n        {\n            invoke(access(/*QnFusion::key*/ setter), target, std::move(member));\n            if (m_ctx-&gt;trackUnparsed())\n                m_object.remove(key);\n        }\n        else\n        {\n            m_ctx-&gt;setSomeFieldsNotFound(true);\n        }\n        return true;\n    }\n\nprivate:\n    QnJsonContext* m_ctx;\n    const QJsonValue&amp; m_value;\n    QJsonObject m_object;\n};\n\n} // namespace QJsonDetail\n\n#if defined(_MSC_VER)\n/* Workaround against boost bug in variadic templates implementation, introduced in Boost 1.57. */\n#pragma warning(disable:4003)\n#endif\nQN_FUSION_REGISTER_SERIALIZATION_VISITORS(QJsonValue, QJsonDetail::SerializationVisitor, QJsonDetail::DeserializationVisitor)\n\n#define QN_FUSION_DEFINE_FUNCTIONS_json_lexical(TYPE, ... /* PREFIX */)         \\\n[[maybe_unused]]                                                                \\\n__VA_ARGS__ void serialize(QnJsonContext*, const TYPE &amp;value, QJsonValue* target) { \\\n    *target = QnLexical::serialized(value);                                     \\\n}                                                                               \\\n                                                                                \\\n[[maybe_unused]]                                                                \\\n__VA_ARGS__ bool deserialize(QnJsonContext*, const QJsonValue&amp; value, TYPE* target) { \\\n    QString string;                                                             \\\n    return QJson::deserialize(value, &amp;string) &amp;&amp; QnLexical::deserialize(string, target); \\\n}\n\n#define QN_FUSION_DEFINE_FUNCTIONS_json(TYPE, ... /* PREFIX */)                 \\\n[[maybe_unused]]                                                                \\\n__VA_ARGS__ void serialize(QnJsonContext* ctx, const TYPE&amp; value, QJsonValue* target) { \\\n    QnFusion::serialize(ctx, value, target);                                    \\\n}                                                                               \\\n                                                                                \\\n[[maybe_unused]]                                                                \\\n__VA_ARGS__ bool deserialize(QnJsonContext* ctx, const QJsonValue&amp; value, TYPE* target) { \\\n    return QnFusion::deserialize(ctx, value, target);                           \\\n}\n"}, "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/serialization.h": {"id": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/serialization.h", "filePath": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/serialization.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_SERIALIZATION_H\n#define QN_SERIALIZATION_H\n\n#include &lt;cassert&gt;\n#include &lt;type_traits&gt; /* For std::enable_if, std::is_base_of, std::integral_constant. */\n\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;nx/utils/conversion_wrapper.h&gt;\n#include &lt;nx/utils/flat_map.h&gt;\n#include &lt;nx/utils/log/assert.h&gt;\n#include &lt;nx/utils/log/log.h&gt;\n#include &lt;nx/utils/synchronized_flat_storage.h&gt;\n\nnamespace QnSerializationDetail {\n    template&lt;class Context, class T, class D&gt;\n    void serialize_direct(Context *ctx, const T &amp;value, D *target);\n    template&lt;class Context, class T, class D&gt;\n    bool deserialize_direct(Context *ctx, const D &amp;value, T *target);\n    template&lt;class T, class D&gt;\n    void serialize_internal(const T &amp;value, D *target);\n    template&lt;class T, class D&gt;\n    bool deserialize_internal(const D &amp;value, T *target);\n} // namespace QssDetail\n\nnamespace QnSerialization {\n    template&lt;class Serializer, class T, class Enable = void&gt;\n    struct default_serializer;\n} // namespace QnSerialization\n\ntemplate&lt;class Serializer&gt;\nclass QnSerializationContext {\npublic:\n    typedef Serializer serializer_type;\n\n    void registerSerializer(serializer_type *serializer) {\n        m_serializerByType.insert(serializer-&gt;type(), serializer);\n    }\n\n    void unregisterSerializer(int type) {\n        m_serializerByType.remove(type);\n    }\n\n    serializer_type *serializer(int type) const {\n        return m_serializerByType.value(type);\n    }\n\nprivate:\n    QnFlatMap&lt;unsigned int, serializer_type *&gt; m_serializerByType;\n};\n\nclass QnSerializerBase {\npublic:\n    QnSerializerBase(QMetaType type): m_type(type) {}\n    virtual ~QnSerializerBase() {}\n\n    QMetaType type() const {\n        return m_type;\n    }\n\n    QString idForToStringFromPtr() const {\n        return QString::number(m_type.id());\n    }\n\nprivate:\n    QMetaType m_type;\n};\n\nclass QnContextSerializerBase: public QnSerializerBase {\npublic:\n    QnContextSerializerBase(QMetaType type): QnSerializerBase(type) {}\n};\n\nclass QnBasicSerializerBase: public QnSerializerBase {\npublic:\n    QnBasicSerializerBase(QMetaType type): QnSerializerBase(type) {}\n};\n\ntemplate&lt;class D, class Context&gt;\nclass QnContextSerializer: public QnContextSerializerBase {\npublic:\n    typedef Context context_type;\n    typedef D data_type;\n\n    QnContextSerializer(QMetaType type): QnContextSerializerBase(type) {}\n\n    void serialize(context_type *ctx, const QVariant &amp;value, data_type *target) const {\n        NX_ASSERT(ctx &amp;&amp; value.metaType() == type() &amp;&amp; target);\n\n        serializeInternal(ctx, value.constData(), target);\n    }\n\n    void serialize(context_type *ctx, const void *value, data_type *target) const {\n        NX_ASSERT(ctx &amp;&amp; value &amp;&amp; target);\n\n        serializeInternal(ctx, value, target);\n    }\n\n    bool deserialize(context_type *ctx, const data_type &amp;value, QVariant *target) const {\n        NX_ASSERT(ctx &amp;&amp; target);\n\n        *target = QVariant(type());\n        return deserializeInternal(ctx, value, target-&gt;data());\n    }\n\n    bool deserialize(context_type *ctx, const data_type &amp;value, void *target) const {\n        NX_ASSERT(ctx &amp;&amp; target);\n\n        return deserializeInternal(ctx, value, target);\n    }\n\nprotected:\n    virtual void serializeInternal(context_type *ctx, const void *value, data_type *target) const = 0;\n    virtual bool deserializeInternal(context_type *ctx, const data_type &amp;value, void *target) const = 0;\n};\n\ntemplate&lt;class T, class Base&gt;\nclass QnDefaultContextSerializer: public Base {\npublic:\n    using typename Base::context_type;\n    using typename Base::data_type;\n\n    QnDefaultContextSerializer(): Base(QMetaType::fromType&lt;T&gt;()) {}\n\nprotected:\n    virtual void serializeInternal(context_type *ctx, const void *value, data_type *target) const override {\n        QnSerializationDetail::serialize_direct(ctx, *static_cast&lt;const T *&gt;(value), target);\n    }\n\n    virtual bool deserializeInternal(context_type *ctx, const data_type &amp;value, void *target) const override {\n        return QnSerializationDetail::deserialize_direct(ctx, value, static_cast&lt;T *&gt;(target));\n    }\n};\n\ntemplate&lt;class D&gt;\nclass QnBasicSerializer: public QnBasicSerializerBase {\npublic:\n    typedef D data_type;\n\n    QnBasicSerializer(QMetaType type): QnBasicSerializerBase(type) {}\n\n    void serialize(const QVariant &amp;value, data_type *target) const {\n        NX_ASSERT(value.userType() == type().id() &amp;&amp; target);\n\n        serializeInternal(value.constData(), target);\n    }\n\n    void serialize(const void *value, data_type *target) const {\n        NX_ASSERT(value &amp;&amp; target);\n\n        serializeInternal(value, target);\n    }\n\n    bool deserialize(const data_type &amp;value, QVariant *target) const {\n        NX_ASSERT(target);\n\n        *target = QVariant(type(), static_cast&lt;const void *&gt;(NULL));\n        return deserializeInternal(value, target-&gt;data());\n    }\n\n    bool deserialize(const data_type &amp;value, void *target) const {\n        NX_ASSERT(target);\n\n        return deserializeInternal(value, target);\n    }\n\nprotected:\n    virtual void serializeInternal(const void *value, data_type *target) const = 0;\n    virtual bool deserializeInternal(const data_type &amp;value, void *target) const = 0;\n};\n\ntemplate&lt;class T, class Base&gt;\nclass QnDefaultBasicSerializer: public Base {\npublic:\n    using typename Base::data_type;\n\n    QnDefaultBasicSerializer(): Base(QMetaType::fromType&lt;T&gt;()) {}\n\nprotected:\n    virtual void serializeInternal(const void *value, data_type *target) const override {\n        QnSerializationDetail::serialize_internal(*static_cast&lt;const T *&gt;(value), target);\n    }\n\n    virtual bool deserializeInternal(const data_type &amp;value, void *target) const override {\n        return QnSerializationDetail::deserialize_internal(value, static_cast&lt;T *&gt;(target));\n    }\n};\n\ntemplate&lt;class Serializer&gt;\nclass QnSerializerStorage\n{\npublic:\n    Serializer* serializer(int type)\n    {\n        NX_ASSERT(!m_storage.empty(), &quot;%1 search in empty storage&quot;, this);\n\n        const auto value = m_storage.value(type);\n        NX_VERBOSE(this, &quot;Return type %1 &#x27;%2&#x27;: %3&quot;, type, QMetaType(type).name(), value);\n        return value;\n    }\n\n    QSet&lt;Serializer*&gt; serializers()\n    {\n        const auto values = m_storage.values();\n        NX_VERBOSE(this, &quot;Return %1 serializers&quot;, values.count());\n        return values;\n    }\n\n    void registerSerializer(Serializer* serializer)\n    {\n        const auto type = serializer-&gt;type();\n        if (const auto existing = m_storage.value(type.id()))\n        {\n            NX_ASSERT(typeid(*existing) == typeid(*serializer),\n                &quot;%1 Overriding %2 with %3&quot;, this, existing, serializer);\n            return;\n        }\n\n        NX_DEBUG(this, &quot;Register %1 &#x27;%2&#x27;: %3&quot;, type.id(), type.name(), serializer);\n        m_storage.insert(type.id(), serializer);\n    }\n\n    template&lt;class T&gt;\n    void registerSerializer()\n    {\n        registerSerializer(new typename QnSerialization::default_serializer&lt;Serializer, T&gt;::type());\n    }\n\nprivate:\n    QnSynchronizedFlatStorage&lt;int, Serializer*&gt; m_storage;\n};\n\ntemplate&lt;class Serializer, class Instance&gt;\nclass QnStaticSerializerStorage {\npublic:\n    static Serializer *serializer(int type) { return Instance()()-&gt;serializer(type); }\n    static QSet&lt;Serializer *&gt; serializers() { return Instance()()-&gt;serializers(); }\n    static void registerSerializer(Serializer *serializer) { Instance()()-&gt;registerSerializer(serializer); }\n    template&lt;class T&gt;\n    static void registerSerializer() { registerSerializer(new typename QnSerialization::default_serializer&lt;Serializer, T&gt;::type()); }\n};\n\n\nnamespace QnSerializationDetail {\n\n    /* Internal interface for (de)serializers that do not use context. */\n\n    template&lt;class T, class D&gt;\n    void serialize_internal(const T &amp;value, D *target) {\n        serialize(value, target); /* That&#x27;s the place where ADL kicks in. */\n    }\n\n    template&lt;class T, class D&gt;\n    bool deserialize_internal(const D &amp;value, T *target) {\n        /* That&#x27;s the place where ADL kicks in.\n         *\n         * Note that we wrap a serialized type into a wrapper so that\n         * ADL would find only overloads with it as the first parameter.\n         * Otherwise, other overloads could also be discovered.\n         *\n         * Also note that disable_user_conversions is also looked up via ADL, and thus\n         * conversion wrapping for the data type can actually be disabled by\n         * overloading disable_user_conversions. */\n        return deserialize(disable_user_conversions(value), target);\n    }\n\n    /* Internal interface for (de)serializers that use context. */\n\n    template&lt;class Context, class T, class D&gt;\n    void serialize_direct(Context *ctx, const T &amp;value, D *target) {\n        serialize(ctx, value, target); /* That&#x27;s the place where ADL kicks in. */\n    }\n\n    template&lt;class Context, class T, class D&gt;\n    bool deserialize_direct(Context *ctx, const D &amp;value, T *target) {\n        /* That&#x27;s the place where ADL kicks in.\n         *\n         * Note that we wrap a serialized type into a wrapper so that\n         * ADL would find only overloads with it as the first parameter.\n         * Otherwise, other overloads could also be discovered. */\n        return deserialize(ctx, disable_user_conversions(value), target);\n    }\n\n    template&lt;class T&gt;\n    struct is_metatype_defined:\n        std::integral_constant&lt;bool, QMetaTypeId2&lt;T&gt;::Defined&gt;\n    {};\n\n    template&lt;class Context, class T, class D&gt;\n    void serialize_internal(Context *ctx, const T &amp;value, D *target,\n        std::enable_if_t&lt;is_metatype_defined&lt;T&gt;::value&gt; * = NULL) {\n\n        typename Context::serializer_type *serializer = ctx-&gt;serializer(qMetaTypeId&lt;T&gt;());\n        if(serializer) {\n            serializer-&gt;serialize(ctx, static_cast&lt;const void *&gt;(&amp;value), target);\n        } else {\n            serialize_direct(ctx, value, target);\n        }\n    }\n\n    template&lt;class Context, class T, class D&gt;\n    void serialize_internal(Context *ctx, const T &amp;value, D *target,\n        std::enable_if_t&lt;!is_metatype_defined&lt;T&gt;::value&gt; * = NULL) {\n\n        serialize_direct(ctx, value, target);\n    }\n\n    template&lt;class Context, class T, class D&gt;\n    bool deserialize_internal(Context *ctx, const D &amp;value, T *target,\n        typename std::enable_if&lt;is_metatype_defined&lt;T&gt;::value&gt;::type * = NULL) {\n\n        typename Context::serializer_type *serializer = ctx-&gt;serializer(qMetaTypeId&lt;T&gt;());\n        if(serializer) {\n            return serializer-&gt;deserialize(ctx, value, static_cast&lt;void *&gt;(target));\n        } else {\n            return deserialize_direct(ctx, value, target);\n        }\n    }\n\n    template&lt;class Context, class T, class D&gt;\n    bool deserialize_internal(Context *ctx, const D &amp;value, T *target,\n        typename std::enable_if&lt;!is_metatype_defined&lt;T&gt;::value&gt;::type * = NULL) {\n\n        return deserialize_direct(ctx, value, target);\n    }\n\n} // namespace QnSerializationDetail\n\nnamespace QnSerialization {\n\n    /* Public interface for (de)serializers that do not use context. */\n\n    template&lt;class T, class D&gt;\n    void serialize(const T &amp;value, D *target) {\n        NX_ASSERT(target);\n        QnSerializationDetail::serialize_internal(value, target);\n    }\n\n    template&lt;class T, class D&gt;\n    bool deserialize(const D &amp;value, T *target) {\n        NX_ASSERT(target);\n        return QnSerializationDetail::deserialize_internal(value, target);\n    }\n\n\n    /* Public interface for (de)serializers that use context. */\n\n    // TODO: use template for context, with static_assert, so that the\n    // actual type is passed down the call tree.\n\n    template&lt;class Context, class T, class D&gt;\n    void serialize(Context *ctx, const T &amp;value, D *target) {\n        NX_ASSERT(ctx &amp;&amp; target);\n        QnSerializationDetail::serialize_internal(ctx, value, target);\n    }\n\n    template&lt;class Context, class T, class D&gt;\n    bool deserialize(Context *ctx, const D &amp;value, T *target) {\n        NX_ASSERT(ctx &amp;&amp; target);\n        return QnSerializationDetail::deserialize_internal(ctx, value, target);\n    }\n\n    template&lt;class Serializer, class T&gt;\n    struct default_serializer&lt;Serializer, T, typename std::enable_if&lt;std::is_base_of&lt;QnContextSerializerBase, Serializer&gt;::value&gt;::type&gt; {\n        typedef QnDefaultContextSerializer&lt;T, Serializer&gt; type;\n    };\n\n    template&lt;class Serializer, class T&gt;\n    struct default_serializer&lt;Serializer, T, typename std::enable_if&lt;std::is_base_of&lt;QnBasicSerializerBase, Serializer&gt;::value&gt;::type&gt; {\n        typedef QnDefaultBasicSerializer&lt;T, Serializer&gt; type;\n    };\n\n} // namespace QnSerialization\n\n#endif // QN_SERIALIZATION_H\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/abstract_data_packet.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/abstract_data_packet.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/abstract_data_packet.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;nx/utils/datetime.h&gt;\n\nclass QnAbstractStreamDataProvider;\n\nstruct NX_MEDIA_CORE_API QnAbstractDataPacket\n{\n    virtual ~QnAbstractDataPacket() = default;\n\n    qint64 timestamp = DATETIME_INVALID; //&lt; TODO: Rename to timestampUs.\n\n    bool isSpecialTimeValue() const\n    {\n        return timestamp &lt; 0 || timestamp == DATETIME_NOW;\n    }\n};\n\ntypedef std::shared_ptr&lt;QnAbstractDataPacket&gt; QnAbstractDataPacketPtr;\ntypedef std::shared_ptr&lt;const QnAbstractDataPacket&gt; QnConstAbstractDataPacketPtr;\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/aligned_allocator.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/aligned_allocator.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/aligned_allocator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_ALIGNED_ALLOCATOR_H\n#define QN_ALIGNED_ALLOCATOR_H\n\n#include &lt;memory&gt;\n\n#include &lt;nx/media/config.h&gt;\n\ntemplate &lt;typename T, std::size_t N = CL_MEDIA_ALIGNMENT&gt;\nclass QnAlignedAllocator {\npublic:\n    typedef T value_type;\n    typedef std::size_t size_type;\n    typedef std::ptrdiff_t difference_type;\n\n    typedef T * pointer;\n    typedef const T * const_pointer;\n\n    typedef T &amp; reference;\n    typedef const T &amp; const_reference;\n\npublic:\n    QnAlignedAllocator() throw() {}\n\n    template &lt;typename T2&gt;\n    QnAlignedAllocator(const QnAlignedAllocator&lt;T2, N&gt; &amp;) throw() {}\n\n    ~QnAlignedAllocator() throw() {}\n    pointer address(reference r) { return &amp;r; }\n    const_pointer address(const_reference r) const { return &amp;r; }\n    pointer allocate(size_type n) { return (pointer) qMallocAligned(n * sizeof(value_type), N); }\n    void deallocate(pointer p, size_type) { qFreeAligned(p); }\n    void construct(pointer p, const value_type &amp;wert) { new (p) value_type(wert); }\n\n    /**\n     * C++11 extension member.\n     */\n    void construct(pointer p) { new (p) value_type(); }\n    void destroy(pointer p) { p-&gt;~value_type(); }\n    size_type max_size() const throw() { return size_type(-1) / sizeof(value_type); }\n\n    template &lt;typename T2&gt;\n    struct rebind {\n        typedef QnAlignedAllocator&lt;T2, N&gt; other;\n    };\n\n    bool operator!=(const QnAlignedAllocator&lt;T, N&gt; &amp;other) const { return !(*this == other); }\n\n    /**\n     * \\param other\n     * \\returns True if and only if storage allocated from \\a this can be deallocated from \\a other.\n     *          Always returns true for stateless allocators.\n     */\n    bool operator==(const QnAlignedAllocator&lt;T,N&gt;&amp; /*other*/) const { return true; }\n};\n\n#endif // QN_ALIGNED_ALLOCATOR_H\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/codec_parameters.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/codec_parameters.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/codec_parameters.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\nextern &quot;C&quot; {\n#include &lt;libavcodec/avcodec.h&gt;\n#include &lt;libavformat/avformat.h&gt;\n} // extern &quot;C&quot;\n\n#include &lt;memory&gt;\n\n#include &lt;QtCore/QByteArray&gt;\n\n/**\n * Class that wraps (and owns) AVCodecParameters\n */\nclass NX_MEDIA_CORE_API CodecParameters\n{\npublic:\n    virtual ~CodecParameters();\n\n    // Deserialize from ubjson format.\n    // Specify &#x27;version&#x27; only for the version of VMS between 5.0 - 5.0.34644, all other versions\n    // should be analyzed automatically(zero value).\n    bool deserialize(const char* data, int size, int version = 0);\n\n    // Serialize to ubjson format.\n    QByteArray serialize() const;\n\n    // Serialize to ubjson format that compatible with version 4.2 and below\n    QByteArray serializeInDeprecatedFormat42() const;\n\n    CodecParameters();\n\n    /**\n     * Copy the specified AVCodecContext into the internal one.\n     */\n    CodecParameters(const AVCodecContext* codecContext);\n\n    /**\n     * Copy the specified AVCodecParameters into the internal ones.\n     */\n    CodecParameters(const AVCodecParameters* avCodecParams);\n\n    /**\n     * @return Pointer to the internal AVCodecContext which can be altered.\n     */\n    AVCodecParameters* getAvCodecParameters() const { return m_codecParams; }\n\n    void toAvCodecContext(AVCodecContext* context) const;\n\n    /**\n     * Replace existing extradata with the copy of the provided one.\n     * @param extradata Can be null, in which case extradata_size is ignored.\n     * @param extradata_size Can be 0.\n     */\n    void setExtradata(const uint8_t* data, int size);\n\n    // Check equality\n    bool isEqual(const CodecParameters&amp; other) const;\n\n    QString toString() const;\n\n    // Can be empty, but never null.\n    QString codecName() const;\n\n    // Can be empty, but never null.\n    QString getAudioCodecDescription() const;\n\n    //--------------------------------------------------------------------------\n\n    AVCodecID getCodecId() const;\n    AVMediaType getCodecType() const;\n    const quint8* getExtradata() const;\n    int getExtradataSize() const;\n\n    int getChannels() const;\n    int getSampleRate() const;\n    AVSampleFormat getSampleFmt() const;\n    int getBitsPerCodedSample() const;\n    int getWidth() const;\n    int getHeight() const;\n    int getBitRate() const;\n    quint64 getChannelLayout() const;\n    int getBlockAlign() const;\n    int getFrameSize() const;\n\n    int version() const;\n\nprivate:\n    CodecParameters(const CodecParameters&amp;);\n    CodecParameters&amp; operator=(const CodecParameters&amp;);\n\n    AVCodecParameters* m_codecParams;\n    int m_version = 0;\n};\n\nusing CodecParametersPtr = std::shared_ptr&lt;CodecParameters&gt;;\nusing CodecParametersConstPtr = std::shared_ptr&lt;const CodecParameters&gt;;\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/media_data_packet.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/media_data_packet.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/media_data_packet.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include &lt;nx/media/abstract_data_packet.h&gt;\n#include &lt;nx/media/codec_parameters.h&gt;\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/utils/byte_array.h&gt;\n\n// TODO: #dmishin move all classes to separate source files.\n// TODO: #dmishin place this code into proper namespace.\n\nenum MediaQuality\n{\n    MEDIA_Quality_High = 1,\n    MEDIA_Quality_Low = 2,\n    // At current version MEDIA_Quality_ForceHigh is very similar to MEDIA_Quality_High.\n    // It used for export to &#x27;avi&#x27; or &#x27;mkv&#x27;.\n    // This mode do not tries first short LQ chunk if LQ chunk has slightly better position\n    MEDIA_Quality_ForceHigh,\n    MEDIA_Quality_ForceLow,\n    MEDIA_Quality_Auto,\n    MEDIA_Quality_CustomResolution,\n    MEDIA_Quality_LowIframesOnly,\n    MEDIA_Quality_None\n};\n\ntemplate&lt;typename Visitor&gt;\nconstexpr auto nxReflectVisitAllEnumItems(MediaQuality*, Visitor&amp;&amp; visitor)\n{\n    using Item = nx::reflect::enumeration::Item&lt;MediaQuality&gt;;\n    return visitor(\n        Item{MEDIA_Quality_High, &quot;high&quot;},\n        Item{MEDIA_Quality_Low, &quot;low&quot;},\n        Item{MEDIA_Quality_ForceHigh, &quot;force-high&quot;},\n        Item{MEDIA_Quality_Auto, &quot;auto&quot;},\n        Item{MEDIA_Quality_CustomResolution, &quot;custom&quot;},\n        Item{MEDIA_Quality_LowIframesOnly, &quot;low-iframes-only&quot;},\n        Item{MEDIA_Quality_None, &quot;&quot;}\n    );\n}\n\nNX_MEDIA_CORE_API bool isLowMediaQuality(MediaQuality q);\n\nstruct QnAbstractMediaData;\nstruct QnEmptyMediaData;\n\nusing QnAbstractMediaDataPtr = std::shared_ptr&lt;QnAbstractMediaData&gt;;\nusing QnConstAbstractMediaDataPtr = std::shared_ptr&lt;const QnAbstractMediaData&gt;;\nusing QnEmptyMediaDataPtr = std::shared_ptr&lt;QnEmptyMediaData&gt;;\n\nstruct NX_MEDIA_CORE_API QnAbstractMediaData: public QnAbstractDataPacket\n{\n\npublic:\n    NX_REFLECTION_ENUM_IN_CLASS(MediaFlag,\n        MediaFlags_None                 = 0x00000,\n        // KeyFrame, must be equal to AV_PKT_FLAG_KEY from avcodec.h,\n        // checked via static_assert below.\n        MediaFlags_AVKey                = 0x00001,\n        MediaFlags_AfterEOF             = 0x00002,\n        MediaFlags_BOF                  = 0x00004,\n        MediaFlags_LIVE                 = 0x00008,\n        // The frame should not be displayed.\n        MediaFlags_Ignore               = 0x00010,\n\n        MediaFlags_ReverseReordered     = 0x00020,\n        MediaFlags_ReverseBlockStart    = 0x00040,\n        MediaFlags_Reverse              = 0x00080,\n\n        MediaFlags_LowQuality           = 0x00100,\n        MediaFlags_StillImage           = 0x00200,\n\n        // Switch archive to a new server.\n        MediaFlags_NewServer            = 0x00400,\n        MediaFlags_newCodecParams       = 0x00800,\n        // Fast channel zapping flag.\n        MediaFlags_FCZ                  = 0x01000,\n\n        MediaFlags_ReplacedVideo        = 0x02000,\n\n        // Hardware decoding is used.\n        MediaFlags_HWDecodingUsed       = 0x04000,\n        // Ignore syncplay mode.\n        MediaFlags_PlayUnsync           = 0x08000,\n        // Ignore packet at all.\n        MediaFlags_Skip                 = 0x10000,\n        MediaFlags_AlwaysSave           = 0x20000,\n\n        // The only intention for packets with such a flag is to be shown to the user in the Live\n        // mode. They are not going to be recorded.\n        MediaFlags_LiveOnly             = 0x40000,\n\n        // Best shot packets. They can be pipelined with some delay from live. Will not be recorded\n        // to mkv files. Will not be reordered in AbstractDataReorderer.\n        MediaFlags_MetaDataBestShot     = 0x80000,\n\n        // Media packet from old archive version that should be BOM decoded before decryption\n        // This flag can be removed in a 5.3\n        MediaFlags_BomDecoding         = 0x100000,\n\n        // Flag indicates that motion sensitivity should be temporary increased in region\n        // where object metadata was recently received.\n        MediaFlags_UpdateMotionSensitivity = 0x200000,\n\n        // Flag indicates to the first frame after a removed portion of the stream (e.g. when\n        // clearing the media queue due to overflow).\n        MediaFlags_Discontinuity        = 0x400000\n    )\n\n    Q_DECLARE_FLAGS(MediaFlags, MediaFlag)\n\n    NX_REFLECTION_ENUM_IN_CLASS(DataType,\n        UNKNOWN = -1,\n        VIDEO = 0,\n        AUDIO,\n        CONTAINER,\n        EMPTY_DATA,\n        META_V1, //&lt; Deprecated. Don&#x27;t use it. Use MetadataType instead.\n        GENERIC_METADATA\n    )\n\npublic:\n    QnAbstractMediaData(DataType _dataType);\n    virtual ~QnAbstractMediaData();\n\n    virtual QnAbstractMediaData* clone() const = 0;\n\n    virtual const char* data() const = 0;\n    virtual size_t dataSize() const = 0;\n\n    virtual void setData(nx::utils::ByteArray&amp;&amp; buffer) = 0;\n\n    bool isLQ() const;\n    bool isLive() const;\n\n    QString idForToStringFromPtr() const;\n\npublic:\n    QnAbstractStreamDataProvider* dataProvider;\n    DataType dataType;\n    AVCodecID compressionType;\n    mutable MediaFlags flags;\n    // Video or audio channel number. Some devices might have more than one sensor.\n    quint32 channelNumber;\n    CodecParametersConstPtr context;\n    int opaque;\n    std::vector&lt;uint8_t&gt; encryptionData; //&lt; Its non-empty in case of packet is encrypted.\nprotected:\n    void assign(const QnAbstractMediaData* other);\n};\n\nAVMediaType NX_MEDIA_CORE_API toAvMediaType(QnAbstractMediaData::DataType dataType);\n\nQ_STATIC_ASSERT(AV_PKT_FLAG_KEY == QnAbstractMediaData::MediaFlags_AVKey);\nQ_DECLARE_OPERATORS_FOR_FLAGS(QnAbstractMediaData::MediaFlags)\n\nstruct NX_MEDIA_CORE_API QnEmptyMediaData: public QnAbstractMediaData\n{\n\npublic:\n    QnEmptyMediaData();\n\n    virtual QnEmptyMediaData* clone() const override;\n\n    virtual const char* data() const override;\n    virtual size_t dataSize() const override;\n\n    virtual void setData(nx::utils::ByteArray&amp;&amp; buffer) override;\n\npublic:\n    nx::utils::ByteArray m_data;\n};\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/auth_tools.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/auth_tools.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/auth_tools.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n/**\n * @file\n * Helper functions for calculating HTTP Digest (rfc2617).\n */\n\n#pragma once\n\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\n#include &quot;../app_info.h&quot;\n#include &quot;http_types.h&quot;\n\nclass QAuthenticator;\n\nnamespace nx::network::http {\n\nNX_REFLECTION_ENUM_CLASS(AuthTokenType,\n    none,\n    password,\n    ha1,\n    bearer\n)\n\n/**\n * An HTTP auth token. It can be either password, HA1 hash or a bearer token.\n */\nclass NX_NETWORK_API AuthToken\n{\npublic:\n    std::string value;\n    AuthTokenType type = AuthTokenType::none;\n\n    void setPassword(const std::string_view&amp; password);\n    bool isPassword() const;\n    void setHa1(const std::string_view&amp; ha1);\n    bool isHa1() const;\n    void setBearerToken(const std::string_view&amp; bearer);\n    bool isBearerToken() const;\n    bool empty() const;\n\n    bool operator==(const AuthToken&amp; other) const = default;\n};\n\nclass NX_NETWORK_API PasswordAuthToken:\n    public AuthToken\n{\npublic:\n    PasswordAuthToken(const std::string_view&amp; password);\n};\n\nclass NX_NETWORK_API Ha1AuthToken:\n    public AuthToken\n{\npublic:\n    Ha1AuthToken(const std::string_view&amp; ha1);\n};\n\nclass NX_NETWORK_API BearerAuthToken:\n    public AuthToken\n{\npublic:\n    BearerAuthToken(const std::string_view&amp; token);\n};\n\nclass NX_NETWORK_API VideoWallAuthToken:\n    public AuthToken\n{\npublic:\n    static inline const std::string prefix = &quot;videoWall-&quot;;\n\n    VideoWallAuthToken(const nx::Uuid&amp; videoWallId);\n};\n\nclass NX_NETWORK_API Credentials\n{\npublic:\n    std::string username;\n    AuthToken authToken;\n\n    Credentials() = default;\n    Credentials(const std::string_view&amp; username, const AuthToken&amp; authToken);\n    Credentials(const BearerAuthToken&amp; authToken);\n\n    // TODO: #akolesnikov get rid of this constructor. Credentials can be used instead of QAuthenticator\n    // across the code.\n    Credentials(const QAuthenticator&amp; credentials);\n\n    bool operator==(const Credentials&amp; other) const = default;\n};\n\n/** GTest support. */\nNX_NETWORK_API void PrintTo(const Credentials&amp; val, ::std::ostream* os);\n\nclass NX_NETWORK_API PasswordCredentials: public Credentials\n{\npublic:\n    PasswordCredentials(const std::string_view&amp; username, const std::string_view&amp; password):\n        Credentials(username, PasswordAuthToken(password))\n    {\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Data structure to store and load credentials in a way compatible with Qt. This representation\n * is also more user-friendly, so can be used in public api.\n */\nstruct NX_NETWORK_API SerializableCredentials\n{\n    std::string user;\n    std::optional&lt;std::string&gt; password;\n    std::optional&lt;std::string&gt; ha1;\n    std::optional&lt;std::string&gt; token;\n\n    SerializableCredentials() = default;\n    SerializableCredentials(std::string user);\n    SerializableCredentials(const Credentials&amp; credentials);\n\n    operator Credentials() const;\n    bool operator==(const SerializableCredentials&amp; other) const = default;\n};\n#define SerializableCredentials_Fields (user)(password)(ha1)(token)\nNX_REFLECTION_INSTRUMENT(SerializableCredentials, SerializableCredentials_Fields);\n\n//-------------------------------------------------------------------------------------------------\n\nstruct AuthInfo\n{\n    Credentials credentials;\n    Credentials proxyCredentials;\n    // TODO: #akolesnikov Remove proxyEndpoint and isProxySecure from here.\n    SocketAddress proxyEndpoint;\n    bool isProxySecure = false;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nNX_NETWORK_API std::optional&lt;header::Authorization&gt; generateAuthorization(\n    const Request&amp; request,\n    const Credentials&amp; credentials,\n    const header::WWWAuthenticate&amp; wwwAuthenticateHeader);\n\nNX_NETWORK_API std::optional&lt;header::Authorization&gt; generateDigestAuthorization(\n    const Request&amp; request,\n    const Credentials&amp; credentials,\n    const header::WWWAuthenticate&amp; wwwAuthenticateHeader,\n    int nonceCount);\n\nNX_NETWORK_API std::string calcHa1(\n    const std::string_view&amp; userName,\n    const std::string_view&amp; realm,\n    const std::string_view&amp; userPassword,\n    const std::string_view&amp; algorithm = {});\n\nNX_NETWORK_API std::string calcHa2(\n    const Method&amp; method,\n    const std::string_view&amp; uri,\n    const std::string_view&amp; algorithm = {});\n\nNX_NETWORK_API std::string calcResponse(\n    const std::string_view&amp; ha1,\n    const std::string_view&amp; nonce,\n    const std::string_view&amp; ha2,\n    const std::string_view&amp; algorithm = {});\n\nNX_NETWORK_API std::string calcResponseAuthInt(\n    const std::string_view&amp; ha1,\n    const std::string_view&amp; nonce,\n    const std::string_view&amp; nonceCount,\n    const std::string_view&amp; clientNonce,\n    const std::string_view&amp; qop,\n    const std::string_view&amp; ha2,\n    const std::string_view&amp; algorithm = {});\n\n/**\n * NOTE: If predefinedHa1 is present, then it is used. Otherwise, HA1 is calculated based on userPassword.\n */\nNX_NETWORK_API bool calcDigestResponse(\n    const Method&amp; method,\n    const std::string_view&amp; userName,\n    const std::optional&lt;std::string_view&gt;&amp; userPassword,\n    const std::optional&lt;std::string_view&gt;&amp; predefinedHa1,\n    const std::string_view&amp; uri,\n    const std::map&lt;std::string, std::string&gt;&amp; inputParams,\n    std::map&lt;std::string, std::string&gt;* outputParams);\n\nNX_NETWORK_API bool calcDigestResponse(\n    const Method&amp; method,\n    const std::string_view&amp; userName,\n    const std::optional&lt;std::string_view&gt;&amp; userPassword,\n    const std::optional&lt;std::string_view&gt;&amp; predefinedHa1,\n    const std::string_view&amp; uri,\n    const header::WWWAuthenticate&amp; wwwAuthenticateHeader,\n    header::DigestAuthorization* const digestAuthorizationHeader,\n    int nonceCount = 1);\n\nbool NX_NETWORK_API calcDigestResponse(\n    const Method&amp; method,\n    const Credentials&amp; credentials,\n    const std::string_view&amp; uri,\n    const header::WWWAuthenticate&amp; wwwAuthenticateHeader,\n    header::DigestAuthorization* const digestAuthorizationHeader,\n    int nonceCount = 1);\n\n/**\n * To be used by server to validate received Authorization against known credentials.\n */\nNX_NETWORK_API bool validateAuthorization(\n    const Method&amp; method,\n    const std::string_view&amp; userName,\n    const std::optional&lt;std::string_view&gt;&amp; userPassword,\n    const std::optional&lt;std::string_view&gt;&amp; predefinedHa1,\n    const header::DigestAuthorization&amp; digestAuthorizationHeader);\n\nNX_NETWORK_API bool validateAuthorization(\n    const Method&amp; method,\n    const std::string_view&amp; userName,\n    const std::optional&lt;std::string_view&gt;&amp; userPassword,\n    const std::optional&lt;std::string_view&gt;&amp; predefinedHa1,\n    const header::DigestCredentials&amp; digestAuthorizationHeader);\n\nNX_NETWORK_API bool validateAuthorization(\n    const Method&amp; method,\n    const Credentials&amp; credentials,\n    const header::DigestAuthorization&amp; digestAuthorizationHeader);\n\nNX_NETWORK_API bool validateAuthorization(\n    const Method&amp; method,\n    const Credentials&amp; credentials,\n    const header::DigestCredentials&amp; digestAuthorizationHeader);\n\nNX_NETWORK_API bool validateAuthorizationByIntemerdiateResponse(\n    const Method&amp; method,\n    const std::string_view&amp; intermediateResponse,\n    const std::string_view&amp; baseNonce,\n    const header::DigestCredentials&amp; digestAuthorizationHeader);\n\n/**\n * @param ha1 That&#x27;s what calcHa1 has returned.\n * WARNING: ha1.size() + 1 + nonce.size() MUST be divisible by 64!\n *   This is requirement of MD5 algorithm.\n */\nNX_NETWORK_API std::string calcIntermediateResponse(\n    const std::string_view&amp; ha1,\n    const std::string_view&amp; nonce);\n\n/**\n * Calculates MD5(ha1:nonce:ha2).\n * nonce is concatenation of nonceBase and nonceTrailer.\n * intermediateResponse is result of nx::network::http::calcIntermediateResponse.\n * @param intermediateResponse Calculated with calcIntermediateResponse.\n * @param intermediateResponseNonceLen Length of nonce (bytes) used to generate intermediateResponse.\n */\nNX_NETWORK_API std::string calcResponseFromIntermediate(\n    const std::string_view&amp; intermediateResponse,\n    size_t intermediateResponseNonceLen,\n    const std::string_view&amp; nonceTrailer,\n    const std::string_view&amp; ha2);\n\n/**\n * Generates nonce according to rfc7616.\n */\nNX_NETWORK_API std::string generateNonce(\n    const std::string&amp; eTag = std::string());\n\nNX_NETWORK_API header::WWWAuthenticate generateWwwAuthenticateBasicHeader(\n    const std::string&amp; realm = AppInfo::realm());\n\nNX_NETWORK_API header::WWWAuthenticate generateWwwAuthenticateDigestHeader(\n    const std::string&amp; nonce,\n    const std::string&amp; realm = AppInfo::realm());\n\nNX_NETWORK_API std::string digestUri(const Method&amp; method, const nx::Url&amp; url);\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Interface of a class-source of HTTP credentials.\n */\nclass NX_NETWORK_API AbstractCredentialsProvider\n{\npublic:\n    struct Result\n    {\n        Credentials credentials;\n        std::optional&lt;std::chrono::system_clock::time_point&gt; expirationTime;\n    };\n\n    virtual ~AbstractCredentialsProvider() = default;\n\n    /**\n     * Returns the credentials or std::nullopt if there are no credentials at this moment.\n     * It is recommended that the implementation is thread-safe.\n     */\n    virtual std::optional&lt;Result&gt; get() const = 0;\n};\n\n} // namespace nx::network::http\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;compare&gt;\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QDateTime&gt;\n\n#include &lt;nx/network/socket_common.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/log/assert.h&gt;\n#include &lt;nx/utils/software_version.h&gt;\n#include &lt;nx/utils/std/cpp20.h&gt;\n#include &lt;nx/utils/stree/attribute_dictionary.h&gt;\n#include &lt;nx/utils/string.h&gt;\n#include &lt;nx/utils/type_utils.h&gt;\n#include &lt;nx/utils/url.h&gt;\n\n#include &quot;http_status.h&quot;\n\n/**\n * Holds HTTP implementation suitable for async/sync i/o.\n * Common structures, parsers/serializers, http client, http server.\n *\n * All classes use std::string for representing HTTP headers and nx::Buffer wherever\n * a raw buffer is needed.\n */\nnamespace nx::network::http {\n\nconst int DEFAULT_HTTP_PORT = 80;\nconst int DEFAULT_HTTPS_PORT = 443;\n\nstatic constexpr char kUrlSchemeName[] = &quot;http&quot;;\nstatic constexpr char kSecureUrlSchemeName[] = &quot;https&quot;;\n\nNX_NETWORK_API const char* urlScheme(bool isSecure);\n\nNX_NETWORK_API bool isUrlScheme(const std::string_view&amp; scheme);\n\n// Emulating explicit isUrlScheme(const QString&amp;).\ntemplate&lt;typename S, typename = std::enable_if_t&lt;std::is_same_v&lt;S, QString&gt;&gt;&gt;\nbool isUrlScheme(const S&amp; s)\n{\n    return isUrlScheme(s.toStdString());\n}\n\nNX_NETWORK_API int defaultPortForScheme(const std::string_view&amp; scheme);\nNX_NETWORK_API int defaultPort(bool isSecure);\n\n/** HTTP header container.\n * WARNING: This is multimap(!) to allow same header be present multiple times in a\n * single http message.\n * To insert or replace use nx::network::http::insertOrReplaceHeader\n */\nusing HttpHeaders = std::multimap&lt;std::string, std::string, nx::utils::ci_less&gt;;\nusing HttpHeader = HttpHeaders::value_type;\n\n/** map&lt;name, value&gt;. */\nclass RequestPathParams:\n    public nx::utils::stree::StringAttrDict\n{\n    using base_type = nx::utils::stree::StringAttrDict;\n\npublic:\n    using base_type::base_type;\n\n    std::string getByName(const std::string&amp; name) const\n    {\n        auto it = find(name);\n        return it != end() ? it-&gt;second : std::string();\n    }\n};\n\n/**\n * This is convenient method for simplify transition from QHttp.\n * @return Value of header headerName (if found), empty string otherwise.\n*/\nNX_NETWORK_API std::string getHeaderValue(\n    const HttpHeaders&amp; headers, const std::string_view&amp; headerName);\n\n/**\n * @return false if requested header was not found.\n */\nNX_NETWORK_API bool readHeader(\n    const HttpHeaders&amp; headers,\n    const std::string_view&amp; headerName,\n    int* value);\n\n/**\n * Convenient function for inserting or replacing header.\n * @return iterator of added element.\n */\nNX_NETWORK_API HttpHeaders::iterator insertOrReplaceHeader(\n    HttpHeaders* const headers, const HttpHeader&amp; newHeader);\n\ntemplate&lt;typename HeaderType&gt;\nHttpHeaders::iterator insertOrReplaceHeader(\n    HttpHeaders* const headers, const HeaderType&amp; header)\n{\n    return insertOrReplaceHeader(\n        headers,\n        HttpHeader(HeaderType::NAME, header.toString()));\n}\n\nNX_NETWORK_API HttpHeaders::iterator insertHeader(\n    HttpHeaders* const headers, HttpHeader newHeader);\n\nNX_NETWORK_API void removeHeader(\n    HttpHeaders* const headers, const std::string&amp; name);\n\n/**\n * Adds CORS to headers. supportedOrigins must be equal to &#x27;*&#x27; or a comma separated origins\n * supported.\n */\nNX_NETWORK_API void insertOrReplaceCorsHeaders(\n    HttpHeaders* headers,\n    const class Method&amp; method,\n    std::string origin,\n    const std::string&amp; supportedOrigins,\n    std::string_view methods);\n\n/** Parses data and saves header name and data to *headerName and *headerValue. */\nNX_NETWORK_API bool parseHeader(\n    const ConstBufferRefType&amp; data,\n    std::string* const headerName,\n    std::string* const headerValue);\n\nNX_NETWORK_API bool parseHeader(\n    const ConstBufferRefType&amp; data,\n    ConstBufferRefType* const headerName,\n    ConstBufferRefType* const headerValue);\n\nNX_NETWORK_API HttpHeader parseHeader(const ConstBufferRefType&amp; data);\n\ntemplate&lt;class MessageType, class MessageLineType&gt;\nbool parseRequestOrResponse(\n    const ConstBufferRefType&amp; data,\n    MessageType* message,\n    MessageLineType MessageType::* messageLine,\n    bool parseHeadersNonStrict = false)\n{\n    // TODO: nx::utils::split\n\n    enum ParseState\n    {\n        readingMessageLine, //request line or status line\n        readingHeaders,\n        readingMessageBody\n    }\n    state = readingMessageLine;\n\n    for (size_t curPos = 0; curPos &lt; data.size(); /*no increment*/)\n    {\n        if (state == readingMessageBody)\n        {\n            message-&gt;messageBody = data.substr(curPos);\n            break;\n        }\n\n        //breaking into lines\n        const auto lineSepPos = data.find_first_of(&quot;\\r\\n&quot;, curPos);\n        const ConstBufferRefType currentLine = data.substr(\n            curPos,\n            lineSepPos == ConstBufferRefType::npos ? lineSepPos : lineSepPos - curPos);\n        switch (state)\n        {\n            case readingMessageLine:\n                if (!(message-&gt;*messageLine).parse(currentLine))\n                    return false;\n                state = readingHeaders;\n                break;\n\n            case readingHeaders:\n            {\n                if (!currentLine.empty())\n                {\n                    std::string headerName;\n                    std::string headerValue;\n                    if (!parseHeader(currentLine, &amp;headerName, &amp;headerValue))\n                    {\n                        if (parseHeadersNonStrict)\n                            break;\n                        else\n                            return false;\n                    }\n                    message-&gt;headers.emplace(std::move(headerName), std::move(headerValue));\n                    break;\n                }\n                else\n                {\n                    state = readingMessageBody;\n                }\n            }\n\n            case readingMessageBody:\n                break;\n        }\n\n        if (lineSepPos == ConstBufferRefType::npos)\n            break;  //no more data to parse\n        curPos = lineSepPos;\n        ++curPos;   //skipping separator\n        if (curPos &lt; data.size() &amp;&amp; (data[lineSepPos] == &#x27;\\r&#x27; &amp;&amp; data[curPos] == &#x27;\\n&#x27;))\n            ++curPos;   //skipping complex separator (\\r\\n)\n    }\n\n    return true;\n}\n\n//-------------------------------------------------------------------------------------------------\n// Method.\n\nclass NX_NETWORK_API Method\n{\npublic:\n    static constexpr std::string_view connect = &quot;CONNECT&quot;;\n    static constexpr std::string_view get = &quot;GET&quot;;\n    static constexpr std::string_view head = &quot;HEAD&quot;;\n    static constexpr std::string_view post = &quot;POST&quot;;\n    static constexpr std::string_view put = &quot;PUT&quot;;\n    static constexpr std::string_view patch = &quot;PATCH&quot;;\n    static constexpr std::string_view delete_ = &quot;DELETE&quot;;\n    static constexpr std::string_view options = &quot;OPTIONS&quot;;\n\n    Method() = default;\n    Method(const Method&amp;) = default;\n    Method(Method&amp;&amp;) = default;\n\n    Method(const std::string_view&amp; str);\n    Method(const char* str);\n    Method(std::string str);\n\n    Method&amp; operator=(const Method&amp;) = default;\n    Method&amp; operator=(Method&amp;&amp;) = default;\n\n    Method&amp; operator=(const std::string_view&amp; str);\n    Method&amp; operator=(const char* str);\n    Method&amp; operator=(std::string str);\n\n    bool operator&lt;(const Method&amp; right) const;\n    bool operator&lt;(const std::string_view&amp; right) const;\n\n    bool operator==(const Method&amp; right) const;\n    bool operator!=(const Method&amp; right) const;\n\n    inline bool operator==(const char* right) const\n    { return nx::utils::stricmp(m_value, right) == 0; }\n\n    inline bool operator!=(const char* right) const\n    { return nx::utils::stricmp(m_value, right) != 0; }\n\n    inline bool operator==(const std::string&amp; right) const\n    { return nx::utils::stricmp(m_value, right) == 0; }\n\n    inline bool operator!=(const std::string&amp; right) const\n    { return nx::utils::stricmp(m_value, right) != 0; }\n\n    inline bool operator==(const std::string_view&amp; right) const\n    { return nx::utils::stricmp(m_value, right) == 0; }\n\n    inline bool operator!=(const std::string_view&amp; right) const\n    { return nx::utils::stricmp(m_value, right) != 0; }\n\n    const std::string&amp; toString() const;\n\n    static bool isKnown(const std::string_view&amp; str);\n\n    static bool isMessageBodyAllowed(const Method&amp; method);\n    bool isMessageBodyAllowed() const\n    {\n        return isMessageBodyAllowed(*this);\n    }\n\n    static bool isMessageBodyAllowedInResponse(\n        const Method&amp; method,\n        StatusCode::Value statusCode);\n\nprivate:\n    std::string m_value;\n};\n\ninline bool operator==(const std::string_view&amp; left, const Method&amp; right)\n{ return right == left; }\n\ninline bool operator!=(const std::string_view&amp; left, const Method&amp; right)\n{ return right != left; }\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Method&amp; method)\n{ return os &lt;&lt; method.toString(); }\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Represents string like HTTP/1.1, RTSP/1.0.\n */\nclass NX_NETWORK_API MimeProtoVersion\n{\npublic:\n    std::string protocol;\n    std::string version;\n\n    bool parse(const ConstBufferRefType&amp; data);\n\n    /** Appends serialized data to dstBuffer. */\n    void serialize(nx::Buffer* const dstBuffer) const;\n\n    bool operator==(const MimeProtoVersion&amp; right) const\n    {\n        return protocol == right.protocol\n            &amp;&amp; version == right.version;\n    }\n\n    bool operator!=(const MimeProtoVersion&amp; right) const\n    {\n        return !(*this == right);\n    }\n\n    friend bool operator &lt; (const MimeProtoVersion&amp; lhs, const MimeProtoVersion&amp; rhs)\n    {\n        return lhs.version &lt; rhs.version;\n    }\n};\n\nstatic const MimeProtoVersion http_1_0 = { &quot;HTTP&quot;, &quot;1.0&quot; };\nstatic const MimeProtoVersion http_1_1 = { &quot;HTTP&quot;, &quot;1.1&quot; };\n\nclass NX_NETWORK_API RequestLine\n{\npublic:\n    Method method;\n\n    // FIXME: URL is not correct structure here, should use more general structure.\n    //        See: RFC 2616, section-5.1.2.\n    nx::Url url;\n    MimeProtoVersion version;\n\n    bool parse(const ConstBufferRefType&amp; data);\n    /** Appends serialized data to dstBuffer. */\n    void serialize(nx::Buffer* dstBuffer) const;\n    std::string toString() const;\n\n    enum class EncodeUrlParts { all, authority };\n\n    /**\n     * Encodes the URL before putting it into the HTTP request.\n     */\n    std::string encodeUrl(\n        const nx::Url&amp; url, EncodeUrlParts parts = EncodeUrlParts::all) const;\n};\n\ninline bool operator==(const RequestLine&amp; left, const RequestLine&amp; right)\n{\n    return left.method == right.method\n        &amp;&amp; left.url == right.url\n        &amp;&amp; left.version == right.version;\n}\n\nclass NX_NETWORK_API StatusLine\n{\npublic:\n    MimeProtoVersion version;\n    StatusCode::Value statusCode;\n    std::string reasonPhrase;\n\n    StatusLine();\n    StatusLine(StatusLine&amp;&amp;) = default;\n    StatusLine&amp; operator=(StatusLine&amp;&amp;) = default;\n    StatusLine(const StatusLine&amp;) = default;\n    StatusLine&amp; operator=(const StatusLine&amp;) = default;\n\n    bool parse(const ConstBufferRefType&amp; data);\n    /** Appends serialized data to dstBuffer. */\n    void serialize(nx::Buffer* const dstBuffer) const;\n    std::string toString() const;\n};\n\ninline bool operator==(const StatusLine&amp; left, const StatusLine&amp; right)\n{\n    return left.version == right.version\n        &amp;&amp; left.statusCode == right.statusCode\n        &amp;&amp; left.reasonPhrase == right.reasonPhrase;\n}\n\nNX_NETWORK_API void serializeHeaders(const HttpHeaders&amp; headers, nx::Buffer* dstBuffer);\n\nstatic constexpr char kDeletedCookieValue[] = &quot;_DELETED_COOKIE_VALUE_&quot;;\nNX_NETWORK_API std::string getCookieValue(const std::string_view&amp; name, const HttpHeaders&amp; headers);\n\nclass NX_NETWORK_API Request\n{\npublic:\n    RequestLine requestLine;\n    HttpHeaders headers;\n    nx::Buffer messageBody;\n\n    bool parse(const ConstBufferRefType&amp; data);\n\n    /**\n     * Appends serialized data to dstBuffer.\n     * NOTE: Adds \\r\\n headers/body separator.\n     */\n    void serialize(nx::Buffer* const dstBuffer) const;\n\n    nx::Buffer serialized() const;\n    std::string toString() const;\n\n    /**\n     * @param Case-sensitive cookie name.\n     */\n    std::string getCookieValue(const std::string_view&amp; name) const\n    {\n        return http::getCookieValue(name, headers);\n    }\n\n    /**\n     * @param Case-sensitive cookie name.\n     */\n    void removeCookie(const std::string_view&amp; name);\n};\n\ninline bool operator==(const Request&amp; left, const Request&amp; right)\n{\n    return left.requestLine == right.requestLine\n        &amp;&amp; left.headers == right.headers\n        &amp;&amp; left.messageBody == right.messageBody;\n}\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Request&amp; request)\n{\n    return os &lt;&lt; request.toString();\n}\n\nclass NX_NETWORK_API Response\n{\npublic:\n    StatusLine statusLine;\n    HttpHeaders headers;\n    nx::Buffer messageBody;\n\n    bool parse(const ConstBufferRefType&amp; data);\n\n    /** Appends serialized data to dstBuffer. */\n    void serialize(nx::Buffer* dstBuffer) const;\n\n    /** Appends serialized multipart data block to dstBuffer. */\n    void serializeMultipartResponse(\n        const ConstBufferRefType&amp; boundary,\n        nx::Buffer* dstBuffer) const;\n\n    std::string toString() const;\n    std::string toMultipartString(const ConstBufferRefType&amp; boundary) const;\n\n    void setCookie(\n        const std::string&amp; name, const std::string&amp; value,\n        const std::string&amp; path = &quot;/&quot;, bool secure = true);\n\n    void setDeletedCookie(const std::string&amp; name);\n    std::map&lt;std::string, std::string&gt; getCookies() const;\n};\n\nNX_NETWORK_API HttpHeader deletedCookieHeader(\n    const std::string&amp; name, const std::string&amp; path = &quot;/&quot;);\n\nNX_NETWORK_API HttpHeader cookieHeader(\n    const std::string&amp; name,\n    const std::string&amp; value,\n    const std::string&amp; path = &quot;/&quot;,\n    bool secure = true,\n    bool httpOnly = true);\n\ninline bool operator==(const Response&amp; left, const Response&amp; right)\n{\n    return left.statusLine == right.statusLine\n        &amp;&amp; left.headers == right.headers\n        &amp;&amp; left.messageBody == right.messageBody;\n}\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Response&amp; response)\n{\n    return os &lt;&lt; response.toString();\n}\n\nNX_NETWORK_API bool isMessageBodyPresent(const Response&amp; response);\n\nclass NX_NETWORK_API RtspResponse:\n    public Response\n{\npublic:\n    bool parse(const ConstBufferRefType&amp; data);\n};\n\nnamespace MessageType {\n\nenum Value\n{\n    none,\n    request,\n    response\n};\n\nNX_NETWORK_API const char* toString(Value val);\n\n} // namespace MessageType\n\nclass NX_NETWORK_API Message\n{\npublic:\n    MessageType::Value type;\n    union\n    {\n        Request* request;\n        Response* response;\n    };\n\n    Message(MessageType::Value _type = MessageType::none);\n    Message(const Message&amp; right);\n    Message(Message&amp;&amp; right);\n    ~Message();\n\n    Message&amp; operator=(const Message&amp; right);\n    Message&amp; operator=(Message&amp;&amp; right);\n\n    void serialize(nx::Buffer* const dstBuffer) const;\n\n    void clear();\n\n    HttpHeaders&amp; headers()\n    {\n        return type == MessageType::request ? request-&gt;headers : response-&gt;headers;\n    }\n\n    const HttpHeaders&amp; headers() const\n    {\n        return type == MessageType::request ? request-&gt;headers : response-&gt;headers;\n    }\n\n    const MimeProtoVersion&amp; version() const\n    {\n        return type == MessageType::request\n            ? request-&gt;requestLine.version\n            : response-&gt;statusLine.version;\n    }\n\n    void setBody(nx::Buffer body);\n\n    std::string toString() const;\n    bool operator==(const Message&amp; msg) const;\n};\n\nNX_REFLECTION_ENUM_CLASS(AuthType,\n    authBasicAndDigest,\n    authDigest,\n    authBasic,\n    authBearer\n)\n\n/** Contains HTTP header structures. */\nnamespace header {\n\n/** Common header name constants. */\nstatic constexpr char kAccept[] = &quot;Accept&quot;;\nstatic constexpr char kAcceptLanguage[] = &quot;Accept-Language&quot;;\nstatic constexpr char kContentType[] = &quot;Content-Type&quot;;\nstatic constexpr char kContentLength[] = &quot;Content-Length&quot;;\nstatic constexpr char kUserAgent[] = &quot;User-Agent&quot;;\n\n//!Http authentication scheme enumeration\nnamespace AuthScheme {\n\nenum Value\n{\n    none,\n    basic,\n    digest,\n    bearer,\n};\n\nNX_NETWORK_API std::string_view toString(Value val);\nNX_NETWORK_API Value fromString(const std::string_view&amp; str);\n\n} // namespace AuthScheme\n\n/**\n * Login/password to use in http authorization.\n */\nclass NX_NETWORK_API UserCredentials\n{\npublic:\n    std::string userid;\n    std::string password;\n\n    auto operator&lt;=&gt;(const UserCredentials&amp;) const = default;\n};\n\n/** rfc2617, section 2. */\nclass NX_NETWORK_API BasicCredentials:\n    public UserCredentials\n{\npublic:\n    bool parse(const std::string_view&amp; str);\n    void serialize(nx::Buffer* dest) const;\n};\n\n/** rfc2617, section 3.2.2. */\nclass NX_NETWORK_API DigestCredentials:\n    public UserCredentials\n{\npublic:\n    std::map&lt;std::string, std::string&gt; params;\n\n    bool parse(const std::string_view&amp; str, char separator = &#x27;,&#x27;);\n    void serialize(nx::Buffer* dest) const;\n};\n\n/** rfc6750, section 2.1. */\nclass NX_NETWORK_API BearerCredentials:\n    public UserCredentials\n{\npublic:\n    std::string token;\n\n    bool parse(const std::string_view&amp; str);\n    void serialize(nx::Buffer* const dstBuffer) const;\n};\n\n/** Authorization header ([rfc2616, 14.8], rfc2617). */\nclass NX_NETWORK_API Authorization\n{\npublic:\n    static constexpr char NAME[] = &quot;Authorization&quot;;\n    static constexpr char TOKEN_USERID[] = &quot;-&quot;;\n\n    AuthScheme::Value authScheme;\n    union\n    {\n        BasicCredentials* basic;\n        DigestCredentials* digest;\n        BearerCredentials* bearer;\n    };\n\n    Authorization();\n    Authorization(const AuthScheme::Value&amp; authSchemeVal);\n    Authorization(Authorization&amp;&amp; right);\n    Authorization(const Authorization&amp;);\n    ~Authorization();\n\n    Authorization&amp; operator=(Authorization&amp;&amp; right);\n\n    bool parse(const std::string_view&amp; str);\n    void serialize(nx::Buffer* const dest) const;\n    nx::Buffer serialized() const;\n    std::string toString() const;\n    void clear();\n\n    const std::string&amp; userid() const;\n    const std::string* token() const;\n\nprivate:\n    const Authorization&amp; operator=(const Authorization&amp;);\n};\n\nstatic constexpr char kProxyAuthorization[] = &quot;Proxy-Authorization&quot;;\n\n/**\n * Convenient class for generating Authorization header with Basic authentication method.\n */\nclass NX_NETWORK_API BasicAuthorization:\n    public Authorization\n{\npublic:\n    BasicAuthorization(const std::string&amp; userName, const std::string&amp; userPassword);\n};\n\nclass NX_NETWORK_API DigestAuthorization:\n    public Authorization\n{\npublic:\n    DigestAuthorization();\n    DigestAuthorization(DigestAuthorization&amp;&amp; right);\n    DigestAuthorization(const DigestAuthorization&amp; right);\n\n    void addParam(const std::string&amp; name, const std::string&amp; value);\n};\n\nclass NX_NETWORK_API BearerAuthorization:\n    public Authorization\n{\npublic:\n    BearerAuthorization(const std::string&amp; token);\n};\n\n/**\n * [rfc2616, 14.47].\n */\nclass NX_NETWORK_API WWWAuthenticate\n{\npublic:\n    static constexpr char NAME[] = &quot;WWW-Authenticate&quot;;\n\n    AuthScheme::Value authScheme;\n    std::map&lt;std::string, std::string&gt; params;\n\n    WWWAuthenticate(AuthScheme::Value authScheme = AuthScheme::none);\n\n    std::string getParam(const std::string&amp; key) const;\n    bool parse(const std::string_view&amp; str);\n    void serialize(nx::Buffer* dest) const;\n    nx::Buffer serialized() const;\n    std::string toString() const;\n};\n\nstatic constexpr char IDENTITY_CODING[] = &quot;identity&quot;;\nstatic constexpr char ANY_CODING[] = &quot;*&quot;;\n\nstatic constexpr char kProxyAuthenticate[] = &quot;Proxy-Authenticate&quot;;\n\n/**\n * [rfc2616, 14.3].\n */\nclass NX_NETWORK_API AcceptEncodingHeader\n{\npublic:\n    AcceptEncodingHeader(const std::string_view&amp; str);\n\n    void parse(const std::string_view&amp; str);\n\n    /**\n     * @return true if encodingName is present in header and\n     *   returns corresponding q value in *q (if not null).\n     */\n    bool encodingIsAllowed(\n        const std::string&amp; encodingName,\n        double* q = nullptr) const;\n\n    const std::map&lt;std::string, double&gt;&amp; allEncodings() const;\n\nprivate:\n    /** map&lt;coding, qvalue&gt;. */\n    std::map&lt;std::string, double&gt; m_codings;\n    std::optional&lt;double&gt; m_anyCodingQValue;\n};\n\n/**\n * NOTE: Boundaries are inclusive.\n */\nclass NX_NETWORK_API RangeSpec\n{\npublic:\n    quint64 start = 0;\n    std::optional&lt;quint64&gt; end;\n};\n\n/**\n * [rfc2616, 14.35].\n */\nclass NX_NETWORK_API Range\n{\npublic:\n    Range();\n\n    /**\n     * NOTE: In case of parse error, contents of this object are undefined.\n     */\n    bool parse(const std::string_view&amp; str);\n\n    /**\n     * @return true if range is satisfiable for content of size contentSize.\n     */\n    bool validateByContentSize(size_t contentSize) const;\n    /**\n     * @return true, if empty range (does not include any bytes of content).\n     */\n    bool empty() const;\n    /**\n     * @return true, if range is full (includes all bytes of content of size contentSize).\n     */\n    bool full(size_t contentSize) const;\n    /**\n     * @return range length for content of size contentSize.\n     */\n    quint64 totalRangeLength(size_t contentSize) const;\n\n    std::vector&lt;RangeSpec&gt; rangeSpecList;\n};\n\n/**\n * [rfc2616, 14.16].\n */\nclass NX_NETWORK_API ContentRange\n{\npublic:\n    //!By default, bytes\n    std::string unitName;\n    std::optional&lt;quint64&gt; instanceLength;\n    RangeSpec rangeSpec;\n\n    ContentRange();\n\n    quint64 rangeLength() const;\n    std::string toString() const;\n};\n\n/**\n * [rfc2616, 14.45].\n */\nclass NX_NETWORK_API Via\n{\npublic:\n    class ProxyEntry\n    {\n    public:\n        std::optional&lt;std::string&gt; protoName;\n        std::string protoVersion;\n        /** ( host [ &quot;:&quot; port ] ) | pseudonym. */\n        std::string receivedBy;\n        std::string comment;\n    };\n\n    std::vector&lt;ProxyEntry&gt; entries;\n\n    /**\n     * NOTE: In case of parse error, contents of this object are undefined.\n     */\n    bool parse(const std::string_view&amp; str);\n    std::string toString() const;\n};\n\nclass NX_NETWORK_API KeepAlive\n{\npublic:\n    std::chrono::seconds timeout = std::chrono::seconds::zero();\n    std::optional&lt;int&gt; max;\n\n    KeepAlive() = default;\n    KeepAlive(\n        std::chrono::seconds _timeout,\n        std::optional&lt;int&gt; _max = std::nullopt);\n\n    bool parse(const std::string_view&amp; str);\n    std::string toString() const;\n};\n\nclass NX_NETWORK_API Server\n{\npublic:\n    class Product\n    {\n    public:\n        std::string name;\n        std::string version;\n        std::string comment;\n\n        std::string toString() const;\n        bool operator==(const Product&amp;) const;\n\n        /**\n         * @param str String of the following format:\n         * product = token [&quot;/&quot; product-version] *( RWS comment )\n         * product-version = token\n         * comment = &quot;(&quot; TEXT &quot;)&quot;\n         */\n        static Product fromString(const std::string_view&amp; str);\n    };\n\n    static constexpr char NAME[] = &quot;Server&quot;;\n\n    std::vector&lt;Product&gt; products;\n\n    Server();\n\n    bool operator==(const Server&amp;) const;\n\n    bool parse(const std::string_view&amp; strValue);\n    std::string toString() const;\n};\n\n// User-Agent header has the same format as Server.\nusing UserAgent = Server;\n\nclass NX_NETWORK_API StrictTransportSecurity\n{\npublic:\n    static constexpr char NAME[] = &quot;Strict-Transport-Security&quot;;\n\n    std::chrono::seconds maxAge = std::chrono::seconds::zero();\n    bool includeSubDomains = false;\n    bool preload = false;\n\n    bool operator==(const StrictTransportSecurity&amp;) const;\n    bool parse(const std::string_view&amp; strValue);\n    std::string toString() const;\n};\n\nclass NX_NETWORK_API XForwardedFor\n{\npublic:\n    static constexpr char NAME[] = &quot;X-Forwarded-For&quot;;\n\n    std::string client;\n    std::vector&lt;std::string&gt; proxies;\n\n    bool parse(const std::string_view&amp; str);\n    std::string toString() const;\n};\n\nclass NX_NETWORK_API XForwardedProto\n{\npublic:\n    static constexpr char NAME[] = &quot;X-Forwarded-Proto&quot;;\n\n    static constexpr char kHttp[] = &quot;http&quot;;\n    static constexpr char kHttps[] = &quot;https&quot;;\n};\n\nstruct NX_NETWORK_API ForwardedElement\n{\n    std::string by;\n    std::string for_;\n    std::string host;\n    std::string proto;\n\n    bool parse(const std::string_view&amp; str);\n    std::string toString() const;\n\n    bool operator==(const ForwardedElement&amp; right) const;\n\nprivate:\n    std::string quoteIfNeeded(const std::string_view&amp; str) const;\n};\n\nclass NX_NETWORK_API Forwarded\n{\npublic:\n    static constexpr char NAME[] = &quot;Forwarded&quot;;\n\n    std::vector&lt;ForwardedElement&gt; elements;\n\n    Forwarded() = default;\n    Forwarded(std::vector&lt;ForwardedElement&gt; elements);\n\n    bool parse(const std::string_view&amp; str);\n    std::string toString() const;\n\n    bool operator==(const Forwarded&amp; right) const;\n};\n\nstruct NX_NETWORK_API ContentType\n{\n    static constexpr char NAME[] = &quot;Content-Type&quot;;\n\n    static constexpr char kAny[] = &quot;*/*&quot;;\n    static constexpr char kDefaultCharset[] = &quot;utf-8&quot;;\n\n    static const ContentType kPlain;\n    static const ContentType kHtml;\n    static const ContentType kXml;\n    static const ContentType kForm;\n    static const ContentType kJson;\n    static const ContentType kUbjson;\n    static const ContentType kBinary;\n\n    std::string value;\n    std::string charset;\n    std::string boundary;\n\n    ContentType(const std::string_view&amp; str = kPlain.toString());\n    ContentType(const char* str);\n\n    /**\n     * NOTE: This constructor works with any type that has &quot;const char* data()&quot; and &quot;size()&quot;.\n     * E.g., QByteArray.\n     */\n    template&lt;typename String&gt;\n    ContentType(\n        const String&amp; str,\n        std::enable_if_t&lt;nx::utils::IsConvertibleToStringViewV&lt;String&gt;&gt;* = nullptr)\n        :\n        ContentType(std::string_view(str.data(), (std::size_t) str.size()))\n    {\n    }\n\n    std::string toString() const;\n\n    bool operator==(const ContentType&amp; rhs) const;\n    bool operator!=(const ContentType&amp; rhs) const { return !(*this == rhs); }\n    bool operator==(const std::string&amp; rhs) const;\n\n    operator std::string() const { return toString(); }\n};\n\nclass NX_NETWORK_API Host\n{\npublic:\n    static constexpr char NAME[] = &quot;Host&quot;;\n\n    Host(const SocketAddress&amp; endpoint);\n\n    /**\n     * Always omits default HTTP ports (80, 443).\n     */\n    std::string toString() const;\n\nprivate:\n    SocketAddress m_endpoint;\n};\n\n} // namespace header\n\nusing ChunkExtension = std::pair&lt;std::string, std::string&gt;;\n\n/**\n * chunk-size [ chunk-extension ] CRLF\n * chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )\n * chunk-ext-name = token\n * chunk-ext-val  = token | quoted-string\n */\nclass NX_NETWORK_API ChunkHeader\n{\npublic:\n    size_t chunkSize = 0;\n    std::vector&lt;ChunkExtension&gt; extensions;\n\n    void clear();\n\n    /**\n     * @return bytes read from buf. -1 in case of parse error.\n     * NOTE: In case of parse error object state is undefined.\n     */\n    int parse(const ConstBufferRefType&amp; buf);\n\n    /**\n     * @return bytes written to dest. -1 in case of serialize error.\n     *   In this case contents of dest are undefined.\n     */\n    int serialize(nx::Buffer* const dest) const;\n};\n\n/**\n * @return common value for User-Agent header.\n */\nNX_NETWORK_API std::string userAgentString();\n\nNX_NETWORK_API header::UserAgent defaultUserAgent();\n\n/**\n * @return common value for Server header.\n */\nNX_NETWORK_API std::string serverString();\n\n/**\n * @return Server header value containing well-known HTTP server name(s).\n * Should be used by HTTP servers for better compatibility with browsers.\n */\nNX_NETWORK_API std::string compatibilityServerName();\n\n} // namespace nx::network::http\n\ntemplate&lt;&gt;\nstruct std::hash&lt;nx::network::http::Method&gt;\n{\n    std::size_t operator()(const nx::network::http::Method&amp; method) const noexcept\n    {\n        return std::hash&lt;std::string&gt;{}(method.toString());\n    }\n};\n"}, "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h": {"id": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "filePath": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;variant&gt;\n\n#include &lt;nx/reflect/generic_visitor.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n\n#include &quot;tags.h&quot;\n#include &quot;to_string.h&quot;\n#include &quot;type_utils.h&quot;\n\nnamespace nx::reflect {\n\ntemplate&lt;typename Result&gt;\nclass AbstractComposer\n{\npublic:\n    virtual ~AbstractComposer() = default;\n\n    virtual void startArray() = 0;\n    virtual void endArray(int items) = 0;\n\n    virtual void startObject() = 0;\n    virtual void endObject(int members) = 0;\n\n    virtual void writeBool(bool val) = 0;\n    virtual void writeInt(const std::int64_t&amp; val) = 0;\n    virtual void writeFloat(const double&amp; val) = 0;\n    virtual void writeString(const std::string_view&amp; val) = 0;\n    virtual void writeRawString(const std::string_view&amp; val) = 0;\n\n    virtual void writeNull() = 0;\n\n    template&lt;typename T&gt;\n    void writeValue(T val)\n    {\n        if constexpr (std::is_same_v&lt;T, bool&gt;)\n            writeBool(val);\n        else if constexpr (std::is_integral_v&lt;T&gt;)\n            sizeof(T) == 8 &amp;&amp; int64AsString() ? writeString(std::to_string(val)) : writeInt(val);\n        else if constexpr (std::is_floating_point_v&lt;T&gt;)\n            writeFloat(static_cast&lt;double&gt;(val));\n        else if constexpr (std::is_same_v&lt;T, std::nullptr_t&gt;)\n            writeNull();\n        else if constexpr (std::is_same_v&lt;T, std::string&gt; || std::is_same_v&lt;T, std::string_view&gt;)\n            writeString(val);\n        else\n            writeString(std::to_string(val));\n    }\n\n    template&lt;typename... Args&gt;\n    void writeValue(const std::chrono::duration&lt;Args...&gt;&amp; val)\n    {\n        durationAsNumber() ? writeInt(val.count()) : writeString(std::to_string(val.count()));\n    }\n\n    template&lt;typename... Args&gt;\n    void writeValue(\n        const std::chrono::time_point&lt;Args...&gt;&amp; val)\n    {\n        using namespace std::chrono;\n        writeValue(floor&lt;milliseconds&gt;(val.time_since_epoch()));\n    }\n\n    virtual void writeAttributeName(const std::string_view&amp; name) = 0;\n\n    virtual Result take() = 0;\n\n    unsigned int serializeFlags() const { return m_serializeFlags; }\n    unsigned int setSerializeFlags(unsigned int value)\n    {\n        return std::exchange(m_serializeFlags, value);\n    }\n\nprivate:\n    bool durationAsNumber() const { return m_serializeFlags &amp; (1u &lt;&lt; 0); }\n    bool int64AsString() const { return m_serializeFlags &amp; (1u &lt;&lt; 1); }\n\nprivate:\n    unsigned int m_serializeFlags = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n// TODO: #akolesnikov Make this block unconditional and use this concept\n// template&lt;typename T&gt;\n// concept SerializationContext = requires(T a)\n// {\n//     { decltype(a.composer) } -&gt; std::convertible_to&lt;AbstractComposer&gt;;\n// };\n\ntemplate&lt;typename Composer, typename Data&gt; class Visitor;\n\n/**\n * Serializes some type to a format that can be composed using AbstractComposer class.\n * Suitable for json, ubjson, csv, xml.\n */\nnamespace BasicSerializer {\n\nnamespace detail {\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serializeAdl(SerializationContext* ctx, const Data&amp; data);\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serializeAdl(SerializationContext* ctx, const std::optional&lt;Data&gt;&amp; data);\n\ntemplate&lt;typename T, bool result&gt;\nstatic void reportUnsupportedType()\n{\n    static_assert(result, &quot;Type is not serializable&quot;);\n}\n\n} // namespace detail\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serializeAdl(SerializationContext* ctx, const Data&amp; data)\n{\n    auto state = ctx-&gt;beforeSerialize(data);\n\n    // Delegating control to a separate namespace so that current namespace serialize\n    // overloads are not considered during the ADL lookup.\n    // This is needed to provide a way to override serialization for certain template classes.\n\n    detail::serializeAdl(ctx, data);\n\n    ctx-&gt;afterSerialize(data, std::move(state));\n}\n\ntemplate&lt;typename Composer&gt;\nstruct VisitorDeclarator\n{\n    template&lt;typename... Args&gt; using type = Visitor&lt;Composer, Args...&gt;;\n};\n\ntemplate&lt;\n    typename SerializationContext,\n    typename Container\n&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const Container&amp; data,\n    std::enable_if_t&lt;IsArrayV&lt;Container&gt;\n        || IsSequenceContainerV&lt;Container&gt;\n        || IsSetContainerV&lt;Container&gt;\n        || IsUnorderedSetContainerV&lt;Container&gt;\n    &gt;* = nullptr)\n{\n    ctx-&gt;composer.startArray();\n    for (auto it = data.begin(); it != data.end(); ++it)\n        serializeAdl(ctx, *it);\n    ctx-&gt;composer.endArray(data.size());\n}\n\ntemplate&lt;\n    typename SerializationContext,\n    typename C\n&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const C&amp; data,\n    std::enable_if_t&lt;\n        (IsAssociativeContainerV&lt;C&gt; &amp;&amp; !IsSetContainerV&lt;C&gt;)\n            || (IsUnorderedAssociativeContainerV&lt;C&gt; &amp;&amp; !IsUnorderedSetContainerV&lt;C&gt;)\n    &gt;* = nullptr)\n{\n    constexpr bool hasSpecificToStringForKey =\n        requires(const SerializationContext&amp; c, const typename C::key_type&amp; v) { c.toString(v); };\n\n    ctx-&gt;composer.startObject();\n    for (auto it = data.begin(); it != data.end(); ++it)\n    {\n        if constexpr (hasSpecificToStringForKey)\n            ctx-&gt;composer.writeAttributeName(ctx-&gt;toString(it-&gt;first));\n        else\n            ctx-&gt;composer.writeAttributeName(nx::reflect::toString(it-&gt;first));\n        serializeAdl(ctx, it-&gt;second);\n    }\n    ctx-&gt;composer.endObject(data.size());\n}\n\ntemplate&lt;typename SerializationContext&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const std::string&amp; val)\n{\n    ctx-&gt;composer.writeValue(val);\n}\n\ntemplate&lt;typename SerializationContext, typename Value&gt;\nvoid serialize(\n    SerializationContext* ctx, const Value&amp; val, std::enable_if_t&lt;!IsContainerV&lt;Value&gt;&gt;* = nullptr)\n{\n    if constexpr (std::is_same_v&lt;Value, bool&gt;)\n    {\n        ctx-&gt;composer.writeValue(val);\n    }\n    else if constexpr (std::is_integral_v&lt;Value&gt; || std::is_floating_point_v&lt;Value&gt;)\n    {\n        ctx-&gt;composer.writeValue(val);\n    }\n    else if constexpr (std::is_same_v&lt;Value, std::nullptr_t&gt;)\n    {\n        ctx-&gt;composer.writeValue(val);\n    }\n    else if constexpr (IsStringAlikeV&lt;Value&gt; || IsInstrumentedEnumV&lt;Value&gt;)\n    {\n        ctx-&gt;composer.writeValue(nx::reflect::toString(val));\n    }\n    else if constexpr (IsInstrumentedV&lt;Value&gt;)\n    {\n        typename VisitorDeclarator&lt;SerializationContext&gt;::template type&lt;Value&gt; visitor(ctx, val);\n        nx::reflect::visitAllFields&lt;Value&gt;(visitor);\n    }\n    else\n    {\n        detail::reportUnsupportedType&lt;Value, false&gt;();\n    }\n}\n\ntemplate&lt;typename SerializationContext, typename... Args&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const std::chrono::duration&lt;Args...&gt;&amp; val)\n{\n    ctx-&gt;composer.writeValue(val);\n}\n\ntemplate&lt;typename SerializationContext, typename... Args&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const std::chrono::time_point&lt;Args...&gt;&amp; val)\n{\n    ctx-&gt;composer.writeValue(val);\n}\n\ntemplate&lt;typename SerializationContext, typename... Args&gt;\nvoid serialize(\n    SerializationContext* ctx,\n    const std::variant&lt;Args...&gt;&amp; val)\n{\n    if (val.valueless_by_exception())\n        ctx-&gt;composer.writeNull();\n    else\n        std::visit([ctx](auto&amp;&amp; arg) { serializeAdl(ctx, arg); }, val);\n}\n\ntemplate&lt;typename SerializationContext, typename T&gt;\nvoid serialize(SerializationContext* ctx, const std::reference_wrapper&lt;T&gt;&amp; val)\n{\n    serialize(ctx, val.get());\n}\n\nnamespace detail {\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serialize(SerializationContext* ctx, const Data&amp; data)\n{\n    // SFINAE\n    nx::reflect::BasicSerializer::serialize(ctx, data);\n}\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serializeAdl(SerializationContext* ctx, const Data&amp; data)\n{\n    // ADL kicks in. A custom serialization function is invoked here.\n    serialize(ctx, data);\n}\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nvoid serializeAdl(SerializationContext* ctx, const std::optional&lt;Data&gt;&amp; data)\n{\n    if (data)\n        serializeAdl(ctx, *data);\n    else\n        ctx-&gt;composer.writeNull();\n}\n\n} // namespace detail\n\n} // namespace BasicSerializer\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename SerializationContext, typename Data&gt;\nclass Visitor:\n    public nx::reflect::GenericVisitor&lt;Visitor&lt;SerializationContext, Data&gt;&gt;\n{\npublic:\n    Visitor(SerializationContext* ctx, const Data&amp; data):\n        m_ctx(ctx),\n        m_data(data)\n    {\n        m_ctx-&gt;composer.startObject();\n    }\n\n    ~Visitor() { m_ctx-&gt;composer.endObject(m_attributes); }\n\n    template&lt;typename WrappedField&gt;\n    void visitField(const WrappedField&amp; field)\n    {\n        writeAttribute(field.name(), field.get(m_data));\n    }\n\nprivate:\n    SerializationContext* m_ctx = nullptr;\n    const Data&amp; m_data;\n    int m_attributes = 0;\n\n    template&lt;typename Value&gt;\n    void writeAttribute(const char* name, const std::optional&lt;Value&gt;&amp; value)\n    {\n        if (value)\n            writeAttribute(name, *value);\n    }\n\n    template&lt;typename Value&gt;\n    void writeAttribute(const char* name, const Value&amp; value)\n    {\n        if constexpr (std::is_pointer_v&lt;Value&gt;)\n        {\n            if (value)\n                writeAttribute(name, *value);\n        }\n        else\n        {\n            m_ctx-&gt;composer.writeAttributeName(name);\n            BasicSerializer::serializeAdl(m_ctx, value);\n            ++m_attributes;\n        }\n    }\n};\n\n} // namespace nx::reflect\n"}, "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/json/deserializer.h": {"id": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/json/deserializer.h", "filePath": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/json/deserializer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n#include &lt;string_view&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;variant&gt;\n\n#include &lt;rapidjson/document.h&gt;\n\n#include &lt;nx/reflect/enum_string_conversion.h&gt;\n#include &lt;nx/reflect/field_enumerator.h&gt;\n#include &lt;nx/reflect/from_string.h&gt;\n#include &lt;nx/reflect/generic_visitor.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/reflect/tags.h&gt;\n#include &lt;nx/reflect/type_utils.h&gt;\n\n#include &quot;utils.h&quot;\n\nnamespace nx::reflect {\n\nnamespace json {\n\nenum class DeserializationFlag\n{\n    none = 0,\n    ignoreFieldTypeMismatch = 1 &lt;&lt; 0, // All errors from custom deserializers will be skipped too.\n    fields = 1 &lt;&lt; 1, //&lt; Fill deserialized fields.\n};\n\n} // namespace json\n\n/**\n * Not using json::detail so that ADL does not see nx::reflect::json::deserialize call.\n */\nnamespace json_detail {\n\n// NOTE: This class is introduced to simplify forward-declaring custom JSON deserialization functions.\n// Subject to change since it is not a real deserialization context currently.\nstruct DeserializationContext\n{\n    rapidjson::Value&amp; value;\n    int flags = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename Data&gt; class Deserializer;\n\ntemplate&lt;typename T&gt; DeserializationResult deserializeValue(\n    const DeserializationContext&amp; ctx, T* data);\n\ntemplate&lt;\n    typename Data,\n    typename = std::enable_if_t&lt;IsInstrumentedV&lt;Data&gt; &amp;&amp; !IsStringAlikeV&lt;Data&gt;&gt;\n&gt;\nDeserializationResult deserialize(const DeserializationContext&amp; ctx, Data* data)\n{\n    if (!ctx.value.IsObject())\n    {\n        return {\n            false,\n            &quot;Object value expected&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n\n    Deserializer deserializer(ctx, data);\n    nx::reflect::visitAllFields&lt;Data&gt;(deserializer);\n    return deserializer.finish();\n}\n\ntemplate&lt;typename T&gt;\nDeserializationResult deserialize(\n    const DeserializationContext&amp; ctx,\n    T* data,\n    std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;&gt;* = nullptr)\n{\n    if (ctx.value.IsDouble())\n        *data = (T) ctx.value.GetDouble();\n    else if (ctx.value.IsInt64())\n        *data = (T) ctx.value.GetInt64();\n    else if (ctx.value.IsString())\n        *data = (T) std::stod(std::string(ctx.value.GetString(), ctx.value.GetStringLength()));\n    else\n        // Null value should raise failure here to make sure existing field value is not\n        // overwritten with the default-initialized one.\n        return DeserializationResult(false);\n\n    return DeserializationResult(true);\n}\n\ntemplate&lt;typename T, typename... Args&gt;\nDeserializationResult deserializeVariantType(\n    const DeserializationContext&amp; ctx, std::variant&lt;Args...&gt;* data)\n{\n    using namespace std::string_literals;\n\n    T typedData;\n    auto r = deserializeValue(ctx, &amp;typedData);\n    if (r)\n    {\n        if constexpr (IsInstrumentedV&lt;T&gt;)\n        {\n            constexpr auto names{listFieldNames&lt;T&gt;()};\n            for (auto it = ctx.value.MemberBegin(); it != ctx.value.MemberEnd(); ++it)\n            {\n                const char* name = it-&gt;name.GetString();\n                if (std::ranges::none_of(names, [&amp;name](const auto&amp; n) { return n == name; }))\n                {\n                    r.success = false;\n                    r.errorDescription = &quot;`&quot;s + std::string{name} + &quot;` is unexpected&quot;s;\n                    return r;\n                }\n            }\n        }\n        *data = typedData;\n    }\n\n    return r;\n}\n\ntemplate&lt;typename... Args&gt;\nDeserializationResult deserialize(const DeserializationContext&amp; ctx, std::variant&lt;Args...&gt;* data)\n{\n    DeserializationResult r;\n    const DeserializationContext&amp; c = ctx.flags == (int) json::DeserializationFlag::fields\n        ? ctx\n        : DeserializationContext{ctx.value, (int) json::DeserializationFlag::fields};\n    return (... || (r = deserializeVariantType&lt;Args&gt;(c, data))), r;\n}\n\ntemplate&lt;typename... Args&gt;\nDeserializationResult deserialize(\n    const DeserializationContext&amp; ctx,\n    std::chrono::duration&lt;Args...&gt;* data)\n{\n    if (ctx.value.IsNumber())\n    {\n        *data = std::chrono::duration&lt;Args...&gt;(ctx.value.GetInt64());\n    }\n    else if (ctx.value.IsString())\n    {\n        *data = std::chrono::duration&lt;Args...&gt;(std::stoll(\n            std::string(ctx.value.GetString(), ctx.value.GetStringLength())));\n    }\n    else\n    {\n        *data = std::chrono::duration&lt;Args...&gt;();\n        return {\n            false,\n            &quot;Either a number or a string is expected for an std::chrono::duration value&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n\n    return DeserializationResult(true);\n}\n\ntemplate&lt;typename... Args&gt;\nDeserializationResult deserialize(\n    const DeserializationContext&amp; ctx,\n    std::chrono::time_point&lt;Args...&gt;* data)\n{\n    std::chrono::milliseconds ms;\n    *data = std::chrono::time_point&lt;Args...&gt;();\n    auto deserializationResult = deserialize(ctx, &amp;ms);\n    if (!deserializationResult.success)\n        return deserializationResult;\n\n    *data = std::chrono::time_point&lt;Args...&gt;(ms);\n    return DeserializationResult(true);\n}\n\ntemplate&lt;typename C&gt;\nDeserializationResult deserialize(\n    const DeserializationContext&amp; ctx,\n    C* data,\n    std::enable_if_t&lt;IsArrayV&lt;C&gt;\n        || IsSequenceContainerV&lt;C&gt;\n        || IsSetContainerV&lt;C&gt;\n        || IsUnorderedSetContainerV&lt;C&gt;\n    &gt;* = nullptr)\n{\n    *data = C();\n    if (!ctx.value.IsArray())\n        return {false, &quot;Array is expected&quot;, getStringRepresentation(ctx.value)};\n\n    DeserializationResult result;\n    for (rapidjson::SizeType i = 0; i &lt; ctx.value.Size(); ++i)\n    {\n        auto element = createDefault&lt;typename C::value_type&gt;();\n        auto deserializationResult =\n            deserializeValue(DeserializationContext{ctx.value[i], ctx.flags}, &amp;element);\n        if (!deserializationResult.success)\n        {\n            if (!(ctx.flags &amp; (int) json::DeserializationFlag::ignoreFieldTypeMismatch))\n                return deserializationResult;\n            continue;\n        }\n        std::inserter(*data, data-&gt;end()) = std::move(element);\n    }\n    return result;\n}\n\ntemplate&lt;typename C, typename Key, typename = std::void_t&lt;&gt;&gt;\nstruct HasSquareBracketOperator: std::false_type {};\n\ntemplate&lt;typename C, typename Key&gt;\nstruct HasSquareBracketOperator&lt;\n    C,\n    Key,\n    std::void_t&lt;decltype(std::declval&lt;C&gt;()[std::declval&lt;Key&gt;()])&gt;\n&gt;: std::true_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool HasSquareBracketOperatorV = HasSquareBracketOperator&lt;Args...&gt;::value;\n\ntemplate&lt;typename C&gt;\nDeserializationResult deserialize(\n    const DeserializationContext&amp; ctx,\n    C* data,\n    std::enable_if_t&lt;\n        (IsAssociativeContainerV&lt;C&gt; &amp;&amp; !IsSetContainerV&lt;C&gt;)\n            || (IsUnorderedAssociativeContainerV&lt;C&gt; &amp;&amp; !IsUnorderedSetContainerV&lt;C&gt;)\n    &gt;* = nullptr)\n{\n    if (!ctx.value.IsObject())\n    {\n        return DeserializationResult{\n            false,\n            &quot;Associative container value should be an object&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n\n    DeserializationResult result;\n    for (auto it = ctx.value.MemberBegin(); it != ctx.value.MemberEnd(); ++it)\n    {\n        auto element = createDefault&lt;typename C::mapped_type&gt;();\n        auto deserializationResult =\n            deserializeValue(DeserializationContext{it-&gt;value, ctx.flags}, &amp;element);\n        if (!deserializationResult.success)\n        {\n            if (!(ctx.flags &amp; (int) json::DeserializationFlag::ignoreFieldTypeMismatch))\n                return deserializationResult;\n            else\n                continue;\n        }\n\n        typename C::key_type key;\n        std::string_view keyStd(it-&gt;name.GetString(), it-&gt;name.GetStringLength());\n        if (!nx::reflect::fromString(keyStd, &amp;key))\n        {\n            if (!(ctx.flags &amp; (int) json::DeserializationFlag::ignoreFieldTypeMismatch))\n            {\n                return DeserializationResult{\n                    false,\n                    &quot;In a key-value container a key should be a string&quot;,\n                    getStringRepresentation(ctx.value)};\n            }\n            continue;\n        }\n\n        if (ctx.flags &amp; (int) json::DeserializationFlag::fields)\n        {\n            result.addField(\n                std::string{std::move(keyStd)}, std::move(deserializationResult.fields));\n        }\n        if constexpr (HasSquareBracketOperatorV&lt;C, decltype(key)&gt;)\n            data-&gt;insert_or_assign(std::move(key), std::move(element)); //&lt; E.g., std::map\n        else\n            data-&gt;emplace(std::move(key), std::move(element)); //&lt; E.g., std::multimap\n    }\n\n    return result;\n}\n\ntemplate&lt;typename T, typename = std::void_t&lt;&gt;&gt;\nstruct IsDeserializable: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsDeserializable&lt;\n    T,\n    std::void_t&lt;decltype(deserialize(std::declval&lt;DeserializationContext&gt;(), (T*) nullptr))&gt;&gt;\n:\n    std::true_type {};\n\ntemplate&lt;typename... U&gt; inline constexpr bool IsDeserializableV =\n    IsDeserializable&lt;U...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename T, bool result&gt;\nstatic void reportUnsupportedType()\n{\n    static_assert(result, &quot;Type is not deserializable&quot;);\n}\n\ntemplate&lt;typename T&gt;\nDeserializationResult deserializeValue(const DeserializationContext&amp; ctx, T* data)\n{\n    // Using if constexpr over SFINAE to make clear prioritization between serialization methods.\n    // E.g., if type both instrumented and stringizable, then choosing instrumentation.\n\n    if constexpr (IsStringAlikeV&lt;T&gt;)\n    {\n        *data = T();\n        if (!ctx.value.IsString())\n            return {false, &quot;String value is expected&quot;, getStringRepresentation(ctx.value)};\n\n        if constexpr (std::is_same_v&lt;T, std::string&gt;)\n        {\n            *data = std::string();\n            if (!ctx.value.IsString())\n                return {false, &quot;String value is expected&quot;, getStringRepresentation(ctx.value)};\n            *data = std::string(ctx.value.GetString(), ctx.value.GetStringLength());\n            return DeserializationResult(true);\n        }\n        else\n        {\n            if (!nx::reflect::fromString(ctx.value.GetString(), data))\n            {\n                *data = T();\n                return {false,\n                    &quot;Can&#x27;t parse the string (custom parser failed)&quot;,\n                    getStringRepresentation(ctx.value)};\n            }\n            return DeserializationResult(true);\n        }\n    }\n    else if constexpr (nx::reflect::IsInstrumentedV&lt;T&gt;)\n    {\n        // ADL. Custom deserialize() overload will be invoked here if present despite the fact\n        // that the type was instrumented.\n        return deserialize(ctx, data);\n    }\n    else if constexpr (std::is_same_v&lt;T, bool&gt;)\n    {\n        *data = bool();\n        if (ctx.value.IsBool())\n        {\n            *data = ctx.value.GetBool();\n            return DeserializationResult(true);\n        }\n        if (ctx.value.IsString())\n        {\n            std::string_view str(ctx.value.GetString(), ctx.value.GetStringLength());\n            if (str == &quot;true&quot;)\n            {\n                *data = true;\n                return DeserializationResult(true);\n            }\n            if (str == &quot;false&quot;)\n            {\n                *data = false;\n                return DeserializationResult(true);\n            }\n        }\n        return {\n            false,\n            &quot;Either a bool value or a string value \\&quot;true\\&quot; or \\&quot;false\\&quot; is expected&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n    else if constexpr (std::is_integral_v&lt;T&gt;)\n    {\n        *data = T();\n        if (ctx.value.IsNumber())\n        {\n            *data = static_cast&lt;T&gt;(ctx.value.GetInt64());\n            return DeserializationResult(true);\n        }\n        if (ctx.value.IsString())\n        {\n            *data = static_cast&lt;T&gt;(std::stoll(\n                std::string(ctx.value.GetString(), ctx.value.GetStringLength())));\n            return DeserializationResult(true);\n        }\n        return {\n            false,\n            &quot;Either a number or a string is expected for an integral value&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n    else if constexpr (std::is_same_v&lt;T, std::nullptr_t&gt;)\n    {\n        *data = std::nullptr_t();\n        if (ctx.value.IsNull())\n            return DeserializationResult(true);\n        return {\n            false,\n            &quot;A null value is expected&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n    else if constexpr (IsInstrumentedEnumV&lt;T&gt;)\n    {\n        *data = T();\n        if (ctx.value.IsString())\n        {\n            bool ok = enumeration::fromString&lt;T&gt;(\n                std::string(ctx.value.GetString(), ctx.value.GetStringLength()), data);\n            return DeserializationResult(ok);\n        }\n        if (ctx.value.IsNumber())\n        {\n            *data = static_cast&lt;T&gt;(ctx.value.GetInt64());\n            return DeserializationResult(enumeration::isValidEnumValue&lt;T&gt;(*data));\n        }\n        return {\n            false,\n            &quot;Either a number or a string is expected for an enum value&quot;,\n            getStringRepresentation(ctx.value)};\n    }\n    else if constexpr (IsDeserializableV&lt;T&gt;)\n    {\n        // ADL call.\n        return deserialize(ctx, data);\n    }\n    else if constexpr (std::is_same_v&lt;T, rapidjson::Value&gt;)\n    {\n        *data = std::move(ctx.value);\n        return {};\n    }\n    else\n    {\n        reportUnsupportedType&lt;T, false&gt;();\n        return {false, &quot;Unknown type&quot;, getStringRepresentation(ctx.value)};\n    }\n}\n\ntemplate&lt;typename T&gt;\nDeserializationResult deserializeValue(const DeserializationContext&amp; ctx, std::optional&lt;T&gt;* data)\n{\n    if (data-&gt;has_value())\n        return deserializeValue(ctx, &amp;data-&gt;value());\n\n    T val;\n    auto result = deserializeValue(ctx, &amp;val);\n    if (result)\n        *data = std::move(val);\n    return result;\n}\n\ntemplate&lt;typename Data&gt;\nclass Deserializer:\n    public nx::reflect::GenericVisitor&lt;Deserializer&lt;Data&gt;&gt;\n{\npublic:\n    Deserializer(const DeserializationContext&amp; ctx, Data* data):\n        m_ctx(ctx),\n        m_data(data)\n    {\n    }\n\n    template&lt;typename WrappedField&gt;\n    void visitField(const WrappedField&amp; field)\n    {\n        if (!m_deserializationResult.success)\n            return;\n\n        auto deserializationResult =\n            deserializeField(m_ctx, field, (typename WrappedField::Type*) nullptr);\n        if (!deserializationResult\n            &amp;&amp; !(m_ctx.flags &amp; (int) json::DeserializationFlag::ignoreFieldTypeMismatch))\n        {\n            m_deserializationResult = std::move(deserializationResult);\n        }\n    }\n\n    DeserializationResult finish() const\n    {\n        return m_deserializationResult;\n    }\n\nprivate:\n    template&lt;typename WrappedField, typename T&gt;\n    DeserializationResult deserializeField(\n        const DeserializationContext&amp; ctx,\n        const WrappedField&amp; field,\n        std::optional&lt;T&gt;*)\n    {\n        DeserializationResult deserializationResult(true);\n        auto valueIter = ctx.value.FindMember(field.name());\n        if (valueIter != ctx.value.MemberEnd())\n        {\n            if ((ctx.flags &amp; ((int) json::DeserializationFlag::fields))\n                &amp;&amp; m_deserializationResult.hasField(field.name()))\n            {\n                return deserializationResult;\n            }\n\n            std::optional&lt;T&gt; data;\n            if constexpr (HasGet&lt;WrappedField&gt;::value)\n            {\n                data = std::move(field.get(*m_data));\n                if (!data)\n                    data.emplace(createDefault&lt;T&gt;());\n            }\n            else\n            {\n                data.emplace(createDefault&lt;T&gt;());\n            }\n            auto&amp; dataRef = *data;\n            auto curDeserializationResult = deserializeValue(\n                DeserializationContext{valueIter-&gt;value, ctx.flags}, &amp;dataRef);\n            if (curDeserializationResult.success)\n            {\n                if (ctx.flags &amp; ((int) json::DeserializationFlag::fields))\n                {\n                    m_deserializationResult.addField(\n                        field, std::move(curDeserializationResult.fields));\n                }\n                field.set(m_data, std::move(data));\n            }\n            else\n            {\n                deserializationResult = curDeserializationResult;\n                if (!deserializationResult.firstNonDeserializedField)\n                    deserializationResult.firstNonDeserializedField = field.name();\n            }\n        }\n        else\n        {\n            field.set(m_data, std::nullopt);\n        }\n        return deserializationResult;\n    }\n\n    template&lt;typename WrappedField, typename T&gt;\n    DeserializationResult deserializeField(\n        const DeserializationContext&amp; ctx,\n        const WrappedField&amp; field,\n        T*)\n    {\n        auto valueIter = ctx.value.FindMember(field.name());\n        if (valueIter == ctx.value.MemberEnd())\n            return DeserializationResult(true);\n\n        if ((ctx.flags &amp; ((int) json::DeserializationFlag::fields))\n            &amp;&amp; m_deserializationResult.hasField(field.name()))\n        {\n            return {};\n        }\n\n        T data = defaultField&lt;T&gt;(field);\n        auto deserializationResult =\n            deserializeValue(DeserializationContext{valueIter-&gt;value, ctx.flags}, &amp;data);\n\n        if (deserializationResult.success)\n        {\n            field.set(m_data, std::move(data));\n            if (ctx.flags &amp; ((int) json::DeserializationFlag::fields))\n                m_deserializationResult.addField(field, std::move(deserializationResult.fields));\n        }\n        else\n        {\n            // If null value cannot be converted to target value type, then just ignore it.\n            if (valueIter-&gt;value.GetType() == rapidjson::kNullType)\n            {\n                if (ctx.flags &amp; ((int) json::DeserializationFlag::fields))\n                {\n                    m_deserializationResult.addField(\n                        field, std::move(deserializationResult.fields));\n                }\n                return DeserializationResult(true);\n            }\n\n            if (!deserializationResult.firstNonDeserializedField)\n                deserializationResult.firstNonDeserializedField = field.name();\n        }\n\n        return deserializationResult;\n    }\n\nprivate:\n    template&lt;typename F, typename = void&gt;\n    struct HasGet { static constexpr bool value = false; };\n\n    template&lt;typename F&gt;\n    struct HasGet&lt;F, detail::void_t&lt;decltype(&amp;F::get)&gt;&gt; { static constexpr bool value = true; };\n\n    template&lt;typename T, typename WrappedField&gt;\n    T defaultField(const WrappedField&amp; field)\n    {\n        if constexpr (HasGet&lt;WrappedField&gt;::value)\n        {\n            return field.get(*m_data);\n        }\n        else\n        {\n            return createDefault&lt;T&gt;();\n        }\n    }\n\nprivate:\n    const DeserializationContext&amp; m_ctx;\n    Data* m_data = nullptr;\n    DeserializationResult m_deserializationResult;\n};\n\n} // namespace json_detail\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace json {\n\nusing DeserializationContext = json_detail::DeserializationContext;\n\ntemplate&lt;typename T&gt;\nDeserializationResult deserialize(const DeserializationContext&amp; ctx, T* data)\n{\n    try\n    {\n        return json_detail::deserializeValue(ctx, data);\n    }\n    catch (const std::exception&amp; e)\n    {\n        return {\n            false,\n            &quot;Exception during json deserialization: &quot; + std::string(e.what()),\n            json_detail::getStringRepresentation(ctx.value)};\n    }\n}\n\n/**\n * Deserializes JSON text into an object of supported type Data.\n * @param data Can be any instrumented type or a container with instrumented types.\n * @return true if deserialized successfully.\n * NOTE: All JSON fields are considered optional. So, missing field in the JSON text is not an error.\n * Member-fields that are not of instrumented types and not of built-in (int, double, std::string) types\n * must be ConvertibleFromString for the deserialization to work.\n * ConvertibleFromString type supports at least one of the following methods:\n * - static T T::fromStdString(const std::string&amp;)\n * - static T T::fromString(const std::string&amp;)\n * - bool fromString(const std::string&amp;, Data*)\n */\ntemplate&lt;typename Data&gt;\nDeserializationResult deserialize(\n    const std::string_view&amp; json,\n    Data* data,\n    json::DeserializationFlag skipErrors = json::DeserializationFlag::none)\n{\n    using namespace rapidjson;\n\n    Document document;\n    document.Parse(json.data(), json.size());\n    if (document.HasParseError())\n        return DeserializationResult(false, json_detail::parseErrorToString(document), std::string(json));\n\n    // Using fully qualified function name to disable ADL.\n    return ::nx::reflect::json::deserialize(DeserializationContext{document, (int) skipErrors}, data);\n}\n\n/**\n * Deserializes JSON text into an object of supported type Data.\n * This is a convenience overload. See the previous deserialize for details.\n * @return std::tuple&lt;deserialized value, result&gt;\n */\ntemplate&lt;typename Data&gt;\nstd::tuple&lt;Data, DeserializationResult&gt; deserialize(\n    const std::string_view&amp; json,\n    json::DeserializationFlag skipErrors = json::DeserializationFlag::none)\n{\n    Data data = createDefault&lt;Data&gt;();\n    auto result = deserialize&lt;Data&gt;(json, &amp;data, skipErrors);\n    return std::make_tuple(std::move(data), std::move(result));\n}\n\n} // namespace json\n\n} // namespace nx::reflect\n"}, "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/type_utils.h": {"id": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/type_utils.h", "filePath": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/type_utils.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_set&gt;\n#include &lt;variant&gt;\n\n#include &quot;instrument.h&quot;\n\nnamespace nx::reflect {\n\nnamespace detail {\n\ntemplate&lt;typename T, typename = std::void_t&lt;&gt;&gt;\nstruct HasTrimmed: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct HasTrimmed&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().trimmed())&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool HasTrimmedV = HasTrimmed&lt;Args...&gt;::value;\n\n} // namespace detail\n\n//TODO: Remove !std::is_same_v&lt;T, std::nullptr_t&gt; after c++23 support.\ntemplate&lt;typename T&gt;\ninline constexpr bool IsStringAlikeV = !std::is_same_v&lt;T, std::nullptr_t&gt;\n    &amp;&amp; (detail::HasTrimmedV&lt;T&gt;\n        || useStringConversionForSerialization((const T*) nullptr)\n        || std::is_convertible_v&lt;T, std::string&gt;\n        || std::is_convertible_v&lt;T, std::string_view&gt;);\n\ntemplate&lt;typename T&gt;\nstruct IsOptional: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsOptional&lt;std::optional&lt;T&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename T&gt;\ninline constexpr bool IsOptionalV = IsOptional&lt;T&gt;::value;\n\ntemplate&lt;typename T&gt;\nstruct IsArray: std::false_type {};\n\ntemplate&lt;typename V, auto N&gt;\nstruct IsArray&lt;std::array&lt;V, N&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsArrayV = IsArray&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename... Args&gt;\nstruct IsVariant: std::false_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\nstruct IsVariant&lt;std::variant&lt;Args...&gt;&gt;: std::true_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\nconstexpr bool IsVariantV = IsVariant&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * A simplified replacement for Container concept (until we have c++20 concepts).\n */\ntemplate&lt;\n    typename,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsContainer: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsContainer&lt;\n    T,\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().begin())&gt;,\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().end())&gt;,\n    std::void_t&lt;typename T::value_type&gt;\n&gt;: std::bool_constant&lt;!IsStringAlikeV&lt;T&gt;&gt; {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsContainerV = IsContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace detail {\n\ntemplate&lt;typename T, typename = std::void_t&lt;&gt;&gt;\nstruct HasHasher: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct HasHasher&lt;T, std::void_t&lt;typename T::hasher&gt;&gt;:\n    std::true_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool HasHasherV = HasHasher&lt;Args...&gt;::value;\n\n} // namespace detail\n\n/**\n * A simplified replacement for AssociativeContainer concept (until we have c++20 concepts).\n */\ntemplate&lt;\n    typename T,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsAssociativeContainer: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsAssociativeContainer&lt;\n    T,\n    std::void_t&lt;std::enable_if_t&lt;IsContainerV&lt;T&gt;&gt;&gt;,\n    std::void_t&lt;typename T::key_type&gt;,\n    std::void_t&lt;typename T::key_compare&gt;,\n    // NOTE: It is weird, but msvc v141 defines key_compare and value_compare in\n    // unordered containers. So, taking this into account.\n    std::void_t&lt;std::enable_if_t&lt;!detail::HasHasherV&lt;T&gt;&gt;&gt;\n&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsAssociativeContainerV = IsAssociativeContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace detail {\n\ntemplate&lt;typename T, typename = std::void_t&lt;&gt;&gt;\nstruct HasMappedType: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct HasMappedType&lt;T, std::void_t&lt;typename T::mapped_type&gt;&gt;:\n    std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool HasMappedTypeV = HasMappedType&lt;Args...&gt;::value;\n\n} // namespace detail\n\ntemplate&lt;\n    typename T,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsSetContainer: std::false_type {};\n\n/**\n * Tests for std::set and std::multiset.\n * NOTE: there is no a similar concept in the STL.\n */\ntemplate&lt;typename T&gt;\nstruct IsSetContainer&lt;\n    T,\n    std::void_t&lt;std::enable_if_t&lt;IsAssociativeContainerV&lt;T&gt;&gt;&gt;,\n    std::void_t&lt;std::enable_if_t&lt;!detail::HasMappedTypeV&lt;T&gt;&gt;&gt;\n&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsSetContainerV = IsSetContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * A simplified replacement for UnorderedAssociativeContainer concept (until we have c++20 concepts).\n */\ntemplate&lt;\n    typename T,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsUnorderedAssociativeContainer: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsUnorderedAssociativeContainer&lt;\n    T,\n    std::void_t&lt;std::enable_if_t&lt;IsContainerV&lt;T&gt;&gt;&gt;,\n    std::void_t&lt;typename T::key_type&gt;,\n    std::void_t&lt;typename T::hasher&gt;\n&gt;: std::true_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsUnorderedAssociativeContainerV =\n    IsUnorderedAssociativeContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;\n    typename T,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsUnorderedSetContainer: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsUnorderedSetContainer&lt;\n    T,\n    std::void_t&lt;std::enable_if_t&lt;IsUnorderedAssociativeContainerV&lt;T&gt;&gt;&gt;,\n    std::void_t&lt;std::enable_if_t&lt;!detail::HasMappedTypeV&lt;T&gt;&gt;&gt;\n&gt;: std::true_type\n{\n};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsUnorderedSetContainerV = IsUnorderedSetContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * A simplified replacement for SequenceContainer concept (until we have c++20 concepts).\n */\ntemplate&lt;\n    typename T,\n    typename = std::void_t&lt;&gt;,\n    typename = std::void_t&lt;&gt;\n&gt;\nstruct IsSequenceContainer: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct IsSequenceContainer&lt;\n    T,\n    std::enable_if_t&lt;IsContainerV&lt;T&gt;&gt;,\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().push_back(std::declval&lt;typename T::value_type&gt;()))&gt;\n&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsSequenceContainerV = IsSequenceContainer&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename... Args&gt;\nstruct IsStdChronoDuration: std::false_type {};\n\ntemplate&lt;typename... Args&gt;\nstruct IsStdChronoDuration&lt;std::chrono::duration&lt;Args...&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\nconstexpr bool IsStdChronoDurationV = IsStdChronoDuration&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename... Args&gt;\nstruct IsStdChronoTimePoint: std::false_type {};\n\ntemplate&lt;typename... Args&gt;\nstruct IsStdChronoTimePoint&lt;std::chrono::time_point&lt;Args...&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename... Args&gt;\nconstexpr bool IsStdChronoTimePointV = IsStdChronoTimePoint&lt;Args...&gt;::value;\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace detail {\n\ntemplate&lt;typename Func&gt;\nstruct EachFieldVisitor\n{\n    template&lt;typename F&gt;\n    EachFieldVisitor(F&amp;&amp; f): m_f(std::forward&lt;F&gt;(f)) {}\n\n    template&lt;typename... Fields&gt;\n    constexpr void operator()(Fields... fields)\n    {\n        (m_f(fields), ...);\n    }\n\nprivate:\n    Func m_f;\n};\n\n} // namespace detail\n\n/**\n * Invokes f on each field of an instrumented type T.\n * Field is passed as either nx::reflect::WrappedMemberVariableField or nx::reflect::WrappedProperty.\n */\ntemplate&lt;typename T, typename Func&gt;\nrequires IsInstrumentedV&lt;T&gt;\nvoid forEachField(Func&amp;&amp; f)\n{\n    nx::reflect::visitAllFields&lt;T&gt;(\n        detail::EachFieldVisitor&lt;std::decay_t&lt;Func&gt;&gt;(std::forward&lt;Func&gt;(f)));\n}\n\ntemplate&lt;typename C, typename T&gt;\nconstexpr bool isSameField(const WrappedMemberVariableField&lt;C, T&gt;&amp; field, T C::*ptr)\n{\n    return field.ptr() == ptr;\n}\n\ntemplate&lt;typename C, typename T, typename OtherC, typename OtherT,\n    typename = std::enable_if_t&lt;!std::is_same_v&lt;T, OtherT&gt;&gt;\n&gt;\nconstexpr bool isSameField(const WrappedMemberVariableField&lt;C, T&gt;&amp;, OtherT OtherC::*)\n{\n    return false;\n}\n\ntemplate&lt;typename G, typename S, typename C, typename T&gt;\nconstexpr bool isSameField(const WrappedProperty&lt;G, S&gt;&amp;, T C::*)\n{\n    return false;\n}\n\n} // namespace nx::reflect\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;exception&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/utils/log/format.h&gt;\n\nnamespace nx::utils {\n\nclass NX_UTILS_API Exception: public std::exception\n{\npublic:\n    Exception() = default;\n    virtual ~Exception();\n    Exception(Exception&amp;&amp; other);\n    Exception(const Exception&amp; other);\n    Exception&amp; operator=(Exception&amp;&amp; other);\n    Exception&amp; operator=(const Exception&amp; other);\n\n    virtual QString message() const = 0;\n    virtual const char* what() const noexcept override final;\n\nprotected:\n    void clearWhatCache();  //&lt; Not thread-safe.\n\nprivate:\n    mutable std::atomic&lt;char*&gt; m_whatCache = nullptr;\n};\n\n// TODO: Add macros for multiple original exceptions.\n\n/**\n * Catches ORIGINAL_EXCEPTION thrown by EXPRESSION, wraps it and rethrows std::nested_exception\n * inherited from NEW_EXCEPTION with message MESSAGE.\n *\n * unwrapNestedErrors() should be used to get output string for wrapped exceptions.\n */\n#define NX_WRAP_EXCEPTION(EXPRESSION, ORIGINAL_EXCEPTION, NEW_EXCEPTION, MESSAGE) [&amp;]() \\\n{ \\\n    try \\\n    { \\\n        return EXPRESSION; \\\n    } catch (const ORIGINAL_EXCEPTION&amp;)  \\\n    { \\\n        std::throw_with_nested(NEW_EXCEPTION(MESSAGE)); \\\n    } \\\n}()\n\nclass NX_UTILS_API ContextedException: public Exception\n{\nprivate:\n    struct FutureTranslator\n    {\n        template &lt;typename Future&gt;\n        decltype(auto) operator()(Future&amp;&amp; future) const\n        {\n            return translate([&amp;] { return std::forward&lt;Future&gt;(future).get(); });\n        };\n    };\n\npublic:\n    explicit ContextedException(const std::string&amp; message);\n    explicit ContextedException(const std::exception&amp; exception);\n    explicit ContextedException(QString message);\n\n    template &lt;typename... Args&gt;\n    explicit ContextedException(const Args&amp;... args):\n        ContextedException(nx::format(args...).toQString())\n    {\n    }\n\n    void addContext(const std::string&amp; context);\n    void addContext(const QString&amp; context);\n\n    template &lt;typename... Args&gt;\n    void addContext(const Args&amp;... args)\n    {\n        addContext(nx::format(args...).toQString());\n    }\n\n    virtual QString message() const override;\n\n#if 0 //&lt; MSVS c++-20 compiler internal error workaround. Revert when fixed.\n\n    template &lt;typename... Args&gt;\n    static auto addFutureContext(Args&amp;&amp;... args)\n    {\n        return\n            [args = std::make_tuple(std::forward&lt;Args&gt;(args)...)](auto&amp;&amp; future)\n            {\n                try\n                {\n                    return std::forward&lt;decltype(future)&gt;(future).get();\n                }\n                catch (ContextedException&amp; exception)\n                {\n                    std::apply([&amp;](const auto&amp;... args) { exception.addContext(args...); }, args);\n                    throw;\n                }\n            };\n    }\n\n#else\n\n    template &lt;typename T1, typename T2, typename T3&gt;\n    static auto addFutureContext(T1&amp;&amp; arg1, T2&amp;&amp; arg2, T3&amp;&amp; arg3)\n    {\n        return\n            [=](auto&amp;&amp; future)\n            {\n                try\n                {\n                    return std::forward&lt;decltype(future)&gt;(future).get();\n                }\n                catch (ContextedException&amp; exception)\n                {\n                    exception.addContext(arg1, arg2, arg3);\n                    throw;\n                }\n            };\n    }\n\n    template &lt;typename T1, typename T2&gt;\n    static auto addFutureContext(T1&amp;&amp; arg1, T2&amp;&amp; arg2)\n    {\n        return\n            [=](auto&amp;&amp; future)\n            {\n                try\n                {\n                    return std::forward&lt;decltype(future)&gt;(future).get();\n                }\n                catch (ContextedException&amp; exception)\n                {\n                    exception.addContext(arg1, arg2);\n                    throw;\n                }\n            };\n    }\n\n    template &lt;typename T1&gt;\n    static auto addFutureContext(T1&amp;&amp; arg1)\n    {\n        return\n            [=](auto&amp;&amp; future)\n            {\n                try\n                {\n                    return std::forward&lt;decltype(future)&gt;(future).get();\n                }\n                catch (ContextedException&amp; exception)\n                {\n                    exception.addContext(arg1);\n                    throw;\n                }\n            };\n    }\n\n#endif //&lt; MSVS c++-20 compiler internal error workaround\n\n    template &lt;typename Callable&gt;\n    static decltype(auto) translate(Callable&amp;&amp; callable)\n    {\n        try\n        {\n            return std::forward&lt;Callable&gt;(callable)();\n        }\n        catch (const ContextedException&amp;)\n        {\n            throw;\n        }\n        catch (const std::exception&amp; exception)\n        {\n            throw ContextedException(exception);\n        }\n    }\n\n    // MSVC bug prevents this from being a simple lambda\n    static constexpr FutureTranslator translateFuture{};\n\nprivate:\n    QString m_message;\n};\n\n} // namespace nx::utils\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/flat_storage.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/flat_storage.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/flat_storage.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;type_traits&gt; /* For std::is_pointer. */\n\n#include &lt;QtCore/QSet&gt;\n\n#include &quot;flat_map.h&quot;\n\n/**\n * Map for heap-allocated items that takes ownership of the items inside it.\n * Uses integer keys that allows it to use arrays for faster lookup.\n */\ntemplate&lt;class Key, class T&gt;\nclass QnFlatStorage: private QnFlatMap&lt;Key, T&gt; {\n    typedef QnFlatMap&lt;Key, T&gt; base_type;\n\n    static_assert(std::is_pointer&lt;T&gt;::value, &quot;Stored type must be a pointer.&quot;);\n\npublic:\n    QnFlatStorage() {}\n\n    ~QnFlatStorage() {\n        for(T value: m_owned)\n            delete value;\n    }\n\n    using base_type::empty;\n    using base_type::clear;\n    using base_type::value;\n\n    const QSet&lt;T&gt; &amp;values() const {\n        return m_owned;\n    }\n\n    void insert(const Key &amp;key, T value, bool claimOwnership = true) {\n        base_type::insert(key, value);\n        if(value != NULL &amp;&amp; claimOwnership)\n            m_owned.insert(value);\n    }\n\nprivate:\n    Q_DISABLE_COPY(QnFlatStorage);\n\nprivate:\n    QSet&lt;T&gt; m_owned;\n};\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/json.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/json.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/json.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;rapidjson/document.h&gt;\n\n#include &lt;nx/reflect/json.h&gt;\n#include &lt;nx/utils/log/log_main.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nnamespace nx::json {\n\nnamespace details {\n\nclass NX_UTILS_API Composer: public nx::reflect::AbstractComposer&lt;::rapidjson::Document&gt;\n{\npublic:\n    Composer(rapidjson::Document::AllocatorType* allocator = nullptr): m_value(allocator)\n    {\n        setSerializeFlags((/*jsonSerializeChronoDurationAsNumber*/ 1 &lt;&lt; 0u)\n            | (/*jsonSerializeInt64AsString*/ 1 &lt;&lt; 1u));\n    }\n\n    virtual void startArray() override { m_value.StartArray(); }\n    virtual void endArray(int items) override { m_value.EndArray(items); }\n    virtual void startObject() override { m_value.StartObject(); }\n    virtual void endObject(int members) override { m_value.EndObject(members); }\n    virtual void writeBool(bool value) override { m_value.Bool(value); }\n    virtual void writeInt(const std::int64_t&amp; value) override { m_value.Int64(value); }\n\n    virtual void writeFloat(const double&amp; value) override\n    {\n        const auto intValue = static_cast&lt;std::int64_t&gt;(value);\n        if (static_cast&lt;double&gt;(intValue) == value)\n            m_value.Int64(intValue);\n        else\n            m_value.Double(value);\n    }\n\n    virtual void writeNull() override { m_value.Null(); }\n    virtual void writeString(const std::string_view&amp; value) override\n    {\n        m_value.String(value.data(), value.size(), /*copy*/ true);\n    }\n\n    virtual void writeAttributeName(const std::string_view&amp; name) override\n    {\n        m_value.Key(name.data(), name.size(), /*copy*/ true);\n    }\n\n    virtual void writeRawString(const std::string_view&amp;) override\n    {\n        NX_ASSERT(false, &quot;Should not get here&quot;);\n    }\n\n    virtual ::rapidjson::Document take() override\n    {\n        if (m_value.GetStackCapacity() != 0)\n        {\n            auto dummy = [](auto&amp;&amp;) { return true; };\n            m_value.Populate(dummy);\n        }\n        return std::move(m_value);\n    }\n\nprivate:\n    ::rapidjson::Document m_value;\n};\n\nclass NX_UTILS_API StripDefaultComposer: public Composer\n{\npublic:\n    using Composer::Composer;\n    virtual void startArray() override;\n    virtual void endArray(int = 0) override;\n    virtual void startObject() override;\n    virtual void endObject(int = 0) override;\n    virtual void writeBool(bool value) override;\n    virtual void writeInt(const std::int64_t&amp; value) override;\n    virtual void writeFloat(const double&amp; value) override;\n    virtual void writeString(const std::string_view&amp; value) override;\n    virtual void writeNull() override;\n    virtual void writeAttributeName(const std::string_view&amp; name) override;\n\nprivate:\n    struct Structured //&lt; Array or object.\n    {\n        std::string firstAttributeWritten; //&lt; Empty for arrays.\n        int writtenCount = 0;\n\n        void start(Composer* composer) const\n        {\n            if (firstAttributeWritten.empty())\n            {\n                composer-&gt;Composer::startArray();\n            }\n            else\n            {\n                composer-&gt;Composer::startObject();\n                composer-&gt;Composer::writeAttributeName(firstAttributeWritten);\n            }\n        }\n    };\n\nprivate:\n    void onWriteValue();\n    void addValue(std::vector&lt;Structured&gt;::reverse_iterator structured);\n\nprivate:\n    std::vector&lt;Structured&gt; m_structured;\n};\n\nstruct SerializationContextBase\n{\n    template&lt;typename T&gt;\n    unsigned int beforeSerialize(const T&amp;) { return 0u; }\n\n    template&lt;typename T&gt;\n    void afterSerialize(const T&amp;, unsigned int) {}\n\n    constexpr bool uuidWithBraces() const { return false; }\n\n    std::string toString(const nx::Uuid&amp; value) const\n    {\n        return value.toStdString(uuidWithBraces() ? QUuid::WithBraces : QUuid::WithoutBraces);\n    }\n};\n\n} // namespace details\n\nstruct SerializationContext: details::SerializationContextBase\n{\n    details::Composer composer;\n\n    SerializationContext(rapidjson::Document::AllocatorType* allocator = nullptr):\n        composer(allocator)\n    {\n    }\n};\n\nstruct StripDefaultSerializationContext: details::SerializationContextBase\n{\n    details::StripDefaultComposer composer;\n\n    StripDefaultSerializationContext(rapidjson::Document::AllocatorType* allocator = nullptr):\n        composer(allocator)\n    {\n    }\n};\n\ntemplate&lt;typename T&gt;\n::rapidjson::Document serialized(\n    const T&amp; value, bool stripDefault, rapidjson::Document::AllocatorType* allocator = nullptr)\n{\n    if (!stripDefault)\n    {\n        SerializationContext context{allocator};\n        nx::reflect::BasicSerializer::serializeAdl(&amp;context, value);\n        return context.composer.take();\n    }\n\n    StripDefaultSerializationContext context{allocator};\n    nx::reflect::BasicSerializer::serializeAdl(&amp;context, value);\n    auto result{context.composer.take()};\n    if (!result.IsNull())\n        return result;\n\n    using namespace nx::reflect;\n    if constexpr (IsInstrumentedV&lt;T&gt;\n        || IsAssociativeContainerV&lt;T&gt;\n        || IsUnorderedAssociativeContainerV&lt;T&gt;)\n    {\n        result.SetObject();\n    }\n    else if constexpr (IsArrayV&lt;T&gt;\n        || IsSequenceContainerV&lt;T&gt;\n        || IsSetContainerV&lt;T&gt;\n        || IsUnorderedSetContainerV&lt;T&gt;)\n    {\n        result.SetArray();\n    }\n    return result;\n}\n\n} // namespace nx::json\n\nnamespace nx::reflect {\n\ntemplate&lt;typename Data&gt;\nclass Visitor&lt;nx::json::StripDefaultSerializationContext, Data&gt;:\n    public GenericVisitor&lt;Visitor&lt;nx::json::StripDefaultSerializationContext, Data&gt;&gt;\n{\npublic:\n    using StripDefaultSerializationContext = nx::json::StripDefaultSerializationContext;\n\n    Visitor(StripDefaultSerializationContext* context, const Data&amp; data):\n        m_context(context), m_data(data)\n    {\n        m_context-&gt;composer.startObject();\n    }\n\n    ~Visitor() { m_context-&gt;composer.endObject(); }\n\n    template&lt;typename WrappedField&gt;\n    void visitField(const WrappedField&amp; field)\n    {\n        const auto&amp; v = field.get(m_data);\n        if (!isDefault(field.get(m_default), v))\n            writeAttribute(field.name(), v);\n    }\n\nprivate:\n    template&lt;typename T, typename = std::void_t&lt;&gt;&gt;\n    struct HasEqualOperator: std::false_type {};\n\n    template&lt;typename T&gt;\n    struct HasEqualOperator&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;&gt;:\n        std::true_type\n    {};\n\n    template&lt;typename T&gt;\n    static bool isDefault(const T&amp; lhs, const T&amp; rhs)\n    {\n        if constexpr (IsOptionalV&lt;T&gt;)\n        {\n            return !rhs || isDefault(typename T::value_type{}, *rhs);\n        }\n        else if constexpr (IsVariantV&lt;T&gt;)\n        {\n            return rhs.valueless_by_exception()\n                || std::visit(\n                    [](const auto&amp; v) { return isDefault(std::decay_t&lt;decltype(v)&gt;{}, v); }, rhs);\n        }\n        else if constexpr (IsContainerV&lt;T&gt;)\n        {\n            NX_ASSERT(lhs.empty());\n            return rhs.empty();\n        }\n        else if constexpr (HasEqualOperator&lt;T&gt;::value)\n        {\n            return lhs == rhs;\n        }\n        else if constexpr (IsInstrumentedV&lt;T&gt;)\n        {\n            return nxReflectVisitAllFields((T*) nullptr,\n                [&amp;lhs, &amp;rhs](auto&amp;&amp;... f) { return (isDefault(f.get(lhs), f.get(rhs)) &amp;&amp; ...); });\n        }\n        else\n        {\n            return nx::reflect::json::serialize(lhs) == nx::reflect::json::serialize(rhs);\n        }\n    }\n\n    template&lt;typename Value&gt;\n    void writeAttribute(const char* name, const std::optional&lt;Value&gt;&amp; value)\n    {\n        if (value)\n            writeAttribute(name, *value);\n    }\n\n    template&lt;typename Value&gt;\n    void writeAttribute(const char* name, const Value&amp; value)\n    {\n        if constexpr (std::is_pointer_v&lt;Value&gt;)\n        {\n            if (value)\n                writeAttribute(name, *value);\n        }\n        else\n        {\n            m_context-&gt;composer.writeAttributeName(name);\n            BasicSerializer::serializeAdl(m_context, value);\n        }\n    }\n\nprivate:\n    StripDefaultSerializationContext* const m_context;\n    const Data&amp; m_data;\n    const Data m_default = createDefault&lt;Data&gt;();\n};\n\n} // namespace nx::reflect\n\nnamespace rapidjson {\n\ntemplate&lt;typename SerializationContext&gt;\nvoid serialize(SerializationContext* context, const Value&amp; value)\n{\n    if constexpr (std::is_same_v&lt;SerializationContext, nx::reflect::json::SerializationContext&gt;)\n    {\n        return context-&gt;composer.writeRawString(\n            nx::reflect::json_detail::getStringRepresentation(value));\n    }\n\n    if (value.IsBool())\n    {\n        context-&gt;composer.writeValue(value.GetBool());\n    }\n    else if (value.IsNumber())\n    {\n        const auto doubleValue = value.GetDouble();\n        const auto intValue = static_cast&lt;std::int64_t&gt;(doubleValue);\n        if (static_cast&lt;double&gt;(intValue) == doubleValue)\n            context-&gt;composer.writeInt(intValue);\n        else\n            context-&gt;composer.writeFloat(doubleValue);\n    }\n    else if (value.IsNull())\n    {\n        context-&gt;composer.writeNull();\n    }\n    else if (value.IsString())\n    {\n        context-&gt;composer.writeValue(std::string_view{value.GetString(), value.GetStringLength()});\n    }\n    else if (value.IsObject())\n    {\n        context-&gt;composer.startObject();\n        for (auto it = value.MemberBegin(); it != value.MemberEnd(); ++it)\n        {\n            context-&gt;composer.writeAttributeName(\n                std::string_view{it-&gt;name.GetString(), it-&gt;name.GetStringLength()});\n            serialize(context, it-&gt;value);\n        }\n        context-&gt;composer.endObject(value.MemberCount());\n    }\n    else if (value.IsArray())\n    {\n        context-&gt;composer.startArray();\n        for (auto it = value.Begin(); it != value.End(); ++it)\n            serialize(context, *it);\n        context-&gt;composer.endArray(value.Size());\n    }\n    else\n    {\n        NX_ASSERT(false, &quot;Unsupported rapidjson::Value type&quot;);\n    }\n}\n\ntemplate&lt;typename SerializationContext&gt;\nvoid serialize(SerializationContext* context, const Document&amp; value)\n{\n    serialize(context, static_cast&lt;const Value&amp;&gt;(value));\n}\n\n} // namespace rapidjson\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n/**@file\n * Custom nx_reflect/json functions for Qt containers.\n *\n * Qt associative containers do not satisfy STL concepts like AssociativeContainer. So, separate\n * support functions are added here. Qt sequence containers (QList, QVector) work out of the box.\n */\n\n#include &lt;QtCore/QMap&gt;\n#include &lt;QtCore/QMultiMap&gt;\n#include &lt;QtCore/QSet&gt;\n\n#include &lt;nx/reflect/array_orderer.h&gt;\n#include &lt;nx/reflect/filter.h&gt;\n#include &lt;nx/reflect/json.h&gt;\n\n#include &quot;qt_core_types.h&quot;\n\n//-------------------------------------------------------------------------------------------------\n// QSet\n\ntemplate&lt;typename SerializationContext, typename T&gt;\nrequires std::is_member_object_pointer_v&lt;decltype(&amp;SerializationContext::composer)&gt;\nvoid serialize(SerializationContext* context, const QSet&lt;T&gt;&amp; value)\n{\n    context-&gt;composer.startArray();\n    for (const auto&amp; element: value)\n        nx::reflect::BasicSerializer::serializeAdl(context, element);\n    context-&gt;composer.endArray(value.size());\n}\n\ntemplate&lt;typename T&gt;\nnx::reflect::DeserializationResult deserialize(\n    const nx::reflect::json::DeserializationContext&amp; context,\n    QSet&lt;T&gt;* value)\n{\n    using namespace nx::reflect;\n\n    if (!context.value.IsArray())\n        return false;\n\n    for (int i = 0; i &lt; (int) context.value.Size(); ++i)\n    {\n        T val;\n        if (auto result = json::deserialize(json::DeserializationContext{context.value[i]}, &amp;val);\n            !result)\n        {\n            return result;\n        }\n\n        value-&gt;insert(std::move(val));\n    }\n\n    return DeserializationResult(true);\n}\n\n//-------------------------------------------------------------------------------------------------\n// Qt associative containers (QMap/QHash)\n\ntemplate&lt;typename T, typename... Args&gt;\nstruct IsQtAssociativeContainer { static constexpr bool value = false; };\n\ntemplate&lt;typename... Args&gt;\nstruct IsQtAssociativeContainer&lt;QMap&lt;Args...&gt;&gt; { static constexpr bool value = true; };\n\ntemplate&lt;typename... Args&gt;\nstruct IsQtAssociativeContainer&lt;QMultiMap&lt;Args...&gt;&gt; { static constexpr bool value = true; };\n\ntemplate&lt;typename... Args&gt;\nstruct IsQtAssociativeContainer&lt;QHash&lt;Args...&gt;&gt; { static constexpr bool value = true; };\n\ntemplate&lt;&gt;\nstruct IsQtAssociativeContainer&lt;QVariantMap&gt;: std::false_type {};\n\ntemplate&lt;typename... Args&gt;\ninline constexpr bool IsQtAssociativeContainerV = IsQtAssociativeContainer&lt;Args...&gt;::value;\n\ntemplate&lt;typename SerializationContext, typename Container&gt;\nrequires IsQtAssociativeContainerV&lt;Container&gt;\nvoid serialize(SerializationContext* context, const Container&amp; value)\n{\n    context-&gt;composer.startObject();\n    for (auto it = value.begin(); it != value.end(); ++it)\n    {\n        // NOTE: Supporting only string keys.\n        context-&gt;composer.writeAttributeName(nx::reflect::toString(it.key()));\n        nx::reflect::BasicSerializer::serializeAdl(context, it.value());\n    }\n    context-&gt;composer.endObject(value.size());\n}\n\ntemplate&lt;template&lt;typename...&gt; typename Container, typename Key, typename Value&gt;\nrequires IsQtAssociativeContainerV&lt;Container&lt;Key, Value&gt;&gt;\nnx::reflect::DeserializationResult deserialize(\n    const nx::reflect::json::DeserializationContext&amp; context,\n    Container&lt;Key, Value&gt;* value)\n{\n    using namespace nx::reflect;\n\n    if (!context.value.IsObject())\n        return false;\n\n    for (auto it = context.value.MemberBegin(); it != context.value.MemberEnd(); ++it)\n    {\n        std::string_view keyStr(it-&gt;name.GetString(), it-&gt;name.GetStringLength());\n\n        Key key;\n        if (!fromString(keyStr, &amp;key))\n            return DeserializationResult(false, &quot;QMap key must be a string&quot;, std::string(keyStr));\n\n        Value val;\n        if (auto result = json::deserialize(json::DeserializationContext{it-&gt;value}, &amp;val); !result)\n            return result;\n\n        value-&gt;insert(std::move(key), std::move(val));\n    }\n\n    return DeserializationResult(true);\n}\n\nnamespace nx::reflect {\n\ntemplate&lt;typename Matcher, typename T&gt;\nbool filter(QSet&lt;T&gt;* data, const Filter&amp; filter_)\n{\n    if (filter_.values.empty() &amp;&amp; filter_.fields.empty())\n        return false;\n\n    if (!filter_.values.empty() &amp;&amp; !Matcher::matches(*data, filter_.values))\n        return true;\n\n    erase_if(*data, [&amp;filter_](auto&amp; v) { return filter&lt;Matcher&gt;(&amp;v, filter_); });\n    return data-&gt;empty();\n}\n\ntemplate&lt;typename Matcher, template&lt;typename...&gt; typename Container, typename Key, typename Value&gt;\nrequires IsQtAssociativeContainerV&lt;Container&lt;Key, Value&gt;&gt;\nbool filter(Container&lt;Key, Value&gt;* data, const Filter&amp; filter_)\n{\n    if (filter_.values.empty() &amp;&amp; filter_.fields.empty())\n        return false;\n\n    if (!filter_.values.empty() &amp;&amp; !Matcher::matches(*data, filter_.values))\n        return true;\n\n    if (data-&gt;empty())\n        return false;\n\n    for (const auto&amp; field: filter_.fields)\n    {\n        if (field.name == &quot;*&quot;)\n        {\n            erase_if(*data, [&amp;field](auto&amp; it) { return filter&lt;Matcher&gt;(&amp;it.value(), field); });\n            if (data-&gt;empty())\n                return true;\n        }\n        else\n        {\n            auto key = fromString&lt;Key&gt;(field.name);\n            auto it = data-&gt;find(key);\n            if (it != data-&gt;end())\n            {\n                if (filter&lt;Matcher&gt;(&amp;it.value(), field))\n                {\n                    data-&gt;erase(it);\n                    if (data-&gt;empty())\n                        return true;\n                }\n            }\n        }\n    }\n    return data-&gt;empty();\n}\n\ntemplate&lt;template&lt;typename...&gt; typename Container, typename Key, typename Value&gt;\nrequires IsQtAssociativeContainerV&lt;Container&lt;Key, Value&gt;&gt;\nvoid order(Container&lt;Key, Value&gt;* data, const ArrayOrder&amp; order_)\n{\n    for (auto it = data-&gt;begin(); it != data-&gt;end(); ++it)\n        order(&amp;it.value(), order_);\n}\n\nnamespace array_orderer_details {\n\ntemplate&lt;&gt;\ninline std::function&lt;int(const QVariantMap&amp;, const QVariantMap&amp;)&gt; makeComparator(const ArrayOrder&amp;)\n{\n    return {};\n}\n\n} // namespace array_orderer_details\n\n} // namespace nx::reflect\n\nnamespace std {\n\ntemplate&lt;template&lt;typename...&gt; typename Container, typename Key, typename Value&gt;\nrequires IsQtAssociativeContainerV&lt;Container&lt;Key, Value&gt;&gt;\nstruct less&lt;Container&lt;Key, Value&gt;&gt;\n{\n    constexpr inline bool operator()(\n        const Container&lt;Key, Value&gt;&amp;, const Container&lt;Key, Value&gt;&amp;) const\n    {\n        return false;\n    }\n};\n\n} // namespace std\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx {\n\ntemplate &lt;typename Value&gt;\nclass ValueLocker\n{\npublic:\n    ValueLocker(nx::Mutex* mutex = nullptr, Value* value = nullptr): m_mutex(mutex), m_value(value)\n    {\n        if (m_mutex)\n            m_mutex-&gt;lock();\n    }\n\n    ValueLocker(ValueLocker&amp;&amp; other) { *this = std::move(other); }\n    ~ValueLocker() { unlock(); }\n\n    ValueLocker(const ValueLocker&amp; other) = delete;\n    ValueLocker&amp; operator=(const ValueLocker&amp; other) = delete;\n\n    ValueLocker&amp; operator=(ValueLocker&amp;&amp; other)\n    {\n        m_mutex = other.m_mutex;\n        m_value = other.m_value;\n        other.m_mutex = nullptr;\n        other.m_value = nullptr;\n        return *this;\n    }\n\n    void unlock()\n    {\n        if (m_mutex)\n        {\n            m_mutex-&gt;unlock();\n            m_mutex = nullptr;\n            m_value = nullptr;\n        }\n    }\n\n    Value* operator-&gt;() { return m_value; }\n    const Value* operator-&gt;() const { return m_value; }\n    Value&amp; operator*() { return *m_value; }\n    const Value&amp; operator*() const { return *m_value; }\n\nprivate:\n    Mutex* m_mutex;\n    Value* m_value;\n};\n\ntemplate&lt;typename Value&gt;\nclass Lockable\n{\npublic:\n    using LockedType = ValueLocker&lt;Value&gt;;\n\n    template&lt;typename... Args&gt;\n    Lockable(Args&amp;&amp;... args):\n        m_value(std::forward&lt;Args&gt;(args)...)\n    {\n    }\n\n    LockedType lock()\n    {\n        return ValueLocker&lt;Value&gt;(&amp;m_mutex, &amp;m_value);\n    };\n\n    const LockedType lock() const\n    {\n        return LockedType(&amp;m_mutex, &amp;m_value);\n    };\n\nprivate:\n    mutable Mutex m_mutex;\n    mutable Value m_value;\n};\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/abstract_logger.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/abstract_logger.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/abstract_logger.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;set&gt;\n\n#include &lt;nx/utils/std/optional.h&gt;\n#include &lt;nx/utils/thread/cf/cfuture.h&gt;\n\n#include &quot;log_writers.h&quot;\n\nnamespace nx::log {\n\nclass LoggerSettings;\n\nclass NX_UTILS_API AbstractLogger\n{\npublic:\n    using OnLevelChanged = std::function&lt;void()&gt;;\n\n    virtual ~AbstractLogger() = default;\n\n    virtual std::set&lt;Filter&gt; filters() const = 0;\n\n    /** Writes message to every writer if it is to be logged. */\n    virtual void log(Level level, const Tag&amp; tag, const QString&amp; message) = 0;\n\n    /** Writes message to every writer unconditionally. */\n    virtual void logForced(Level level, const Tag&amp; tag, const QString&amp; message) = 0;\n\n    /** Indicates whether this logger is going to log such a message. */\n    virtual bool isToBeLogged(Level level, const Tag&amp; tag = {}) = 0;\n\n    /** Makes this logger log all messages with level &lt;= defaultLevel. */\n    virtual Level defaultLevel() const = 0;\n    virtual void setDefaultLevel(Level level) = 0;\n\n    /** Custom levels for messages which tag matches one of the filters. */\n    virtual LevelFilters levelFilters() const = 0;\n    virtual void setLevelFilters(LevelFilters filters) = 0;\n\n    virtual void setSettings(const LoggerSettings&amp; settings) = 0;\n\n    /** @return Maximum possible log level, according to the current settings. */\n    virtual Level maxLevel() const = 0;\n\n    virtual void setOnLevelChanged(OnLevelChanged onLevelChanged) = 0;\n\n    virtual std::optional&lt;QString&gt; filePath() const = 0;\n\n    virtual cf::future&lt;cf::unit&gt; stopArchivingAsync() = 0;\n\n    virtual void writeLogHeader() = 0;\n};\n\n} // namespace nx::log\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_level.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_level.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_level.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;set&gt;\n\n#include &lt;nx/utils/log/to_string.h&gt;\n\nnamespace nx::log {\n\nNX_REFLECTION_ENUM_CLASS(Level,\n    undefined,\n    none,\n    error,\n    warning,\n    info,\n    debug,\n    verbose,\n    trace,\n    notConfigured = 0xFF\n)\n\nconstexpr size_t kLevelsCount = nx::reflect::enumeration::visitAllItems&lt;Level&gt;(\n    [](auto&amp;&amp;... items)\n    {\n        return sizeof...(items);\n    });\n\nLevel NX_UTILS_API levelFromString(const QString&amp; levelString);\nQString NX_UTILS_API toString(Level level);\n\n#ifdef _DEBUG\n    static constexpr Level kDefaultLevel = Level::debug;\n#else\n    static constexpr Level kDefaultLevel = Level::info;\n#endif\n\nclass NX_UTILS_API Tag\n{\npublic:\n    Tag() = default;\n\n    Tag(const std::type_info&amp; info);\n\n    /** NOTE: Use a tag made from a string only when absolutely necessary. */\n    explicit Tag(QString s);\n\n    /** NOTE: Use a tag made from a string only when absolutely necessary. */\n    explicit Tag(const std::string&amp; s);\n\n    /**\n     * Disabled to prohibit compiling NX_DEBUG(&quot;message&quot;, ...) - incorrect because the message is\n     * passed instead of the tag. Using `explicit` does not help because Tag(const T*) will be\n     * called then, and the wrong call would compile.\n     */\n    Tag(const char* s) = delete;\n\n    template&lt;typename T&gt;\n    Tag(const T* pointer): m_value(nx::toString(pointer)) {}\n\n    template&lt;typename T&gt;\n    Tag join(const T* pointer) const { return Tag(m_value + &quot;::&quot; + nx::toString(pointer)); }\n\n    const QString&amp; toString() const;\n    Tag operator+(const Tag&amp; rhs) const;\n\n    bool operator&lt;(const Tag&amp; rhs) const;\n    bool operator==(const Tag&amp; rhs) const;\n    bool operator!=(const Tag&amp; rhs) const;\n\nprivate:\n    QString m_value;\n};\n\nclass NX_UTILS_API Filter\n{\npublic:\n    /**\n     * Create filter using the provided string. If the starts from the `re:` substring, it is parsed\n     * as a regular expression. Otherwise, `startsWith` logic is applied.\n     */\n    explicit Filter(const QString&amp; source);\n    explicit Filter(const std::string&amp; source);\n\n    /**\n     * Create filter using the provided tag. It will match this tag only.\n     */\n    explicit Filter(const Tag&amp; tag);\n\n    ~Filter();\n\n    bool isValid() const;\n    bool accepts(const Tag&amp; tag) const;\n    QString toString() const;\n\n    bool operator&lt;(const Filter&amp; rhs) const;\n    bool operator==(const Filter&amp; rhs) const;\n    bool operator!=(const Filter&amp; rhs) const;\n\nprivate:\n    class Impl;\n    std::shared_ptr&lt;Impl&gt; m_impl;\n};\n\nusing LevelFilters = std::map&lt;Filter, Level&gt;;\n\nstruct NX_UTILS_API LevelSettings\n{\n    Level primary = kDefaultLevel;\n    LevelFilters filters;\n\n    LevelSettings(Level primary = kDefaultLevel, LevelFilters filters = {});\n    bool operator==(const LevelSettings&amp; rhs) const;\n\n    void reset();\n    QString toString() const;\n\n    /**\n     * Parses settings according to the grammar:\n     * &lt;pre&gt;&lt;code&gt;\n     *     settings ::= levelDescription (&#x27;,&#x27; levelDescription)*\n     *     levelDescription ::= level (&#x27;[&#x27; tagPrefixes &#x27;]&#x27;)?\n     *     level ::= &#x27;none&#x27; | &#x27;always&#x27; | &#x27;error&#x27; | ...\n     *     tagPrefix ::= [a-zA-Z_] [a-zA-Z_0-9:&lt;&gt;]*\n     *     tagPrefixes ::= tagPrefix (&#x27;,&#x27; tagPrefix)*\n     * &lt;/code&gt;&lt;/pre&gt;\n     *\n     * Notes:\n     * - All whitespace is ignored, might be useful for formatting.\n     * - Level without tags is considered as primary level.\n     *\n     * Example:\n     * &lt;pre&gt;&lt;code&gt;\n     *     none, verbose[nx::media::media_player_quality_chooser], debug[ec2::DbManager]\n     * &lt;/code&gt;&lt;/pre&gt;\n     */\n    bool parse(const QString&amp; s);\n\n    template&lt;typename ... Args&gt;\n    bool parse(const QString&amp; arg, Args ... args)\n    {\n        if (arg.isEmpty())\n            return parse(std::forward&lt;Args&gt;(args) ...);\n        else\n            return parse(arg);\n    }\n};\n\n} // namespace nx::log\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_main.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_main.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_main.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/system_error.h&gt;\n#include &lt;nx/utils/time.h&gt;\n\n#include &quot;log_logger.h&quot;\n\nnamespace nx::log {\n\n/** @return Main logger. */\nNX_UTILS_API std::shared_ptr&lt;AbstractLogger&gt; mainLogger();\n\nNX_UTILS_API bool setMainLogger(std::unique_ptr&lt;AbstractLogger&gt; logger);\n\nNX_UTILS_API bool addLogger(\n    std::unique_ptr&lt;AbstractLogger&gt; logger,\n    bool writeLogHeader = true);\n\n/** Every setMainLogger and addLogger calls will fail until unlockConfiguration is called. */\nNX_UTILS_API void lockConfiguration();\n\n/** Allow setMainLogger and addLogger calls after lockConfiguration. */\nNX_UTILS_API void unlockConfiguration();\n\n/** @return AbstractLogger by tag or main if no specific logger is set. */\nNX_UTILS_API std::shared_ptr&lt;AbstractLogger&gt; getLogger(const Tag&amp; tag);\n\n/** @return AbstractLogger by exact tag, nullptr otherwise. */\nNX_UTILS_API std::shared_ptr&lt;AbstractLogger&gt; getExactLogger(const Tag&amp; tag);\n\n/** Removes specific loggers for filters, so such messages will go to main log. */\nNX_UTILS_API void removeLoggers(const std::set&lt;Filter&gt;&amp; filters);\n\n/** Get the maximum log level currently used by any logger registered via addLogger(). */\nNX_UTILS_API Level maxLevel();\n\n/** Indicates if a message is going to be logged by any logger. */\nbool NX_UTILS_API isToBeLogged(Level level, const Tag&amp; tag = {});\n\n/** Indicates if passwords should be shown in logs. */\nbool NX_UTILS_API showPasswords();\n\nnamespace detail {\n\nclass LevelReducer\n{\npublic:\n    LevelReducer(Level level): m_level(level) {}\n    Level baseLevel() const { return m_level; }\n\n    std::pair&lt;Level, bool /*isOnLimit*/&gt; nextLevel()\n    {\n        if (!s_isEnabled || (m_level &gt; Level::info))\n            return {m_level, /*isOnLimit*/ false};\n\n        const auto limit = (uint32_t) nx::utils::ini().logLevelReducerPassLimit;\n        const auto windowSizeS = (uint32_t) nx::utils::ini().logLevelReducerWindowSizeS;\n\n        const auto nowS = (uint32_t) std::chrono::duration_cast&lt;std::chrono::seconds&gt;(\n            nx::utils::monotonicTime().time_since_epoch()).count();\n\n        const auto windowStartS = m_windowStartS.load();\n        if (m_passCount == 0 || windowStartS + windowSizeS &lt;= nowS || windowStartS &gt; nowS)\n        {\n            // It is possible to have a race on these 2 atomics and actual log writing, but it\n            // would only affect the number of records on each level and their order.\n            m_windowStartS = nowS;\n            m_passCount = 0;\n        }\n\n        const auto newCount = ++m_passCount;\n        return {\n            (newCount &lt;= limit) ? m_level : Level::debug,\n            /*isOnLimit*/ (newCount == limit)\n        };\n    }\n\n    static void setEnabled(bool value) { s_isEnabled = value; }\n\nprivate:\n    NX_UTILS_API static bool s_isEnabled /*= true*/;\n\n    const Level m_level;\n    std::atomic&lt;uint32_t&gt; m_passCount{0};\n    std::atomic&lt;uint32_t&gt; m_windowStartS{0};\n};\n\nclass Helper\n{\npublic:\n    Helper() {} //&lt; Constructing a helper which does not log anything.\n\n    Helper(LevelReducer* levelReducer, Tag tag):\n        m_tag(std::move(tag)),\n        m_levelReducer(levelReducer),\n        m_logger(getLogger(m_tag))\n    {\n        if (m_logger &amp;&amp; !m_logger-&gt;isToBeLogged(levelReducer-&gt;baseLevel(), m_tag))\n            m_logger.reset();\n    }\n\n    void log(const QString&amp; message) const\n    {\n        // Avoid crashing during the static deinitialization phase - log to stderr instead.\n        if (!m_logger)\n        {\n            // LevelReducer can be already destroyed at this time, so ignore the level.\n            std::cerr &lt;&lt; (m_tag.toString() + &quot;: &quot; + message + &quot;\\n&quot;).toStdString();\n            std::flush(std::cerr);\n            return;\n        }\n\n        const auto [level, isOnLimit] = m_levelReducer-&gt;nextLevel();\n        m_logger-&gt;log(level, m_tag, isOnLimit ? &quot;TOO MANY SIMILAR MESSAGES: &quot; + message : message);\n    }\n\n    explicit operator bool() const { return m_logger.get(); }\n\nprotected:\n   const Tag m_tag;\n   LevelReducer* const m_levelReducer = nullptr;\n   std::shared_ptr&lt;AbstractLogger&gt; m_logger;\n};\n\nclass Stream: public Helper\n{\npublic:\n    using Helper::Helper;\n\n    Stream() = default;\n    Stream(const Stream&amp;) = delete;\n    Stream(Stream&amp;&amp;) = default;\n    Stream&amp; operator=(const Stream&amp;) = delete;\n    Stream&amp; operator=(Stream&amp;&amp;) = delete;\n\n    Stream&amp; setDelimiter(const QString&amp; delimiter)\n    {\n        m_delimiter = delimiter;\n        return *this;\n    }\n\n    template&lt;typename Value&gt;\n    Stream&amp; operator&lt;&lt;(const Value&amp; value)\n    {\n        m_strings &lt;&lt; nx::toString(value);\n        return *this;\n    }\n\n    void flush()\n    {\n        if (!m_logger)\n            return;\n\n        NX_ASSERT(!m_strings.isEmpty());\n        log(m_strings.join(m_delimiter));\n        m_logger.reset();\n    }\n\nprivate:\n    QStringList m_strings;\n    QString m_delimiter = QStringLiteral(&quot; &quot;);\n};\n\n} // namespace detail\n\ninline void setLevelReducerEnabled(bool value)\n{\n    detail::LevelReducer::setEnabled(value);\n}\n\n/**\n * NOTE: Preserves current system error code (SystemError::getLastOSErrorCode()).\n */\n#define NX_UTILS_LOG_MESSAGE(LEVEL, TAG, ...) do \\\n{ \\\n    struct ScopeTag{}; /*&lt; Used by NX_SCOPE_TAG to get scope from demangled type_info::name(). */ \\\n    if ((LEVEL) &lt;= nx::log::maxLevel()) \\\n    { \\\n        const auto systemErrorBak = SystemError::getLastOSErrorCode(); \\\n        static nx::log::detail::LevelReducer levelReducer(LEVEL); \\\n        if (auto _log_helper = nx::log::detail::Helper(&amp;levelReducer, (TAG))) \\\n            _log_helper.log(::nx::format(__VA_ARGS__)); \\\n        SystemError::setLastErrorCode(systemErrorBak); \\\n    } \\\n} while (0)\n\n#define NX_UTILS_LOG_STREAM(LEVEL, TAG) \\\n    for (auto stream = \\\n            [&amp;]() \\\n            { \\\n                if ((LEVEL) &gt; nx::log::maxLevel()) \\\n                    return nx::log::detail::Stream(); \\\n                static nx::log::detail::LevelReducer levelReducer(LEVEL); \\\n                return nx::log::detail::Stream(&amp;levelReducer, (TAG));  \\\n            }(); \\\n        stream; stream.flush()) \\\n            stream /* &lt;&lt;... */\n\n/**\n * Can be used to redirect nx_kit&#x27;s NX_PRINT to log as following:\n * &lt;pre&gt;&lt;code&gt;\n *     #define NX_PRINT NX_UTILS_LOG_STREAM_NO_SPACE( \\\n *         nx::log::Level::debug, \\\n *         nx::log::Tag(QStringLiteral(&quot;my_plugin&quot;)) \\\n *     ) &lt;&lt; NX_PRINT_PREFIX\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_UTILS_LOG_STREAM_NO_SPACE(LEVEL, TAG) \\\n    NX_UTILS_LOG_STREAM(LEVEL, TAG).setDelimiter(QString()) /* &lt;&lt;... */\n\n/**\n * Usage:\n *     NX_&lt;LEVEL&gt;(TAG, MESSAGE [, VALUES...]; //&lt; Writes MESSAGE to log if LEVEL and TAG allow.\n * or, when the log level is known only at runtime:\n *     NX_UTILS_LOG(nx::log::Level::&lt;level&gt;, TAG, MESSAGE [, VALUES...];\n *\n * Examples:\n *     NX_INFO(this, &quot;Expected value %1&quot;, value);\n *     NX_DEBUG(NX_SCOPE_TAG, &quot;Message from a non-member function.&quot;);\n *\n * Deprecated usage:\n *     NX_ERROR(this) &lt;&lt; &quot;Unexpected value&quot; &lt;&lt; value;\n */\n#define NX_UTILS_LOG(...) \\\n    /* Choose one of the two macros depending on the number of args supplied to this macro. */ \\\n    NX_MSVC_EXPAND(NX_GET_15TH_ARG( \\\n        __VA_ARGS__, \\\n        /* Repeat 12 times: allow for up to 11 args which are %N-substituted into the message. */ \\\n        NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, \\\n        NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, \\\n        NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, NX_UTILS_LOG_MESSAGE, \\\n        NX_UTILS_LOG_STREAM, /*&lt; Chosen when called with TAG arg only (without a message). */ \\\n        args_required /*&lt; Chosen when called without arguments; leads to an error. */ \\\n    )(__VA_ARGS__))\n\n/**\n * Prints a critical error that is likely to cause a complete service interruption. The message\n * text must be clear and make sense to the end-user.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_ERROR(this, &quot;Connection to the DB has been lost: %1&quot;, err);\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_ERROR(...) NX_UTILS_LOG(nx::log::Level::error, __VA_ARGS__)\n\n/**\n * Prints a non-critical error/warning that may cause issues with limited impact. The message text\n * must be clear and make sense to the end-user.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_WARNING(this, &quot;Camera %1 went offline&quot;, camera-&gt;id());\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_WARNING(...) NX_UTILS_LOG(nx::log::Level::warning, __VA_ARGS__)\n\n/**\n * Prints an information message about the service&#x27;s state. The number of such messages must not be\n * large regardless of the load. The message text must be clear and make sense to the end-user.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_INFO(this, &quot;Bound to https port %1 and listening&quot;, server-&gt;port());\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_INFO(...) NX_UTILS_LOG(nx::log::Level::info, __VA_ARGS__)\n\n/**\n * Prints a message that is useful for understanding how a service is operating. Some examples are:\n * user authentication result, API request processing result. Bad examples are: tracing details of\n * a request processing, logging the network traffic.\n *\n * The message should be understandable by a QA/support person, but may also contain information\n * targeted solely for developers.\n *\n * There should not be too many of such messages (though, it may depend on the load). Generally,\n * it should be possible to enable these messages in a production environment for a prolonged\n * period of time without an impact on the service.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_DEBUG(this, &quot;User %1 added to a system %2 with role %3&quot;, username, systemId, role);\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_DEBUG(...) NX_UTILS_LOG(nx::log::Level::debug, __VA_ARGS__)\n\n/**\n * Prints a message that is helpful to a developer for understanding the details of a service\n * behavior.\n *\n * A good example is logging the details of an HTTP request/response exchange:\n * - &quot;connection to %1 is established&quot;\n * - &quot;request headers were sent, sending body&quot;\n * - &quot;full message was sent, waiting for reply&quot;\n *\n * The number of messages at this log level may be huge. It must be expected that enabling this log\n * level on a production system will have a significant impact on the system performance. It is\n * recommended to enable these messages for a short period, only while providing a targeted message\n * filter.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_VERBOSE(this, &quot;%1 response headers from %2 have been received. Waiting for a body&quot;,\n *         response.headers.size(), connection-&gt;getForeignAddress());\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_VERBOSE(...) NX_UTILS_LOG(nx::log::Level::verbose, __VA_ARGS__)\n\n/**\n * Prints a message with very low-level information.\n *\n * The message is likely to make sense only to those developers who are familiar with the given\n * block of code. Can be used to trace an execution where the debugger is not available.\n *\n * It is recommended to use this for messages in huge quantities that can be useful rarely to\n * certain developers only. An example is tracing an SSL socket: logging each read, write,\n * encryption, decryption.\n *\n * The `trace` log level can only be enabled with a non-empty filter. The filter should be limited\n * to the specific class or a small namespace.\n *\n * The number of log messages is likely to be huge in a production environment. It must be expected\n * that enabling this level even with a narrow filter will have a negative impact on the\n * performance.\n *\n * If you decide to use this log level, do not expect that someone else will collect these logs for\n * you or analyze them.\n *\n * Example:\n * &lt;pre&gt;&lt;code&gt;\n *     NX_TRACE(this, &quot;Read %1 bytes out of %2 requested&quot;, result, size);\n * &lt;/code&gt;&lt;/pre&gt;\n */\n#define NX_TRACE(...) NX_UTILS_LOG(nx::log::Level::trace, __VA_ARGS__)\n\n/** Use as a logging tag in functions without &quot;this&quot;. */\n#define NX_SCOPE_TAG nx::log::Tag(nx::scopeOfFunction(typeid(ScopeTag), __FUNCTION__))\n\n} // namespace nx::log\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;future&gt;\n\n#include &lt;QtCore/QDateTime&gt;\n#include &lt;QtCore/QFileInfo&gt;\n#include &lt;QtCore/QLockFile&gt;\n\n#include &lt;nx/utils/log/log_level.h&gt;\n#include &lt;nx/utils/thread/cf/cfuture.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx::log {\n\nstatic constexpr int kMaxLogRotation = 999;\nstatic constexpr qint64 kDefaultMaxLogVolumeSizeB = 250 * 1024 * 1024;\nstatic constexpr qint64 kDefaultMaxLogFileSizeB = 10 * 1024 * 1024;\nstatic constexpr std::chrono::seconds kDefaultMaxLogFileTimePeriodS = std::chrono::seconds::zero();\nstatic constexpr bool kDefaultLogArchivingEnabled = true;\n\nclass NX_UTILS_API AbstractWriter\n{\npublic:\n    virtual ~AbstractWriter() = default;\n    virtual void write(Level level, const QString&amp; message) = 0;\n    virtual cf::future&lt;cf::unit&gt; stopArchivingAsync();\n};\n\n/**\n * Writes to std out.\n */\nclass NX_UTILS_API StdOut: public AbstractWriter\n{\npublic:\n    virtual void write(Level level, const QString&amp; message) override;\n\nprivate:\n    static void writeImpl(Level level, const QString&amp; message);\n\n    nx::Mutex m_mutex;\n};\n\n/**\n * File writer with backup rotation.\n */\nclass NX_UTILS_API File: public AbstractWriter\n{\npublic:\n    enum Extension\n    {\n        log,\n        tmp,\n        zip,\n        zipTmp,\n    };\n\n    template&lt;typename Visitor&gt;\n    friend constexpr auto nxReflectVisitAllEnumItems(Extension*, Visitor&amp;&amp; visitor)\n    {\n        using Item = nx::reflect::enumeration::Item&lt;Extension&gt;;\n        return visitor(\n            Item{log, &quot;.log&quot;},\n            Item{tmp, &quot;.log.tmp&quot;},\n            Item{zip, &quot;.log.zip&quot;},\n            Item{zipTmp, &quot;.log.zip.tmp&quot;}\n        );\n    }\n\n    static QString makeFileName(QString fileName, size_t backupNumber, Extension ext);\n    static QString makeBaseFileName(QString path);\n\n    struct Settings\n    {\n        QString name; /**&lt; Base file name with path. */\n        qint64 maxVolumeSizeB = kDefaultMaxLogVolumeSizeB; /**&lt; Maximum volume size. */\n        qint64 maxFileSizeB = kDefaultMaxLogFileSizeB; /**&lt; Maximum file size. */\n        std::chrono::seconds maxFileTimePeriodS = kDefaultMaxLogFileTimePeriodS; /**&lt; Maximum file duration in time. */\n        bool archivingEnabled = kDefaultLogArchivingEnabled; /**&lt; Zipping enabled/disabled flag. */\n    };\n\n    File(Settings settings);\n    virtual ~File();\n    virtual void write(Level level, const QString&amp; message) override;\n    virtual cf::future&lt;cf::unit&gt; stopArchivingAsync() override;\n    QString getFileName(size_t backupNumber = 0) const;\n\n    void setSettings(const Settings&amp; settings);\n\nprivate:\n    bool openFile();\n    void rotateIfNeeded(nx::Locker&lt;nx::Mutex&gt;* lock);\n    void rotateAndStartArchivingIfNeeded();\n    void rotateLeftovers();\n    bool queueToArchive(nx::Locker&lt;nx::Mutex&gt;* lock);\n    bool isCurrentLimitReached(nx::Locker&lt;nx::Mutex&gt;* lock);\n    void archive(QString fileName, QString archiveName);\n    qint64 totalVolumeSize();\n    qint64 bytesToRemoveByFreeSpaceLimit() const;\n    qint64 calculateMaxVolumeSize();\n\nprivate:\n    Settings m_settings;\n    nx::Mutex m_mutex;\n    std::fstream m_file;\n    QFileInfo m_fileInfo;\n    qint64 m_currentPos = 0;\n    QDateTime m_fileOpenTime;\n    QLockFile m_volumeLock;\n    std::future&lt;void&gt; m_archive;\n    int m_archiveQueue = 0;\n};\n\nNX_UTILS_API QString toQString(File::Extension ext);\n\n/**\n * Writes messages to internal buffer.\n */\nclass NX_UTILS_API Buffer: public AbstractWriter\n{\npublic:\n    virtual void write(Level level, const QString&amp; message) override;\n\n    std::vector&lt;QString&gt; takeMessages();\n    void clear();\n\nprivate:\n    nx::Mutex m_mutex;\n    std::vector&lt;QString&gt; m_messages;\n};\n\n/**\n * Does nothing, all messages are lost.\n */\nclass NX_UTILS_API NullDevice: public AbstractWriter\n{\npublic:\n    virtual void write(Level level, const QString&amp; message) override;\n};\n\n} // namespace nx::log\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nnamespace nx {\n\n/**\n * Move-only analogue of std::function.\n * Can be used to store lambda which has std::unique_ptr as its capture.\n */\ntemplate&lt;class F&gt;\nclass MoveOnlyFunc:\n    private std::function&lt;F&gt;\n{\n    using base_type = std::function&lt;F&gt;;\n\n    template&lt;class Func&gt;\n    class MoveOnlyFuncWrapper\n    {\n    private:\n        Func m_func;\n\n    public:\n        MoveOnlyFuncWrapper(Func p):\n            m_func(std::move(p))\n        {\n        }\n\n        MoveOnlyFuncWrapper(const MoveOnlyFuncWrapper&amp; rhs):\n            m_func(std::move(const_cast&lt;MoveOnlyFuncWrapper&amp;&gt;(rhs).m_func))\n        {\n            NX_ASSERT(false);\n        }\n\n        MoveOnlyFuncWrapper&amp; operator=(const MoveOnlyFuncWrapper&amp;)\n        {\n            NX_ASSERT(false);\n            return *this;\n        }\n\n        MoveOnlyFuncWrapper(MoveOnlyFuncWrapper&amp;&amp; rhs) noexcept(\n            std::is_nothrow_move_constructible_v&lt;Func&gt;)\n            :\n            m_func(std::move(rhs.m_func))\n        {\n        }\n\n        MoveOnlyFuncWrapper&amp; operator=(MoveOnlyFuncWrapper&amp;&amp; rhs)\n        {\n            if (&amp;rhs == this)\n                return *this;\n            m_func = std::move(rhs.m_func);\n            return *this;\n        }\n\n        template&lt;class... Args&gt;\n        auto operator() (Args&amp;&amp;... args)\n            -&gt; decltype(m_func(std::forward&lt;Args&gt;(args)...))\n        {\n            return m_func(std::forward&lt;Args&gt;(args)...);\n        }\n    };\n\npublic:\n    using result_type = typename std::function&lt;F&gt;::result_type;\n\n    MoveOnlyFunc() = default;\n\n    MoveOnlyFunc(std::function&lt;F&gt; func):\n        std::function&lt;F&gt;(std::move(func))\n    {\n    }\n\n    MoveOnlyFunc(std::nullptr_t val):\n        std::function&lt;F&gt;(val)\n    {\n    }\n\n    MoveOnlyFunc(MoveOnlyFunc&amp;&amp;) = default;\n    MoveOnlyFunc&amp; operator=(MoveOnlyFunc&amp;&amp;) = default;\n    MoveOnlyFunc(const MoveOnlyFunc&amp;) = delete;\n    MoveOnlyFunc&amp; operator=(const MoveOnlyFunc&amp;) = delete;\n\n    template&lt;class _Func&gt;\n    MoveOnlyFunc(_Func func):\n        std::function&lt;F&gt;(MoveOnlyFuncWrapper&lt;_Func&gt;(std::move(func)))\n    {\n    }\n\n    MoveOnlyFunc&amp; operator=(std::nullptr_t val)\n    {\n        std::function&lt;F&gt;::operator=(val);\n        return *this;\n    }\n\n    using base_type::operator();\n\n    bool operator==(std::nullptr_t) const\n    {\n        return static_cast&lt;const base_type&amp;&gt;(*this) == nullptr;\n    }\n\n    bool operator!=(std::nullptr_t) const\n    {\n        return !(*this == nullptr);\n    }\n\n    void swap(MoveOnlyFunc&amp; other)\n    {\n        base_type::swap(static_cast&lt;base_type&amp;&gt;(other));\n    }\n\n    using std::function&lt;F&gt;::operator bool;\n};\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid moveAndCall(Function&amp; function, Args&amp;&amp; ... args)\n{\n    const auto handler = std::move(function);\n    function = nullptr;\n    handler(std::forward&lt;Args&gt;(args) ...);\n}\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid moveAndCallOptional(Function&amp; function, Args&amp;&amp; ... args)\n{\n    if (!function)\n        return;\n\n    moveAndCall(function, std::forward&lt;Args&gt;(args) ...);\n}\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid swapAndCall(Function&amp; function, Args&amp;&amp; ... args)\n{\n    Function functionLocal;\n    function.swap(functionLocal);\n    functionLocal(std::forward&lt;Args&gt;(args) ...);\n}\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n\n#include &quot;move_only_func.h&quot;\n\nnamespace nx::utils {\n\ntemplate&lt;typename Callback&gt;\nclass ScopeGuard\n{\npublic:\n    /** Creates disarmed guard. */\n    ScopeGuard() = default;\n\n    /** Creates guard holding @param callback. */\n    ScopeGuard(Callback callback):\n        m_callback(std::move(callback))\n    {\n    }\n\n    ScopeGuard(const ScopeGuard&amp;) = delete;\n    ScopeGuard&amp; operator=(const ScopeGuard&amp;) = delete;\n\n    ScopeGuard(ScopeGuard&amp;&amp; rhs):\n        m_callback(std::exchange(rhs.m_callback, std::nullopt))\n    {\n    }\n\n    /** Fires this guard and moves @param rhs. */\n    ScopeGuard&amp; operator=(ScopeGuard&amp;&amp; rhs)\n    {\n        fire();\n        m_callback = std::exchange(rhs.m_callback, std::nullopt);\n        return *this;\n    }\n\n    /** Fires this guard. */\n    virtual ~ScopeGuard() //noexcept\n    {\n        fire();\n    }\n\n    /** Executes callback and disarms guard. */\n    void fire()\n    {\n        if (m_callback)\n        {\n            auto callback = std::exchange(m_callback, std::nullopt);\n            (*callback)();\n        }\n    }\n\n    /** Disarms guard, so callback is newer called */\n    void disarm()\n    {\n        m_callback = std::nullopt;\n    }\n\n    std::optional&lt;Callback&gt; eject()\n    {\n        std::optional&lt;Callback&gt; callback;\n        std::swap(m_callback, callback);\n        return callback;\n    }\n\n    explicit operator bool() const\n    {\n        return static_cast&lt;bool&gt;(m_callback);\n    }\n\nprivate:\n    std::optional&lt;Callback&gt; m_callback;\n};\n\ntemplate&lt;typename Callback&gt;\nScopeGuard(Callback) -&gt; ScopeGuard&lt;Callback&gt;;\n\nusing Guard = ScopeGuard&lt;nx::MoveOnlyFunc&lt;void()&gt;&gt;;\n\ntemplate&lt;class Func&gt;\nScopeGuard&lt;Func&gt; makeScopeGuard(Func func)\n{\n    return ScopeGuard&lt;Func&gt;(std::move(func));\n}\n\n//-------------------------------------------------------------------------------------------------\n\nusing SharedGuardCallback = nx::MoveOnlyFunc&lt;void()&gt;;\nusing SharedGuard = ScopeGuard&lt;SharedGuardCallback&gt;;\n\nusing SharedGuardPtr = std::shared_ptr&lt;SharedGuard&gt;;\n\n/**\n * @param func is triggered when the last copy of the returned object is destroyed.\n * WARNING: It is not safe to fire shared guard explicitly in a multi-threaded environment.\n * So, to be on safe side, never do it!\n */\ntemplate&lt;typename Func&gt;\nSharedGuardPtr makeSharedGuard(Func func)\n{\n    return std::make_shared&lt;SharedGuard&gt;(std::move(func));\n}\n\ntemplate&lt;template&lt;typename...&gt; typename Container&gt;\nSharedGuardPtr join(Container&lt;SharedGuardPtr&gt; container)\n{\n    return makeSharedGuard([container = std::move(container)]() mutable { container.clear(); });\n}\n\n} // namespace nx::utils\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n#include &lt;unordered_map&gt;\n\n#include &lt;nx/reflect/string_conversion.h&gt;\n#include &lt;nx/utils/string.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nnamespace nx::utils::stree {\n\nusing AttrName = std::string_view;\n\n/**\n * Implement this interface to allow reading attributes.\n */\nclass NX_UTILS_API AbstractAttributeReader\n{\npublic:\n    virtual ~AbstractAttributeReader() = default;\n\n    /**\n     * @return Value of attribute with the given name if found. std::nullopt otherwise.\n     */\n    virtual std::optional&lt;std::string&gt; getStr(const AttrName&amp; name) const = 0;\n\n    /**\n     * An implementation may want to override this method to add support for non-unique attributes.\n     * @return All values of attribute with the given name.\n     */\n    virtual std::vector&lt;std::string&gt; getStrAll(const AttrName&amp; name) const\n    {\n        if (auto value = getStr(name); value)\n            return {std::move(*value)};\n        return {};\n    }\n\n    virtual bool contains(const AttrName&amp; name) const\n    {\n        return getStr(name) != std::nullopt;\n    }\n\n    /**\n     * Helper function to get typed value.\n     * @return Value if attribute was found and converted to T, std::nullopt otherwise.\n     */\n    template&lt;typename T&gt;\n    std::optional&lt;T&gt; get(const AttrName&amp; name) const\n    {\n        if (auto str = getStr(name); str)\n        {\n            if constexpr (std::is_same_v&lt;T, bool&gt;)\n            {\n                return std::make_optional(nx::utils::stricmp(*str, &quot;true&quot;) == 0 || *str == &quot;1&quot;);\n            }\n            else if constexpr (std::is_same_v&lt;T, std::string&gt;)\n            {\n                return str;\n            }\n            else if constexpr (std::is_same_v&lt;T, nx::Uuid&gt;)\n            {\n                nx::Uuid val = nx::Uuid::fromStringSafe(*str);\n                if (!val.isNull())\n                    return val;\n            }\n            else if constexpr (std::is_integral_v&lt;T&gt;)\n            {\n                std::size_t parsedChars = 0;\n                const T val = nx::utils::ston&lt;T&gt;(*str, &amp;parsedChars, /*base*/ 10);\n                return parsedChars &gt; 0 ? std::make_optional(val) : std::nullopt;\n            }\n            else\n            {\n                bool ok = false;\n                auto value = nx::reflect::fromString&lt;T&gt;(str, &amp;ok);\n                return ok ? std::make_optional(std::move(value)) : std::nullopt;\n            }\n        }\n\n        return std::nullopt;\n    }\n\n    template&lt;typename T&gt;\n    T getOr(const AttrName&amp; name, T default_) const\n    {\n        auto value = get&lt;T&gt;(name);\n        return value ? *value : default_;\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Implement this interface to allow adding attributes.\n */\nclass NX_UTILS_API AbstractAttributeWriter\n{\npublic:\n    virtual ~AbstractAttributeWriter() = default;\n\n    /**\n     * If attribute with name already exists, its value is overwritten with value.\n     * Otherwise, new attribute added.\n     */\n    virtual void putStr(const AttrName&amp; name, std::string value) = 0;\n\n    template&lt;typename T&gt;\n    void put(const AttrName&amp; name, const T&amp; value)\n    {\n        putStr(name, nx::reflect::toString(value));\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Iterating over attributes.\n */\nclass NX_UTILS_API AbstractConstIterator\n{\npublic:\n    virtual ~AbstractConstIterator() = default;\n\n    /**\n     * @return false if already at the end.\n     */\n    virtual bool next() = 0;\n\n    virtual bool atEnd() const = 0;\n    virtual AttrName name() const = 0;\n    virtual const std::string&amp; value() const = 0;\n\n    template&lt;typename T&gt;\n    T value(bool* ok = nullptr) const\n    {\n        T val;\n        bool parsed = nx::reflect::fromString(value(), &amp;val);\n        if (ok)\n            *ok = parsed;\n        return val;\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Interface of an attributes dictionary that allows iterating.\n * Usage sample:\n * AbstractIteratableContainer* cont = ...;\n * for (auto it = cont-&gt;begin(); !it-&gt;atEnd(); it-&gt;next())\n * {\n *   //accessing data through iterator\n * }\n */\nclass NX_UTILS_API AbstractIteratableContainer\n{\npublic:\n    virtual ~AbstractIteratableContainer() = default;\n\n    /**\n     * @return Iterator set to the first element.\n     */\n    virtual std::unique_ptr&lt;nx::utils::stree::AbstractConstIterator&gt; begin() const = 0;\n};\n\nNX_UTILS_API void copy(const AbstractIteratableContainer&amp; from, AbstractAttributeWriter* to);\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace detail {\n\ntemplate&lt;typename AttributesMap&gt;\nclass AttributeDictionaryConstIterator:\n    public AbstractConstIterator\n{\npublic:\n    AttributeDictionaryConstIterator(const AttributesMap&amp; attrs):\n        m_attrs(attrs),\n        m_curIter(m_attrs.begin())\n    {\n    }\n\n    virtual bool next() override\n    {\n        if (m_curIter == m_attrs.end())\n            return false;\n        ++m_curIter;\n        return m_curIter != m_attrs.end();\n    }\n\n    virtual bool atEnd() const override { return m_curIter == m_attrs.end(); }\n    virtual AttrName name() const override { return m_curIter-&gt;first; }\n    virtual const std::string&amp; value() const override { return m_curIter-&gt;second; }\n\nprivate:\n    const AttributesMap&amp; m_attrs;\n    typename AttributesMap::const_iterator m_curIter;\n};\n\ntemplate&lt;typename C, typename Key, typename = void&gt;\nstruct FindDefined: public std::false_type {};\n\ntemplate&lt;typename C, typename Key&gt;\nstruct FindDefined&lt;C, Key, std::void_t&lt;decltype(C().find(Key()))&gt;&gt;:\n    public std::true_type {};\n\ntemplate&lt;typename... Args&gt; inline constexpr bool FindDefinedV = FindDefined&lt;Args...&gt;::value;\n\n} // namespace detail\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Adapter for using an STL associative container as AbstractAttributeReader.\n */\ntemplate&lt;typename AttributesMap&gt;\nclass AttributeReaderAdapter:\n    public AbstractAttributeReader\n{\npublic:\n    AttributeReaderAdapter(const AttributesMap&amp; attrs): m_attrs(&amp;attrs) {}\n    AttributeReaderAdapter(const AttributesMap* attrs): m_attrs(attrs) {}\n\n    virtual std::optional&lt;std::string&gt; getStr(const AttrName&amp; name) const override\n    {\n        typename AttributesMap::const_iterator it;\n        if constexpr (detail::FindDefinedV&lt;AttributesMap, AttrName&gt;)\n            it = m_attrs-&gt;find(name);\n        else\n            it = m_attrs-&gt;find(std::string(name));\n\n        return it != m_attrs-&gt;end() ? std::make_optional(it-&gt;second) : std::nullopt;\n    }\n\nprivate:\n    const AttributesMap* m_attrs = nullptr;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Adapts an STL associative container as an attributes container.\n */\ntemplate&lt;typename AttributesMap&gt;\nclass AttributeDictionaryAdapter:\n    public AttributeReaderAdapter&lt;AttributesMap&gt;,\n    public AbstractAttributeWriter,\n    public AbstractIteratableContainer\n{\npublic:\n    AttributeDictionaryAdapter(AttributesMap* attrs):\n        AttributeReaderAdapter&lt;AttributesMap&gt;(attrs),\n        m_attrs(attrs)\n    {\n    }\n\n    virtual void putStr(const AttrName&amp; name, std::string value) override\n    {\n        typename AttributesMap::iterator it;\n        if constexpr (detail::FindDefinedV&lt;AttributesMap, AttrName&gt;)\n            it = m_attrs-&gt;find(name);\n        else\n            it = m_attrs-&gt;find(std::string(name));\n\n        if (it == m_attrs-&gt;end())\n            (*m_attrs)[std::string(name)] = std::move(value);\n        else\n            it-&gt;second = std::move(value);\n    }\n\n    virtual std::unique_ptr&lt;nx::utils::stree::AbstractConstIterator&gt; begin() const override\n    {\n        return std::make_unique&lt;detail::AttributeDictionaryConstIterator&lt;AttributesMap&gt;&gt;(*m_attrs);\n    }\n\n    std::string toString() const\n    {\n        return nx::utils::join(\n            m_attrs-&gt;begin(), m_attrs-&gt;end(), &quot;, &quot;,\n            [](std::string* out, const auto&amp; item)\n            {\n                return buildString(out, item.first, &#x27;:&#x27;, item.second);\n            });\n    }\n\n    bool empty() const\n    {\n        return m_attrs-&gt;empty();\n    }\n\n    /**\n     * Inserts elements of other with keys missing in *this.\n     */\n    void merge(AttributeDictionaryAdapter&amp;&amp; other)\n    {\n        m_attrs-&gt;merge(std::move(*other.m_attrs));\n    }\n\n    void merge(const AttributeDictionaryAdapter&amp; other)\n    {\n        std::copy(other.m_attrs-&gt;begin(), other.m_attrs-&gt;end(), std::inserter(*m_attrs, m_attrs-&gt;end()));\n    }\n\nprivate:\n    AttributesMap* m_attrs = nullptr;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nusing StringAttrDict = std::unordered_map&lt;std::string, std::string,\n    nx::utils::StringHashTransparent, nx::utils::StringEqualToTransparent&gt;;\n\n/**\n * Attributes container. Implements reading and saving attributes.\n * Attributes are stored in a unique-key dictionary internally.\n */\nclass NX_UTILS_API AttributeDictionary:\n    public AttributeDictionaryAdapter&lt;StringAttrDict&gt;\n{\npublic:\n    using Container = StringAttrDict;\n\nprivate:\n    using base_type = AttributeDictionaryAdapter&lt;Container&gt;;\n\npublic:\n    AttributeDictionary();\n    AttributeDictionary(std::initializer_list&lt;std::pair&lt;std::string_view, std::string&gt;&gt; l);\n\n    AttributeDictionary(Container attrs):\n        base_type(&amp;m_attrs),\n        m_attrs(std::move(attrs))\n    {\n    }\n\n    template&lt;typename Iter&gt;\n    AttributeDictionary(Iter begin, Iter end):\n        base_type(&amp;m_attrs),\n        m_attrs(begin, end)\n    {\n    }\n\n    AttributeDictionary(const AttributeDictionary&amp;);\n    AttributeDictionary(AttributeDictionary&amp;&amp;);\n\n    AttributeDictionary&amp; operator=(const AttributeDictionary&amp;);\n    AttributeDictionary&amp; operator=(AttributeDictionary&amp;&amp;);\n\n    const Container&amp; data() const { return m_attrs; }\n    Container takeData() { return std::exchange(m_attrs, {}); }\n\nprivate:\n    Container m_attrs;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Reads from multiple AbstractAttributeReader instances.\n */\ntemplate&lt;std::size_t kSize&gt;\nclass MultiReader:\n    public AbstractAttributeReader\n{\npublic:\n    MultiReader(\n        std::array&lt;std::reference_wrapper&lt;const AbstractAttributeReader&gt;, kSize&gt; readers)\n        :\n        m_readers(std::move(readers))\n    {\n    }\n\n    /**\n     * Queries all readers and returns first value found.\n     */\n    virtual std::optional&lt;std::string&gt; getStr(const AttrName&amp; name) const override\n    {\n        for (const auto reader: m_readers)\n        {\n            if (auto value = reader.get().getStr(name); value)\n                return value;\n        }\n\n        return std::nullopt;\n    }\n\n    virtual std::vector&lt;std::string&gt; getStrAll(const AttrName&amp; name) const override\n    {\n        std::vector&lt;std::string&gt; values;\n        for (const auto reader: m_readers)\n        {\n            auto vals = reader.get().getStrAll(name);\n            std::move(vals.begin(), vals.end(), std::back_inserter(values));\n        }\n\n        return values;\n    }\n\nprivate:\n    std::array&lt;std::reference_wrapper&lt;const AbstractAttributeReader&gt;, kSize&gt; m_readers;\n};\n\ntemplate&lt;typename... Readers&gt;\nMultiReader&lt;sizeof...(Readers)&gt; makeMultiReader(const Readers&amp;... readers)\n{\n    return MultiReader&lt;sizeof...(Readers)&gt;({readers...});\n}\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Writes to all writers.\n */\ntemplate&lt;std::size_t kSize&gt;\nclass MultiWriter:\n    public AbstractAttributeWriter\n{\npublic:\n    MultiWriter(std::array&lt;AbstractAttributeWriter*, kSize&gt; writers):\n        m_writers(std::move(writers))\n    {\n    }\n\n    virtual void putStr(const AttrName&amp; name, std::string value) override\n    {\n        for (auto&amp; writer: m_writers)\n            writer-&gt;putStr(name, value);\n    }\n\nprivate:\n    std::array&lt;AbstractAttributeWriter*, kSize&gt; m_writers;\n};\n\ntemplate&lt;typename... Writers&gt;\nMultiWriter&lt;sizeof...(Writers)&gt; makeMultiWriter(const Writers&amp;... writers)\n{\n    return MultiWriter&lt;sizeof...(Writers)&gt;({writers...});\n}\n\n} // namespace nx::utils::stree\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/synchronized_flat_storage.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/synchronized_flat_storage.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/synchronized_flat_storage.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_PROTECTED_STORAGE_H\n#define QN_PROTECTED_STORAGE_H\n\n#include &lt;mutex&gt;\n\n#include &quot;flat_storage.h&quot;\n\n/**\n * This is a thread-safe container for heap-allocated items that takes ownership\n * of the items inside it.\n */\ntemplate&lt;class Key, class T&gt;\nclass QnSynchronizedFlatStorage {\n    typedef QnFlatStorage&lt;Key, T&gt; base_type;\npublic:\n    QnSynchronizedFlatStorage() {}\n\n    ~QnSynchronizedFlatStorage() {}\n\n    T value(const Key &amp;key) const {\n        std::unique_lock&lt;std::mutex&gt; guard(m_mutex);\n\n        return m_storage.value(key);\n    }\n\n    QSet&lt;T&gt; values() const {\n        std::unique_lock&lt;std::mutex&gt; guard(m_mutex);\n\n        return m_storage.values();\n    }\n\n    void insert(const Key &amp;key, T value, bool claimOwnership = true) {\n        std::unique_lock&lt;std::mutex&gt; guard(m_mutex);\n\n        m_storage.insert(key, value, claimOwnership);\n    }\n\n    void clear() {\n        std::unique_lock&lt;std::mutex&gt; guard(m_mutex);\n\n        m_storage.clear();\n    }\n\n    bool empty() const {\n        std::unique_lock&lt;std::mutex&gt; guard(m_mutex);\n\n        return m_storage.empty();\n    }\n\nprivate:\n    Q_DISABLE_COPY(QnSynchronizedFlatStorage);\n\nprivate:\n    /** Mutex that protects all operations. Note that we&#x27;re not using a\n     * shared/read-write mutex as it is more heavyweight than a regular mutex,\n     * and the read operations are extremely fast anyway. */\n    mutable std::mutex m_mutex;\n\n    /** Underlying storage. */\n    QnFlatStorage&lt;Key, T&gt; m_storage;\n};\n\n#endif // QN_PROTECTED_STORAGE_H\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;exception&gt;\n#include &lt;functional&gt;\n#include &lt;iterator&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;stdexcept&gt;\n#include &lt;system_error&gt;\n#include &lt;thread&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include &quot;common.h&quot;\n\n#if !defined(__clang__) &amp;&amp; defined(__GNUC__) &amp;&amp; (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &lt;= 8)\n    #include &quot;cpp14_type_traits.h&quot;\n#endif\n\nnamespace cf {\n\n// Future&lt;void&gt; and promise&lt;void&gt; are explicitly forbidden.\n// Use cf::unit instead.\nstruct unit {};\ninline bool operator == (unit, unit) { return true; }\ninline bool operator != (unit, unit) { return false; }\n\nenum class future_status {\n  ready,\n  timeout\n};\n\nenum class timeout_state {\n  not_set,\n  expired,\n  result_set\n};\n\n#define ERRC_LIST(APPLY) \\\n  APPLY(broken_promise) \\\n  APPLY(future_already_retrieved) \\\n  APPLY(promise_already_satisfied) \\\n  APPLY(no_state)\n\n#define ENUM_APPLY(value) value,\n\nenum class errc {\n  ERRC_LIST(ENUM_APPLY)\n};\n\n#define STRING_APPLY(value) case errc::value: return #value;\n\ninline std::string errc_string(errc value) {\n  switch (value) {\n    ERRC_LIST(STRING_APPLY)\n  };\n  return &quot;&quot;;\n}\n\n#undef ENUM_APPLY\n#undef STRING_APPLY\n#undef ERRC_LIST\n\nstruct future_error : public std::exception {\n  future_error(errc ecode, const std::string&amp; s)\n    : ecode_(ecode),\n      error_string_(s) {}\n\n  virtual const char* what() const noexcept override {\n    return error_string_.data();\n  }\n\n  errc ecode() const {\n    return ecode_;\n  }\n\n  errc ecode_;\n  std::string error_string_;\n};\n\ntemplate&lt;typename T&gt;\nclass future;\n\ntemplate&lt;typename T&gt;\nfuture&lt;T&gt; make_ready_future(T&amp;&amp; t);\n\nnamespace detail {\n\ntemplate&lt;typename Derived&gt;\nclass shared_state_base {\n  using cb_type = movable_func&lt;void()&gt;;\npublic:\n  ~shared_state_base() {}\n  shared_state_base()\n    : satisfied_(false),\n      executed_(false)\n  {}\n\n  void wait() const {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    cond_.wait(lock, [this] { return satisfied_ == true; });\n  }\n\n  template&lt;typename Rep, typename Period&gt;\n  future_status wait_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout) const {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    cond_.wait_for(lock, timeout, [this] { return satisfied_ == true; });\n    return satisfied_ ? future_status::ready : future_status::timeout;\n  }\n\n  template&lt;typename Clock, typename Duration&gt;\n  future_status wait_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timepoint) const {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    cond_.wait_until(lock, timepoint, [this] { return satisfied_ == true; });\n    return satisfied_ ? future_status::ready : future_status::timeout;\n  }\n\n  void set_ready(std::unique_lock&lt;std::mutex&gt;&amp; lock) {\n    satisfied_ = true;\n    cond_.notify_all();\n    if (cb_.empty()) {\n      return;\n    }\n    bool need_execute = !executed_;\n    if (!need_execute) {\n      return;\n    }\n    executed_ = true;\n    lock.unlock();\n    if (need_execute) {\n      cb_();\n    }\n  }\n\n  template&lt;typename F&gt;\n  void set_callback(F&amp;&amp; f) {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    cb_ = std::forward&lt;F&gt;(f);\n    bool need_execute = satisfied_ &amp;&amp; !executed_;\n    if (!need_execute)\n      return;\n    executed_ = true;\n    lock.unlock();\n    if (need_execute) {\n      cb_();\n    }\n  }\n\n  bool is_ready() const {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    return satisfied_;\n  }\n\n  void set_exception(std::exception_ptr p) {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    throw_if_satisfied();\n    exception_ptr_ = p;\n    set_ready(lock);\n  }\n\n  bool has_exception() const {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    return (bool)exception_ptr_;\n  }\n\n  std::exception_ptr get_exception() const {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    return exception_ptr_;\n  }\n\n  void abandon() {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    if (satisfied_)\n      return;\n    exception_ptr_ = std::make_exception_ptr(\n        future_error(errc::broken_promise,\n                     errc_string(errc::broken_promise)));\n    set_ready(lock);\n  }\n\n  std::mutex&amp; get_timeout_mutex() { return timeout_mutex_; }\n\n  timeout_state expired() const { return timeout_state_; }\n  void expired(timeout_state state) {timeout_state_ = state; }\n\nprotected:\n  void throw_if_satisfied() {\n    if (satisfied_)\n      throw future_error(errc::promise_already_satisfied,\n                         errc_string(errc::promise_already_satisfied));\n  }\n\nprotected:\n  mutable std::mutex mutex_;\n  mutable std::condition_variable cond_;\n  bool satisfied_;\n  bool executed_;\n  std::exception_ptr exception_ptr_;\n  cb_type cb_;\n  timeout_state timeout_state_ = timeout_state::not_set;\n  std::mutex timeout_mutex_;\n};\n\ntemplate&lt;typename T&gt;\nclass shared_state : public shared_state_base&lt;shared_state&lt;T&gt;&gt;,\n                     public std::enable_shared_from_this&lt;shared_state&lt;T&gt;&gt; {\n  using value_type = T;\n  using base_type = shared_state_base&lt;shared_state&lt;T&gt;&gt;;\n\npublic:\n  template&lt;typename U&gt;\n  void set_value(U&amp;&amp; value) {\n    std::unique_lock&lt;std::mutex&gt; lock(base_type::mutex_);\n    base_type::throw_if_satisfied();\n    value_ = std::forward&lt;U&gt;(value);\n    base_type::set_ready(lock);\n  }\n\n  value_type get_value() {\n    base_type::wait();\n    if (base_type::exception_ptr_)\n      std::rethrow_exception(base_type::exception_ptr_);\n    return std::move(value_);\n  }\n\nprivate:\n  value_type value_;\n};\n\ntemplate&lt;typename T&gt;\nusing shared_state_ptr = std::shared_ptr&lt;shared_state&lt;T&gt;&gt;;\n\ntemplate&lt;typename T&gt;\nvoid check_state(const shared_state_ptr&lt;T&gt;&amp; state) {\n  if (!state)\n    throw future_error(errc::no_state, errc_string(errc::no_state));\n}\n\n// various type helpers\n\n// get the return type of a continuation callable\ntemplate&lt;typename T, typename F&gt;\nusing then_arg_ret_type = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, future&lt;T&gt;&gt;;\n\ntemplate&lt;typename F, typename... Args&gt;\nusing callable_ret_type = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;;\n\ntemplate&lt;typename T&gt;\nstruct is_future {\n  const static bool value = false;\n};\n\ntemplate&lt;typename T&gt;\nstruct is_future&lt;future&lt;T&gt;&gt; {\n  const static bool value = true;\n};\n\n// future&lt;T&gt;::then(F&amp;&amp; f) return type\ntemplate&lt;typename T, typename F&gt;\nusing then_ret_type = std::conditional_t&lt;\n  is_future&lt;then_arg_ret_type&lt;T, F&gt;&gt;::value,  // if f returns future&lt;U&gt;\n  then_arg_ret_type&lt;T, F&gt;,                    // then leave type untouched\n  future&lt;then_arg_ret_type&lt;T, F&gt;&gt; &gt;;          // else lift it into the future type\n\ntemplate&lt;typename T&gt;\nstruct future_held_type;\n\ntemplate&lt;typename T&gt;\nstruct future_held_type&lt;future&lt;T&gt;&gt; {\n  using type = std::decay_t&lt;T&gt;;\n};\n\ntemplate&lt;typename R&gt;\nvoid arg_type(R(*)());\n\ntemplate&lt;typename R, typename A&gt;\nA arg_type(R(*)(A));\n\ntemplate&lt;typename R, typename C&gt;\nvoid arg_type(R(C::*)());\n\ntemplate&lt;typename R, typename C, typename A&gt;\nA arg_type(R(C::*)(A));\n\ntemplate&lt;typename R, typename C&gt;\nvoid arg_type(R(C::*)() const);\n\ntemplate&lt;typename R, typename C, typename A&gt;\nA arg_type(R(C::*)(A) const);\n\ntemplate&lt;typename F&gt;\ndecltype(arg_type(&amp;F::operator())) arg_type(F f);\n\ntemplate&lt;typename F&gt;\nusing arg_type_t = decltype(arg_type(std::declval&lt;F&gt;()));\n\ntemplate&lt;typename F&gt;\nauto make_then_unwrap_handler(F&amp;&amp; f) {\n  return [f = std::forward&lt;F&gt;(f)](auto future) mutable {\n    return std::move(f)(future.get());\n  };\n}\n\ntemplate&lt;typename T, typename U&gt;\nauto ensure_future(U&amp;&amp; u) {\n  return make_ready_future&lt;T&gt;(std::forward&lt;U&gt;(u));\n}\n\ntemplate&lt;typename T&gt;\nauto ensure_future(future&lt;T&gt; t) {\n    return t;\n}\n\ntemplate&lt;typename F&gt;\nauto make_catch_handler(F&amp;&amp; f) {\n  return [f = std::forward&lt;F&gt;(f)](auto future) mutable {\n    using T = decltype(future.get());\n    using E = arg_type_t&lt;std::decay_t&lt;F&gt;&gt;;\n    try {\n      return make_ready_future&lt;T&gt;(future.get());\n    } catch (E e) {\n      return ensure_future&lt;T&gt;(std::move(f)(std::forward&lt;E&gt;(e)));\n    }\n  };\n}\n\n} // namespace detail\n\ntemplate&lt;typename T&gt;\nclass future {\n  template&lt;typename U&gt;\n  friend class promise;\n\n  template&lt;typename U&gt;\n  friend future&lt;U&gt; make_ready_future(U&amp;&amp; u);\n\n  template&lt;typename U&gt;\n  friend future&lt;U&gt; make_exceptional_future(std::exception_ptr p);\n\npublic:\n  using value_type = T;\n\n  future() = default;\n\n  future(const future&lt;T&gt;&amp; other) = delete;\n  future&lt;T&gt;&amp; operator = (const future&lt;T&gt;&amp; other) = delete;\n\n  future(future&lt;T&gt;&amp;&amp; other)\n    : state_(std::move(other.state_)) {}\n\n  future&lt;T&gt;&amp; operator = (future&lt;T&gt;&amp;&amp; other) {\n    state_ = std::move(other.state_);\n    return *this;\n  }\n\n  bool valid() const {\n    return state_ != nullptr;\n  }\n\n  T get() {\n    check_state(state_);\n    return state_-&gt;get_value();\n  }\n\n  std::exception_ptr exception() const {\n      check_state(state_);\n      return state_-&gt;get_exception();\n  }\n\n  template&lt;typename F&gt;\n  detail::then_ret_type&lt;T, F&gt; then(F&amp;&amp; f);\n\n  template&lt;typename F&gt;\n  auto then_unwrap(F&amp;&amp; f);\n\n  template&lt;typename F&gt;\n  auto catch_(F&amp;&amp; f);\n\ntemplate&lt;typename Rep, typename Period, typename TimeWatcher, typename Exception&gt;\nfuture&lt;T&gt; timeout(std::chrono::duration&lt;Rep, Period&gt; duration,\n                  const Exception&amp; exception,\n                  TimeWatcher&amp; watcher);\n\n  template&lt;typename F, typename Executor&gt;\n  detail::then_ret_type&lt;T, F&gt; then(Executor&amp; executor, F&amp;&amp; f);\n\n  template&lt;typename F, typename Executor&gt;\n  auto then_unwrap(Executor&amp; executor, F&amp;&amp; f);\n\n  template&lt;typename F, typename Executor&gt;\n  auto catch_(Executor&amp; executor, F&amp;&amp; f);\n\n  bool is_ready() const {\n    check_state(state_);\n    return state_-&gt;is_ready();\n  }\n\n  void wait() const {\n    check_state(state_);\n    if (state_)\n      state_-&gt;wait();\n  }\n\n  template&lt;typename Rep, typename Period&gt;\n  cf::future_status wait_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout) {\n    check_state(state_);\n    return state_-&gt;wait_for(timeout);\n  }\n\n  template&lt;typename Clock, typename Duration&gt;\n  cf::future_status wait_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timepoint) {\n    check_state(state_);\n    return state_-&gt;wait_until(timepoint);\n  }\n\nprivate:\n  future(const detail::shared_state_ptr&lt;T&gt;&amp; state)\n    : state_(state) {}\n\n  template&lt;typename F&gt;\n  typename std::enable_if&lt;\n    detail::is_future&lt;\n      detail::then_arg_ret_type&lt;T, F&gt;\n    &gt;::value,\n    detail::then_ret_type&lt;T, F&gt;\n  &gt;::type\n  then_impl(F&amp;&amp; f);\n\n  template&lt;typename F&gt;\n  typename std::enable_if&lt;\n    !detail::is_future&lt;\n      detail::then_arg_ret_type&lt;T, F&gt;\n    &gt;::value,\n    detail::then_ret_type&lt;T, F&gt;\n  &gt;::type\n  then_impl(F&amp;&amp; f);\n\n  template&lt;typename F, typename Executor&gt;\n  typename std::enable_if&lt;\n    detail::is_future&lt;\n      detail::then_arg_ret_type&lt;T, F&gt;\n    &gt;::value,\n    detail::then_ret_type&lt;T, F&gt;\n  &gt;::type\n  then_impl(F&amp;&amp; f, Executor&amp; executor);\n\n  template&lt;typename F, typename Executor&gt;\n  typename std::enable_if&lt;\n    !detail::is_future&lt;\n      detail::then_arg_ret_type&lt;T, F&gt;\n    &gt;::value,\n    detail::then_ret_type&lt;T, F&gt;\n  &gt;::type\n  then_impl(F&amp;&amp; f, Executor&amp; executor);\n\n  template&lt;typename F&gt;\n  void set_callback(F&amp;&amp; f) {\n    check_state(state_);\n    state_-&gt;set_callback(std::forward&lt;F&gt;(f));\n  }\n\nprivate:\n  detail::shared_state_ptr&lt;T&gt; state_;\n};\n\ntemplate&lt;typename T&gt;\nfuture&lt;T&gt; make_exceptional_future(std::exception_ptr p);\n\n// TODO: shared_future\n// TODO: T&amp; specialization. Forbid and test.\n\ntemplate&lt;&gt;\nclass future&lt;void&gt;;\n\ntemplate&lt;typename T&gt;\nclass future&lt;T&amp;&gt;;\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F&gt;\ndetail::then_ret_type&lt;T, F&gt; future&lt;T&gt;::then(F&amp;&amp; f) {\n  check_state(state_);\n  return then_impl&lt;F&gt;(std::forward&lt;F&gt;(f));\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F&gt;\nauto future&lt;T&gt;::then_unwrap(F&amp;&amp; f) {\n  return then(detail::make_then_unwrap_handler(std::forward&lt;F&gt;(f)));\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F&gt;\nauto future&lt;T&gt;::catch_(F&amp;&amp; f) {\n  return then(detail::make_catch_handler(std::forward&lt;F&gt;(f)));\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F, typename Executor&gt;\ndetail::then_ret_type&lt;T, F&gt; future&lt;T&gt;::then(Executor&amp; executor, F&amp;&amp; f) {\n  check_state(state_);\n  return then_impl&lt;F&gt;(std::forward&lt;F&gt;(f), executor);\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F, typename Executor&gt;\nauto future&lt;T&gt;::then_unwrap(Executor&amp; executor, F&amp;&amp; f) {\n  return then(executor, detail::make_then_unwrap_handler(std::forward&lt;F&gt;(f)));\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F, typename Executor&gt;\nauto future&lt;T&gt;::catch_(Executor&amp; executor, F&amp;&amp; f) {\n  return then(executor, detail::make_catch_handler(std::forward&lt;F&gt;(f)));\n}\n\ntemplate&lt;typename T&gt;\nclass promise;\n\n// future&lt;R&gt; F(future&lt;T&gt;) specialization\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F&gt;\ntypename std::enable_if&lt;\n  detail::is_future&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::value,\n  detail::then_ret_type&lt;T, F&gt;\n&gt;::type\nfuture&lt;T&gt;::then_impl(F&amp;&amp; f) {\n  using R = typename detail::future_held_type&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::type;\n  using S = typename std::remove_reference&lt;decltype(*this-&gt;state_)&gt;::type;\n  promise&lt;R&gt; p;\n  future&lt;R&gt; ret = p.get_future();\n  set_callback([p = std::move(p), f = std::forward&lt;F&gt;(f),\n               state = std::weak_ptr&lt;S&gt;(this-&gt;state_-&gt;shared_from_this())] () mutable {\n    auto sp_state = state.lock();\n    cf::future&lt;T&gt; arg_future;\n\n    if (sp_state-&gt;has_exception()) {\n      arg_future = cf::make_exceptional_future&lt;T&gt;(sp_state-&gt;get_exception());\n    } else {\n      arg_future = cf::make_ready_future&lt;T&gt;(sp_state-&gt;get_value());\n    }\n\n    try {\n      auto inner_f = f(std::move(arg_future));\n      inner_f.then([p = std::move(p)] (cf::future&lt;R&gt; f) mutable {\n        try {\n          p.set_value(f.get());\n        } catch (...) {\n          p.set_exception(std::current_exception());\n        }\n        return cf::unit();\n      });\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n\n  });\n\n  return ret;\n}\n\n// R F(future&lt;T&gt;) specialization\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F&gt;\ntypename std::enable_if&lt;\n  !detail::is_future&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::value,\n  detail::then_ret_type&lt;T, F&gt;\n&gt;::type\nfuture&lt;T&gt;::then_impl(F&amp;&amp; f) {\n  using R = detail::then_arg_ret_type&lt;T, F&gt;;\n  using S = typename std::remove_reference&lt;decltype(*this-&gt;state_)&gt;::type;\n  promise&lt;R&gt; p;\n  future&lt;R&gt; ret = p.get_future();\n  set_callback([p = std::move(p), f = std::forward&lt;F&gt;(f),\n               state = std::weak_ptr&lt;S&gt;(this-&gt;state_-&gt;shared_from_this())] () mutable {\n    auto sp_state = state.lock();\n    cf::future&lt;T&gt; arg_future;\n\n    if (sp_state-&gt;has_exception()) {\n      arg_future = cf::make_exceptional_future&lt;T&gt;(sp_state-&gt;get_exception());\n    } else {\n      arg_future = cf::make_ready_future&lt;T&gt;(sp_state-&gt;get_value());\n    }\n\n    try {\n      auto&amp;&amp; result = f(std::move(arg_future));\n      p.set_value(std::move(result));\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n  });\n\n  return ret;\n}\n\n// future&lt;R&gt; F(future&lt;T&gt;) specialization via executor\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F, typename Executor&gt;\ntypename std::enable_if&lt;\n  detail::is_future&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::value,\n  detail::then_ret_type&lt;T, F&gt;\n&gt;::type\nfuture&lt;T&gt;::then_impl(F&amp;&amp; f, Executor&amp; executor) {\n  using R = typename detail::future_held_type&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::type;\n  using S = typename std::remove_reference&lt;decltype(*this-&gt;state_)&gt;::type;\n  promise&lt;R&gt; p;\n  future&lt;R&gt; ret = p.get_future();\n  set_callback([p = std::move(p), f = std::forward&lt;F&gt;(f),\n               state = std::weak_ptr&lt;S&gt;(this-&gt;state_-&gt;shared_from_this()), &amp;executor] () mutable {\n    auto sp_state = state.lock();\n    cf::future&lt;T&gt; arg_future;\n\n    if (sp_state-&gt;has_exception()) {\n      arg_future = cf::make_exceptional_future&lt;T&gt;(sp_state-&gt;get_exception());\n    } else {\n      arg_future = cf::make_ready_future&lt;T&gt;(sp_state-&gt;get_value());\n    }\n\n    auto promise_ptr = std::make_shared&lt;promise&lt;R&gt;&gt;(std::move(p));\n    auto arg_future_ptr = std::make_shared&lt;future&lt;T&gt;&gt;(std::move(arg_future));\n\n    executor.post([promise_ptr, arg_future_ptr, f = std::forward&lt;F&gt;(f), &amp;executor] () mutable {\n      try {\n        auto inner_f = f(std::move(*arg_future_ptr));\n        inner_f.then(executor, [promise_ptr] (cf::future&lt;R&gt; f) mutable {\n          try {\n            promise_ptr-&gt;set_value(f.get());\n          } catch (...) {\n            promise_ptr-&gt;set_exception(std::current_exception());\n          }\n          return cf::unit();\n        });\n      } catch (...) {\n        promise_ptr-&gt;set_exception(std::current_exception());\n      }\n    });\n  });\n\n  return ret;\n}\n\n// R F(future&lt;T&gt;) specialization via executor\ntemplate&lt;typename T&gt;\ntemplate&lt;typename F, typename Executor&gt;\ntypename std::enable_if&lt;\n  !detail::is_future&lt;\n    detail::then_arg_ret_type&lt;T, F&gt;\n  &gt;::value,\n  detail::then_ret_type&lt;T, F&gt;\n&gt;::type\nfuture&lt;T&gt;::then_impl(F&amp;&amp; f, Executor&amp; executor) {\n  using R = detail::then_arg_ret_type&lt;T, F&gt;;\n  using S = typename std::remove_reference&lt;decltype(*this-&gt;state_)&gt;::type;\n  promise&lt;R&gt; p;\n  future&lt;R&gt; ret = p.get_future();\n  set_callback([p = std::move(p), f = std::forward&lt;F&gt;(f),\n               state = std::weak_ptr&lt;S&gt;(this-&gt;state_-&gt;shared_from_this()), &amp;executor] () mutable {\n    auto sp_state = state.lock();\n    cf::future&lt;T&gt; arg_future;\n\n    if (sp_state-&gt;has_exception()) {\n      arg_future = cf::make_exceptional_future&lt;T&gt;(sp_state-&gt;get_exception());\n    } else {\n      arg_future = cf::make_ready_future&lt;T&gt;(sp_state-&gt;get_value());\n    }\n\n    struct local_state {\n      promise&lt;R&gt; p;\n      F f;\n      local_state(promise&lt;R&gt; p, F f)\n        : p(std::move(p)),\n          f(std::move(f)) {}\n    };\n\n    auto lstate = std::make_shared&lt;local_state&gt;(std::move(p), std::move(f));\n    auto arg_future_ptr = std::make_shared&lt;future&lt;T&gt;&gt;(std::move(arg_future));\n\n    executor.post([arg_future_ptr, lstate, sp_state] () mutable {\n      try {\n        auto&amp;&amp; result = lstate-&gt;f(std::move(*arg_future_ptr));\n        lstate-&gt;p.set_value(std::move(result));\n      } catch (...) {\n        lstate-&gt;p.set_exception(std::current_exception());\n      }\n    });\n  });\n\n  return ret;\n}\n\ntemplate&lt;typename T&gt;\ntemplate&lt;typename Rep, typename Period, typename TimeWatcher, typename Exception&gt;\nfuture&lt;T&gt; future&lt;T&gt;::timeout(std::chrono::duration&lt;Rep, Period&gt; duration,\n                             const Exception&amp; exception,\n                             TimeWatcher&amp; watcher) {\n  auto promise_ptr = std::make_shared&lt;promise&lt;T&gt;&gt;();\n  future&lt;T&gt; ret = promise_ptr-&gt;get_future();\n\n  watcher.add([promise_ptr,\n               state = this-&gt;state_-&gt;shared_from_this(),\n               exception] () mutable {\n    std::lock_guard&lt;std::mutex&gt; lock(state-&gt;get_timeout_mutex());\n    if (state-&gt;expired() == timeout_state::result_set)\n      return;\n    state-&gt;expired(timeout_state::expired);\n    promise_ptr-&gt;set_exception(std::make_exception_ptr(exception));\n  }, duration);\n\n  set_callback([promise_ptr, state = this-&gt;state_-&gt;shared_from_this()] () mutable {\n    std::lock_guard&lt;std::mutex&gt; lock(state-&gt;get_timeout_mutex());\n    if (state-&gt;expired() == timeout_state::expired)\n      return;\n    state-&gt;expired(timeout_state::result_set);\n    if (state-&gt;has_exception())\n      promise_ptr-&gt;set_exception(state-&gt;get_exception());\n    else {\n      promise_ptr-&gt;set_value(state-&gt;get_value());\n    }\n  });\n\n  return ret;\n}\n\ntemplate&lt;typename T&gt;\nclass promise {\npublic:\n  promise()\n    : state_(std::make_shared&lt;detail::shared_state&lt;T&gt;&gt;()) {}\n\n  promise(promise&amp;&amp; other)\n    : state_(std::move(other.state_)) {}\n\n  promise&amp; operator = (promise&amp;&amp; other) {\n    state_ = std::move(other.state_);\n    return *this;\n  }\n\n  ~promise() {\n    if (state_)\n      state_-&gt;abandon();\n  }\n\n  void swap(promise&amp; other) noexcept {\n    state_.swap(other.state_);\n  }\n\n  template&lt;typename U&gt;\n  void set_value(U&amp;&amp; value) {\n    check_state(state_);\n    state_-&gt;set_value(std::forward&lt;U&gt;(value));\n  }\n\n  future&lt;T&gt; get_future() {\n    check_state(state_);\n    if (state_.use_count() &gt; 1) {\n      throw future_error(errc::future_already_retrieved,\n                         errc_string(errc::future_already_retrieved));\n    }\n    return future&lt;T&gt;(state_);\n  }\n\n  void set_exception(std::exception_ptr p) {\n    check_state(state_);\n    state_-&gt;set_exception(p);\n  }\n\nprivate:\n  detail::shared_state_ptr&lt;T&gt; state_;\n};\n\ntemplate&lt;&gt;\nclass promise&lt;void&gt;;\n\ntemplate&lt;typename T&gt;\nclass promise&lt;T&amp;&gt;;\n\ntemplate&lt;typename U&gt;\nfuture&lt;U&gt; make_ready_future(U&amp;&amp; u) {\n  detail::shared_state_ptr&lt;U&gt; state =\n    std::make_shared&lt;detail::shared_state&lt;U&gt;&gt;();\n  state-&gt;set_value(std::forward&lt;U&gt;(u));\n  return future&lt;U&gt;(state);\n}\n\ntemplate&lt;typename U&gt;\nfuture&lt;U&gt; make_exceptional_future(std::exception_ptr p) {\n  detail::shared_state_ptr&lt;U&gt; state =\n    std::make_shared&lt;detail::shared_state&lt;U&gt;&gt;();\n  state-&gt;set_exception(p);\n  return future&lt;U&gt;(state);\n}\n\n#if !defined (__clang__) &amp;&amp; defined (__GNUC__) &amp;&amp; (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &lt;= 8)\ntemplate&lt;typename F&gt;\nfuture&lt;detail::callable_ret_type&lt;F&gt;&gt; async(F&amp;&amp; f) {\n  using future_inner_type = detail::callable_ret_type&lt;F&gt;;\n\n  promise&lt;future_inner_type&gt; p;\n  auto result = p.get_future();\n\n  std::thread([p = std::move(p), f = std::forward&lt;F&gt;(f)] () mutable {\n    try {\n      p.set_value(std::forward&lt;F&gt;(f)());\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n  }).detach();\n\n  return result;\n}\n\ntemplate&lt;typename F, typename Arg1&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Arg1&gt;&gt; async(F&amp;&amp; f, Arg1&amp;&amp; arg1) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Arg1&gt;;\n\n  promise&lt;future_inner_type&gt; p;\n  auto result = p.get_future();\n\n  std::thread([p = std::move(p), f = std::forward&lt;F&gt;(f), arg1] () mutable {\n    try {\n      p.set_value(std::forward&lt;F&gt;(f)(arg1));\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n  }).detach();\n\n  return result;\n}\n\ntemplate&lt;typename F, typename Arg1, typename Arg2&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Arg1, Arg2&gt;&gt; async(F&amp;&amp; f, Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Arg1, Arg2&gt;;\n\n  promise&lt;future_inner_type&gt; p;\n  auto result = p.get_future();\n\n  std::thread([p = std::move(p), f = std::forward&lt;F&gt;(f), arg1, arg2] () mutable {\n    try {\n      p.set_value(std::forward&lt;F&gt;(f)(arg1, arg2));\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n  }).detach();\n\n  return result;\n}\n\ntemplate&lt;typename Executor, typename F&gt;\nfuture&lt;detail::callable_ret_type&lt;F&gt;&gt; async(Executor&amp; executor, F&amp;&amp; f) {\n  using future_inner_type = detail::callable_ret_type&lt;F&gt;;\n\n  auto promise_ptr = std::make_shared&lt;promise&lt;future_inner_type&gt;&gt;();\n  auto result = promise_ptr-&gt;get_future();\n  executor.post([promise_ptr, f = std::forward&lt;F&gt;(f)] () mutable {\n    try {\n      promise_ptr-&gt;set_value(std::forward&lt;F&gt;(f)());\n    } catch (...) {\n      promise_ptr-&gt;set_exception(std::current_exception());\n    }\n  });\n\n  return result;\n}\n\ntemplate&lt;typename Executor, typename F, typename Arg1&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Arg1&gt;&gt; async(Executor&amp; executor, F&amp;&amp; f, Arg1&amp;&amp; arg1) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Arg1&gt;;\n\n  auto promise_ptr = std::make_shared&lt;promise&lt;future_inner_type&gt;&gt;();\n  auto result = promise_ptr-&gt;get_future();\n  executor.post([promise_ptr, f = std::forward&lt;F&gt;(f), arg1] () mutable {\n    try {\n      promise_ptr-&gt;set_value(std::forward&lt;F&gt;(f)(arg1));\n    } catch (...) {\n      promise_ptr-&gt;set_exception(std::current_exception());\n    }\n  });\n\n  return result;\n}\n\ntemplate&lt;typename Executor, typename F, typename Arg1, typename Arg2&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Arg1, Arg2&gt;&gt;\nasync(Executor&amp; executor, F&amp;&amp; f, Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Arg1, Arg2&gt;;\n\n  auto promise_ptr = std::make_shared&lt;promise&lt;future_inner_type&gt;&gt;();\n  auto result = promise_ptr-&gt;get_future();\n  executor.post([promise_ptr, f = std::forward&lt;F&gt;(f), arg1, arg2] () mutable {\n    try {\n      promise_ptr-&gt;set_value(std::forward&lt;F&gt;(f)(arg1, arg2));\n    } catch (...) {\n      promise_ptr-&gt;set_exception(std::current_exception());\n    }\n  });\n\n  return result;\n}\n#endif\n\n#if defined (__clang__) || defined(_MSC_VER) || \\\n    (defined (__GNUC__) &amp;&amp; ((__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 9) || __GNUC__ &gt;= 5))\n\ntemplate&lt;typename F, typename... Args&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Args...&gt;&gt; async(F&amp;&amp; f, Args&amp;&amp;... args) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Args...&gt;;\n\n  promise&lt;future_inner_type&gt; p;\n  auto result = p.get_future();\n\n  std::thread([p = std::move(p), f = std::forward&lt;F&gt;(f), args...] () mutable {\n    try {\n      p.set_value(std::forward&lt;F&gt;(f)(args...));\n    } catch (...) {\n      p.set_exception(std::current_exception());\n    }\n  }).detach();\n\n  return result;\n}\n\ntemplate&lt;typename Executor, typename F, typename... Args&gt;\nfuture&lt;detail::callable_ret_type&lt;F, Args...&gt;&gt; async(Executor&amp; executor, F&amp;&amp; f, Args&amp;&amp;... args) {\n  using future_inner_type = detail::callable_ret_type&lt;F, Args...&gt;;\n\n  auto promise_ptr = std::make_shared&lt;promise&lt;future_inner_type&gt;&gt;();\n  auto result = promise_ptr-&gt;get_future();\n  executor.post([promise_ptr, f = std::forward&lt;F&gt;(f), args...] () mutable {\n    try {\n      promise_ptr-&gt;set_value(std::forward&lt;F&gt;(f)(args...));\n    } catch (...) {\n      promise_ptr-&gt;set_exception(std::current_exception());\n    }\n  });\n\n  return result;\n}\n#endif\n\ntemplate&lt;typename InputIt&gt;\nauto when_all(InputIt first, InputIt last)\n-&gt; future&lt;std::vector&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;&gt; {\n  using argument_element_type = typename std::iterator_traits&lt;InputIt&gt;::value_type;\n  using future_vector_type = std::vector&lt;argument_element_type&gt;;\n\n  struct context {\n    size_t total_futures = 0;\n    size_t ready_futures = 0;\n    future_vector_type future_vector;\n    future_vector_type result;\n    std::mutex mutex;\n    promise&lt;future_vector_type&gt; p;\n  };\n\n  auto shared_context = std::make_shared&lt;context&gt;();\n  auto result_future = shared_context-&gt;p.get_future();\n  shared_context-&gt;total_futures = std::distance(first, last);\n  shared_context-&gt;result.resize(shared_context-&gt;total_futures);\n  size_t index = 0;\n\n  if (shared_context-&gt;total_futures == 0)\n    return cf::make_ready_future(future_vector_type());\n\n  for (; first != last; ++first, ++index) {\n    shared_context-&gt;future_vector.emplace_back(std::move(*first));\n    shared_context-&gt;future_vector[index].then(\n      [shared_context, index](argument_element_type f) mutable {\n        std::lock_guard&lt;std::mutex&gt; lock(shared_context-&gt;mutex);\n        shared_context-&gt;result[index] = std::move(f);\n        ++shared_context-&gt;ready_futures;\n        if (shared_context-&gt;ready_futures == shared_context-&gt;total_futures)\n          shared_context-&gt;p.set_value(std::move(shared_context-&gt;result));\n        return unit();\n      });\n  }\n\n  return result_future;\n}\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; flat_collect(std::vector&lt;cf::future&lt;T&gt;&gt; vec) {\n  std::vector&lt;T&gt; result;\n  result.reserve(vec.size());\n  for (auto&amp; f: vec)\n    result.push_back(f.get());\n  return result;\n}\n\nnamespace detail {\ntemplate&lt;size_t I, typename Context, typename Future&gt;\nvoid when_inner_helper(Context context, Future&amp;&amp; f) {\n  std::get&lt;I&gt;(context-&gt;result) = std::move(f);\n  std::get&lt;I&gt;(context-&gt;result).then(\n      [context](typename std::remove_reference&lt;Future&gt;::type f) {\n    std::lock_guard&lt;std::mutex&gt; lock(context-&gt;mutex);\n    ++context-&gt;ready_futures;\n    std::get&lt;I&gt;(context-&gt;result) = std::move(f);\n    if (context-&gt;ready_futures == context-&gt;total_futures)\n      context-&gt;p.set_value(std::move(context-&gt;result));\n    return unit();\n  });\n}\n\ntemplate&lt;size_t I, typename Context&gt;\nvoid apply_helper(const Context&amp;) {}\n\ntemplate&lt;size_t I, typename Context, typename FirstFuture, typename... Futures&gt;\nvoid apply_helper(const Context&amp; context, FirstFuture&amp;&amp; f, Futures&amp;&amp;... fs) {\n  detail::when_inner_helper&lt;I&gt;(context, std::forward&lt;FirstFuture&gt;(f));\n  apply_helper&lt;I+1&gt;(context, std::forward&lt;Futures&gt;(fs)...);\n}\n\n} // namespace detail\n\ntemplate&lt;typename... Futures&gt;\nauto when_all(Futures&amp;&amp;... futures)\n-&gt; future&lt;std::tuple&lt;std::decay_t&lt;Futures&gt;...&gt;&gt; {\n  using result_inner_type = std::tuple&lt;std::decay_t&lt;Futures&gt;...&gt;;\n  struct context {\n    size_t total_futures;\n    size_t ready_futures = 0;\n    result_inner_type result;\n    promise&lt;result_inner_type&gt; p;\n    std::mutex mutex;\n  };\n  auto shared_context = std::make_shared&lt;context&gt;();\n  shared_context-&gt;total_futures = sizeof...(futures);\n  detail::apply_helper&lt;0&gt;(shared_context, std::forward&lt;Futures&gt;(futures)...);\n  return shared_context-&gt;p.get_future();\n}\n\ntemplate&lt;typename Sequence&gt;\nstruct when_any_result {\n  size_t index;\n  Sequence sequence;\n};\n\ntemplate&lt;typename InputIt&gt;\nauto when_any(InputIt first, InputIt last)\n-&gt;future&lt;\n    when_any_result&lt;\n      std::vector&lt;\n        typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;&gt;&gt; {\n  using result_inner_type =\n    std::vector&lt;typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;;\n  using future_inner_type = when_any_result&lt;result_inner_type&gt;;\n\n  struct context {\n    size_t total = 0;\n    std::atomic&lt;size_t&gt; processed;\n    future_inner_type result;\n    promise&lt;future_inner_type&gt; p;\n    bool ready = false;\n    bool result_moved = false;\n    std::mutex mutex;\n  };\n\n  auto shared_context = std::make_shared&lt;context&gt;();\n  auto result_future = shared_context-&gt;p.get_future();\n  shared_context-&gt;processed = 0;\n  shared_context-&gt;total = std::distance(first, last);\n  shared_context-&gt;result.sequence.reserve(shared_context-&gt;total);\n  size_t index = 0;\n\n  auto first_copy = first;\n  for (; first_copy != last; ++first_copy) {\n    shared_context-&gt;result.sequence.push_back(std::move(*first_copy));\n  }\n\n  for (; first != last; ++first, ++index) {\n    shared_context-&gt;result.sequence[index].then(\n    [shared_context, index]\n    (typename std::iterator_traits&lt;InputIt&gt;::value_type f) mutable {\n      {\n        std::lock_guard&lt;std::mutex&gt; lock(shared_context-&gt;mutex);\n        if (!shared_context-&gt;ready) {\n          shared_context-&gt;result.index = index;\n          shared_context-&gt;ready = true;\n          shared_context-&gt;result.sequence[index] = std::move(f);\n          if (shared_context-&gt;processed == shared_context-&gt;total &amp;&amp;\n              !shared_context-&gt;result_moved) {\n            shared_context-&gt;p.set_value(std::move(shared_context-&gt;result));\n            shared_context-&gt;result_moved = true;\n          }\n        }\n      }\n      return unit();\n    });\n    ++shared_context-&gt;processed;\n  }\n\n  {\n    std::lock_guard&lt;std::mutex&gt; lock(shared_context-&gt;mutex);\n    if (shared_context-&gt;ready &amp;&amp; !shared_context-&gt;result_moved) {\n      shared_context-&gt;p.set_value(std::move(shared_context-&gt;result));\n      shared_context-&gt;result_moved = true;\n    }\n  }\n\n  return result_future;\n}\n\nnamespace detail {\ntemplate&lt;size_t I, typename Context&gt;\nvoid when_any_inner_helper(Context context) {\n  using ith_future_type =\n    std::decay_t&lt;decltype(std::get&lt;I&gt;(context-&gt;result.sequence))&gt;;\n  std::get&lt;I&gt;(context-&gt;result.sequence).then(\n  [context](ith_future_type f) {\n    std::lock_guard&lt;std::mutex&gt; lock(context-&gt;mutex);\n    if (!context-&gt;ready) {\n      context-&gt;ready = true;\n      context-&gt;result.index = I;\n      std::get&lt;I&gt;(context-&gt;result.sequence) = std::move(f);\n      if (context-&gt;processed == context-&gt;total &amp;&amp;\n          !context-&gt;result_moved) {\n        context-&gt;p.set_value(std::move(context-&gt;result));\n        context-&gt;result_moved = true;\n      }\n    }\n    return unit();\n  });\n}\n\ntemplate&lt;size_t I, size_t S&gt;\nstruct when_any_helper_struct {\n  template&lt;typename Context, typename... Futures&gt;\n  static void apply(const Context&amp; context, std::tuple&lt;Futures...&gt;&amp; t) {\n    when_any_inner_helper&lt;I&gt;(context);\n    ++context-&gt;processed;\n    when_any_helper_struct&lt;I+1, S&gt;::apply(context, t);\n  }\n};\n\ntemplate&lt;size_t S&gt;\nstruct when_any_helper_struct&lt;S, S&gt; {\n  template&lt;typename Context, typename... Futures&gt;\n  static void apply(const Context&amp;, std::tuple&lt;Futures...&gt;&amp;) {}\n};\n\ntemplate&lt;size_t I, typename Context&gt;\nvoid fill_result_helper(const Context&amp;) {}\n\ntemplate&lt;size_t I, typename Context, typename FirstFuture, typename... Futures&gt;\nvoid fill_result_helper(const Context&amp; context, FirstFuture&amp;&amp; f, Futures&amp;&amp;... fs) {\n  std::get&lt;I&gt;(context-&gt;result.sequence) = std::move(f);\n  fill_result_helper&lt;I+1&gt;(context, std::forward&lt;Futures&gt;(fs)...);\n}\n\ntemplate&lt;typename F&gt;\nauto make_initiate_handler(F&amp;&amp; f) {\n  return [f = std::forward&lt;F&gt;(f)](auto future) mutable {\n    future.get();\n    return std::move(f)();\n  };\n}\n\n}\n\ntemplate&lt;typename... Futures&gt;\nauto when_any(Futures&amp;&amp;... futures)\n-&gt; future&lt;when_any_result&lt;std::tuple&lt;std::decay_t&lt;Futures&gt;...&gt;&gt;&gt; {\n  using result_inner_type = std::tuple&lt;std::decay_t&lt;Futures&gt;...&gt;;\n  using future_inner_type = when_any_result&lt;result_inner_type&gt;;\n\n  struct context {\n    bool ready = false;\n    bool result_moved = false;\n    size_t total = 0;\n    std::atomic&lt;size_t&gt; processed;\n    future_inner_type result;\n    promise&lt;future_inner_type&gt; p;\n    std::mutex mutex;\n  };\n\n  auto shared_context = std::make_shared&lt;context&gt;();\n  shared_context-&gt;processed = 0;\n  shared_context-&gt;total = sizeof...(futures);\n\n  detail::fill_result_helper&lt;0&gt;(shared_context, std::forward&lt;Futures&gt;(futures)...);\n  detail::when_any_helper_struct&lt;0, sizeof...(futures)&gt;::apply(\n      shared_context, shared_context-&gt;result.sequence);\n  {\n    std::lock_guard&lt;std::mutex&gt; lock(shared_context-&gt;mutex);\n    if (shared_context-&gt;ready &amp;&amp; !shared_context-&gt;result_moved) {\n      shared_context-&gt;p.set_value(std::move(shared_context-&gt;result));\n      shared_context-&gt;result_moved = true;\n    }\n  }\n  return shared_context-&gt;p.get_future();\n}\n\ntemplate&lt;typename F&gt;\nauto initiate(F&amp;&amp; f) {\n  return cf::make_ready_future(cf::unit()).then(\n    detail::make_initiate_handler(std::forward&lt;F&gt;(f)));\n}\n\ntemplate&lt;typename F, typename Executor&gt;\nauto initiate(Executor&amp; executor, F&amp;&amp; f) {\n  return cf::make_ready_future(cf::unit()).then(executor,\n    detail::make_initiate_handler(std::forward&lt;F&gt;(f)));\n}\n\nconstexpr auto translate_broken_promise_to_operation_canceled = [](auto f) {\n  try {\n    return f.get();\n  } catch (const future_error&amp; e) {\n    if (e.ecode() != errc::broken_promise)\n      throw;\n    throw std::system_error(\n      (int) std::errc::operation_canceled, std::generic_category());\n  }\n};\n\nconstexpr auto discard_value = [](auto f) {\n  f.get();\n  return cf::unit();\n};\n\n} // namespace cf\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n\nnamespace cf {\nnamespace detail {\n\n// We can&#x27;t use std::function as continuation holder, as it\n// requires held type to be copyable. So here is simple move-only\n// callable wrapper.\ntemplate&lt;typename F&gt;\nclass movable_func;\n\ntemplate&lt;typename R, typename... Args&gt;\nclass movable_func&lt;R(Args...)&gt; {\n\n  struct base_holder {\n    virtual R operator() (Args... args) = 0;\n    virtual ~base_holder() {}\n  };\n\n  template&lt;typename F&gt;\n  struct holder : base_holder {\n    holder(F f) : f_(std::move(f)) {}\n    virtual R operator() (Args... args) override {\n      return f_(args...);\n    }\n\n    F f_;\n  };\n\npublic:\n  template&lt;typename F&gt;\n  movable_func(F f) : held_(new holder&lt;F&gt;(std::move(f))) {}\n  movable_func(std::nullptr_t): held_(nullptr) {}\n  movable_func() : held_(nullptr) {}\n  movable_func(movable_func&lt;R(Args...)&gt;&amp;&amp;) = default;\n  movable_func&amp; operator = (movable_func&lt;R(Args...)&gt;&amp;&amp;) = default;\n  movable_func(const movable_func&lt;R(Args...)&gt;&amp;) = delete;\n  movable_func&amp; operator = (const movable_func&lt;R(Args...)&gt;&amp;) = delete;\n  bool empty() const { return !held_; }\n\n  explicit operator bool() const { return !empty(); }\n\n  R operator() (Args... args) const {\n    return held_-&gt;operator()(args...);\n  }\n\nprivate:\n  std::unique_ptr&lt;base_holder&gt; held_;\n};\n\nusing task_type = movable_func&lt;void()&gt;;\n}\n}\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n\n#include &quot;mutex_locker.h&quot;\n\nnamespace nx {\n\nclass NX_UTILS_API MutexDelegate\n{\npublic:\n\n    virtual ~MutexDelegate() = default;\n\n    virtual void lock(const char* sourceFile, int sourceLine, int lockId) = 0;\n    virtual bool tryLock(const char* sourceFile, int sourceLine, int lockId) = 0;\n\n    virtual void unlock() = 0;\n    virtual bool isRecursive() const = 0;\n};\n\nclass NX_UTILS_API Mutex\n{\npublic:\n    enum RecursionMode { Recursive, NonRecursive };\n    Mutex(RecursionMode mode = NonRecursive);\n\n    void lock(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n    bool tryLock(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n    bool try_lock() { return tryLock(); }\n\n    void unlock();\n    bool isRecursive() const;\n\nprivate:\n    friend class WaitCondition;\n    std::unique_ptr&lt;MutexDelegate&gt; m_delegate;\n};\n\nclass NX_UTILS_API MutexLocker: public Locker&lt;Mutex&gt;\n{\npublic:\n    MutexLocker(Mutex* mutex, const char* sourceFile, int sourceLine);\n};\n\n#define NX_MUTEX_LOCKER \\\n    struct NX_CONCATENATE(NxUtilsMutexLocker, __LINE__): public ::nx::MutexLocker \\\n    { \\\n        explicit NX_CONCATENATE(NxUtilsMutexLocker, __LINE__)(::nx::Mutex* mutex): \\\n            ::nx::MutexLocker(mutex, __FILE__, __LINE__) {}  \\\n    }\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_UTILS_API ReadWriteLockDelegate\n{\npublic:\n    virtual ~ReadWriteLockDelegate() = default;\n\n    virtual void lockForRead(const char* sourceFile, int sourceLine, int lockId) = 0;\n    virtual void lockForWrite(const char* sourceFile, int sourceLine, int lockId) = 0;\n\n    virtual bool tryLockForRead(const char* sourceFile, int sourceLine, int lockId) = 0;\n    virtual bool tryLockForWrite(const char* sourceFile, int sourceLine, int lockId) = 0;\n\n    virtual void unlock() = 0;\n};\n\nclass NX_UTILS_API ReadWriteLock\n{\npublic:\n    enum RecursionMode { Recursive, NonRecursive };\n    ReadWriteLock(RecursionMode mode = NonRecursive);\n\n    void lockForRead(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n    void lockForWrite(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n\n    bool tryLockForRead(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n    bool tryLockForWrite(const char* sourceFile = 0, int sourceLine = 0, int lockId = 0);\n\n    void unlock();\n\nprivate:\n    friend class WaitCondition;\n    std::unique_ptr&lt;ReadWriteLockDelegate&gt; m_delegate;\n};\n\nclass NX_UTILS_API ReadLocker: public Locker&lt;ReadWriteLock&gt;\n{\npublic:\n    ReadLocker(ReadWriteLock* mutex, const char* sourceFile, int sourceLine);\n};\n\n#define NX_READ_LOCKER \\\n    struct NX_CONCATENATE(NxUtilsReadLocker, __LINE__): public ::nx::ReadLocker \\\n    { \\\n        NX_CONCATENATE(NxUtilsReadLocker, __LINE__)(::nx::ReadWriteLock* mutex): \\\n            ::nx::ReadLocker(mutex, __FILE__, __LINE__) {} \\\n    }\n\nclass NX_UTILS_API WriteLocker: public Locker&lt;ReadWriteLock&gt;\n{\npublic:\n    WriteLocker(ReadWriteLock* mutex, const char* sourceFile, int sourceLine);\n};\n\n#define NX_WRITE_LOCKER \\\n    struct NX_CONCATENATE(NxUtilsWriteLocker, __LINE__): public ::nx::WriteLocker \\\n    { \\\n        NX_CONCATENATE(NxUtilsWriteLocker, __LINE__)(::nx::ReadWriteLock* mutex): \\\n            ::nx::WriteLocker(mutex, __FILE__, __LINE__) {} \\\n    }\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_UTILS_API WaitConditionDelegate\n{\npublic:\n    virtual ~WaitConditionDelegate() = default;\n\n    virtual bool wait(MutexDelegate* mutex, std::chrono::milliseconds timeout) = 0;\n    virtual void wakeAll() = 0;\n    virtual void wakeOne() = 0;\n};\n\nclass NX_UTILS_API WaitCondition\n{\npublic:\n    WaitCondition();\n\n    bool wait(Mutex* mutex, std::chrono::milliseconds timeout = std::chrono::milliseconds::max());\n    bool wait(Mutex* mutex, unsigned long timeout); //&lt; TODO: Remove with usages.\n\n    /**\n     * Waits until pred() returns true or timeout passes.\n     * @return true if pred() returned true. false if timeout has passed.\n     */\n    template&lt;typename Pred&gt;\n    bool waitFor(\n        Mutex* mutex,\n        std::chrono::milliseconds timeout,\n        Pred pred)\n    {\n        using namespace std::chrono;\n\n        if (timeout == std::chrono::milliseconds::max())\n        {\n            while (!pred())\n                wait(mutex, timeout);\n        }\n        else\n        {\n            const auto deadline = steady_clock::now() + timeout;\n            while (!pred())\n            {\n                timeout = duration_cast&lt;milliseconds&gt;(deadline - steady_clock::now());\n                if (timeout &lt;= milliseconds::zero())\n                    return false;\n\n                wait(mutex, timeout);\n            }\n        }\n\n        return true;\n    }\n\n    void wakeAll();\n    void wakeOne();\n\nprivate:\n    std::unique_ptr&lt;WaitConditionDelegate&gt; m_delegate;\n};\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nnamespace nx {\n\ntemplate&lt;typename Mutex&gt;\nclass NX_UTILS_API Locker\n{\npublic:\n    typedef void(Mutex::*LockMethod)(\n        const char* /*sourceFile*/, int /*sourceLine*/, int /*lockId*/);\n\n    Locker(Mutex* const mutex, LockMethod lockMethod, const char* sourceFile, int sourceLine):\n        m_mutex(mutex),\n        m_lockMethod(lockMethod),\n        m_sourceFile(sourceFile),\n        m_sourceLine(sourceLine)\n    {\n        (m_mutex-&gt;*m_lockMethod)(m_sourceFile, m_sourceLine, m_relockCount);\n    }\n\n    ~Locker()\n    {\n        if (m_isLocked)\n            m_mutex-&gt;unlock();\n    }\n\n    Locker(Locker&amp;&amp; rhs) noexcept:\n        m_mutex(rhs.m_mutex),\n        m_lockMethod(rhs.m_lockMethod),\n        m_sourceFile(rhs.m_sourceFile),\n        m_sourceLine(rhs.m_sourceLine),\n        m_relockCount(rhs.m_relockCount),\n        m_isLocked(rhs.m_isLocked)\n    {\n        rhs.m_isLocked = false;\n    }\n\n    Locker&amp; operator=(Locker&amp;&amp; rhs) noexcept\n    {\n        if (m_isLocked)\n            unlock();\n\n        std::swap(m_mutex, rhs.m_mutex);\n        std::swap(m_lockMethod, rhs.m_lockMethod),\n        std::swap(m_sourceFile, rhs.m_sourceFile);\n        std::swap(m_sourceLine, rhs.m_sourceLine);\n        std::swap(m_relockCount, rhs.m_relockCount);\n        std::swap(m_isLocked, rhs.m_isLocked);\n        return *this;\n    }\n\n    Mutex* mutex() const\n    {\n        return m_mutex;\n    }\n\n    void relock()\n    {\n        NX_ASSERT(!m_isLocked);\n        (m_mutex-&gt;*m_lockMethod)(m_sourceFile, m_sourceLine, ++m_relockCount);\n        m_isLocked = true;\n    }\n\n    void unlock()\n    {\n        m_mutex-&gt;unlock();\n        m_isLocked = false;\n    }\n\n    bool isLocked() const\n    {\n        return m_isLocked;\n    }\n\nprivate:\n    Mutex* m_mutex;\n    LockMethod m_lockMethod;\n    const char* m_sourceFile;\n    int m_sourceLine;\n    int m_relockCount = 0;\n    bool m_isLocked = true;\n};\n\ntemplate&lt;typename Mutex&gt;\nclass NX_UTILS_API Unlocker\n{\npublic:\n    Unlocker(Locker&lt;Mutex&gt;* locker):\n        m_locker(locker)\n    {\n        m_locker-&gt;unlock();\n    }\n\n    ~Unlocker()\n    {\n        m_locker-&gt;relock();\n    }\n\n    Unlocker(Unlocker&amp;&amp; rhs) = delete;\n    Unlocker&amp; operator=(Unlocker&amp;&amp; rhs) = delete;\n\nprivate:\n    Locker&lt;Mutex&gt;* m_locker;\n};\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;ctime&gt;\n#include &lt;optional&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;QtCore/QDateTime&gt;\n#include &lt;QtCore/QString&gt;\n#include &lt;QtCore/QStringList&gt;\n\n#include &quot;string.h&quot;\n\nnamespace nx {\nnamespace utils {\n\n/**\n * @return By default, std::chrono::system_clock::now() is returned.\n */\nNX_UTILS_API std::chrono::system_clock::time_point utcTime();\n\n/** Should be used instead of ::time(). */\nNX_UTILS_API std::chrono::seconds timeSinceEpoch();\n\n/**\n * @return UTC time (time since epoch) in milliseconds.\n */\nNX_UTILS_API std::chrono::milliseconds millisSinceEpoch();\n\n/**\n * @return By default, std::chrono::steady_clock::now () is returned.\n */\nNX_UTILS_API std::chrono::steady_clock::time_point monotonicTime();\n\n/**\n * @return Returns the number of milliseconds that have elapsed since the system was started.\n * The timer continues to run even if the system is suspended. This is not a high resolution timer:\n * on Windows, it has a resolution of 10-16 ms.\n */\nNX_UTILS_API std::chrono::milliseconds systemUptime();\n\n/**\n * @return system time and apply test timeShift value on it. It is used in UT only.\n */\nNX_UTILS_API std::chrono::system_clock::time_point systemClockTime();\n\n/**\n * On Linux, set system time zone. On other platforms, do nothing, return true.\n * @param timeZoneId IANA id of a time zone.\n * @return False on error, unsupported timeZoneId or unsupported platform, true on success.\n */\nNX_UTILS_API bool setTimeZone(const QString&amp; timeZoneId);\n\n/**\n * @return List of ids of time zones which are supported by setTimeZone().\n */\nNX_UTILS_API QStringList getSupportedTimeZoneIds();\n\n/**\n * Get the current time zone id. ATTENTION: This id is NOT guaranteed to be in the result of\n * getSupportedTimeZoneIds(). Also it is not guaranteed to be exactly the one actually set by the\n * previous call to setTimeZone() or by other means, though is guaranteed to have the same\n * UTC offset as the latter.\n */\nNX_UTILS_API QString getCurrentTimeZoneId();\n\n/**\n * On Linux, set system date and time. On other platforms, do nothing, return true.\n * @return false on error or unsupported platform, true on success.\n */\nNX_UTILS_API bool setDateTime(qint64 millisecondsSinceEpoch);\n\n/**\n * @return QDateTime object corresponding to the given offset from Unix epoch.\n */\nNX_UTILS_API QDateTime fromOffsetSinceEpoch(const std::chrono::nanoseconds&amp; offset);\n\n/**\n * Parses the string of the following format:\n * 1 * DIGIT [ SUFFIX ]\n * SUFFIX = ( &quot;h&quot; | &quot;m&quot; | &quot;s&quot; | &quot;ms&quot; | &quot;us&quot; | &quot;ns&quot; )\n * If suffix was not specified then seconds are assumed.\n *\n * @return parsed time duration, std::nullopt in case of malformed string.\n * NOTE: microseconds and nanoseconds are truncated to milliseconds.\n */\nNX_UTILS_API std::optional&lt;std::chrono::milliseconds&gt; parseDuration(const std::string_view&amp; str);\n\n/**\n * Invokes parseDuration(str) and returns its result or defaultValue.\n */\nNX_UTILS_API std::chrono::milliseconds parseDurationOr(\n    const std::string_view&amp; str,\n    std::chrono::milliseconds defaultValue);\n\nnamespace detail {\n\ntemplate&lt;typename D&gt;\nstruct DurationTraits {};\n\ntemplate&lt;typename D&gt;\nstruct DurationTraitsHelper\n{\n    using HigherOrderDurationType = D;\n};\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::nanoseconds&gt;:\n    public DurationTraitsHelper&lt;std::chrono::microseconds&gt; { static constexpr char kSuffix[] = &quot;ns&quot;; };\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::microseconds&gt;:\n    public DurationTraitsHelper&lt;std::chrono::milliseconds&gt; { static constexpr char kSuffix[] = &quot;us&quot;; };\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::milliseconds&gt;:\n    public DurationTraitsHelper&lt;std::chrono::seconds&gt; { static constexpr char kSuffix[] = &quot;ms&quot;; };\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::seconds&gt;:\n    public DurationTraitsHelper&lt;std::chrono::minutes&gt; { static constexpr char kSuffix[] = &quot;s&quot;; };\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::minutes&gt;:\n    public DurationTraitsHelper&lt;std::chrono::hours&gt; { static constexpr char kSuffix[] = &quot;m&quot;; };\n\ntemplate&lt;&gt; struct DurationTraits&lt;std::chrono::hours&gt;:\n    public DurationTraitsHelper&lt;void&gt; { static constexpr char kSuffix[] = &quot;h&quot;; };\n\n} // namespace detail\n\n/**\n * Converts duration to string suffixing it with a corresponding\n * suffix: ns (nanoseconds), us (microseconds), ms (milliseconds), s, m, h.\n * E.g., `std::chrono::milliseconds(60&#x27;000)` is represented with a string `1m`.\n * The resulting string can be passed to parseDuration.\n */\ntemplate&lt;typename Rep, typename Period&gt;\nstd::string durationToString(const std::chrono::duration&lt;Rep, Period&gt;&amp; d)\n{\n    using Traits = detail::DurationTraits&lt;std::decay_t&lt;decltype(d)&gt;&gt;;\n\n    if constexpr (std::is_void_v&lt;typename Traits::HigherOrderDurationType&gt;)\n    {\n        return nx::utils::buildString(d.count(), Traits::kSuffix);\n    }\n    else\n    {\n        const auto higherOrderDuration =\n            std::chrono::duration_cast&lt;typename Traits::HigherOrderDurationType&gt;(d);\n        if (higherOrderDuration == d)\n            return durationToString(higherOrderDuration);\n\n        return nx::utils::buildString(d.count(), Traits::kSuffix);\n    }\n}\n\n/**\n * Rounds timePoint down to DurationTypeToRoundTo type.\n */\ntemplate&lt;typename DurationTypeToRoundTo&gt;\nstd::chrono::system_clock::time_point floor(\n    std::chrono::system_clock::time_point timePoint)\n{\n    using namespace std::chrono;\n    return system_clock::time_point(\n        duration_cast&lt;DurationTypeToRoundTo&gt;(timePoint.time_since_epoch()));\n}\n\n//-------------------------------------------------------------------------------------------------\n\nnamespace test {\n\nenum class ClockType\n{\n    system,\n    steady\n};\n\n/**\n * Provides a way to shift the result of utcTime() or monotonicTime() relative to the system values.\n * Test-only!\n */\nclass ScopedTimeShift\n{\npublic:\n    ScopedTimeShift(ClockType clockType):\n        m_clockType(clockType),\n        m_currentAbsoluteShift(std::chrono::milliseconds::zero())\n    {\n    }\n\n    ScopedTimeShift(ClockType clockType, std::chrono::milliseconds value):\n        m_clockType(clockType),\n        m_currentAbsoluteShift(value)\n    {\n        shiftCurrentTime(m_clockType, m_currentAbsoluteShift);\n    }\n\n    ScopedTimeShift(ScopedTimeShift&amp;&amp; rhs) noexcept:\n        m_clockType(rhs.m_clockType),\n        m_currentAbsoluteShift(rhs.m_currentAbsoluteShift)\n    {\n        rhs.m_currentAbsoluteShift = std::chrono::milliseconds::zero();\n    }\n\n    ScopedTimeShift&amp; operator=(ScopedTimeShift&amp;&amp; rhs) noexcept\n    {\n        if (&amp;rhs == this)\n            return *this;\n\n        m_clockType = rhs.m_clockType;\n        m_currentAbsoluteShift = rhs.m_currentAbsoluteShift;\n        rhs.m_currentAbsoluteShift = std::chrono::milliseconds::zero();\n        return *this;\n    }\n\n    ScopedTimeShift(const ScopedTimeShift&amp;) = delete;\n    ScopedTimeShift&amp; operator=(const ScopedTimeShift&amp;) = delete;\n\n    ~ScopedTimeShift()\n    {\n        if (m_currentAbsoluteShift != std::chrono::milliseconds::zero())\n            shiftCurrentTime(m_clockType, std::chrono::seconds::zero());\n    }\n\n    void applyAbsoluteShift(std::chrono::milliseconds value)\n    {\n        m_currentAbsoluteShift = value;\n        shiftCurrentTime(m_clockType, m_currentAbsoluteShift);\n    }\n\n    void applyRelativeShift(std::chrono::milliseconds value)\n    {\n        m_currentAbsoluteShift += value;\n        shiftCurrentTime(m_clockType, m_currentAbsoluteShift);\n    }\n\nprivate:\n    ClockType m_clockType;\n    std::chrono::milliseconds m_currentAbsoluteShift;\n\n    /**\n     * Test-only function!\n     * After this call utcTime() will add diff to return value.\n     */\n    NX_UTILS_API static void shiftCurrentTime(\n        ClockType clockType,\n        std::chrono::milliseconds diff);\n};\n\n/**\n * Provides a way to fix the result of utcTime() and make it independent of the\n * system time.\n * Test-only!\n */\nstruct NX_UTILS_API ScopedUtcTimeFix\n{\n    explicit ScopedUtcTimeFix(std::chrono::system_clock::time_point time);\n    ~ScopedUtcTimeFix();\n};\n\n/**\n * Provides a way to shift the result of monotonicTime() and make it independent of the system time.\n * Test-only!\n */\nclass NX_UTILS_API ScopedSyntheticMonotonicTime\n{\npublic:\n    ScopedSyntheticMonotonicTime(const ScopedSyntheticMonotonicTime&amp;) = delete;\n    ScopedSyntheticMonotonicTime&amp; operator=(const ScopedSyntheticMonotonicTime&amp;) = delete;\n\npublic:\n    ScopedSyntheticMonotonicTime(\n        const std::chrono::steady_clock::time_point&amp; initTime = monotonicTime());\n    ~ScopedSyntheticMonotonicTime();\n    void applyRelativeShift(std::chrono::milliseconds value);\n    void applyAbsoluteShift(std::chrono::milliseconds value);\n\nprivate:\n    std::chrono::steady_clock::time_point m_initTime;\n};\n\n} // namespace test\n} // namespace utils\n} // namespace nx\n\n#ifdef _WIN32\ninline errno_t gmtime_r(const time_t* time, struct tm* result)\n{\n    return gmtime_s(result, time);\n}\n#endif\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/value_cache.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/value_cache.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/value_cache.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n\n#include &lt;nx/utils/elapsed_timer.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx::utils {\n\n/**\n *  Allows caching of the value and automatic cache invalidation. Methods get(), reset() and\n *  update() can be called safely from different threads.\n */\ntemplate&lt;class ValueType&gt;\nclass CachedValue\n{\npublic:\n    /**\n     *  @param valueGenerator This functor is called from get() and update() to get value, it\n     *      must be thread-safe.\n     *  @note valueGenerator is not called here!\n     */\n    CachedValue(MoveOnlyFunc&lt;ValueType()&gt; valueGenerator):\n        m_valueGenerator(std::move(valueGenerator))\n    {\n    }\n\n    ValueType get() const\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        if (m_valueVersion == m_version)\n            return m_value;\n        return updated(&amp;lock);\n    }\n\n    void reset()\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        ++m_version;\n    }\n\n    void update()\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        update(&amp;lock);\n    }\n\n    ValueType updated() const\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        return updated(&amp;lock);\n    }\n\nprotected:\n\n    ValueType updated(nx::Locker&lt;nx::Mutex&gt;* lock) const\n    {\n        update(lock);\n        return m_value;\n    }\n\n    void update(nx::Locker&lt;nx::Mutex&gt;* lock) const\n    {\n        int version = ++m_version;\n\n        lock-&gt;unlock();\n        ValueType value = m_valueGenerator();\n        lock-&gt;relock();\n\n        if (version &lt; m_valueVersion)\n            return; //&lt; Already updated\n\n        m_valueVersion = version;\n        m_value = std::move(value);\n    }\n\nprotected:\n    mutable nx::Mutex m_mutex;\n\n    mutable ValueType m_value;\n    mutable int64_t m_valueVersion = -1;\n    mutable int64_t m_version = 0;\n    const MoveOnlyFunc&lt;ValueType()&gt; m_valueGenerator;\n};\n\n/**\n *  Allows caching of the value and automatic cache invalidation. Methods get(), reset() and\n *  update() can be called safely from different threads.\n */\ntemplate&lt;class ValueType&gt;\nclass CachedValueWithTimeout: public CachedValue&lt;ValueType&gt;\n{\n    using base_type = CachedValue&lt;ValueType&gt;;\n    using base_type::m_mutex;\n    using base_type::m_valueVersion;\n    using base_type::m_version;\n    using base_type::m_value;\npublic:\n\n    /**\n     *  @param valueGenerator This functor is called from get() and update() to get value, it\n     *      must be thread-safe.\n     *  @param expirationTime CachedValue will automatically update value on get() or\n     *      update() every expirationTime milliseconds. Setting to 0 ms disables expiration.\n     *  @note valueGenerator is not called here!\n     */\n    CachedValueWithTimeout(\n        MoveOnlyFunc&lt;ValueType()&gt; valueGenerator,\n        std::chrono::milliseconds expirationTime)\n        :\n        base_type(std::move(valueGenerator)),\n        m_expirationTime(expirationTime)\n    {\n    }\n\n    ValueType get() const\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        if (m_valueVersion == m_version &amp;&amp; !m_timer.hasExpired(m_expirationTime))\n            return m_value;\n        return updated(&amp;lock);\n    }\n\n    // Updated(lock) function is not virtual, so this function is required as well.\n    ValueType updated() const\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        return updated(&amp;lock);\n    }\n\n    // Update(lock) function is not virtual, so this function is required as well.\n    void update()\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        update(&amp;lock);\n    }\n\n    bool isExpired() const\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        return m_timer.hasExpired(m_expirationTime);\n    }\n\nprotected:\n\n    // Update(lock) function is not virtual, so this function is required as well.\n    ValueType updated(nx::Locker&lt;nx::Mutex&gt;* lock) const\n    {\n        update(lock);\n        return m_value;\n    }\n\n    void update(nx::Locker&lt;nx::Mutex&gt;* lock) const\n    {\n        base_type::update(lock);\n        m_timer.restart();\n    }\n\nprivate:\n    mutable ElapsedTimer m_timer;\n    const std::chrono::milliseconds m_expirationTime;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Caches a value and updates its value periodically from a given function.\n * The class is not thread-safe!\n */\ntemplate&lt;typename Value, typename StorageType = Value&gt;\nclass ValueCacheUnSafe\n{\npublic:\n    ValueCacheUnSafe(\n        nx::MoveOnlyFunc&lt;Value()&gt; generator,\n        std::chrono::milliseconds valueUpdatePeriod)\n        :\n        m_generator(std::move(generator)),\n        m_valueUpdatePeriod(valueUpdatePeriod)\n    {\n    }\n\n    virtual ~ValueCacheUnSafe() = default;\n\n    Value get()\n    {\n        const auto now = std::chrono::steady_clock::now();\n        if (now - m_lastUpdateTime.load() &gt; m_valueUpdatePeriod)\n            generateValue();\n\n        return m_value;\n    }\n\nprotected:\n    virtual void generateValue()\n    {\n        m_value = m_generator();\n        m_lastUpdateTime.store(std::chrono::steady_clock::now());\n    }\n\nprivate:\n    nx::MoveOnlyFunc&lt;Value()&gt; m_generator;\n    const std::chrono::milliseconds m_valueUpdatePeriod;\n    std::atomic&lt;std::chrono::steady_clock::time_point&gt; m_lastUpdateTime;\n    StorageType m_value = {};\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Caches a value and updates its value periodically from a given function.\n * Locks internal mutex when value update is needed only.\n * So, this class is suitable for multithreaded environment with a lot of concurrent value access.\n * Value type must be suitable for std::atomic&lt;Value&gt;.\n */\ntemplate&lt;typename Value&gt;\nclass AtomicValueCache:\n    public ValueCacheUnSafe&lt;Value, std::atomic&lt;Value&gt;&gt;\n{\n    using base_type = ValueCacheUnSafe&lt;Value, std::atomic&lt;Value&gt;&gt;;\n\npublic:\n    using base_type::base_type;\n\nprotected:\n    virtual void generateValue() override\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        base_type::generateValue();\n    }\n\nprivate:\n    nx::Mutex m_mutex;\n};\n\n} // namespace nx::utils\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/analytics/analytics_taxonomy_manager.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/analytics/analytics_taxonomy_manager.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/analytics/analytics_taxonomy_manager.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;QtCore/QHash&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QSet&gt;\n\n#include &lt;nx/analytics/taxonomy/abstract_engine.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_state.h&gt;\n#include &lt;nx/analytics/taxonomy/object_type.h&gt;\n#include &lt;nx/vms/client/core/system_context_aware.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n\n#include &quot;taxonomy/state_view.h&quot;\n\nnamespace nx::vms::client::core {\n\nclass AnalyticsSearchSetup;\n\nnamespace analytics {\nnamespace taxonomy {\n\nclass AnalyticsFilterModel;\n\n} // namespace taxonomy\n\n\nusing Taxonomy = nx::analytics::taxonomy::AbstractState;\n\nclass NX_VMS_CLIENT_CORE_API TaxonomyManager:\n    public QObject,\n    public SystemContextAware\n{\n    Q_OBJECT\n    Q_PROPERTY(nx::analytics::taxonomy::AbstractState* currentTaxonomy\n        READ qmlCurrentTaxonomy NOTIFY currentTaxonomyChanged)\n\npublic:\n    explicit TaxonomyManager(SystemContext* systemContext, QObject* parent = nullptr);\n    virtual ~TaxonomyManager() override;\n\n    static void registerQmlTypes();\n\n    std::shared_ptr&lt;Taxonomy&gt; currentTaxonomy() const;\n    Taxonomy* qmlCurrentTaxonomy() const;\n    Q_INVOKABLE nx::vms::client::core::analytics::taxonomy::AnalyticsFilterModel*\n        createFilterModel(QObject* parent = nullptr);\n\n    Q_INVOKABLE nx::vms::client::core::analytics::taxonomy::StateView*\n        createStateView(QObject* parent = nullptr) const;\n\n    Q_INVOKABLE QVariant objectTypeById(const QString&amp; objectTypeId) const;\n\n    Q_INVOKABLE bool isEngineRelevant(nx::analytics::taxonomy::AbstractEngine* engine) const;\n\n    Q_INVOKABLE bool isRelevantForEngine(nx::analytics::taxonomy::ObjectType* type,\n        nx::analytics::taxonomy::AbstractEngine* engine) const;\n\n    QSet&lt;nx::analytics::taxonomy::AbstractEngine*&gt; relevantEngines() const;\n\n    QSet&lt;nx::analytics::taxonomy::ObjectType*&gt; relevantObjectTypes(\n        nx::analytics::taxonomy::AbstractEngine* engine) const;\n\nsignals:\n    void currentTaxonomyAboutToBeChanged(QPrivateSignal);\n    void currentTaxonomyChanged(QPrivateSignal);\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace analytics\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/application_context.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/application_context.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/application_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/serialization/format.h&gt;\n#include &lt;nx/vms/client/core/system_context.h&gt;\n#include &lt;nx/vms/common/application_context.h&gt;\n\nQ_MOC_INCLUDE(&quot;nx/vms/client/core/network/cloud_status_watcher.h&quot;)\n\nclass QQmlEngine;\n\nclass QnAbstractStreamDataProvider;\nclass QnClientCoreSettings;\nclass QnResourcePool;\n\nnamespace nx::i18n { class TranslationManager; }\nnamespace nx::vms::discovery { class Manager; }\n\nnamespace nx::vms::client::core {\n\nclass ColorTheme;\nclass CloudCrossSystemManager;\nclass CloudLayoutsManager;\nclass CloudStatusWatcher;\nclass FontConfig;\nclass NetworkModule;\nclass Skin;\nclass Settings;\nclass SystemFinder;\nclass ThreadPool;\nclass UnifiedResourcePool;\nclass VoiceSpectrumAnalyzer;\nclass SessionTokenTerminator;\n\nnamespace watchers { class KnownServerConnections; }\n\n/**\n * Main context of the desktop client application. Exists through all application lifetime and is\n * accessible from anywhere using `appContext function.\n */\nclass NX_VMS_CLIENT_CORE_API ApplicationContext: public common::ApplicationContext\n{\n    Q_OBJECT\n\n    Q_PROPERTY(CloudStatusWatcher* cloudStatusWatcher\n        READ cloudStatusWatcher\n        CONSTANT)\n\npublic:\n    enum class Mode\n    {\n        desktopClient,\n        mobileClient,\n        unitTests\n    };\n\n    enum class FeatureFlag\n    {\n        none = 0,\n        qml = 1 &lt;&lt; 0,\n        cross_site = 1 &lt;&lt; 1,\n\n        all = -1\n    };\n    Q_DECLARE_FLAGS(FeatureFlags, FeatureFlag)\n\n    struct Features\n    {\n        common::ApplicationContext::Features base;\n        bool ignoreCustomization = false;\n        FeatureFlags flags = FeatureFlag::none;\n\n        Features() = default;\n        Features(\n            common::ApplicationContext::Features base,\n            FeatureFlags flags)\n            :\n            base(base),\n            flags(flags)\n        {\n        }\n\n        static Features all()\n        {\n            return {\n                common::ApplicationContext::Features::all(),\n                FeatureFlag::all\n            };\n        }\n\n        static Features none()\n        {\n            return {\n                common::ApplicationContext::Features::none(),\n                FeatureFlag::none\n            };\n        }\n    };\n\n    ApplicationContext(\n        Mode mode,\n        Qn::SerializationFormat serializationFormat,\n        PeerType peerType = PeerType::notDefined,\n        Features features = Features::none(),\n        const QString&amp; customCloudHost = {},\n        const QString&amp; customExternalResourceFile = {},\n        QObject* parent = nullptr);\n    virtual ~ApplicationContext() override;\n\n    Qn::SerializationFormat serializationFormat() const;\n\n    QQmlEngine* qmlEngine() const;\n\n    CloudStatusWatcher* cloudStatusWatcher() const;\n\n    nx::vms::discovery::Manager* moduleDiscoveryManager() const;\n\n    SystemFinder* systemFinder() const;\n\n    VoiceSpectrumAnalyzer* voiceSpectrumAnalyzer() const;\n\n    Settings* coreSettings() const;\n\n    watchers::KnownServerConnections* knownServerConnectionsWatcher() const;\n\n    Skin* skin() const;\n\n    ColorTheme* colorTheme() const;\n\n    /**\n     * Unified interface to access all available Resource Pools.\n     */\n    UnifiedResourcePool* unifiedResourcePool() const;\n\n    virtual SystemContext* createSystemContext(\n        SystemContext::Mode mode, QObject* parent = nullptr);\n\n    /**\n     * Context of the System we are currently connected to. Also contains local files.\n     */\n    SystemContext* currentSystemContext() const;\n\n    /**\n     * Contexts of the all Systems for which we have established connection.\n     */\n    std::vector&lt;SystemContext*&gt; systemContexts() const;\n\n    /**\n     * Register existing System Context. First registered is considered to be the Current Context.\n     * Ownership is not passed, but Context is to be unregistered before being destroyed.\n     * TODO: #sivanov Pass ownership here and emit signals on adding / deleting Contexts.\n     * TODO: @sivanov Allow to change Current Context later.\n     */\n    void addSystemContext(SystemContext* systemContext);\n\n    // Temporary workaround: needed until we have a single main SystemContext for all connections.\n    void addMainContext(SystemContext* mainContext);\n\n    /**\n     * Unregister existing system context before destroying.\n     */\n    void removeSystemContext(SystemContext* systemContext);\n\n    /**\n     * Find existing System Context by its cloud system id.\n     */\n    SystemContext* systemContextByCloudSystemId(const QString&amp; cloudSystemId) const;\n\n    /**\n     * Monitors available Cloud Systems and manages corresponding cross-system Contexts.\n     */\n    CloudCrossSystemManager* cloudCrossSystemManager() const;\n\n    /**\n     * Monitors available Cloud Layouts.\n     */\n    CloudLayoutsManager* cloudLayoutsManager() const;\n\n    /**\n     * System context, containing Cloud Layouts.\n     */\n    SystemContext* cloudLayoutsSystemContext() const;\n    QnResourcePool* cloudLayoutsPool() const;\n\n    FontConfig* fontConfig() const;\n\n    virtual nx::Uuid peerId() const;\n\n    /**\n     * Obtain a named thread pool.\n     * This is the preferred way (instead of explicitly creating a QThreadPool), as these pools are\n     * owned by the application context, and destruction of them and their threads happens at\n     * a safe moment (before QCoreApplication destruction).\n     */\n    ThreadPool* threadPool(const QString&amp; id) const;\n\n    SessionTokenTerminator* sessionTokenTerminator() const;\n\n    virtual bool isCertificateValidationLevelStrict() const override;\n\n    /** Provider of input audio data from the system microphone. */\n    virtual std::unique_ptr&lt;QnAbstractStreamDataProvider&gt; createAudioInputProvider() const;\n\n    NetworkModule* networkModule() const;\n\nsignals:\n    void systemContextAdded(SystemContext* systemContext);\n    void systemContextRemoved(SystemContext* systemContext);\n\nprotected:\n\n    void storeFontConfig(FontConfig* config);\n\n    void resetEngine();\n\n    /**\n     *  Initializes translation-related stuff. Should be called on the inheritor side since\n     *  we need some migration/initializations to be done before translations setup.\n     */\n    void initializeTranslations(const QString&amp; targetLocale);\n\n    /**\n    * Initialize network-related modules.\n    * Not called from the constructor, should be explicitly called from descendants instead.\n    */\n    void initializeNetworkModules();\n\n    /**\n    * Initialize cross-system-related modules.\n    * Not called from the constructor, should be explicitly called from descendants instead.\n    */\n    void initializeCrossSystemModules();\n\n    /** Destroy cross-system-related modules early from descendants. */\n    void destroyCrossSystemModules();\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n/**\n * Main context of the client application. Exists through all application lifetime.\n */\ninline ApplicationContext* appContext()\n{\n    return common::ApplicationContext::instance()-&gt;as&lt;ApplicationContext&gt;();\n}\n\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;nx/vms/api/data/module_information.h&gt;\n#include &lt;nx/vms/client/core/analytics/analytics_taxonomy_manager.h&gt;\n#include &lt;nx/vms/common/system_context.h&gt;\n#include &lt;nx/vms/utils/abstract_session_token_helper.h&gt;\n\n#include &quot;system_context_aware.h&quot; //&lt; Forward declarations.\n\nQ_MOC_INCLUDE(&quot;camera/camera_bookmarks_manager.h&quot;)\nQ_MOC_INCLUDE(&quot;nx/vms/client/core/watchers/feature_access_watcher.h&quot;)\nQ_MOC_INCLUDE(&quot;nx/vms/client/core/watchers/user_watcher.h&quot;)\nQ_MOC_INCLUDE(&quot;nx/vms/client/core/watchers/watermark_watcher.h&quot;)\n\nclass QnPtzControllerPool;\nclass QQmlContext;\nclass QnCameraBookmarksManager;\nclass QnServerStorageManager;\n\nnamespace ec2 {\n\nclass AbstractECConnection;\nusing AbstractECConnectionPtr = std::shared_ptr&lt;AbstractECConnection&gt;;\n\n} // namespace ec2\n\nnamespace nx::network::http { class Credentials; }\nnamespace nx::vms::api { struct SystemSettings; }\nnamespace nx::vms::rules { class Engine; }\n\nnamespace nx::vms::client::core {\n\nclass AccessController;\nclass AnalyticsEventsSearchTreeBuilder;\nclass CameraDataManager;\nclass FeatureAccessWatcher;\nclass IoPortsCompatibilityInterface;\nclass ServerRuntimeEventConnector;\nclass UserWatcher;\nclass VideoCache;\nclass RemoteSessionTimeoutWatcher;\nclass WatermarkWatcher;\nclass TrafficRelayUrlWatcher;\n\nnamespace analytics {\nclass AttributeHelper;\n} // namespace analytics\n\nclass NX_VMS_CLIENT_CORE_API SystemContext: public common::SystemContext\n{\n    Q_OBJECT\n    using base_type = common::SystemContext;\n\n    Q_PROPERTY(analytics::TaxonomyManager* taxonomyManager\n        READ taxonomyManager\n        CONSTANT)\n\n    Q_PROPERTY(WatermarkWatcher* watermarkWatcher\n        READ watermarkWatcher\n        CONSTANT)\n\n    Q_PROPERTY(UserWatcher* userWatcher\n        READ userWatcher\n        CONSTANT)\n\n    Q_PROPERTY(QnCameraBookmarksManager* bookmarksManager\n        READ cameraBookmarksManager\n        CONSTANT)\n\n    Q_PROPERTY(FeatureAccessWatcher* featureAccess\n        READ featureAccess\n        CONSTANT)\n\npublic:\n    /**\n     * Initialize client-core-level System Context based on existing common-level System Context.\n     * Destruction order must be handled by the caller.\n     * @param peerId Id of the current peer in the Message Bus. It is persistent and is not changed\n     *     between the application runs. Desktop Client calculates actual peer id depending on the\n     *     stored persistent id and on the number of the running client instance, so different\n     *     Client windows have different peer ids.\n     */\n    SystemContext(Mode mode, nx::Uuid peerId, QObject* parent = nullptr);\n    virtual ~SystemContext() override;\n\n    static SystemContext* fromResource(const QnResourcePtr&amp; resource);\n\n    /**\n     * Information about the Server we are connected to.\n     */\n    nx::vms::api::ModuleInformation moduleInformation() const;\n\n    /**\n     * Update remote session this Context belongs to. Current client architecture supposes one main\n     * System Context to exist through whole Application lifetime, and different Sessions are\n     * loaded into it and unloaded when session is terminated.\n     * // TODO: #sivanov Invert architecture, so Remote Session will own the System Context.\n     */\n    void setSession(std::shared_ptr&lt;RemoteSession&gt; session);\n\n    /**\n     * Set connection which this Context should use to communicate with the corresponding System.\n     * Connection is mutually exclusive with ::setSession() and should be used for session-less\n     * Contexts only.\n     */\n    void setConnection(RemoteConnectionPtr connection);\n\n    /**\n     * Id of the server which was used to establish the Remote Session (if it is present).\n     */\n    nx::Uuid currentServerId() const;\n\n    /**\n     * The server which was used to establish the Remote Session (if it is present).\n     */\n    QnMediaServerResourcePtr currentServer() const;\n\n    /**\n     * Remote session this context belongs to (if any).\n     */\n    std::shared_ptr&lt;RemoteSession&gt; session() const;\n\n    /**\n     * Connection which this Context should use to communicate with the corresponding System.\n     */\n    RemoteConnectionPtr connection() const;\n\n    /**\n     * Local id of the system to which we are currently connected.\n     */\n    nx::Uuid localSystemId() const;\n\n    /**\n     * Cloud id of the system (if any) to which we are currently connected.\n     */\n    QString cloudSystemId() const;\n\n    /**\n     * Credentials we are using to authorize the connection.\n     */\n    virtual nx::network::http::Credentials credentials() const override;\n\n    /** API interface of the currently connected server. */\n    rest::ServerConnectionPtr connectedServerApi() const;\n\n    /**\n     * Id of the connection in the Audit Trail and Runtime Info Manager (taken from the remote\n     * connection if it is established).\n     */\n    virtual nx::Uuid auditId() const override;\n\n    /**\n     * Established p2p connection (if any).\n     */\n    ec2::AbstractECConnectionPtr messageBusConnection() const;\n\n    /** Message processor, cast to actual class. */\n    QnClientMessageProcessor* clientMessageProcessor() const;\n\n    QnPtzControllerPool* ptzControllerPool() const;\n\n    UserWatcher* userWatcher() const;\n    QnUserResourcePtr user() const;\n\n    WatermarkWatcher* watermarkWatcher() const;\n\n    ServerTimeWatcher* serverTimeWatcher() const;\n\n    QnCameraBookmarksManager* cameraBookmarksManager() const;\n\n    FeatureAccessWatcher* featureAccess() const;\n\n    CameraDataManager* cameraDataManager() const;\n\n    nx::vms::api::SystemSettings* systemSettings() const;\n\n    virtual nx::vms::common::SessionTokenHelperPtr getSessionTokenHelper() const;\n\n    analytics::TaxonomyManager* taxonomyManager() const;\n\n    analytics::AttributeHelper* analyticsAttributeHelper() const;\n\n    QnServerStorageManager* serverStorageManager() const;\n\n    ServerRuntimeEventConnector* serverRuntimeEventConnector() const;\n\n    AccessController* accessController() const;\n\n    virtual void startModuleDiscovery(\n        nx::vms::discovery::Manager* moduleDiscoveryManager) override;\n\n    VideoCache* videoCache() const;\n\n    AnalyticsEventsSearchTreeBuilder* analyticsEventsSearchTreeBuilder() const;\n\n    IoPortsCompatibilityInterface* ioPortsInterface() const;\n\n    RemoteSessionTimeoutWatcher* sessionTimeoutWatcher() const;\n\n    TrafficRelayUrlWatcher* trafficRelayUrlWatcher() const;\n\nsignals:\n    void remoteIdChanged(const nx::Uuid&amp; id);\n\n    /**\n     * Signal which sent when current user of this system context is changed. Actual only while\n     * legacy system context architecture is in action, when there is only one active system\n     * context, and new remote connection clears everything in it and fills it again.\n     */\n    void userChanged(const QnUserResourcePtr&amp; user);\n\nprotected:\n    virtual void setMessageProcessor(QnCommonMessageProcessor* messageProcessor) override;\n    void resetAccessController(AccessController* accessController);\n\nprotected:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/application_context.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/application_context.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/application_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/software_version.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/client/core/application_context.h&gt;\n\nclass QOpenGLWidget;\n\nclass QnResourceDiscoveryManager;\nclass QnResourcePool;\n\nclass QnClientCoreModule;\nclass QnForgottenSystemsManager;\nclass QnClientRuntimeSettings;\nstruct QnStartupParameters;\n\nnamespace nx::cloud::gateway { class VmsGatewayEmbeddable; }\nnamespace nx::vms::client::core { class ObjectDisplaySettings; }\n\nnamespace nx::vms::client::desktop {\n\nclass ClientStateHandler;\nclass ContextStatisticsModule;\nclass FontConfig;\nclass LocalSettings;\nclass PerformanceMonitor;\nclass RadassController;\nclass ResourceFactory;\nclass ResourceDirectoryBrowser;\nclass ResourcesChangesManager;\nclass RunningInstancesManager;\nclass ScreenRecordingSettings;\nclass SharedMemoryManager;\nclass ShowOnceSettings;\nclass MessageBarSettings;\nclass SystemContext;\nclass UploadManager;\nclass WebPageDataCache;\nclass WindowContext;\n\nnamespace joystick { class Manager; }\n\n/**\n * Main context of the desktop client application. Exists through all application lifetime and is\n * accessible from anywhere using appContext function.\n */\nclass NX_VMS_CLIENT_DESKTOP_API ApplicationContext: public core::ApplicationContext\n{\n    Q_OBJECT\n    using base_type = core::ApplicationContext;\n\npublic:\n    enum class Mode\n    {\n        /** Generic Desktop Client mode. */\n        desktopClient,\n\n        /** Desktop Client self-update mode (with admin permissions). */\n        selfUpdate,\n\n        /** Unit tests mode. */\n        unitTests,\n    };\n\n    enum class FeatureFlag\n    {\n        none = 0,\n        // No additional features currently.\n        all = -1\n    };\n    Q_DECLARE_FLAGS(FeatureFlags, FeatureFlag)\n\n    struct Features\n    {\n        core::ApplicationContext::Features core;\n        FeatureFlags flags = FeatureFlag::none;\n\n        Features() = default;\n        Features(\n            core::ApplicationContext::Features core,\n            FeatureFlags flags)\n            :\n            core(core),\n            flags(flags)\n        {\n        }\n\n        static Features all()\n        {\n            return {\n                core::ApplicationContext::Features::all(),\n                FeatureFlag::all\n            };\n        }\n\n        static Features none()\n        {\n            return {\n                core::ApplicationContext::Features::none(),\n                FeatureFlag::none\n            };\n        }\n    };\n\n    ApplicationContext(\n        Mode mode,\n        Features features,\n        const QnStartupParameters&amp; startupParameters,\n        QObject* parent = nullptr);\n    virtual ~ApplicationContext() override;\n\n    virtual core::SystemContext* createSystemContext(\n        core::SystemContext::Mode mode, QObject* parent = nullptr) override;\n\n    /**\n     * Version of the application. Can be overridden with command-line parameters.\n     */\n    nx::utils::SoftwareVersion version() const;\n\n    /**\n     * Context of the System we are currently connected to. Also contains local files.\n     */\n    SystemContext* currentSystemContext() const;\n\n    /**\n     * Main Window context.\n     */\n    WindowContext* mainWindowContext() const;\n\n    /**\n     * Register existing Window Context. First registered is considered to be the Main Window.\n     * Ownership is not passed, but Context is to be unregistered before being destroyed.\n     * TODO: #sivanov Pass ownership here and emit signals on adding / deleting Contexts.\n     * TODO: @sivanov Allow to change Main Window later.\n     */\n    void addWindowContext(WindowContext* windowContext);\n\n    /**\n     * Unregister existing Window Context before destroying.\n     */\n    void removeWindowContext(WindowContext* windowContext);\n\n    /**\n     * Initialize desktop camera implementation depending on the current OS. For Windows it will be\n     * the screen recording camera, for other OS - audio only.\n     */\n    void initializeDesktopCamera(QOpenGLWidget* window);\n\n    /**\n     * @return Id of the current peer in the Message Bus. It is persistent and is not changed\n     *     between the application runs. Desktop Client calculates actual peer id depending on the\n     *     stored persistent id and on the number of the running client instance, so different\n     *     Client windows have different peer ids.\n     */\n    virtual nx::Uuid peerId() const override;\n\n    /**\n     * @return Id of the current Video Wall instance if the client was run in the Video Wall mode.\n     */\n    nx::Uuid videoWallInstanceId() const;\n\n    /**\n     * Central place for the initialization, storage and access to various statistics modules.\n     */\n    ContextStatisticsModule* statisticsModule() const;\n\n    /**\n     * Local Client settings.\n     */\n    LocalSettings* localSettings() const;\n\n    /** Runtime Client instance settings. */\n    QnClientRuntimeSettings* runtimeSettings() const;\n\n    ScreenRecordingSettings* screenRecordingSettings() const;\n\n    /** Provider of input audio data from the system microphone. */\n    virtual std::unique_ptr&lt;QnAbstractStreamDataProvider&gt; createAudioInputProvider() const override;\n\n    ShowOnceSettings* showOnceSettings() const;\n    MessageBarSettings* messageBarSettings() const;\n\n    /**\n     * Map of analytics objects colors by object type. Persistently stored on a PC.\n     */\n    core::ObjectDisplaySettings* objectDisplaySettings() const;\n\n    ClientStateHandler* clientStateHandler() const;\n\n    /** Interface for IPC between client instances. */\n    SharedMemoryManager* sharedMemoryManager() const;\n\n    /** Set custom Shared Memory Manager implementation. */\n    void setSharedMemoryManager(std::unique_ptr&lt;SharedMemoryManager&gt; value);\n\n    RunningInstancesManager* runningInstancesManager() const;\n\n    /**\n     * Monitors system resources usage: CPU, memory, GPU, etc, in its own separate thread.\n     */\n    PerformanceMonitor* performanceMonitor() const;\n\n    RadassController* radassController() const;\n\n    ResourceFactory* resourceFactory() const;\n\n    UploadManager* uploadManager() const;\n\n    QnResourceDiscoveryManager* resourceDiscoveryManager() const;\n\n    ResourceDirectoryBrowser* resourceDirectoryBrowser() const;\n\n    ResourcesChangesManager* resourcesChangesManager() const;\n\n    QnForgottenSystemsManager* forgottenSystemsManager() const;\n\n    WebPageDataCache* webPageDataCache() const;\n\n    nx::cloud::gateway::VmsGatewayEmbeddable* cloudGateway() const;\n\n    FontConfig* fontConfig() const;\n\n    joystick::Manager* joystickManager() const;\n\n    const QnStartupParameters&amp; startupParameters() const;\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n/**\n * Main context of the desktop client application. Exists through all application lifetime.\n */\ninline ApplicationContext* appContext()\n{\n    return common::ApplicationContext::instance()-&gt;as&lt;ApplicationContext&gt;();\n}\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/core/system_context.h&gt;\n\n#include &quot;system_context_aware.h&quot; //&lt; Forward declarations.\n\nclass QnMediaServerStatisticsManager;\n\nnamespace nx::vms::client::core { class AnalyticsEventsSearchTreeBuilder; }\n\nnamespace nx::vms::client::desktop {\n\nclass BookmarkTagsWatcher;\nclass DefaultPasswordCamerasWatcher;\nclass DesktopCameraConnectionController;\nclass DesktopCameraStubController;\nclass LdapStatusWatcher;\nclass LocalFileCache;\nclass LogsManagementWatcher;\nclass NonEditableUsersAndGroups;\nclass OtherServersManager;\nclass RemoteSession;\nclass RestApiHelper;\nclass ServerImageCache;\nclass ServerNotificationCache;\nclass ShowreelStateManager;\nclass SystemHealthState;\nclass SystemSpecificLocalSettings;\nclass UserNotificationSettingsManager;\nclass UserSpecificSettings;\nclass VideoCache;\nclass VideoWallOnlineScreensWatcher;\nclass VirtualCameraManager;\nclass StorageLocationCameraController;\n\nclass NX_VMS_CLIENT_DESKTOP_API SystemContext: public core::SystemContext\n{\n    Q_OBJECT\n    using base_type = core::SystemContext;\n\npublic:\n    /**\n     * Initialize client-level System Context based on existing client-core-level System Context.\n     * Destruction order must be handled by the caller.\n     * @param peerId Id of the current peer in the Message Bus. It is persistent and is not changed\n     *     between the application runs. Desktop Client calculates actual peer id depending on the\n     *     stored persistent id and on the number of the running client instance, so different\n     *     Client windows have different peer ids.\n     */\n    SystemContext(Mode mode, nx::Uuid peerId, QObject* parent = nullptr);\n    virtual ~SystemContext() override;\n\n    static void registerQmlType();\n    static SystemContext* fromResource(const QnResourcePtr&amp; resource);\n\n    /**\n     * This method should be called only when user clicks &quot;Push my screen&quot;, but until 2-way audio\n     * is reimplemented, we should initialize camera as soon as possible.\n     * TODO: #sivanov Fix QnLocalSettingsDialog also when it is done.\n     */\n    DesktopCameraConnectionController* desktopCameraConnectionController();\n\n    /**\n     * Is needed for QnWorkbenchVideoWallHandler, when it handles local Push my screen button action\n     * and creates DesktopCamera layout and initial DesktopCameraPreloaderResource.\n     */\n    DesktopCameraStubController* desktopCameraStubController();\n\n    /**\n     * Overload of the corresponding function from core context.\n     *\n     * Remote session this context belongs to (if any).\n     */\n    std::shared_ptr&lt;RemoteSession&gt; session() const;\n\n    BookmarkTagsWatcher* bookmarkTagWatcher() const;\n    VideoWallOnlineScreensWatcher* videoWallOnlineScreensWatcher() const;\n    LdapStatusWatcher* ldapStatusWatcher() const;\n    NonEditableUsersAndGroups* nonEditableUsersAndGroups() const;\n    VirtualCameraManager* virtualCameraManager() const;\n    ShowreelStateManager* showreelStateManager() const;\n    LogsManagementWatcher* logsManagementWatcher() const;\n    QnMediaServerStatisticsManager* mediaServerStatisticsManager() const;\n    SystemSpecificLocalSettings* localSettings() const;\n    UserSpecificSettings* userSettings() const;\n    RestApiHelper* restApiHelper() const;\n    OtherServersManager* otherServersManager() const;\n    virtual nx::vms::common::SessionTokenHelperPtr getSessionTokenHelper() const override;\n    DefaultPasswordCamerasWatcher* defaultPasswordCamerasWatcher() const;\n    SystemHealthState* systemHealthState() const;\n    LocalFileCache* localFileCache() const;\n    ServerImageCache* serverImageCache() const;\n    ServerNotificationCache* serverNotificationCache() const;\n    UserNotificationSettingsManager* userNotificationSettingsManager() const;\n    StorageLocationCameraController* storageLocationCameraController() const;\n\nprotected:\n    virtual void setMessageProcessor(QnCommonMessageProcessor* messageProcessor) override;\n\nprotected:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n\nQ_DECLARE_METATYPE(nx::vms::client::desktop::SystemContext)\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_test_fixture.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_test_fixture.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_test_fixture.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#include &lt;gtest/gtest.h&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/vms/client/desktop/common/flux/flux_state_store.h&gt;\n#include &lt;nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_dialog_state.h&gt;\n#include &lt;nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_dialog_state_reducer.h&gt;\n#include &lt;nx/vms/client/desktop/test_support/test_context.h&gt;\n#include &lt;nx/vms/common/resource/camera_resource_stub.h&gt;\n\nnamespace nx::vms::client::desktop {\nnamespace test {\n\nclass CameraSettingsTestFixture:\n    public ContextBasedTest,\n    public FluxStateStore&lt;CameraSettingsDialogState&gt;\n{\npublic:\n    using State = CameraSettingsDialogState;\n    using Reducer = CameraSettingsDialogStateReducer;\n\n    CameraSettingsTestFixture();\n    virtual ~CameraSettingsTestFixture();\n\nprotected:\n    enum class CameraFeature\n    {\n        none = 0,\n        motion = 1 &lt;&lt; 0,\n        objects = 1 &lt;&lt; 1,\n        remoteArchive = 1 &lt;&lt; 2,\n    };\n    Q_DECLARE_FLAGS(CameraFeatures, CameraFeature)\n\n    CameraResourceStubPtr givenCamera(CameraFeatures features =\n        CameraFeatures(CameraFeature::motion) | CameraFeature::objects);\n\n    StubCameraResourceList cameras() const;\n\n    void whenChangesAreSaved();\n\n    void whenCameraRemoved(CameraResourceStubPtr camera);\n\n    void whenCameraStatusChangedTo(CameraResourceStubPtr camera,\n        nx::vms::api::ResourceStatus status);\n    void whenCameraStatusChangedTo(nx::vms::api::ResourceStatus status);\n\n    void whenCameraFeaturesEnabled(\n        CameraResourceStubPtr camera,\n        CameraFeatures features,\n        bool on = true);\n\n    /** Process all cameras at once. */\n    void whenCameraFeaturesEnabled(\n        CameraFeatures features,\n        bool on = true);\n\n    void whenMotionEnabled(bool on = true)\n    {\n        whenCameraFeaturesEnabled(CameraFeature::motion, on);\n    }\n\n    void whenObjectsEnabled(bool on = true)\n    {\n        whenCameraFeaturesEnabled(CameraFeature::objects, on);\n    }\n\n    void whenRecordingEnabled(bool on = true);\n    void whenDualStreamingEnabled(bool on = true);\n    void whenSecondaryStreamRecordingEnabled(bool on = true);\n    void whenCamerasAreLoaded();\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace test\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/test_support/test_context.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/test_support/test_context.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/test_support/test_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;gtest/gtest.h&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/vms/client/desktop/application_context.h&gt;\n#include &lt;nx/vms/client/desktop/system_context.h&gt;\n#include &lt;nx/vms/common/test_support/test_context.h&gt;\n\nclass QnClientCoreModule;\n\nnamespace nx::vms::client::desktop::test {\n\nclass MessageProcessorMock;\n\nclass Context\n{\npublic:\n    Context();\n    virtual ~Context();\n\n    SystemContext* systemContext() const;\n};\n\nclass SystemContextBasedTest: public nx::vms::common::test::GenericContextBasedTest&lt;Context&gt;\n{\n    using base_type = nx::vms::common::test::GenericContextBasedTest&lt;Context&gt;;\n\npublic:\n    /** Create and install dummy message processor. */\n    MessageProcessorMock* createMessageProcessor();\n\n    /** Client tests should create client layouts. */\n    virtual QnLayoutResourcePtr createLayout() override;\n\n    static void initAppContext(ApplicationContext::Features features);\n    static void deinitAppContext();\n\nprotected:\n     virtual void TearDown();\n};\n\nstruct WithoutFeatures\n{\n    static ApplicationContext::Features features() { return ApplicationContext::Features::none(); }\n};\n\nstruct WithQmlFeatures\n{\n    static ApplicationContext::Features features()\n    {\n        auto result = ApplicationContext::Features::none();\n        result.core.flags.setFlag(core::ApplicationContext::FeatureFlag::qml);\n        return result;\n    }\n};\n\ntemplate&lt;typename FeaturesProvider = WithoutFeatures&gt;\nclass AppContextBasedTest: public SystemContextBasedTest\n{\npublic:\n    static void SetUpTestSuite()\n    {\n        ApplicationContext::Features features = FeaturesProvider::features();\n        initAppContext(features);\n    }\n\n    static void TearDownTestSuite()\n    {\n        deinitAppContext();\n    }\n};\n\nusing ContextBasedTest = AppContextBasedTest&lt;&gt;;\nusing QmlContextBasedTest = AppContextBasedTest&lt;WithQmlFeatures&gt;;\n\n} // namespace nx::vms::client::desktop::test\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;set&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/kit/utils.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/json/qjson.h&gt;\n#include &lt;nx/utils/json/qt_core_types.h&gt;\n#include &lt;nx/vms/api/analytics/engine_manifest.h&gt;\n#include &lt;nx/vms/api/analytics/manifest_items.h&gt;\n\n#include &quot;descriptors_fwd.h&quot;\n\nnamespace nx::vms::api::analytics {\n\n/**%apidoc\n * %param:string groupId\n * %param:string provider\n * %param:boolean hasTypeEverBeenSupportedInThisScope\n */\nstruct DescriptorScope\n{\n    nx::Uuid engineId;\n    mutable QString groupId;\n    mutable QString provider;\n    mutable bool hasTypeEverBeenSupportedInThisScope = false;\n\n    bool operator==(const DescriptorScope&amp; other) const = default;\n\n    bool operator&lt;(const DescriptorScope&amp; other) const\n    {\n        return engineId &lt; other.engineId;\n    }\n\n    bool isNull() const\n    {\n        return engineId.isNull() &amp;&amp; groupId.isEmpty() &amp;&amp; provider.isEmpty();\n    }\n};\n#define nx_vms_api_analytics_DescriptorScope_Fields (engineId)\\\n    (groupId)\\\n    (provider)\\\n    (hasTypeEverBeenSupportedInThisScope)\nNX_REFLECTION_INSTRUMENT(DescriptorScope, nx_vms_api_analytics_DescriptorScope_Fields);\n\ntemplate&lt;typename T, typename = void&gt;\nstruct hasGroupId: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct hasGroupId&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().groupId)&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename T, typename = void&gt;\nstruct hasProvider: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct hasProvider&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().provider)&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename T, typename = void&gt;\nstruct hasScopes: std::false_type {};\n\ntemplate&lt;typename T&gt;\nstruct hasScopes&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().scopes)&gt;&gt;: std::true_type {};\n\ntemplate&lt;typename T&gt;\nDescriptorScope scopeFromItem(nx::Uuid engineId, T item)\n{\n    DescriptorScope scope;\n    if (engineId.isNull())\n        return DescriptorScope();\n\n    scope.engineId = std::move(engineId);\n    if constexpr (hasGroupId&lt;T&gt;::value)\n        scope.groupId = std::move(item.groupId);\n\n    if constexpr (hasProvider&lt;T&gt;::value)\n        scope.provider = std::move(item.provider);\n\n    return scope;\n}\n\nstruct BaseDescriptor\n{\n    QString id;\n    QString name;\n\n    BaseDescriptor() = default;\n    BaseDescriptor(NamedItem namedItem):\n        id(std::move(namedItem.id)),\n        name(std::move(namedItem.name))\n    {\n    }\n\n    BaseDescriptor(QString id, QString name):\n        id(std::move(id)),\n        name(std::move(name))\n    {\n    }\n\n    bool operator==(const BaseDescriptor&amp; other) const = default;\n};\n#define nx_vms_api_analytics_BaseDescriptor_Fields (id)(name)\nNX_REFLECTION_INSTRUMENT(BaseDescriptor, nx_vms_api_analytics_BaseDescriptor_Fields);\n\n/**%apidoc\n * %param:{std::vector&lt;DescriptorScope&gt;} scopes\n */\nstruct BaseScopedDescriptor: BaseDescriptor\n{\n    BaseScopedDescriptor() = default;\n    BaseScopedDescriptor(DescriptorScope scope, NamedItem namedItem):\n        BaseDescriptor(std::move(namedItem))\n    {\n        if (!scope.isNull())\n            scopes.insert(std::move(scope));\n    }\n\n    BaseScopedDescriptor(DescriptorScope scope, QString id, QString name):\n        BaseDescriptor(std::move(id), std::move(name))\n    {\n        if (!scope.isNull())\n            scopes.insert(std::move(scope));\n    }\n\n    bool operator==(const BaseScopedDescriptor&amp; other) const = default;\n\n    std::set&lt;DescriptorScope&gt; scopes;\n};\n#define nx_vms_api_analytics_BaseScopedDescriptor_Fields \\\n    nx_vms_api_analytics_BaseDescriptor_Fields \\\n    (scopes)\nNX_REFLECTION_INSTRUMENT(BaseScopedDescriptor, nx_vms_api_analytics_BaseScopedDescriptor_Fields);\n\nstruct PluginDescriptor: BaseDescriptor\n{\n    PluginDescriptor() = default;\n    PluginDescriptor(QString id, QString name):\n        BaseDescriptor(std::move(id), std::move(name))\n    {\n    }\n\n    bool operator==(const PluginDescriptor&amp; other) const = default;\n};\n#define nx_vms_api_analyitcs_PluginDescriptor_Fields nx_vms_api_analytics_BaseDescriptor_Fields\nNX_REFLECTION_INSTRUMENT(PluginDescriptor, nx_vms_api_analyitcs_PluginDescriptor_Fields);\n\nstruct EngineDescriptor\n{\n    nx::Uuid id;\n    QString name;\n    QString pluginId;\n    EngineCapabilities capabilities;\n\n    EngineDescriptor() = default;\n    EngineDescriptor(\n        nx::Uuid id,\n        QString name,\n        QString pluginId,\n        const EngineManifest&amp; engineManifest)\n        :\n        id(std::move(id)),\n        name(std::move(name)),\n        pluginId(std::move(pluginId)),\n        capabilities(engineManifest.capabilities)\n    {\n    }\n\n    bool operator==(const EngineDescriptor&amp; other) const = default;\n};\n#define nx_vms_api_analytics_EngineDescriptor_Fields (id)(name)(pluginId)(capabilities)\nNX_REFLECTION_INSTRUMENT(EngineDescriptor, nx_vms_api_analytics_EngineDescriptor_Fields);\n\n/** GoogleTest printer. */\ninline void PrintTo(const EngineDescriptor&amp; d, std::ostream* s)\n{\n    *s &lt;&lt; &quot;EngineDescriptor{id &quot; &lt;&lt; d.id.toSimpleStdString()\n        &lt;&lt; &quot;, name &quot; &lt;&lt; nx::kit::utils::toString(d.name)\n        &lt;&lt; &quot;, pluginId &quot; &lt;&lt; nx::kit::utils::toString(d.pluginId)\n        &lt;&lt; &quot;, ...}&quot;;\n}\n\nstruct GroupDescriptor: BaseScopedDescriptor\n{\n    GroupDescriptor() = default;\n    GroupDescriptor(nx::Uuid engineId, const Group&amp; group):\n        BaseScopedDescriptor(scopeFromItem(engineId, group), group)\n    {\n    }\n\n    bool operator==(const GroupDescriptor&amp; other) const = default;\n};\n#define nx_vms_api_analyitcs_GroupDescriptor_Fields \\\n    nx_vms_api_analytics_BaseScopedDescriptor_Fields\nNX_REFLECTION_INSTRUMENT(GroupDescriptor, nx_vms_api_analyitcs_GroupDescriptor_Fields);\n\nstruct ExtendedScopedDescriptor: public BaseScopedDescriptor\n{\n    ExtendedScopedDescriptor() = default;\n    ExtendedScopedDescriptor(DescriptorScope scope, ExtendedType extendedType):\n        BaseScopedDescriptor(std::move(scope), extendedType),\n        icon(std::move(extendedType.icon)),\n        base(std::move(extendedType.base)),\n        omittedBaseAttributes(std::move(extendedType.omittedBaseAttributes)),\n        attributes(std::move(extendedType.attributes))\n    {\n    }\n\n    bool operator==(const ExtendedScopedDescriptor&amp; other) const = default;\n\n    QString icon;\n    std::optional&lt;QString&gt; base;\n    std::vector&lt;QString&gt; omittedBaseAttributes;\n    std::vector&lt;AttributeDescription&gt; attributes;\n    std::map&lt;QString /*attributeName*/, std::set&lt;EngineId&gt;&gt; attributeSupportInfo;\n    bool hasEverBeenSupported = false;\n};\n#define nx_vms_api_analytics_ExtendedScopedDescriptor_Fields \\\n    nx_vms_api_analytics_BaseScopedDescriptor_Fields \\\n    (icon) \\\n    (base) \\\n    (omittedBaseAttributes) \\\n    (attributes) \\\n    (attributeSupportInfo)\nNX_REFLECTION_INSTRUMENT(ExtendedScopedDescriptor,\n    nx_vms_api_analytics_ExtendedScopedDescriptor_Fields);\n\nstruct EventTypeDescriptor: public ExtendedScopedDescriptor\n{\n    EventTypeDescriptor() = default;\n    EventTypeDescriptor(nx::Uuid engineId, const AnalyticsEventType&amp; eventType):\n        ExtendedScopedDescriptor(scopeFromItem(engineId, eventType), eventType),\n        flags(eventType.flags)\n    {\n    }\n\n    bool operator==(const EventTypeDescriptor&amp; other) const = default;\n\n    EventTypeFlags flags;\n\n    /** See ObjectType::isSupposedToMimicBaseType(). */\n    bool isSupposedToMimicBaseType() const { return false; }\n\n    bool isHidden() const { return flags.testFlag(EventTypeFlag::hidden); }\n};\n#define nx_vms_api_analyitcs_EventTypeDescriptor_Fields \\\n    nx_vms_api_analytics_ExtendedScopedDescriptor_Fields \\\n    (flags) \\\n    (hasEverBeenSupported)\nNX_REFLECTION_INSTRUMENT(EventTypeDescriptor, nx_vms_api_analyitcs_EventTypeDescriptor_Fields);\n\nstruct ObjectTypeDescriptor: public ExtendedScopedDescriptor\n{\n    ObjectTypeDescriptor() = default;\n    ObjectTypeDescriptor(nx::Uuid engineId, const ObjectType&amp; objectType):\n        ExtendedScopedDescriptor(scopeFromItem(engineId, objectType), objectType),\n        flags(objectType.flags)\n    {\n    }\n\n    bool operator==(const ObjectTypeDescriptor&amp; other) const = default;\n\n    ObjectTypeFlags flags;\n\n    /**\n     * Some Object Types aren&#x27;t visible anywhere in the GUI (hidden), but behave like mixins for\n     * its base Types (mimicking them). E.g its attributes become a part of the base Object Type\n     * attribute set.\n     */\n    bool isSupposedToMimicBaseType() const\n    {\n        return flags.testFlag(ObjectTypeFlag::hiddenDerivedType);\n    }\n\n    bool isHidden() const { return isSupposedToMimicBaseType(); }\n};\n#define nx_vms_api_analyitcs_ObjectTypeDescriptor_Fields \\\n    nx_vms_api_analytics_ExtendedScopedDescriptor_Fields \\\n    (flags) \\\n    (hasEverBeenSupported)\nNX_REFLECTION_INSTRUMENT(ObjectTypeDescriptor, nx_vms_api_analyitcs_ObjectTypeDescriptor_Fields);\n\nstruct ActionTypeDescriptor: BaseDescriptor\n{\n    ActionTypeDescriptor() = default;\n    ActionTypeDescriptor(nx::Uuid /*engineId*/, ObjectAction actionType):\n        BaseDescriptor(\n            actionType.id,\n            actionType.name),\n        supportedObjectTypeIds(std::move(actionType.supportedObjectTypeIds)),\n        parametersModel(std::move(actionType.parametersModel)),\n        requirements(std::move(actionType.requirements))\n    {\n    }\n\n    bool operator==(const ActionTypeDescriptor&amp; other) const = default;\n\n    QList&lt;QString&gt; supportedObjectTypeIds;\n    QJsonObject parametersModel;\n    analytics::ObjectActionRequirements requirements;\n};\n#define nx_vms_api_analytics_ActionTypeDescriptor_Fields \\\n    nx_vms_api_analytics_BaseDescriptor_Fields \\\n    (supportedObjectTypeIds) \\\n    (parametersModel) \\\n    (requirements)\nNX_REFLECTION_INSTRUMENT(ActionTypeDescriptor, nx_vms_api_analytics_ActionTypeDescriptor_Fields);\n\nstruct EnumTypeDescriptor: public BaseDescriptor\n{\n    EnumTypeDescriptor() = default;\n    EnumTypeDescriptor(nx::Uuid /*engineId*/, EnumType enumType):\n        BaseDescriptor(enumType),\n        base(std::move(enumType.base)),\n        baseItems(std::move(enumType.baseItems)),\n        items(std::move(enumType.items))\n    {\n    }\n\n    bool operator==(const EnumTypeDescriptor&amp; other) const = default;\n\n    std::optional&lt;QString&gt; base;\n    std::vector&lt;QString&gt; baseItems;\n    std::vector&lt;QString&gt; items;\n};\n#define nx_vms_api_analytics_EnumTypeDescriptor_Fields \\\n    nx_vms_api_analytics_BaseDescriptor_Fields \\\n    (base) \\\n    (baseItems) \\\n    (items)\nNX_REFLECTION_INSTRUMENT(EnumTypeDescriptor, nx_vms_api_analytics_EnumTypeDescriptor_Fields);\n\nstruct ColorTypeDescriptor: public BaseDescriptor\n{\n    ColorTypeDescriptor() = default;\n    ColorTypeDescriptor(nx::Uuid /*engineId*/, ColorType colorType):\n        BaseDescriptor(colorType),\n        base(std::move(colorType.base)),\n        baseItems(std::move(colorType.baseItems)),\n        items(std::move(colorType.items))\n    {\n    }\n\n    bool operator==(const ColorTypeDescriptor&amp; other) const = default;\n\n    std::optional&lt;QString&gt; base;\n    std::vector&lt;QString&gt; baseItems;\n    std::vector&lt;ColorItem&gt; items;\n};\n#define nx_vms_api_analytics_ColorTypeDescriptor_Fields \\\n    nx_vms_api_analytics_BaseDescriptor_Fields \\\n    (base) \\\n    (baseItems) \\\n    (items)\nNX_REFLECTION_INSTRUMENT(ColorTypeDescriptor, nx_vms_api_analytics_ColorTypeDescriptor_Fields);\n\n// Client and web api uses group ids in the same filter scenarios as event and object type ids.\nstatic_assert(std::is_same&lt;GroupId, EventTypeId&gt;::value);\nstatic_assert(std::is_same&lt;GroupId, ObjectTypeId&gt;::value);\n\nusing PluginDescriptorMap = std::map&lt;PluginId, PluginDescriptor&gt;;\nusing EngineDescriptorMap = std::map&lt;EngineId, EngineDescriptor&gt;;\nusing GroupDescriptorMap = std::map&lt;GroupId, GroupDescriptor&gt;;\nusing EventTypeDescriptorMap = std::map&lt;EventTypeId, EventTypeDescriptor&gt;;\nusing ObjectTypeDescriptorMap = std::map&lt;ObjectTypeId, ObjectTypeDescriptor&gt;;\n\nusing EnumTypeDescriptorMap = std::map&lt;EnumTypeId, EnumTypeDescriptor&gt;;\nusing ColorTypeDescriptorMap = std::map&lt;ColorTypeId, ColorTypeDescriptor&gt;;\n\nusing AttributeListMap = std::map&lt;AttributeListId, AttributesWithId&gt;;\n\nusing ScopedEventTypeIds = std::map&lt;EngineId, std::map&lt;GroupId, std::set&lt;EventTypeId&gt;&gt;&gt;;\nusing ScopedObjectTypeIds = std::map&lt;EngineId, std::map&lt;GroupId, std::set&lt;ObjectTypeId&gt;&gt;&gt;;\nusing ScopedEntityTypeIds = std::map&lt;EngineId, std::map&lt;GroupId, std::set&lt;QString&gt;&gt;&gt;;\n\nusing ActionTypeDescriptorMap = std::map&lt;EngineId, std::map&lt;ActionTypeId, ActionTypeDescriptor&gt;&gt;;\n\nstruct NX_VMS_API Descriptors\n{\n    PluginDescriptorMap pluginDescriptors;\n    EngineDescriptorMap engineDescriptors;\n    GroupDescriptorMap groupDescriptors;\n    EventTypeDescriptorMap eventTypeDescriptors;\n    ObjectTypeDescriptorMap objectTypeDescriptors;\n    EnumTypeDescriptorMap enumTypeDescriptors;\n    ColorTypeDescriptorMap colorTypeDescriptors;\n    AttributeListMap attributeListDescriptors;\n\n    void merge(Descriptors descriptors);\n\n    bool isEmpty() const;\n    bool operator==(const Descriptors&amp; other) const = default;\n};\n\n#define nx_vms_api_analytics_Descriptors_Fields \\\n    (pluginDescriptors) \\\n    (engineDescriptors) \\\n    (groupDescriptors) \\\n    (eventTypeDescriptors) \\\n    (objectTypeDescriptors) \\\n    (enumTypeDescriptors) \\\n    (colorTypeDescriptors) \\\n    (attributeListDescriptors)\nNX_REFLECTION_INSTRUMENT(Descriptors, nx_vms_api_analytics_Descriptors_Fields);\n\nQN_FUSION_DECLARE_FUNCTIONS(Descriptors, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(DescriptorScope, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(BaseDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(BaseScopedDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ExtendedScopedDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(PluginDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(EngineDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(GroupDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(EventTypeDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ObjectTypeDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ActionTypeDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(EnumTypeDescriptor, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ColorTypeDescriptor, (json), NX_VMS_API)\n\n} // namespace nx::vms::api::analytics\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;optional&gt;\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/json/flags.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nnamespace nx::vms::api::analytics {\n\nstruct NamedItem\n{\n    /**%apidoc[opt] */\n    QString id;\n    /**%apidoc[opt] */\n    QString name;\n\n    bool operator==(const NamedItem&amp; other) const = default;\n};\n#define NamedItem_Fields (id)(name)\nNX_REFLECTION_INSTRUMENT(NamedItem, NamedItem_Fields);\n\nstruct EnumType: public NamedItem\n{\n    std::optional&lt;QString&gt; base;\n    /**%apidoc[opt] */\n    std::vector&lt;QString&gt; baseItems;\n    /**%apidoc[opt] */\n    std::vector&lt;QString&gt; items;\n};\n#define EnumType_Fields NamedItem_Fields (base)(baseItems)(items)\nNX_REFLECTION_INSTRUMENT(EnumType, EnumType_Fields);\n\nstruct ColorItem\n{\n    /**%apidoc[opt] */\n    QString name;\n    /**%apidoc[opt] */\n    QString rgb;\n\n    bool operator==(const ColorItem&amp; other) const = default;\n};\n#define ColorItem_Fields (name)(rgb)\nNX_REFLECTION_INSTRUMENT(ColorItem, ColorItem_Fields);\n\nstruct ColorType: public NamedItem\n{\n    std::optional&lt;QString&gt; base;\n    /**%apidoc[opt] */\n    std::vector&lt;QString&gt; baseItems;\n    /**%apidoc[opt] */\n    std::vector&lt;ColorItem&gt; items;\n};\n#define ColorType_Fields NamedItem_Fields (base)(baseItems)(items)\nNX_REFLECTION_INSTRUMENT(ColorType, ColorType_Fields);\n\nenum class AttributeType\n{\n    /**%apidoc[unused] */\n    undefined,\n\n    /**%apidoc\n     * %caption Number\n     */\n    number,\n\n    /**%apidoc\n     * %caption Boolean\n     */\n    boolean,\n\n    /**%apidoc\n     * %caption String\n     */\n    string,\n\n    /**%apidoc\n     * %caption Color\n     */\n    color,\n\n    /**%apidoc\n     * %caption Enum\n     */\n    enumeration,\n\n    /**%apidoc\n     * %caption Object\n     */\n    object,\n};\n\ntemplate&lt;typename Visitor&gt;\nconstexpr auto nxReflectVisitAllEnumItems(AttributeType*, Visitor&amp;&amp; visitor)\n{\n    using Item = nx::reflect::enumeration::Item&lt;AttributeType&gt;;\n    return visitor(\n        Item{AttributeType::undefined, &quot;&quot;},\n        Item{AttributeType::number, &quot;Number&quot;},\n        Item{AttributeType::boolean, &quot;Boolean&quot;},\n        Item{AttributeType::string, &quot;String&quot;},\n        Item{AttributeType::color, &quot;Color&quot;},\n        Item{AttributeType::enumeration, &quot;Enum&quot;},\n        Item{AttributeType::object, &quot;Object&quot;});\n}\n\nstruct AttributeDescriptionCommon\n{\n    /**%apidoc[opt] */\n    QString name;\n    std::optional&lt;AttributeType&gt; type; /**&lt; Can be omitted for Enum and Color attributes. */\n    std::optional&lt;QString&gt; subtype; /**&lt; One of: empty, a Name, &quot;integer&quot; or &quot;float&quot; for Numbers. */\n    std::optional&lt;QString&gt; unit; /**&lt; Only for Number. Can be empty. */\n\n    /**%apidoc:integer */\n    std::optional&lt;double&gt; minValue; /**&lt; Only for Number. */\n\n    /**%apidoc:integer */\n    std::optional&lt;double&gt; maxValue; /**&lt; Only for Number. */\n\n    std::optional&lt;QString&gt; attributeList; /**&lt; If not empty, all other fields are ignored. */\n\n    /**\n     * Condition string that defines whether this Attribute makes sense for the Object or Event\n     * Type depending on values of the other Attributes. Uses the same syntax as in the Object\n     * Search panel.\n     */\n    std::optional&lt;QString&gt; condition;\n\n    AttributeDescriptionCommon()\n    {\n    }\n\n    AttributeDescriptionCommon(const AttributeDescriptionCommon&amp; other)\n        : name(other.name),\n        type(other.type),\n        subtype(other.subtype),\n        unit(other.unit),\n        minValue(other.minValue),\n        maxValue(other.maxValue),\n        attributeList(other.attributeList),\n        condition(other.condition)\n    {\n    }\n\n    bool operator==(const AttributeDescriptionCommon&amp; other) const = default;\n};\n\n#define AttributeDescriptionCommon_Fields \\\n    (name)\\\n    (type)\\\n    (subtype)\\\n    (unit)\\\n    (minValue)\\\n    (maxValue)\\\n    (attributeList)\\\n    (condition)\n\nstruct DependentAttributeDescription : AttributeDescriptionCommon\n{\n    std::optional&lt;std::vector&lt;QString&gt;&gt; items; /**&lt; Only for Enums. */\n\n    bool operator==(const DependentAttributeDescription&amp; other) const = default;\n};\n#define DependentAttributeDescription_Fields \\\n    AttributeDescriptionCommon_Fields \\\n    (items)\n\nstruct ItemObject\n{\n    /**%apidoc[opt] */\n    QString value;\n    /**%apidoc[opt] */\n    std::vector&lt;DependentAttributeDescription&gt; dependentAttributes;\n\n    bool operator==(const ItemObject&amp; other) const = default;\n};\n#define ItemObject_Fields \\\n    (value) \\\n    (dependentAttributes)\n\nusing Item = std::variant&lt;ItemObject, QString&gt;;\n\nstruct AttributeDescription : AttributeDescriptionCommon\n{\n    std::optional&lt;std::vector&lt;std::variant&lt;ItemObject, QString&gt;&gt;&gt; items; /**&lt; Only for Enums. */\n\n    bool operator==(const AttributeDescription&amp; other) const = default;\n\n    AttributeDescription()\n    {\n    }\n\n    AttributeDescription(const AttributeDescription&amp; other)\n        : AttributeDescriptionCommon(other),\n        items(other.items)\n    {\n    }\n\n    AttributeDescription(const DependentAttributeDescription&amp; dep)\n        : AttributeDescriptionCommon(dep)\n    {\n        if (dep.items)\n        {\n            std::vector&lt;Item&gt; convertedItems;\n            for (const auto&amp; item : *dep.items)\n                convertedItems.emplace_back(QString(item));\n            items = std::move(convertedItems);\n        }\n    }\n};\n\n#define AttributeDescription_Fields \\\n    AttributeDescriptionCommon_Fields \\\n    (items)\n\nNX_REFLECTION_INSTRUMENT(AttributeDescriptionCommon, AttributeDescriptionCommon_Fields);\nNX_REFLECTION_INSTRUMENT(ItemObject, ItemObject_Fields);\nNX_REFLECTION_INSTRUMENT(DependentAttributeDescription, DependentAttributeDescription_Fields);\nNX_REFLECTION_INSTRUMENT(AttributeDescription, AttributeDescription_Fields);\n\nstruct ExtendedType: public NamedItem\n{\n    /**%apidoc[opt] */\n    QString icon; //&lt; internal id or empty.\n    /**%apidoc[opt] */\n    std::optional&lt;QString&gt; base;\n    /**%apidoc[opt] */\n    std::vector&lt;QString&gt; omittedBaseAttributes;\n    /**%apidoc[opt] */\n    std::vector&lt;AttributeDescription&gt; attributes;\n\n    bool operator==(const ExtendedType&amp; other) const = default;\n};\n#define ExtendedType_Fields NamedItem_Fields (icon)(base)(omittedBaseAttributes)(attributes)\nNX_REFLECTION_INSTRUMENT(ExtendedType, ExtendedType_Fields);\n\n/** See the documentation in manifests.md. */\nenum class EventTypeFlag\n{\n    noFlags = 0,\n    stateDependent = 1 &lt;&lt; 0,\n    regionDependent = 1 &lt;&lt; 1,\n    hidden = 1 &lt;&lt; 2,\n    useTrackBestShotAsPreview = 1 &lt;&lt; 3\n};\nQ_DECLARE_FLAGS(EventTypeFlags, EventTypeFlag)\n\ntemplate&lt;typename Visitor&gt;\nconstexpr auto nxReflectVisitAllEnumItems(EventTypeFlag*, Visitor&amp;&amp; visitor)\n{\n    using Item = nx::reflect::enumeration::Item&lt;EventTypeFlag&gt;;\n    return visitor(\n        Item{EventTypeFlag::noFlags, &quot;&quot;},\n        Item{EventTypeFlag::noFlags, &quot;noFlags&quot;},\n        Item{EventTypeFlag::stateDependent, &quot;stateDependent&quot;},\n        Item{EventTypeFlag::regionDependent, &quot;regionDependent&quot;},\n        Item{EventTypeFlag::hidden, &quot;hidden&quot;},\n        Item{EventTypeFlag::useTrackBestShotAsPreview, &quot;useTrackBestShotAsPreview&quot;});\n}\n\n/**\n * Description of the Analytics Event type.\n */\nstruct AnalyticsEventType: public ExtendedType\n{\n    /**%apidoc[opt] */\n    EventTypeFlags flags = EventTypeFlag::noFlags;\n    /**%apidoc[opt] */\n    QString groupId;\n    /**%apidoc[opt] */\n    QString provider = &quot;&quot;;\n\n    bool isStateful() const noexcept { return flags.testFlag(EventTypeFlag::stateDependent); }\n};\n#define AnalyticsEventType_Fields ExtendedType_Fields (flags)(groupId)(provider)\nNX_REFLECTION_INSTRUMENT(AnalyticsEventType, AnalyticsEventType_Fields);\nsize_t NX_VMS_API qHash(const AnalyticsEventType&amp; eventType);\n\nenum class ObjectTypeFlag\n{\n    noFlags = 0,\n    hiddenDerivedType = 1 &lt;&lt; 0,\n    nonIndexable = 1 &lt;&lt; 1,\n    liveOnly = 1 &lt;&lt; 2,\n};\nQ_DECLARE_FLAGS(ObjectTypeFlags, ObjectTypeFlag)\n\ntemplate&lt;typename Visitor&gt;\nconstexpr auto nxReflectVisitAllEnumItems(ObjectTypeFlag*, Visitor&amp;&amp; visitor)\n{\n    using Item = nx::reflect::enumeration::Item&lt;ObjectTypeFlag&gt;;\n    return visitor(\n        Item{ObjectTypeFlag::noFlags, &quot;&quot;},\n        Item{ObjectTypeFlag::noFlags, &quot;noFlags&quot;},\n        Item{ObjectTypeFlag::hiddenDerivedType, &quot;hiddenDerivedType&quot;},\n        Item{ObjectTypeFlag::nonIndexable, &quot;nonIndexable&quot;},\n        Item{ObjectTypeFlag::liveOnly, &quot;liveOnly&quot;});\n}\n\n/**\n * Description of the Analytics Object Type.\n */\nstruct ObjectType: public ExtendedType\n{\n    /**%apidoc[opt] */\n    QString provider;\n    /**%apidoc[opt] */\n    ObjectTypeFlags flags;\n\n    bool operator==(const ObjectType&amp; other) const = default;\n};\n#define ObjectType_Fields ExtendedType_Fields (provider)(flags)\nNX_REFLECTION_INSTRUMENT(ObjectType, ObjectType_Fields);\n\nstruct HiddenExtendedType\n{\n    QString id;\n    std::vector&lt;AttributeDescription&gt; attributes;\n\n    bool operator==(const HiddenExtendedType&amp; other) const = default;\n};\n#define HiddenExtendedType_Fields (id)(attributes)\nNX_REFLECTION_INSTRUMENT(HiddenExtendedType, HiddenExtendedType_Fields);\n\nstruct AttributesWithId\n{\n    QString id;\n    std::vector&lt;AttributeDescription&gt; attributes;\n\n    bool operator==(const AttributesWithId&amp; other) const = default;\n};\n#define AttributesWithId_Fields (id)(attributes)\nNX_REFLECTION_INSTRUMENT(AttributesWithId, AttributesWithId_Fields)\n\n/**\n * Named group which is referenced from a &quot;groupId&quot; attribute of other types to group them.\n */\nstruct Group: NamedItem\n{\n};\n#define Group_Fields NamedItem_Fields\nNX_REFLECTION_INSTRUMENT(Group, Group_Fields);\n\nstruct TypeSupportInfo\n{\n    /**%apidoc[opt] */\n    QString eventTypeId; //&lt; eventTypeId and objectTypeId can&#x27;t be non-empty at the same time.\n    /**%apidoc[opt] */\n    QString objectTypeId;\n    /**%apidoc[opt] */\n    std::vector&lt;QString&gt; attributes;\n\n    bool operator==(const TypeSupportInfo&amp; other) const = default;\n};\n\n#define TypeSupportInfo_Fields \\\n    (eventTypeId) \\\n    (objectTypeId) \\\n    (attributes)\nNX_REFLECTION_INSTRUMENT(TypeSupportInfo, TypeSupportInfo_Fields);\n\nQ_DECLARE_OPERATORS_FOR_FLAGS(EventTypeFlags)\nQ_DECLARE_OPERATORS_FOR_FLAGS(ObjectTypeFlags)\n\nbool NX_VMS_API operator==(const AnalyticsEventType&amp; lh, const AnalyticsEventType&amp; rh);\n\nQN_FUSION_DECLARE_FUNCTIONS(ColorItem, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ColorType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(EnumType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ItemObject, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(AttributeDescription, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ExtendedType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(AnalyticsEventType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(ObjectType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(HiddenExtendedType, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(AttributesWithId, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(Group, (json), NX_VMS_API)\nQN_FUSION_DECLARE_FUNCTIONS(TypeSupportInfo, (json), NX_VMS_API)\n\n} // namespace nx::vms::api::analytics\n\nQN_FUSION_DECLARE_FUNCTIONS(nx::vms::api::analytics::EventTypeFlag, (lexical),\n    NX_VMS_API)\n\nQN_FUSION_DECLARE_FUNCTIONS(nx::vms::api::analytics::EventTypeFlags, (lexical),\n    NX_VMS_API)\n\nQN_FUSION_DECLARE_FUNCTIONS(nx::vms::api::analytics::ObjectTypeFlag, (lexical),\n    NX_VMS_API)\n\nQN_FUSION_DECLARE_FUNCTIONS(nx::vms::api::analytics::ObjectTypeFlags, (lexical),\n    NX_VMS_API)\n\nQN_FUSION_DECLARE_FUNCTIONS(nx::vms::api::analytics::AttributeType, (lexical),\n    NX_VMS_API)\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/analytics_data.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/analytics_data.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/analytics_data.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QByteArray&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/data/rect_as_string.h&gt;\n#include &lt;nx/vms/api/data/resource_data.h&gt;\n#include &lt;nx/vms/api/json/value_or_array.h&gt;\n#include &lt;nx/vms/api/types/motion_types.h&gt;\n\nnamespace nx::vms::api {\n\n// TODO: Rename to AnalyticsIntegrationData.\nstruct NX_VMS_API AnalyticsPluginData: ResourceData\n{\n    static const QString kResourceTypeName;\n    static const nx::Uuid kResourceTypeId;\n};\n#define AnalyticsPluginData_Fields ResourceData_Fields\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(AnalyticsPluginData)\nNX_REFLECTION_INSTRUMENT(AnalyticsPluginData, AnalyticsPluginData_Fields)\n\nstruct NX_VMS_API AnalyticsEngineData: ResourceData\n{\n    static const QString kResourceTypeName;\n    static const nx::Uuid kResourceTypeId;\n};\n#define AnalyticsEngineData_Fields ResourceData_Fields\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(AnalyticsEngineData)\nNX_REFLECTION_INSTRUMENT(AnalyticsEngineData, AnalyticsEngineData_Fields)\n\n/**%apidoc\n * Information about a Server Integration that resides in a plugin (dynamic library). If the\n * Integration object was not created because of issues with the dynamic library, this structure\n * keeps information about these issues. If there is more than one Integration object created by\n * the same dynamic library, each will have its own instance of this structure.\n */\nstruct NX_VMS_API PluginInfo\n{\n    NX_REFLECTION_ENUM_CLASS_IN_CLASS(Optionality,\n        nonOptional = 0,\n        optional = 1\n    )\n\n    NX_REFLECTION_ENUM_CLASS_IN_CLASS(Status,\n        loaded = 0,\n        notLoadedBecauseOfError = 1,\n        notLoadedBecauseOfBlackList = 2,\n        notLoadedBecauseOptional = 3\n    )\n\n    NX_REFLECTION_ENUM_CLASS_IN_CLASS(Error,\n        /**%apidoc\n         * No error.\n         */\n        noError = 0,\n\n        /**%apidoc\n         * OS cannot load the library file.\n         */\n        cannotLoadLibrary = 1,\n\n        /**%apidoc\n         * The library does not seem to be a valid Nx Plugin library, e.g. no expected entry point\n         * functions found.\n         */\n        invalidLibrary = 2,\n\n        /**%apidoc\n         * The plugin library failed to initialize, e.g. its entry point function returned an\n         * error.\n         */\n        libraryFailure = 3,\n\n        /**%apidoc\n         * The plugin has returned a bad manifest, e.g. null, empty, non-json, or json with an\n         * unexpected structure.\n         */\n        badManifest = 4,\n\n        /**%apidoc\n         * The plugin API version is no longer supported.\n         */\n        unsupportedVersion = 5,\n\n        /**%apidoc\n         * Some internal error has occurred which made the proper PluginInfo structure unavailable.\n         * In this case the error message is stored in statusMessage field.\n         */\n        internalError = 6\n    )\n\n    NX_REFLECTION_ENUM_CLASS_IN_CLASS(MainInterface,\n        undefined = 0,\n        nxpl_PluginInterface = 1, /**&lt;%apidoc Base interface for the old 3.2 SDK. */\n        nxpl_Plugin = 2, /**&lt;%apidoc Old 3.2 SDK plugin supporting roSettings. */\n        nxpl_Plugin2 = 3, /**&lt;%apidoc Old 3.2 SDK plugin supporting pluginContainer. */\n        /**%apidoc Base interface for the 4.0+ SDK: nx::sdk::IIntegration or nx::sdk::IPlugin. */\n        nx_sdk_IIntegration = 4,\n        /**%apidoc New 4.0 SDK: nx::sdk::analytics::Integration or nx::sdk::IPlugin. */\n        nx_sdk_analytics_IIntegration = 5\n    )\n\n    /**%apidoc\n     * Name of the Integration from its manifest.\n     */\n    QString name;\n\n    /**%apidoc\n     * Description of the Integration from its manifest.\n     */\n    QString description;\n\n    /**%apidoc\n     * Plugin name for logging: library file name with no `lib` prefix (on Linux) and no extension.\n     */\n    QString libName;\n\n    /**%apidoc\n     * Absolute path to the plugin dynamic library.\n     */\n    QString libraryFilename;\n\n    /**%apidoc\n     * Absolute path to the plugin&#x27;s dedicated directory where its dynamic library resides together\n     * with its possible dependencies, or an empty string if the plugin resides in a common\n     * directory with other plugins.\n     */\n    QString homeDir;\n\n    /**%apidoc\n     * Vendor of the Integration from its manifest.\n     */\n    QString vendor;\n\n    /**%apidoc\n     * Version of the Integration from its manifest.\n     */\n    QString version;\n\n    /**%apidoc\n     * Whether the plugin resides in &quot;pluins_optional&quot; folder or in the regular &quot;plugins&quot; folder.\n     */\n    Optionality optionality = Optionality::nonOptional;\n\n    /**%apidoc\n     * Status of the plugin after the plugin loading attempt.\n     */\n    Status status = Status::loaded;\n\n    /**%apidoc\n     * Message in English with details about the plugin loading attempt.\n     */\n    QString statusMessage;\n\n    /**%apidoc\n     * If the plugin status is &quot;notLoadedBecauseOfError&quot;, describes the error. Can be &quot;internalError&quot;\n     * regardless of the status, in which case the statusMessage field contains the error message\n     * and the original status message and error code obtained while loading the plugin.\n     */\n    Error errorCode = Error::noError;\n\n    /**%apidoc\n     * The highest interface that the Integration object (the one returned by the plugin entry\n     * point function) supports via queryInterface().\n     */\n    MainInterface mainInterface = MainInterface::undefined;\n\n    /**%apidoc\n     * For non-Analytics Integrations and for device-independent Analytics Integrations, is always\n     * set to true. For device-dependent Analytics Integrations, is set to true if and only if the\n     * Integration has ever had a DeviceAgent since the Server start.\n     */\n    bool isActive = true;\n\n    /**%apidoc\n     * Version of the SDK, as reported by plugin&#x27;s function nxSdkVersion()). Not empty - if the\n     * plugin fails to report the SDK version, this value is set to the description of the reason.\n     */\n    QString nxSdkVersion;\n\n    /**%apidoc\n     * For Plugins created via multi-IIntegration entry point function, a 0-based index of the IIntegration\n     * instance corresponding to this PluginInfo instance. Otherwise, -1.\n     */\n    int instanceIndex = -1;\n\n    /**%apidoc\n     * For Plugins created via multi-IIntegration entry point function, an id of the IIntegration\n     * instance corresponding to this PluginInfo instance, or, if the id is not available -\n     * instanceIndex as a string. Otherwise, empty.\n     */\n    QString instanceId;\n};\n#define PluginInfo_Fields \\\n    (name) \\\n    (description) \\\n    (libName) \\\n    (libraryFilename) \\\n    (homeDir) \\\n    (vendor) \\\n    (version) \\\n    (optionality) \\\n    (status) \\\n    (statusMessage) \\\n    (errorCode) \\\n    (mainInterface) \\\n    (isActive) \\\n    (nxSdkVersion) \\\n    (instanceIndex) \\\n    (instanceId)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(PluginInfo)\nNX_REFLECTION_INSTRUMENT(PluginInfo, PluginInfo_Fields)\n\n/**%apidoc\n * Information about bound resources. For Analytics Plugins contains information about the\n * resources bound to its Engine. For Device Plugins the information is related to the resources\n * bound to the Plugin itself.\n */\nstruct NX_VMS_API PluginResourceBindingInfo\n{\n    /**%apidoc\n     * Id of the Engine in the case of Analytics Plugins, an empty string for Device Plugins.\n     */\n    QString id;\n\n    /**%apidoc\n     * Name of the Engine (for Analytics Plugins) or the Plugin (for Device Plugins).\n     */\n    QString name;\n\n    /**%apidoc\n     * For Analytics Plugins - number of resources on which the Engine is enabled automatically or\n     * by the User. In the case of Device Plugins - the number of resources that are produced by\n     * the Plugin.\n     */\n    int boundResourceCount = 0;\n\n    /**%apidoc\n     * For Analytics Integrations - number of resources on which the Engine is enabled\n     * automatically or by the User and that are currently online (thus a Device Agent is created\n     * for them). In the case of Device Integrations - the number of Resources that are produced by\n     * the Integration and are online.\n     */\n    int onlineBoundResourceCount = 0;\n};\n#define PluginResourceBindingInfo_Fields \\\n    (id) \\\n    (name) \\\n    (boundResourceCount) \\\n    (onlineBoundResourceCount)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(PluginResourceBindingInfo)\nNX_REFLECTION_INSTRUMENT(PluginResourceBindingInfo, PluginResourceBindingInfo_Fields)\n\n/**%apidoc Extended information about a Server Plugin. */\nstruct NX_VMS_API PluginInfoEx: PluginInfo\n{\n    PluginInfoEx() = default;\n    PluginInfoEx(PluginInfo pluginInfo)\n    {\n        static_cast&lt;PluginInfo&amp;&gt;(*this) = std::move(pluginInfo);\n    }\n\n    PluginInfoEx(const PluginInfoEx&amp; other) = default;\n    PluginInfoEx(PluginInfoEx&amp;&amp; other) = default;\n    PluginInfoEx&amp; operator=(const PluginInfoEx&amp; other) = default;\n    PluginInfoEx&amp; operator=(PluginInfoEx&amp;&amp; other) = default;\n\n    /**%apidoc\n     * Array with information about bound Resources. For Device Integrations contains zero (if the\n     * plugin is not loaded) or one item. For Analytics Integrations, the number of items is equal\n     * to the number of Engines of the Integration.\n     */\n    std::vector&lt;PluginResourceBindingInfo&gt; resourceBindingInfo;\n};\n#define PluginInfoEx_Fields PluginInfo_Fields (resourceBindingInfo)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(PluginInfoEx)\nNX_REFLECTION_INSTRUMENT(PluginInfoEx, PluginInfoEx_Fields)\n\nusing ExtendedPluginInfoByServer = std::map&lt;nx::Uuid, PluginInfoExList&gt;;\n\n//-------------------------------------------------------------------------------------------------\n\nstruct BestShotV4\n{\n    std::chrono::milliseconds timestampMs;\n\n    /**%apidoc[opt]:string Coordinates in range [0..1]. The format is `{x},{y},{width}x{height}`. */\n    std::optional&lt;RectAsString&gt; boundingBox;\n\n    nx::vms::api::StreamIndex streamIndex = nx::vms::api::StreamIndex::undefined;\n\n    // TODO: When Best Shot Attributes are implemented on the Server, add them here.\n};\n#define BestShotV4_Fields \\\n    (timestampMs)(boundingBox)(streamIndex)\nNX_VMS_API_DECLARE_STRUCT_EX(BestShotV4, (json));\nNX_REFLECTION_INSTRUMENT(BestShotV4, BestShotV4_Fields)\n\n/**%apidoc\n * Common properties of an image taken from a video frame.\n */\nstruct ObjectTrackVideoFrameImageInfo\n{\n    std::chrono::milliseconds timestampMs{};\n\n    /**%apidoc:string\n     * Specifies the image rectangle within a frame, coordinates in range [0..1], in the format\n     * `{x},{y},{width}x{height}`.\n     */\n    RectAsString boundingBox;\n    nx::vms::api::StreamIndex streamIndex = nx::vms::api::StreamIndex::undefined;\n};\n#define ObjectTrackVideoFrameImageInfo_Fields \\\n    (timestampMs)(boundingBox)(streamIndex)\nNX_VMS_API_DECLARE_STRUCT_EX(ObjectTrackVideoFrameImageInfo, (json));\nNX_REFLECTION_INSTRUMENT(ObjectTrackVideoFrameImageInfo, ObjectTrackVideoFrameImageInfo_Fields)\n\nstruct ObjectTrackTitle\n{\n    /**%apidoc[opt] Single-line text to be shown to the user. */\n    QString text;\n\n    /**%apidoc\n     * Is present if the Title has an image, and this image was taken from a video frame.\n     */\n    std::optional&lt;ObjectTrackVideoFrameImageInfo&gt; imageInfo;\n\n    /**%apidoc\n     * Whether the Title has an image, either taken from a video frame (then imageInfo is present),\n     * or received from an Integration in the form of pixel data.\n     * `GET /rest/v{4-}/analytics/objectTracks/{id}/titleImage` or\n     * `GET /rest/v{4-}/analytics/objectTracks/{id}/titleImage.{format}`.\n     */\n    bool isImageAvailable = false;\n\n    bool operator&lt;(const ObjectTrackTitle&amp; other) const noexcept { return text &lt; other.text; }\n};\n#define ObjectTrackTitle_Fields (text)(imageInfo)(isImageAvailable)\nNX_VMS_API_DECLARE_STRUCT_EX(ObjectTrackTitle, (json));\nNX_REFLECTION_INSTRUMENT(ObjectTrackTitle, ObjectTrackTitle_Fields)\n\nstruct BaseObjectRegion\n{\n    /**%apidoc\n     * Roughly defines a region on a video frame where the Object(s) were detected, as an array of\n     * bytes encoded in base64.\n     * &lt;br/&gt;\n     * The region is represented as a grid of 32 rows and 44 columns, stored by columns. The grid\n     * coordinate system starts at the top left corner, the row index grows down and the column\n     * index grows right. This grid is represented as a contiguous array, each bit of which\n     * corresponds to the state of a particular cell of the grid (1 if the region includes the\n     * cell, 0 otherwise). The bit index for a cell with coordinates (column, row) can be\n     * calculated using the following formula: bitIndex = gridHeight * column + row.\n     * &lt;br/&gt;\n     * NOTE: This is the same binary format that is used by the VMS for motion detection metadata.\n     */\n    QByteArray boundingBoxGrid;\n};\n#define BaseObjectRegion_Fields (boundingBoxGrid)\nNX_VMS_API_DECLARE_STRUCT(BaseObjectRegion);\nNX_REFLECTION_INSTRUMENT(BaseObjectRegion, BaseObjectRegion_Fields)\n\n/**%apidoc Attribute of an analytics entity. */\nstruct AnalyticsAttribute\n{\n    QString name;\n    QString value;\n\n    AnalyticsAttribute() = default;\n    AnalyticsAttribute(const QString&amp; name, const QString&amp; value): name(name), value(value) {}\n};\n#define AnalyticsAttribute_Fields (name)(value)\nNX_VMS_API_DECLARE_STRUCT(AnalyticsAttribute);\nNX_REFLECTION_INSTRUMENT(AnalyticsAttribute, AnalyticsAttribute_Fields)\n\nstruct NX_VMS_API ObjectTrackV4\n{\n    nx::Uuid id;\n\n    /**%apidoc Id of a Device the Object has been detected on. */\n    nx::Uuid deviceId;\n\n    /**%apidoc Id of an Object Type of the last received Object Metadata in the Track. */\n    QString objectTypeId;\n\n    std::chrono::milliseconds startTimeMs;\n\n    std::chrono::milliseconds endTimeMs;\n\n    BaseObjectRegion objectRegion;\n\n    std::vector&lt;AnalyticsAttribute&gt; attributes;\n\n    std::optional&lt;BestShotV4&gt; bestShot;\n\n    std::optional&lt;ObjectTrackTitle&gt; title = std::nullopt;\n\n    nx::Uuid analyticsEngineId;\n};\n#define ObjectTrackV4_Fields \\\n    (id)(deviceId)(objectTypeId)(startTimeMs)(endTimeMs) \\\n    (objectRegion)(attributes)(bestShot)(title)(analyticsEngineId)\nNX_VMS_API_DECLARE_STRUCT_EX(ObjectTrackV4, (json));\nNX_REFLECTION_INSTRUMENT(ObjectTrackV4, ObjectTrackV4_Fields)\n\nstruct ObjectTrackFilterFreeText\n{\n    /**%apidoc[opt]\n     * Text to match within Object Track Attributes. The text is actually an expression in the\n     * special language. Its syntax will likely evolve in the future, and is designed to be close\n     * to a &quot;free text&quot; search request in simple cases, so it is described with examples (rather\n     * than with a formal definition):\n     * &lt;ul&gt;\n     * &lt;li&gt;Search for Object Tracks which have an Attribute name or an Attribute value (called here\n     *     a string) containing a certain text:\n     *     &lt;ul&gt;\n     *     &lt;li&gt;`abc`: Match if the word `abc` (case-insensitive) is found at any position in the\n     *         string.&lt;/li&gt;\n     *     &lt;li&gt;`abc def`: Match if both words `abc` and `def` (case-insensitive) are found at any\n     *         position in the string, in any order. Any number of words can be specified.&lt;/li&gt;\n     *     &lt;/ul&gt;\n     * &lt;/li&gt;\n     * &lt;li&gt;Search for Object Tracks which have an Attribute with the specified name with a value\n     *     containing certain text:\n     *     &lt;ul&gt;\n     *     &lt;li&gt;`param: expression`: Match if the Attribute with the name `param` is present and its\n     *         value matches the expression specified after `:` using the same features as in the\n     *         examples above.&lt;/li&gt;\n     *     &lt;li&gt;`param: &quot;complete&quot;` or `param: $complete^`: Match if the Attribute with the name\n     *         `param` is present and its value is exactly `complete` (without any prefix or\n     *         suffix).&lt;/li&gt;\n     *     &lt;li&gt;NOTE: To specify an Attribute name which contains spaces, colons or other special\n     *         characters, enquote the Attribute name:\n     *         &lt;ul&gt;\n     *         &lt;li&gt;`&quot;License Plate&quot;: 123`&lt;/li&gt;\n     *         &lt;/ul&gt;\n     *     &lt;/li&gt;\n     *     &lt;li&gt;NOTE: To specify a fragment of an Attribute value which contains quotes, colons,\n     *         backslashes or dollar signs, prepend these characters with a backslash:\n     *         &lt;ul&gt;\n     *         &lt;li&gt;`param: abc\\&quot;quoted\\&quot;\\$\\def\\\\ghi`: Match if the Attribute value contains the\n     *             text `abc&quot;quoted&quot;$def\\ghi` (case-insensitive) at any position.&lt;/li&gt;\n     *         &lt;/ul&gt;\n     *     &lt;li&gt;NOTE: The specified fragment of an Attribute value must contain at least 3\n     *         characters.&lt;/li&gt;\n     *     &lt;li&gt;NOTE: To require that the specified fragment of an Attribute value must start at the\n     *          beginning of the value or end at the end of the value, use the symbols `^` or `$`\n     *          respectively:\n     *          &lt;ul&gt;\n     *          &lt;li&gt;`glasses=$red`: Match both `glasses=red` and `glasses=reddish` but not\n     *              `glasses=dark-red`.&lt;/li&gt;\n     *          &lt;li&gt;`glasses=red^`: Match both `glasses=red` and `glasses=dark-red` but not\n     *              `glasses=reddish`.&lt;/li&gt;\n     *          &lt;/ul&gt;\n     *     &lt;/li&gt;\n     *     &lt;/ul&gt;\n     * &lt;/li&gt;\n     * &lt;li&gt;Search for Object Tracks which have the specified Attribute present, regardless of its\n     *     value:\n     *     &lt;ul&gt;\n     *     &lt;li&gt;`param:` or `$param`: Match if an Attribute with the name `param` is present.&lt;/li&gt;\n     *     &lt;/ul&gt;\n     * &lt;/li&gt;\n     * &lt;li&gt;Search for Object Tracks which have at least one Attribute (i.e. on some particular\n     *     video frame in the Object Track) with the specified name with a numeric value that\n     *     matches the specified condition:\n     *     &lt;ul&gt;\n     *     &lt;li&gt;`speed=5`: Match if there is a value equal to 5.&lt;/li&gt;\n     *     &lt;li&gt;`speed&gt;5`: Match if there is a value greater than 5.&lt;/li&gt;\n     *     &lt;li&gt;`speed&gt;=5`: Match if there is a value greater than or equal to 5.&lt;/li&gt;\n     *     &lt;li&gt;`speed&lt;5`: Match if there is a value less than 5.&lt;/li&gt;\n     *     &lt;li&gt;`speed&lt;=5`: Match if there is a value less than or equal to 5.&lt;/li&gt;\n     *     &lt;li&gt;`speed=[5...10]` or `speed=5...10`: Match if there is a value in the range from 5 to\n     *         10 (inclusive).&lt;/li&gt;\n     *     &lt;li&gt;`speed=(5...10)`: Match if there is a value which is greater than 5 and less than 10\n     *         (i.e. 5 to 10 non-inclusive).&lt;/li&gt;\n     *     &lt;li&gt;`speed=[-5.4...7.2)`: Match if there is a value which is greater than or equal to\n     *         -5.4 and strictly less than 7.2.&lt;/li&gt;\n     *     &lt;/ul&gt;\n     * &lt;/li&gt;\n     * &lt;li&gt;Search for Object Tracks which do not have any Attributes matching the specified\n     *     condition:\n     *     &lt;ul&gt;\n     *     &lt;li&gt;`!wearsGlasses`: Match if the Object Track contains no Attributes with the name\n     *         `wearsGlasses`.&lt;/li&gt;\n     *     &lt;/li&gt;`color!=red`: Match if the Object Track does not contain an Attribute with the name\n     *         `color` with the value `red`.&lt;/li&gt;\n     *     &lt;/ul&gt;\n     * &lt;/li&gt;\n     * &lt;li&gt;NOTE: If an Object Track contains an Attribute with the name containing a period, e.g.\n     *     `glasses.color=red`, the Attribute name specified in the search expression can be a\n     *     prefix of this name until the period, e.g. `glasses=red` will match.&lt;/li&gt;\n     * &lt;li&gt;NOTE: To match any Attribute with the name starting from a certain prefix, append an\n     *     asterisk to this prefix: `glas*=red` will match both `glasses.color=red` and\n     *     `glassColor=red`.&lt;/li&gt;\n     * &lt;/ul&gt;\n     */\n    QString freeText;\n};\n#define ObjectTrackFilterFreeText_Fields (freeText)\nNX_VMS_API_DECLARE_STRUCT_EX(ObjectTrackFilterFreeText, (json));\nNX_REFLECTION_INSTRUMENT(ObjectTrackFilterFreeText, ObjectTrackFilterFreeText_Fields)\n\nstruct ObjectTrackFilter: IdData, ObjectTrackFilterFreeText\n{\n    /**%apidoc[opt]:stringArray\n     * If present, only Object Tracks originating from the specified Device(s) will be considered\n     * for search. Device id (can be obtained from &quot;id&quot;, &quot;physicalId&quot; or &quot;logicalId&quot; field via\n     * `GET /rest/v{1-}/devices`) or MAC address (not supported for certain cameras).\n     */\n    json::ValueOrArray&lt;QString&gt; deviceId;\n\n    /**%apidoc[opt]:stringArray\n     * If present, only Object Tracks of the specified type(s) will be considered for search.\n     */\n    json::ValueOrArray&lt;QString&gt; objectTypeId;\n\n    /**%apidoc\n     * Start of the time period to search within, in milliseconds since epoch (1970-01-01 00:00, UTC).\n     */\n    std::optional&lt;std::chrono::milliseconds&gt; startTimeMs;\n\n    /**%apidoc\n     * End of the time period to search within, in milliseconds since epoch (1970-01-01 00:00, UTC).\n     */\n    std::optional&lt;std::chrono::milliseconds&gt; endTimeMs;\n\n    /**%apidoc[opt]:string\n     * Coordinates of the picture bounding box to search within; in range [0..1]. The format is\n     * `{x},{y},{width}x{height}`.\n     */\n    std::optional&lt;RectAsString&gt; boundingBox;\n\n    /**%apidoc\n     * Maximum number of Object Tracks to return.\n     */\n    std::optional&lt;int&gt; limit;\n\n    /**%apidoc[opt]:enum\n     * Sort order of Object Tracks by a Track start timestamp.\n     *     %value asc Ascending order.\n     *     %value desc Descending order.\n     */\n    Qt::SortOrder sortOrder = Qt::SortOrder::DescendingOrder;\n\n    /**%apidoc\n     * If specified, only Object Tracks detected by specified engine will be considered for search.\n     */\n    std::optional&lt;nx::Uuid&gt; analyticsEngineId;\n};\n#define ObjectTrackFilter_Fields IdData_Fields ObjectTrackFilterFreeText_Fields \\\n    (deviceId)(objectTypeId)(startTimeMs)(endTimeMs)(boundingBox)(limit) \\\n    (sortOrder)(analyticsEngineId)\nNX_VMS_API_DECLARE_STRUCT_EX(ObjectTrackFilter, (json));\nNX_REFLECTION_INSTRUMENT(ObjectTrackFilter, ObjectTrackFilter_Fields)\n\nstruct AnalyticsObjectMetadataRequest\n{\n    /**%apidoc Id of the Analytic Object Track. */\n    nx::Uuid id;\n\n    /**%apidoc\n     * Flexible Device id (can be obtained from &quot;id&quot;, &quot;physicalId&quot; or &quot;logicalId&quot; field via `GET\n     * /rest/v{1-}/devices`) or MAC address (not supported for certain cameras).\n     *\n     * %// TODO: Remove this parameter by implementing the Device-from-ObjectTrackId logic. The\n     *     Device is used for resolution of permissions.\n     */\n    QString deviceId;\n};\n#define AnalyticsObjectMetadataRequest_Fields (id)(deviceId)\nNX_VMS_API_DECLARE_STRUCT_EX(AnalyticsObjectMetadataRequest, (json));\nNX_REFLECTION_INSTRUMENT(AnalyticsObjectMetadataRequest, AnalyticsObjectMetadataRequest_Fields)\n\nstruct AnalyticsObjectMetadata\n{\n    /**%apidoc Id of a Device the Object has been detected on. */\n    nx::Uuid deviceId;\n\n    std::chrono::milliseconds timestampMs;\n    std::chrono::milliseconds durationMs;\n\n    /**%apidoc:string\n     * Coordinates of the bounding box on a video frame where an Object is shown; in range [0..1].\n     * The format is: `{x},{y},{width}x{height}`\n     */\n    RectAsString boundingBox;\n\n    /**%apidoc Attributes of an Object, like a car speed. */\n    std::vector&lt;AnalyticsAttribute&gt; attributes;\n};\n#define AnalyticsObjectMetadata_Fields \\\n    (deviceId)(timestampMs)(durationMs)(boundingBox)(attributes)\nNX_VMS_API_DECLARE_STRUCT_EX(AnalyticsObjectMetadata, (json));\nNX_REFLECTION_INSTRUMENT(AnalyticsObjectMetadata, AnalyticsObjectMetadata_Fields)\n\n} // namespace nx::vms::api\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/media_server_data.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/media_server_data.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/media_server_data.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/reflect/filter.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/reflect/json.h&gt;\n#include &lt;nx/utils/json/json.h&gt;\n#include &lt;nx/vms/api/types/day_of_week.h&gt;\n#include &lt;nx/vms/api/types/resource_types.h&gt;\n\n#include &quot;resource_data.h&quot;\n\nnamespace nx::vms::api {\n\n/**%apidoc\n * %param[immutable] id Storage unique id. Can be omitted when creating a new object.\n * %param parentId Parent Server unique id.\n * %param[opt] name Arbitrary Storage name.\n * %param url Full Storage url (path to the local folder).\n * %param[proprietary] typeId Should have fixed value.\n *     %value {f8544a40-880e-9442-b78a-9da6db6862b4}\n */\nstruct NX_VMS_API StorageData: ResourceData\n{\n    StorageData(): ResourceData(kResourceTypeId) {}\n\n    static const QString kResourceTypeName;\n    static const nx::Uuid kResourceTypeId;\n\n    /**%apidoc[opt]\n     * Free space to maintain on the Storage, in bytes. Recommended value is 10 gigabytes for local\n     * Storages and 100 gigabytes for NAS.\n     */\n    qint64 spaceLimit = -1;\n\n    /**%apidoc[opt] Whether writing to the Storage is allowed. */\n    bool usedForWriting = false;\n\n    /**%apidoc[opt]\n     * Type of the method to access the Storage.\n     *     %value &quot;local&quot;\n     *     %value &quot;network&quot; Manually mounted NAS.\n     *     %value &quot;smb&quot; Automatically mounted NAS.\n     */\n    QString storageType;\n\n    /**%apidoc[proprietary]\n     * List of Storage additional parameters. Intended for internal use; leave empty when creating\n     * a new Storage.\n     */\n    ResourceParamDataList addParams;\n    ResourceStatus status = ResourceStatus::offline;\n\n    /**%apidoc[opt] Whether the Storage is used for backup. */\n    bool isBackup = false;\n\n    bool operator==(const StorageData&amp; other) const = default;\n};\n#define StorageData_Fields \\\n    ResourceData_Fields \\\n    (spaceLimit) \\\n    (usedForWriting) \\\n    (storageType) \\\n    (addParams) \\\n    (status) \\\n    (isBackup)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(StorageData)\nNX_REFLECTION_INSTRUMENT(StorageData, StorageData_Fields)\n\nstruct NX_VMS_API MediaServerData: ResourceData\n{\n    MediaServerData(): ResourceData(kResourceTypeId) {}\n\n    bool operator==(const MediaServerData&amp; other) const = default;\n\n    static const QString kResourceTypeName;\n    static const nx::Uuid kResourceTypeId;\n\n    QString networkAddresses;\n    ServerFlags flags = SF_None;\n    QString version;\n    QString systemInfo;\n    QString authKey;\n    QString osInfo;\n};\n#define MediaServerData_Fields \\\n    ResourceData_Fields \\\n    (networkAddresses) \\\n    (flags) \\\n    (version) \\\n    (systemInfo) \\\n    (authKey) \\\n    (osInfo)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(MediaServerData)\nNX_REFLECTION_INSTRUMENT(MediaServerData, MediaServerData_Fields)\n\nstruct NX_VMS_API BackupBitrateKey\n{\n    DayOfWeek day = DayOfWeek::monday;\n    int hour = 0;\n\n    bool operator&lt;(const BackupBitrateKey&amp; other) const\n    {\n        if (day != other.day)\n            return day &lt; other.day;\n        return hour &lt; other.hour;\n    }\n\n    bool operator==(const BackupBitrateKey&amp;) const = default;\n};\n#define BackupBitrateKey_Fields \\\n    (day) \\\n    (hour)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(BackupBitrateKey)\nNX_REFLECTION_INSTRUMENT(BackupBitrateKey, BackupBitrateKey_Fields)\n\nusing BackupBitrateBytesPerSecond = QMap&lt;BackupBitrateKey, qint64&gt;;\nconstexpr int64_t kNoRecordingBitrateBps = 0L;\n\ntemplate&lt;typename SerializationContext&gt;\nvoid serialize(\n    SerializationContext* context,\n    const BackupBitrateBytesPerSecond&amp; value)\n{\n    context-&gt;composer.startArray();\n    for (auto it = value.begin(); it != value.end(); ++it)\n    {\n        context-&gt;composer.startObject();\n\n        context-&gt;composer.writeAttributeName(&quot;key&quot;);\n        nx::reflect::BasicSerializer::serializeAdl(context, it.key());\n\n        context-&gt;composer.writeAttributeName(&quot;value&quot;);\n        nx::reflect::BasicSerializer::serializeAdl(context, it.value());\n\n        context-&gt;composer.endObject(/*members*/ 2);\n    }\n    context-&gt;composer.endArray(value.size());\n}\n\nnx::reflect::DeserializationResult NX_VMS_API deserialize(\n    const nx::reflect::json::DeserializationContext&amp; context,\n    BackupBitrateBytesPerSecond* value);\n\ntemplate&lt;typename Matcher&gt;\nbool filter(BackupBitrateBytesPerSecond* data, const nx::reflect::Filter&amp; filter_)\n{\n    if (data-&gt;empty())\n        return false;\n\n    for (const auto&amp; field: filter_.fields)\n    {\n        if (field.name == &quot;key&quot;)\n        {\n            if (!filter_.values.empty())\n            {\n                data-&gt;removeIf(\n                    [&amp;filter_](BackupBitrateBytesPerSecond::Iterator&amp; it)\n                    {\n                        return !Matcher::matches(it.key(), filter_.values);\n                    });\n            }\n            for (const auto&amp; nested: field.fields)\n            {\n                if (nested.name == &quot;day&quot;)\n                {\n                    data-&gt;removeIf(\n                        [&amp;nested](BackupBitrateBytesPerSecond::Iterator&amp; it)\n                        {\n                            return !Matcher::matches(it.key().day, nested.values);\n                        });\n                }\n                else if (NX_ASSERT(nested.name == &quot;hour&quot;, &quot;Unknown filter field %1&quot;, nested.name))\n                {\n                    data-&gt;removeIf(\n                        [&amp;nested](BackupBitrateBytesPerSecond::Iterator&amp; it)\n                        {\n                            return !Matcher::matches(it.key().hour, nested.values);\n                        });\n                }\n            }\n        }\n        else if (NX_ASSERT(field.name == &quot;value&quot;, &quot;Unknown filter field %1&quot;, field.name))\n        {\n            data-&gt;removeIf(\n                [&amp;filter_](BackupBitrateBytesPerSecond::Iterator&amp; it)\n                {\n                    return !Matcher::matches(it.value(), filter_.values);\n                });\n        }\n    }\n    return data-&gt;empty();\n}\n\n/**%apidoc\n * %param[opt]:array backupBitrateBytesPerSecond\n *     Backup bitrate per day of week and hour, as a JSON array of key-value objects, structured\n *     according to the following example:\n *     &lt;pre&gt;&lt;code&gt;\n *     [\n *         {\n *             &quot;key&quot;: { &quot;day&quot;: &quot;DAY_OF_WEEK&quot;, &quot;hour&quot;: HOUR },\n *             &quot;value&quot;: BYTES_PER_SECOND\n *         },\n *         ...\n *     ]\n *     &lt;/code&gt;&lt;/pre&gt;\n *     Here &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; is one of &lt;code&gt;monday&lt;/code&gt;, &lt;code&gt;tuesday&lt;/code&gt;,\n *     &lt;code&gt;wednesday&lt;/code&gt;, &lt;code&gt;thursday&lt;/code&gt;, &lt;code&gt;friday&lt;/code&gt;, &lt;code&gt;saturday&lt;/code&gt;,\n *     &lt;code&gt;sunday&lt;/code&gt;; &lt;code&gt;HOUR&lt;/code&gt; is an integer in range 0..23;\n *     &lt;code&gt;BYTES_PER_SECOND&lt;/code&gt; is an integer that can be represented as a number or a string.\n *     &lt;br/&gt;\n *     For any day-hour position, a missing value means &quot;unlimited bitrate&quot;, and a zero value means\n *     &quot;don&#x27;t perform backup&quot;.\n * %param:object backupBitrateBytesPerSecond[].key\n * %param:enum backupBitrateBytesPerSecond[].key.day\n *     %value monday\n *     %value tuesday\n *     %value wednesday\n *     %value thursday\n *     %value friday\n *     %value saturday\n *     %value sunday\n * %param:integer backupBitrateBytesPerSecond[].key.hour\n *     %example 0\n * %param:string backupBitrateBytesPerSecond[].value\n *     %example 0\n */\nstruct NX_VMS_API MediaServerUserAttributesData\n{\n    /**%apidoc Server unique id. */\n    nx::Uuid serverId;\n\n    /**%apidoc Server name. */\n    QString serverName;\n\n    /**%apidoc Maximum number of cameras on the server. */\n    int maxCameras = 0;\n\n    /**%apidoc\n     * Whether the Server can take Cameras from an offline Server automatically.\n     * %value false\n     * %value true\n     */\n    bool allowAutoRedundancy = false;\n\n    BackupBitrateBytesPerSecond backupBitrateBytesPerSecond;\n    int locationId = 0;\n\n    /** Used by ...Model::toDbTypes() and transaction-description-modify checkers. */\n    CheckResourceExists checkResourceExists = CheckResourceExists::yes; /**&lt;%apidoc[unused] */\n\n    nx::Uuid getIdForMerging() const { return serverId; } //&lt; See IdData::getIdForMerging().\n    nx::Uuid getId() const { return serverId; }\n\n    bool operator==(const MediaServerUserAttributesData&amp; other) const = default;\n\n    static const DeprecatedFieldNames* getDeprecatedFieldNames();\n};\n#define MediaServerUserAttributesData_Fields_Short \\\n    (maxCameras) \\\n    (allowAutoRedundancy) \\\n    (backupBitrateBytesPerSecond)\\\n    (locationId)\n\n#define MediaServerUserAttributesData_Fields \\\n    (serverId) \\\n    (serverName) \\\n    MediaServerUserAttributesData_Fields_Short\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(MediaServerUserAttributesData)\nNX_REFLECTION_INSTRUMENT(MediaServerUserAttributesData, MediaServerUserAttributesData_Fields)\n\nstruct NX_VMS_API MediaServerDataEx:\n    MediaServerData,\n    MediaServerUserAttributesData\n{\n    ResourceStatus status = ResourceStatus::offline;\n    ResourceParamDataList addParams;\n    StorageDataList storages;\n\n    MediaServerDataEx() = default;\n\n    MediaServerDataEx(const MediaServerDataEx&amp;) = default;\n    MediaServerDataEx(MediaServerDataEx&amp;&amp;) = default;\n\n    MediaServerDataEx&amp; operator=(const MediaServerDataEx&amp;) = default;\n    MediaServerDataEx&amp; operator=(MediaServerDataEx&amp;&amp;) = default;\n\n    MediaServerDataEx(const MediaServerData&amp; slice);\n    MediaServerDataEx(MediaServerData&amp;&amp; slice);\n\n    MediaServerDataEx&amp; operator=(const MediaServerData&amp; slice);\n    MediaServerDataEx&amp; operator=(MediaServerData&amp;&amp; slice);\n\n    bool operator==(const MediaServerDataEx&amp; other) const = default;\n};\n#define MediaServerDataEx_Fields  \\\n    MediaServerData_Fields \\\n    MediaServerUserAttributesData_Fields_Short \\\n    (status) \\\n    (addParams) \\\n    (storages)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(MediaServerDataEx)\nNX_REFLECTION_INSTRUMENT(MediaServerDataEx, MediaServerDataEx_Fields)\n\n/**\n * Wrapper to be used for overloading as a distinct type for StorageData api requests.\n */\nclass StorageParentId: public nx::Uuid\n{\npublic:\n    StorageParentId() = default;\n    StorageParentId(const nx::Uuid&amp; id): nx::Uuid(id) {}\n    StorageParentId(const QString&amp; id): nx::Uuid(id) {}\n};\ninline void serialize(\n    nx::reflect::json::SerializationContext* context, const StorageParentId&amp; value)\n{\n    serialize(context, static_cast&lt;const nx::Uuid&amp;&gt;(value));\n}\n\nstruct StorageFilter: IdData\n{\n    using IdData::IdData;\n    StorageFilter(const nx::Uuid&amp; id, const nx::Uuid&amp; serverId): IdData(id), serverId(serverId) {}\n    StorageFilter getId() const { return *this; }\n    bool operator==(const StorageFilter&amp; origin) const = default;\n\n    nx::Uuid serverId;\n};\nQN_FUSION_DECLARE_FUNCTIONS(StorageFilter, (csv_record)(json)(ubjson)(xml), NX_VMS_API)\nNX_REFLECTION_INSTRUMENT(StorageFilter, (id)(serverId))\n\n} // namespace nx::vms::api\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n\n#include &lt;QtCore/QSet&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/json/qt_containers_reflect.h&gt;\n#include &lt;nx/utils/os_info.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/data/saas_data.h&gt;\n#include &lt;nx/vms/api/types/resource_types.h&gt;\n\n#include &quot;data_macros.h&quot;\n#include &quot;os_information.h&quot;\n#include &quot;runtime_data.h&quot;\n#include &quot;server_flags.h&quot;\n#include &quot;server_hardware_info.h&quot;\n#include &quot;server_timezone_information.h&quot;\n#include &quot;software_version_serialization.h&quot;\n#include &quot;timestamp.h&quot;\n\nnamespace nx::vms::api {\n\nNX_REFLECTION_ENUM_CLASS(HwPlatform,\n    unknown = 0,\n    raspberryPi,\n    bananaPi\n)\n\nstruct NX_VMS_API ServerPortInformation\n{\n    int port = 0;\n    nx::Uuid id;\n    bool operator==(const ServerPortInformation&amp; other) const = default;\n};\n#define ServerPortInformation_Fields (port)(id)\nNX_VMS_API_DECLARE_STRUCT_EX(ServerPortInformation, (ubjson)(json)(xml)(csv_record))\nNX_REFLECTION_INSTRUMENT(ServerPortInformation, ServerPortInformation_Fields);\n\nstruct NX_VMS_API ModuleInformationBase: ServerPortInformation\n{\n    QString type;\n    QString customization;\n    QString brand;\n    nx::utils::SoftwareVersion version; /**&lt;%apidoc:string */\n    QString name;\n    bool sslAllowed = true;\n    int protoVersion = 0;\n    nx::Uuid runtimeId;\n    QString realm;\n    QString cloudPortalUrl;\n    QString cloudHost;\n    HwPlatform hwPlatform;\n\n    /**%apidoc Current time synchronized with the VMS Site, in milliseconds since epoch. */\n    std::chrono::milliseconds synchronizedTimeMs{0};\n\n    /**%apidoc Presented if the Site is bound to the Cloud. */\n    std::optional&lt;nx::Uuid&gt; cloudOwnerId;\n    std::optional&lt;nx::Uuid&gt; organizationId;\n    nx::vms::api::SaasState saasState = nx::vms::api::SaasState::uninitialized;\n\n    bool operator==(const ModuleInformationBase&amp; other) const = default;\n};\n\nstruct NX_VMS_API ModuleInformation: ModuleInformationBase\n{\n    ServerFlags serverFlags = {};\n    QString systemName;\n    QString cloudSystemId;\n    nx::Uuid localSystemId;\n    // The field is unused in the code, only for api compatibility.\n    bool ecDbReadOnly = false;\n\n    void fixRuntimeId();\n    QString cloudId() const;\n    bool isNewSystem() const;\n    bool isSaasSystem() const;\n\n    bool operator==(const ModuleInformation&amp; other) const = default;\n\n    static QString mediaServerId();\n    static QString clientId();\n};\n\n#define ModuleInformation_Fields \\\n    (type) \\\n    (customization) \\\n    (version) \\\n    (systemName) \\\n    (name) \\\n    (port) \\\n    (id) \\\n    (sslAllowed) \\\n    (protoVersion) \\\n    (runtimeId) \\\n    (serverFlags) \\\n    (realm) \\\n    (ecDbReadOnly) \\\n    (cloudSystemId) \\\n    (cloudHost) \\\n    (brand) \\\n    (localSystemId) \\\n    (hwPlatform) \\\n    (synchronizedTimeMs) \\\n    (cloudOwnerId) \\\n    (organizationId) \\\n    (saasState)\nNX_VMS_API_DECLARE_STRUCT_EX(ModuleInformation, (ubjson)(json)(xml)(csv_record))\nNX_REFLECTION_INSTRUMENT(ModuleInformation, ModuleInformation_Fields);\n\nstruct NX_VMS_API ModuleInformationWithAddresses: ModuleInformation\n{\n    /**%apidoc:stringArray\n     * If any of these addresses don&#x27;t contain port, ModuleInformation::port must be used.\n     */\n    QSet&lt;QString&gt; remoteAddresses;\n\n    ModuleInformationWithAddresses() = default;\n    ModuleInformationWithAddresses&amp; operator=(const ModuleInformationWithAddresses&amp;) = default;\n    ModuleInformationWithAddresses(const ModuleInformationWithAddresses&amp; other) = default;\n    ModuleInformationWithAddresses(const ModuleInformation&amp; other): ModuleInformation(other) {}\n\n    bool operator==(const ModuleInformationWithAddresses&amp; other) const = default;\n};\n\n#define ModuleInformationWithAddresses_Fields ModuleInformation_Fields (remoteAddresses)\nNX_VMS_API_DECLARE_STRUCT_EX(ModuleInformationWithAddresses, (ubjson)(json)(xml)(csv_record))\nNX_REFLECTION_INSTRUMENT(ModuleInformationWithAddresses, ModuleInformationWithAddresses_Fields);\n\nstruct NX_VMS_API TransactionLogTime\n{\n    int64_t sequence{0};\n    std::chrono::milliseconds ticksMs{0};\n\n    TransactionLogTime(Timestamp t = {}): sequence(t.sequence), ticksMs(t.ticks) {}\n    operator Timestamp() const { return Timestamp(sequence, ticksMs.count()); }\n\n    bool operator==(const TransactionLogTime&amp; other) const = default;\n};\n\n#define TransactionLogTime_Fields (sequence)(ticksMs)\nNX_VMS_API_DECLARE_STRUCT_EX(TransactionLogTime, (json))\nNX_REFLECTION_INSTRUMENT(TransactionLogTime, TransactionLogTime_Fields);\n\nstruct NX_VMS_API ServerInformationBase: ModuleInformationBase\n{\n    /**%apidoc:stringArray\n     * If any of these addresses don&#x27;t contain port, port must be used.\n     */\n    QSet&lt;QString&gt; remoteAddresses;\n    /**%apidoc\n     * The content of a user-provided file `cert.pem` on the Server file system in PEM format\n     * without private key. Empty if not provided or can&#x27;t be loaded and parsed. It is used by\n     * the Server if no Server-specific SNI is required by a Client.\n     */\n    std::string userProvidedCertificatePem;\n\n    /**%apidoc\n     * Server-generated self-signed certificate in PEM format without private key. It is used by\n     * the Server if Server-specific SNI is required by a Client or there is no the user-provided\n     * certificate or the user-provided certificate is invalid.\n     */\n    std::string certificatePem;\n\n    TransactionLogTime transactionLogTime;\n\n    bool collectedByThisServer = false;\n\n    ServerInformationBase() = default;\n    ServerInformationBase(const ServerInformationBase&amp; rhs) = default;\n    ServerInformationBase&amp; operator=(const ServerInformationBase&amp; rhs) = default;\n    ServerInformationBase(ServerInformationBase&amp;&amp; rhs) = default;\n    ServerInformationBase&amp; operator=(ServerInformationBase&amp;&amp; rhs) = default;\n    ServerInformationBase(const ModuleInformationWithAddresses&amp; rhs):\n        ModuleInformationBase(rhs),\n        remoteAddresses(rhs.remoteAddresses)\n    {}\n};\n#define ServerInformationBase_Fields  \\\n    (type) \\\n    (customization) \\\n    (version) \\\n    (name) \\\n    (port) \\\n    (id) \\\n    (sslAllowed) \\\n    (protoVersion) \\\n    (runtimeId) \\\n    (realm) \\\n    (cloudHost) \\\n    (brand) \\\n    (hwPlatform) \\\n    (synchronizedTimeMs) \\\n    (cloudOwnerId) \\\n    (organizationId) \\\n    (saasState)\\\n    (remoteAddresses) \\\n    (userProvidedCertificatePem) \\\n    (certificatePem) \\\n    (transactionLogTime) \\\n    (collectedByThisServer)\n\nNX_VMS_API_DECLARE_STRUCT_AND_LIST_EX(ServerInformationBase, (json))\nNX_REFLECTION_INSTRUMENT(ServerInformationBase, ServerInformationBase_Fields);\n\nstruct NX_VMS_API ServerInformationV4: ServerInformationBase\n{\n    ServerModelFlags serverFlags = {};\n    QString siteName;\n    QString cloudSiteId;\n    nx::Uuid localSiteId;\n    std::chrono::milliseconds identityTimeMs{0};\n\n    ServerInformationV4() = default;\n    ServerInformationV4(const ServerInformationV4&amp; rhs) = default;\n    ServerInformationV4&amp; operator=(const ServerInformationV4&amp; rhs) = default;\n    ServerInformationV4(ServerInformationV4&amp;&amp; rhs) = default;\n    ServerInformationV4&amp; operator=(ServerInformationV4&amp;&amp; rhs) = default;\n\n    ServerInformationV4(const ModuleInformationWithAddresses&amp; rhs);\n\n    ModuleInformation getModuleInformation() const;\n\n    bool isNewSite() const;\n};\n#define ServerInformationV4_Fields  \\\n    ServerInformationBase_Fields \\\n    (serverFlags) \\\n    (siteName) \\\n    (cloudSiteId) \\\n    (localSiteId) \\\n    (identityTimeMs)\n\nNX_VMS_API_DECLARE_STRUCT_AND_LIST_EX(ServerInformationV4, (json))\nNX_REFLECTION_INSTRUMENT(ServerInformationV4, ServerInformationV4_Fields);\n\nstruct NX_VMS_API ServerInformationV1: ServerInformationBase\n{\n    ServerFlags serverFlags = {};\n    QString systemName;\n    QString cloudSystemId;\n    nx::Uuid localSystemId;\n    std::chrono::milliseconds systemIdentityTimeMs{0};\n    // The field is unused in the code, only for api compatibility for v{1-2}.\n    bool ecDbReadOnly = false;\n\n    ServerInformationV1() = default;\n    ServerInformationV1(const ServerInformationV1&amp; rhs) = default;\n    ServerInformationV1&amp; operator=(const ServerInformationV1&amp; rhs) = default;\n    ServerInformationV1(ServerInformationV1&amp;&amp; rhs) = default;\n    ServerInformationV1&amp; operator=(ServerInformationV1&amp;&amp; rhs) = default;\n\n    ServerInformationV1(ServerInformationV4&amp;&amp; rhs);\n\n    ServerInformationV1(const ModuleInformationWithAddresses&amp; rhs);\n\n    ModuleInformation getModuleInformation() const;\n\n    bool isNewSite() const;\n};\n#define ServerInformationV1_Fields  \\\n    ServerInformationBase_Fields \\\n    (serverFlags) \\\n    (systemName) \\\n    (cloudSystemId) \\\n    (localSystemId) \\\n    (systemIdentityTimeMs) \\\n    (ecDbReadOnly)\n\nNX_VMS_API_DECLARE_STRUCT_AND_LIST_EX(ServerInformationV1, (json))\nNX_REFLECTION_INSTRUMENT(ServerInformationV1, ServerInformationV1_Fields);\n\nusing ServerInformation = ServerInformationV4;\n\nstruct NX_VMS_API ServerRuntimeInformation: ServerPortInformation, ServerTimeZoneInformation\n{\n    nx::utils::OsInfo osInfo;\n\n    /**%apidoc Local OS time on the Server, in milliseconds since epoch. */\n    std::chrono::milliseconds osTimeMs{0};\n\n    /**%apidoc Current time synchronized with the VMS Site, in milliseconds since epoch. */\n    std::chrono::milliseconds synchronizedTimeMs{0};\n\n    RuntimeData runtimeData;\n    std::vector&lt;std::string&gt; storageProtocols;\n    ServerHardwareInfo hardware;\n\n    ServerRuntimeInformation() = default;\n    ~ServerRuntimeInformation() = default;\n    ServerRuntimeInformation(const ServerRuntimeInformation&amp; rhs) = default;\n};\n#define ServerRuntimeInformation_Fields \\\n    ServerPortInformation_Fields \\\n    ServerTimeZoneInformation_Fields \\\n    (osInfo)(osTimeMs)(synchronizedTimeMs)(runtimeData)(storageProtocols)(hardware)\nNX_VMS_API_DECLARE_STRUCT_EX(ServerRuntimeInformation, (json))\nNX_REFLECTION_INSTRUMENT(ServerRuntimeInformation, ServerRuntimeInformation_Fields);\n\n} // namespace nx::vms::api\n\nnamespace nx::utils {\n\n// TODO: Invent a better place for it.\n// So far OsInfo serialization is required only for ModuleInformation.\nQN_FUSION_DECLARE_FUNCTIONS(nx::utils::OsInfo, (ubjson)(json)(xml)(csv_record), NX_VMS_API)\n\n} // namespace nx::utils\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/user_data.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/user_data.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/user_data.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;map&gt;\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/latin1_array.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/types/access_rights_types.h&gt;\n\n#include &quot;resource_data.h&quot;\n#include &quot;user_external_id.h&quot;\n\nnamespace nx::vms::api {\n\nNX_REFLECTION_ENUM_CLASS(UserType,\n    /**%apidoc This User is managed by VMS. */\n    local = 0,\n\n    /**%apidoc This User is managed by VMS and has a time limited access by the session token. */\n    temporaryLocal = 3,\n\n    /**%apidoc This User is imported from LDAP Server. */\n    ldap = 1,\n\n    /**%apidoc This is a Cloud User with access to this VMS Site. */\n    cloud = 2\n)\n\nNX_REFLECTION_ENUM_CLASS(UserAttribute,\n    /**%apidoc This User can not be managed from VMS side. */\n    readonly = 1 &lt;&lt; 0,\n\n    /**%apidoc This User should not be shown in user management by default. */\n    hidden = 1 &lt;&lt; 1,\n\n    /**%apidoc Cloud User is a member of an Organization. */\n    organization = 1 &lt;&lt; 2,\n\n    /**%apidoc Cloud User is a member of a Channel Partner. */\n    channelPartner = 1 &lt;&lt; 3,\n\n    /**%apidoc This user belongs to an Integration. */\n    integration = 1 &lt;&lt; 4,\n\n    /**%apidoc[unused] The only possible action for such user is to recreate it. */\n    removed = 1 &lt;&lt; 30\n)\n\nQ_DECLARE_FLAGS(UserAttributes, UserAttribute)\nQ_DECLARE_OPERATORS_FOR_FLAGS(UserAttributes)\n\nconstexpr UserAttributes kCloudUserTypeAttributes =\n    UserAttribute::organization | UserAttribute::channelPartner;\n\n/**%apidoc User information object.\n * %param[readonly] id Internal user identifier. This identifier can be used as {id} path parameter in\n *     requests related to user.\n * %param[proprietary] parentId Should be empty.\n * %param name User name.\n * %param[proprietary] url Should be empty.\n * %param[proprietary] typeId Should have fixed value.\n *     %value {774e6ecd-ffc6-ae88-0165-8f4a6d0eafa7}\n */\nstruct NX_VMS_API UserData: ResourceData\n{\n    UserData(): ResourceData(kResourceTypeId) {}\n\n    UserData(const UserData&amp; other) = default;\n    UserData(UserData&amp;&amp; other) = default;\n    UserData&amp; operator=(const UserData&amp; other) = default;\n    UserData&amp; operator=(UserData&amp;&amp; other) = default;\n    bool operator==(const UserData&amp; other) const = default;\n\n    /** See fillId() in IdData. */\n    void fillId();\n\n    static const QString kResourceTypeName;\n    static const nx::Uuid kResourceTypeId;\n\n    static constexpr const char* kCloudPasswordStub = &quot;password_is_in_cloud&quot;;\n    static constexpr const char* kHttpIsDisabledStub = &quot;http_is_disabled&quot;;\n\n    /**%apidoc[opt] Type of the user. */\n    UserType type = UserType::local;\n\n    /**%apidoc[opt] Whether the user is enabled.*/\n    bool isEnabled = true;\n\n    /**%apidoc[opt] Full name of the user.*/\n    QString fullName;\n\n    /**%apidoc[opt] User&#x27;s email.*/\n    QString email;\n\n    /**%apidoc[opt] Own user global permissions. */\n    GlobalPermissions permissions = GlobalPermission::none;\n\n    /**%apidoc[opt] List of groups to inherit permissions. */\n    std::vector&lt;nx::Uuid&gt; groupIds;\n\n    /**%apidoc[opt] Access rights per Resource or Resource Group. */\n    std::map&lt;nx::Uuid, AccessRights&gt; resourceAccessRights;\n\n    /** Checks if this user is a member of the Administrators group. */\n    bool isAdministrator() const;\n\n    /**%apidoc[proprietary] External identification data (currently used for LDAP only). */\n    UserExternalId externalId;\n\n    /**%apidoc[readonly] */\n    UserAttributes attributes{};\n\n    /**%apidoc[proprietary] HA1 digest hash from user password, as per RFC 2069. When modifying an\n     * existing user, supply empty string. When creating a new user, calculate the value based on\n     * UTF-8 password as follows:\n     * &lt;code&gt;digest = md5_hex(user_name + &quot;:&quot; + realm + &quot;:&quot; + password);&lt;/code&gt;\n     */\n    QnLatin1Array digest;\n\n    /**%apidoc[proprietary] User&#x27;s password hash. When modifying an existing user, supply empty\n     * string. When creating a new user, see QnUserHash for detailed options.\n     */\n    QnLatin1Array hash;\n\n    /**%apidoc[proprietary] Cryptography key hash. Supply empty string when creating, keep the\n     * value when modifying.\n     */\n    QnLatin1Array cryptSha512Hash; /**&lt; Hash suitable to be used in /etc/shadow file.*/\n\n    /**%apidoc[opt]\n     * Preferred locale of the user. Will affect language of the emails and notifications both in\n     * desktop and mobile clients.\n     * %example en_US\n     */\n    QString locale;\n\n    /**%apidoc[opt] List of groups in the Organization to inherit permissions. */\n    std::vector&lt;nx::Uuid&gt; orgGroupIds;\n};\n#define UserData_Fields \\\n    ResourceData_Fields \\\n    (type) \\\n    (isEnabled) \\\n    (fullName) \\\n    (email) \\\n    (permissions) \\\n    (resourceAccessRights) \\\n    (groupIds) \\\n    (externalId) \\\n    (attributes) \\\n    (digest) \\\n    (hash) \\\n    (cryptSha512Hash) \\\n    (locale) \\\n    (orgGroupIds)\nNX_VMS_API_DECLARE_STRUCT_AND_LIST(UserData)\nNX_REFLECTION_INSTRUMENT(UserData, UserData_Fields)\n\n} // namespace nx::vms::api\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;set&gt;\n\n#include &lt;QtCore/QRect&gt;\n#include &lt;QtCore/QVector&gt;\n\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/media/meta_data_packet.h&gt;\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/data/analytics_data.h&gt;\n#include &lt;nx/vms/api/types/motion_types.h&gt;\n\nnamespace nx {\nnamespace common {\nnamespace metadata {\n\n/** Adds more serialization options needed for the Legacy API. */\nstruct NX_VMS_COMMON_API Attribute: nx::vms::api::AnalyticsAttribute\n{\n    using AnalyticsAttribute::AnalyticsAttribute;\n};\n#define Attribute_Fields AnalyticsAttribute_Fields\nQN_FUSION_DECLARE_FUNCTIONS(Attribute, (json)(ubjson)(xml)(csv_record), NX_VMS_COMMON_API);\n\nNX_REFLECTION_INSTRUMENT(Attribute, Attribute_Fields)\n\nNX_VMS_COMMON_API bool operator&lt;(const Attribute&amp; f, const Attribute&amp; s);\nNX_VMS_COMMON_API bool operator==(const Attribute&amp; left, const Attribute&amp; right);\n\nNX_VMS_COMMON_API QString toString(const Attribute&amp;);\n\nusing Attributes = std::vector&lt;Attribute&gt;;\n\nNX_VMS_COMMON_API void addAttributeIfNotExists(Attributes* result, const Attribute&amp; a);\nNX_VMS_COMMON_API Attributes::iterator findFirstAttributeByName(Attributes* a, const QString&amp; name);\nNX_VMS_COMMON_API Attributes::const_iterator findFirstAttributeByName(\n    const Attributes* a, const QString&amp; name);\n\nstruct RangePoint\n{\n    float value = 0.0;\n    bool inclusive = false;\n};\n\nstruct NX_VMS_COMMON_API NumericRange\n{\n    NumericRange() = default;\n    NumericRange(float value):\n        from(RangePoint{value, true}),\n        to(RangePoint{value, true})\n    {\n    }\n\n    NumericRange(std::optional&lt;RangePoint&gt; from, std::optional&lt;RangePoint&gt; to):\n        from(std::move(from)), to(std::move(to))\n    {\n    }\n\n    bool intersects(const NumericRange&amp; range) const;\n    bool hasRange(const NumericRange&amp; range) const;\n    QString stringValue() const;\n    bool isNull() const { return !from &amp;&amp; !to; }\n\n    std::optional&lt;RangePoint&gt; from;\n    std::optional&lt;RangePoint&gt; to;\n};\n\nstruct NX_VMS_COMMON_API AttributeEx\n{\n    QString name;\n    std::variant&lt;QString, NumericRange&gt; value;\n\n    AttributeEx() = default;\n    AttributeEx(const Attribute&amp; attribute);\n\n    static NumericRange parseRangeFromValue(const QString&amp; value);\n    static bool isNumberOrRange(const QString&amp; attributeName, const QString&amp; attributeValue);\n\n    void addRange(const NumericRange&amp; range);\n    QString stringValue() const;\n};\n\nstruct AttributeGroup\n{\n    QString name;\n    QStringList values;\n};\n\nNX_VMS_COMMON_API bool operator==(const AttributeGroup&amp; left, const AttributeGroup&amp; right);\n\nusing GroupedAttributes = QVector&lt;AttributeGroup&gt;; //&lt; QVector for implicit sharing in the UI.\n\nNX_VMS_COMMON_API GroupedAttributes groupAttributes(\n    const Attributes&amp; attributes,\n    bool humanReadableNames = true, //&lt; If true, replaces dots with spaces.\n    bool filterOutHidden = true);\n\n//-------------------------------------------------------------------------------------------------\nstatic constexpr int kCoordinateDecimalDigits = 4;\n\n/**%apidoc Describes whether the image should be loaded from the VMS Archive or an Integration. */\nNX_REFLECTION_ENUM_CLASS(ImageLocation,\n    undefined,\n\n    /**%apidoc The image is loaded from the VMS Archive. */\n    internal,\n\n    /**%apidoc The image is read from an Integration. */\n    external\n)\nstruct BaseMetadata\n{\n    /**%apidoc Unique track Id. */\n    nx::Uuid trackId;\n\n    /**%apidoc:object Bounding box of the object. JSON object containing top-left corner (fields `x`\n     * and `y`), `width` and `height`. Relative coordinates are in range [0;1].\n     */\n    QRectF boundingBox;\n};\n#define BaseMetadata_Fields (trackId)(boundingBox)\n\n/**\n * Designed to match IObjectMetadata, and Best Shots are yielded by an Integration as\n * IObjectTrackBestShotPacket which has no relation to IObjectMetadata.\n */\nstruct ObjectMetadata: BaseMetadata\n{\n    /**%apidoc Object type.\n     * %example car\n     */\n    QString typeId;\n\n    /**%apidoc Metadata attributes. */\n    std::vector&lt;Attribute&gt; attributes;\n};\n#define ObjectMetadata_Fields BaseMetadata_Fields (typeId) (attributes)\nQN_FUSION_DECLARE_FUNCTIONS(ObjectMetadata, (json)(ubjson), NX_VMS_COMMON_API);\nNX_VMS_COMMON_API bool operator==(const ObjectMetadata&amp; left, const ObjectMetadata&amp; right);\nNX_VMS_COMMON_API QString toString(const ObjectMetadata&amp; object);\nNX_REFLECTION_INSTRUMENT(ObjectMetadata, ObjectMetadata_Fields)\n\n//-------------------------------------------------------------------------------------------------\n\nstruct NX_VMS_COMMON_API BestShotMetadata: public BaseMetadata\n{\n    ImageLocation location = ImageLocation::internal;\n    std::vector&lt;Attribute&gt; attributes;\n\n    BestShotMetadata() = default;\n    BestShotMetadata(const BaseMetadata&amp; base): BaseMetadata(base) {}\n};\n#define BestShotMetadata_Fields BaseMetadata_Fields (location)(attributes)\nQN_FUSION_DECLARE_FUNCTIONS(BestShotMetadata, (json)(ubjson), NX_VMS_COMMON_API);\nNX_VMS_COMMON_API QString toString(const BestShotMetadata&amp; object);\nNX_REFLECTION_INSTRUMENT(BestShotMetadata, BestShotMetadata_Fields)\n\n//-------------------------------------------------------------------------------------------------\n\nstruct NX_VMS_COMMON_API TitleMetadata: public BaseMetadata\n{\n    ImageLocation location = ImageLocation::internal;\n    QString text;\n\n    TitleMetadata(const BaseMetadata&amp; base) : BaseMetadata(base) {}\n    TitleMetadata() = default;\n};\n#define TitleMetadata_Fields BaseMetadata_Fields (location)(text)\nQN_FUSION_DECLARE_FUNCTIONS(TitleMetadata, (json)(ubjson), NX_VMS_COMMON_API);\nQN_FUSION_DECLARE_FUNCTIONS(TitleMetadata, (json)(ubjson), NX_VMS_COMMON_API);\nNX_VMS_COMMON_API QString toString(const TitleMetadata&amp; object);\nNX_REFLECTION_INSTRUMENT(TitleMetadata, TitleMetadata_Fields)\n\n//-------------------------------------------------------------------------------------------------\n\n/**%apidoc Analytics metadata packet representing an Object on a given video frame. */\nstruct NX_VMS_COMMON_API ObjectMetadataPacket\n{\n    /**%apidoc Device id. */\n    nx::Uuid deviceId;\n\n    /**%apidoc UTC timestamp in microseconds. */\n    qint64 timestampUs = 0;\n\n    /**%apidoc[opt] Duration of the object in microseconds. */\n    qint64 durationUs = 0;\n\n    std::vector&lt;ObjectMetadata&gt; objectMetadataList;\n    std::optional&lt;BestShotMetadata&gt; bestShot;\n    std::optional&lt;TitleMetadata&gt; title;\n\n    /**%apidoc[opt] Video stream from which analytics data was received. */\n    nx::vms::api::StreamIndex streamIndex = nx::vms::api::StreamIndex::undefined;\n\n\n    nx::Uuid analyticsEngineId;\n\n    bool isEmpty() const { return objectMetadataList.empty() &amp;&amp; !bestShot &amp;&amp; !title; }\n};\n\n#define ObjectMetadataPacket_Fields (deviceId) \\\n    (timestampUs) \\\n    (durationUs) \\\n    (objectMetadataList) \\\n    (bestShot) \\\n    (title) \\\n    (streamIndex) \\\n    (analyticsEngineId)\n\nQN_FUSION_DECLARE_FUNCTIONS(ObjectMetadataPacket, (json)(ubjson), NX_VMS_COMMON_API);\n\nNX_REFLECTION_INSTRUMENT(ObjectMetadataPacket, ObjectMetadataPacket_Fields)\n\nNX_VMS_COMMON_API bool operator==(const ObjectMetadataPacket&amp; left, const ObjectMetadataPacket&amp; right);\n\nusing ObjectMetadataPacketPtr = std::shared_ptr&lt;ObjectMetadataPacket&gt;;\nusing ConstObjectMetadataPacketPtr = std::shared_ptr&lt;const ObjectMetadataPacket&gt;;\n\nNX_VMS_COMMON_API bool operator&lt;(\n    const ObjectMetadataPacket&amp; first,\n    const ObjectMetadataPacket&amp; second);\nNX_VMS_COMMON_API bool operator&lt;(std::chrono::microseconds first, const ObjectMetadataPacket&amp; second);\nNX_VMS_COMMON_API bool operator&lt;(const ObjectMetadataPacket&amp; first, std::chrono::microseconds second);\n\nNX_VMS_COMMON_API QString toString(const ObjectMetadataPacket&amp; packet);\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Contains the binary data for the records from ObjectMetadataPacket which have the same Object\n * Type.\n */\nclass NX_VMS_COMMON_API QnCompressedObjectMetadataPacket: public QnCompressedMetadata\n{\npublic:\n    using base_type = QnCompressedMetadata;\n\n    using QnCompressedMetadata::QnCompressedMetadata;\n\n    virtual QnAbstractMediaData* clone() const override;\n\n    /**\n     * Reference to the source (non-compressed) packet. Multiple compressed packets can share\n     * the same non-compressed source packet, when they are formed via splitting the source packet\n     * by Object Types.\n     */\n    ConstObjectMetadataPacketPtr packet;\n\nprivate:\n    void assign(const QnCompressedObjectMetadataPacket* other);\n};\nusing QnCompressedObjectMetadataPacketPtr = std::shared_ptr&lt;QnCompressedObjectMetadataPacket&gt;;\nusing QnConstCompressedObjectMetadataPacketPtr = std::shared_ptr&lt;const QnCompressedObjectMetadataPacket&gt;;\n\nNX_VMS_COMMON_API ObjectMetadataPacketPtr fromCompressedMetadataPacket(\n    const QnConstCompressedMetadataPtr&amp;);\n\n} // namespace metadata\n} // namespace common\n} // namespace nx\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/db/abstract_object_type_dictionary.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/db/abstract_object_type_dictionary.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/db/abstract_object_type_dictionary.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;optional&gt;\n\n#include &lt;QtCore/QString&gt;\n\nnamespace nx::analytics::db {\n\nclass AbstractObjectTypeDictionary\n{\npublic:\n    virtual ~AbstractObjectTypeDictionary() = default;\n\n    /**\n     * NOTE: This function is not expected to block.\n     * Doing so may degrade analytics DB performance significantly.\n     */\n    virtual std::optional&lt;QString&gt; idToName(const QString&amp; id) const = 0;\n};\n\n} // namespace nx::analytics::db\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QMetaType&gt;\n#include &lt;QtCore/QStringList&gt;\n\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/string.h&gt;\n#include &lt;nx/utils/json/flags.h&gt;\n#include &lt;nx/vms/api/types/access_rights_types.h&gt;\n#include &lt;nx/vms/api/types/audit_record_type.h&gt;\n#include &lt;nx/vms/api/types/motion_types.h&gt;\n#include &lt;nx/vms/api/types/resource_types.h&gt;\n\nnamespace Qn {\n    Q_NAMESPACE_EXPORT(NX_VMS_COMMON_API)\n\n    NX_REFLECTION_ENUM(ExtrapolationMode,\n        ConstantExtrapolation,\n        LinearExtrapolation,\n        PeriodicExtrapolation\n    )\n    Q_ENUM_NS(ExtrapolationMode)\n\n    NX_REFLECTION_ENUM(BackupState,\n        BackupState_None = 0,\n        BackupState_InProgress = 1\n    )\n\n    enum Projection {\n        RectilinearProjection,\n        EquirectangularProjection\n    };\n\n    NX_REFLECTION_ENUM(PanicMode,\n        PM_None = 0,\n        PM_BusinessEvents = 1\n    )\n\n    NX_REFLECTION_ENUM(ConnectionRole,\n        CR_Default,         /// In client this flag is sufficient to receive both archive and live video\n        CR_LiveVideo,\n        CR_SecondaryLiveVideo,\n        CR_Archive,\n        CR_SeamlessArchive\n    )\n\n    NX_VMS_COMMON_API nx::vms::api::StreamIndex toStreamIndex(ConnectionRole role);\n\n    Qn::ConnectionRole fromStreamIndex(nx::vms::api::StreamIndex streamIndex);\n\n    // TODO: #sivanov Split to server-only and client-only flags as they are always local.\n    enum ResourceFlag\n    {\n        none = 0, /**&lt; No flags. */\n        network = 1 &lt;&lt; 0, /**&lt; Has ip and mac. */\n        url = 1 &lt;&lt; 1, /**&lt; Has url, e.g. file name. */\n        media = 1 &lt;&lt; 2,\n        playback = 1 &lt;&lt; 3, /**&lt; Something playable (not real time and not a single shot). */\n        video = 1 &lt;&lt; 4,\n        audio = 1 &lt;&lt; 5,\n        live = 1 &lt;&lt; 6,\n\n        still_image = 1 &lt;&lt; 7, /**&lt; Still image device. */\n        local = 1 &lt;&lt; 8, /**&lt; Local client resource. */\n        server = 1 &lt;&lt; 9, /**&lt; Server resource. */\n        remote = 1 &lt;&lt; 10, /**&lt; Remote (on-server) resource. */\n\n        layout = 1 &lt;&lt; 11, /**&lt; Layout resource. */\n        user = 1 &lt;&lt; 12, /**&lt; User resource. */\n        utc = 1 &lt;&lt; 13, /**&lt; Uses UTC-based timing. */\n        periods = 1 &lt;&lt; 14, /**&lt; Has recorded periods. */\n        motion = 1 &lt;&lt; 15, /**&lt; Has motion */\n        sync = 1 &lt;&lt; 16, /**&lt; Can be used in sync playback mode. */\n\n        // Server-only flag.\n        foreigner = 1 &lt;&lt; 17, /**&lt; Belongs to other entity, e.g., camera on another server */\n\n        // Client-only flag.\n        /**\n         * Fake server (belonging to other system) / Intercom layout, while it is local / User /\n         * Desktop camera preloader (before it is updated by server, by creation real Desktop\n         * camera).\n         */\n        fake = 1 &lt;&lt; 18,\n\n        videowall = 1 &lt;&lt; 19, /**&lt; Videowall resource */\n        desktop_camera = 1 &lt;&lt; 20, /**&lt; Desktop Camera resource */\n\n        // Server-only flag.\n        need_recreate = 1 &lt;&lt; 21, /**&lt; Camera discovery internal purpose. Server-only flag. */\n\n        // Server-only flag.\n        search_upd_only = 1 &lt;&lt; 22, /**&lt; Disable to insert new resource during discovery process,\n                                        allow update only */\n\n        io_module = 1 &lt;&lt; 23, /**&lt; I/O module device (camera subtype) */\n        read_only = 1 &lt;&lt; 24, /**&lt; Resource is read-only by design. */\n\n        // Server-only flag.\n        storage_fastscan = 1 &lt;&lt; 25, /**&lt; Fast scan for storage in progress */\n\n        // Client-only flag.\n        exported = 1 &lt;&lt; 26, /**&lt; Exported media file. */\n\n        removed = 1 &lt;&lt; 27, /**&lt; Resource is already removed from the resource pool. */\n\n        virtual_camera = 1 &lt;&lt; 28, /**&lt; Virtual camera resource. */\n\n        /**\n         * Cross-system Resource, e.g. Camera from another System or it&#x27;s parent Server. Cloud\n         * Layouts are also considered as cross-system Resources.\n         */\n        cross_system = 1 &lt;&lt; 29,\n\n        /**\n         * Do not generate periodic(auto) thumbnails for camera\n         */\n        no_periodic_thumbnails = 1 &lt;&lt; 30,\n\n        local_media = local | media | url,\n        exported_media = local_media | exported,\n\n        local_layout = local | layout,\n        exported_layout = local_layout | url | exported,\n        local_intercom_layout = Qn::layout | Qn::local | Qn::fake,\n\n        local_server = local | server,\n        remote_server = remote | server,\n\n        live_cam = utc | sync | live | media | video, // don&#x27;t set w/o `local` or `remote` flag\n        local_live_cam = live_cam | local | network,\n        server_live_cam = live_cam | remote, // | network,\n        local_video = local_media | video | audio, /**&lt; Local media file. */\n        local_image = local_media | still_image, /**&lt; Local still image file. */\n\n        web_page = url | remote, /**&lt; Web-page resource */\n    };\n    Q_DECLARE_FLAGS(ResourceFlags, ResourceFlag)\n    Q_FLAG_NS(ResourceFlags)\n    Q_DECLARE_OPERATORS_FOR_FLAGS(ResourceFlags)\n\n    // TODO: Move to the client code.\n    /** Level of detail for displaying resource info. */\n    enum ResourceInfoLevel\n    {\n        /**%apidoc[unused] */\n        RI_Invalid,\n\n        /**%apidoc\n         * Only resource name\n         * %caption nameOnly\n         */\n        RI_NameOnly,\n\n        /**%apidoc\n         * Resource name and url (if exist)\n         * %caption withUrl\n         */\n        RI_WithUrl,\n\n        /**%apidoc\n         * All info\n         * %caption full\n         */\n        RI_FullInfo\n    };\n\n    template&lt;typename Visitor&gt;\n    constexpr auto nxReflectVisitAllEnumItems(ResourceInfoLevel*, Visitor&amp;&amp; visitor)\n    {\n        using Item = nx::reflect::enumeration::Item&lt;ResourceInfoLevel&gt;;\n        return visitor(\n            Item{RI_Invalid, &quot;&quot;},\n            Item{RI_NameOnly, &quot;nameOnly&quot;},\n            Item{RI_WithUrl, &quot;withUrl&quot;},\n            Item{RI_FullInfo, &quot;full&quot;}\n        );\n    }\n\n    NX_REFLECTION_ENUM_CLASS(StatusChangeReason,\n        Local,\n        GotFromRemotePeer\n    )\n\n    enum IOPortType\n    {\n        /**%apidoc\n         * %caption Unknown\n         */\n        PT_Unknown = 0x0,\n\n        /**%apidoc\n         * %caption Disabled\n         */\n        PT_Disabled = 0x1,\n\n        /**%apidoc\n         * %caption Input\n         */\n        PT_Input = 0x2,\n\n        /**%apidoc\n         * %caption Output\n         */\n        PT_Output = 0x4\n    };\n\n    template&lt;typename Visitor&gt;\n    constexpr auto nxReflectVisitAllEnumItems(IOPortType*, Visitor&amp;&amp; visitor)\n    {\n        using Item = nx::reflect::enumeration::Item&lt;IOPortType&gt;;\n        return visitor(\n            Item{PT_Unknown, &quot;Unknown&quot;},\n            Item{PT_Disabled, &quot;Disabled&quot;},\n            Item{PT_Input, &quot;Input&quot;},\n            Item{PT_Output, &quot;Output&quot;}\n        );\n    }\n\n    Q_DECLARE_FLAGS(IOPortTypes, IOPortType)\n    Q_DECLARE_OPERATORS_FOR_FLAGS(IOPortTypes)\n\n    NX_REFLECTION_ENUM(LegacyAuditRecordType,\n        AR_NotDefined = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::notDefined),\n        AR_UnauthorizedLogin = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::unauthorizedLogin),\n        AR_Login = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::login),\n        AR_UserUpdate = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::userUpdate),\n        AR_ViewLive = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::viewLive),\n        AR_ViewArchive = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::viewArchive),\n        AR_ExportVideo = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::exportVideo),\n        AR_CameraUpdate = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::deviceUpdate),\n        AR_SystemNameChanged = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::siteNameChanged),\n        AR_SystemmMerge = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::siteMerge),\n        AR_SettingsChange = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::settingsChange),\n        AR_ServerUpdate = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::serverUpdate),\n        AR_BEventUpdate = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::eventUpdate),\n        AR_EmailSettings = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::emailSettings),\n        AR_CameraRemove = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::deviceRemove),\n        AR_ServerRemove = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::serverRemove),\n        AR_BEventRemove = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::eventRemove),\n        AR_UserRemove = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::userRemove),\n        AR_DatabaseRestore = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::databaseRestore),\n        AR_CameraInsert = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::deviceInsert),\n        AR_UpdateInstall = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::updateInstall),\n        AR_StorageInsert = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::storageInsert),\n        AR_StorageUpdate = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::storageUpdate),\n        AR_StorageRemove = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::storageRemove),\n        AR_MitmAttack = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::mitmAttack),\n        AR_CloudBind = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::cloudBind),\n        AR_CloudUnbind = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::cloudUnbind),\n        AR_ProxySession = static_cast&lt;int&gt;(nx::vms::api::AuditRecordType::proxySession)\n    )\n    Q_DECLARE_FLAGS(LegacyAuditRecordTypes, LegacyAuditRecordType)\n    Q_DECLARE_OPERATORS_FOR_FLAGS(LegacyAuditRecordTypes)\n\n    enum IODefaultState {\n        IO_OpenCircuit,\n        IO_GroundedCircuit\n    };\n\n    template&lt;typename Visitor&gt;\n    constexpr auto nxReflectVisitAllEnumItems(IODefaultState*, Visitor&amp;&amp; visitor)\n    {\n        using Item = nx::reflect::enumeration::Item&lt;IODefaultState&gt;;\n        return visitor(\n            Item{IO_OpenCircuit, &quot;Open Circuit&quot;},\n            Item{IO_GroundedCircuit, &quot;Grounded circuit&quot;}\n        );\n    }\n\n    enum TimePeriodContent {\n        RecordingContent,\n        MotionContent,\n        AnalyticsContent,\n\n        TimePeriodContentCount\n    };\n    Q_ENUM_NS(TimePeriodContent)\n\n    using StreamQuality = nx::vms::api::StreamQuality;\n\n    enum class BitrateControl {\n        undefined,\n        cbr,\n        vbr\n    };\n\n    enum class EncodingPriority {\n        undefined,\n        framerate,\n        compressionLevel\n    };\n\n    enum class EntropyCoding {\n        undefined,\n        cavlc,\n        cabac\n    };\n\n    NX_REFLECTION_ENUM(StatisticsDeviceType,\n        StatisticsCPU = 0, /**&lt; CPU load in percents. */\n        StatisticsRAM = 1, /**&lt; RAM load in percents. */\n        StatisticsHDD = 2, /**&lt; HDD load in percents. */\n        StatisticsNETWORK = 3 /**&lt; Network load in percent. */\n    )\n\n    using CameraStatusFlag = nx::vms::api::CameraStatusFlag;\n    using CameraStatusFlags = nx::vms::api::CameraStatusFlags;\n\n    using RecordingType = nx::vms::api::RecordingType;\n    using RecordingMetadataType = nx::vms::api::RecordingMetadataType;\n    using RecordingMetadataTypes = nx::vms::api::RecordingMetadataTypes;\n\n    NX_REFLECTION_ENUM(LicenseType,\n        /**\n         * Includes free license, which each user can activate once, and demo licenses, which are\n         * provided by the support team on user&#x27;s request.\n         */\n        LC_Trial,\n\n        LC_Analog,\n        LC_Professional,\n        LC_Edge,\n        LC_VMAX,\n        LC_AnalogEncoder,\n        LC_VideoWall,\n\n        /**\n         * I/O Modules license.\n         * Needs to be activated to enable I/O module features. One license channel per one module.\n         */\n        LC_IO,\n\n        /**\n         * Like a professional license.\n         * Only one license key per system (not server). If systems are merged and each of them had\n         * some start licenses originally, new merged system will only take one start license (the\n         * one with bigger number of channels). Other start licenses will become invalid.\n         */\n        LC_Start,\n\n        /**\n         * A camera with Free License can be recorded without License activation. It is always\n         * available for use.\n         */\n        LC_Free,\n\n        /**\n         * For all new DVR/NVR devices except of VMAX\n         */\n        LC_Bridge,\n\n        /**\n         * Like a professional license.\n         * Only one license key per system (not server). If systems are merged and each of them had\n         * some NVR licenses originally, new merged system will only take one NVR license (the one\n         * with bigger number of channels). Other NVR licenses will become invalid.\n         */\n        LC_Nvr,\n\n        /**\n         * Saas local recording service.\n         */\n        LC_SaasLocalRecording,\n\n        /**\n         * Invalid license. Required when the correct license type is not known in current version.\n         */\n        LC_Invalid,\n\n        LC_Count\n    )\n\n    using FailoverPriority = nx::vms::api::FailoverPriority;\n\n    enum StorageInitResult\n    {\n        /**%apidoc\n         * %caption Ok\n         */\n        StorageInit_Ok,\n\n        /**%apidoc\n         * %caption CreateFailed\n         */\n        StorageInit_CreateFailed,\n\n        /**%apidoc\n         * %caption InitFailed_WrongPath\n         */\n        StorageInit_WrongPath,\n\n        /**%apidoc\n         * %caption InitFailed_WrongAuth\n         */\n        StorageInit_WrongAuth,\n    };\n\n    template&lt;typename Visitor&gt;\n    constexpr auto nxReflectVisitAllEnumItems(StorageInitResult*, Visitor&amp;&amp; visitor)\n    {\n        using Item = nx::reflect::enumeration::Item&lt;StorageInitResult&gt;;\n        return visitor(\n            Item{StorageInit_Ok, &quot;Ok&quot;},\n            Item{StorageInit_CreateFailed, &quot;CreateFailed&quot;},\n            Item{StorageInit_WrongPath, &quot;InitFailed_WrongPath&quot;},\n            Item{StorageInit_WrongAuth, &quot;InitFailed_WrongAuth&quot;}\n        );\n    }\n\n    /**\n     * Flags describing the actions permitted for the user/role to do with the selected resource.\n     * Calculated in runtime.\n     */\n    NX_REFLECTION_ENUM(Permission,\n        //-----------------------------------------------------------------------------------------\n        //  Generic resource permissions.\n\n        // No access.\n        NoPermissions = 0,\n\n        // Generic read access. Having this permission doesn&#x27;t necessary mean that all\n        // information is readable. See resource-specific permissions below. By default this means\n        // that this resource will be available in server api replies (e.g. FullInfo)\n        ReadPermission = 1 &lt;&lt; 0,\n\n        // Generic write access. Having this permission doesn&#x27;t necessary mean that all\n        // information is writable. See resource-specific permissions below. Actual only on the\n        // client side. By default this means we can modify the resource somehow.\n        WritePermission = 1 &lt;&lt; 1,\n\n        // Generic save access. Resource can be saved to the server database. Actual both on the\n        // client and the server side.\n        SavePermission = 1 &lt;&lt; 2,\n\n        // Generic delete permission. Resource can be deleted from the server database.\n        RemovePermission = 1 &lt;&lt; 3,\n\n        // Permission to edit resource&#x27;s name.\n        WriteNamePermission = 1 &lt;&lt; 4,\n\n        // Alias for common set of generic permissions.\n        ReadWriteSavePermission = ReadPermission | WritePermission | SavePermission,\n\n        // Alias for generic edit set of permissions.\n        GenericEditPermissions = WritePermission | WriteNamePermission | SavePermission,\n\n        // Alias for full set of generic permissions.\n        FullGenericPermissions = ReadWriteSavePermission | RemovePermission | WriteNamePermission,\n\n        /**\n         * Generic permission to view actual resource content.\n         * Actually that means we can open widget with this resource&#x27;s content on the scene.\n         *  - cameras &amp; devices: can be opened on the scene with live and/or archive access\n         *      (comes with ViewLivePermission or ViewFootagePermission or both)\n         *  - servers: health monitor widgets can be opened on the scene\n         *  - web pages: can be opened on the scene\n         *  - layouts: can be opened on the scene or placed on a showreel\n         *      (doesn&#x27;t mean that layout items also have this permission)\n         *  - videowalls: can be opened on the scene as a videowall review layout\n         */\n        ViewContentPermission = 1 &lt;&lt; 5,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // Webpage-specific permissions.\n\n        FullWebPagePermissions = FullGenericPermissions | ViewContentPermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // Server-specific permissions.\n\n        // Full set of permissions which can be available for the server resource.\n        FullServerPermissions = FullGenericPermissions | ViewContentPermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // Layout-specific permissions.\n\n         // Permission to add or remove items from a layout.\n        AddRemoveItemsPermission = 1 &lt;&lt; 6,\n\n        // Permission to setup layout background or set locked flag.\n        EditLayoutSettingsPermission = 1 &lt;&lt; 7,\n\n        // Permission set to modify without saving.\n        ModifyLayoutPermissions = ReadPermission\n            | WritePermission\n            | ViewContentPermission\n            | AddRemoveItemsPermission,\n\n        // Full set of permissions which can be available for the layout resource.\n        FullLayoutPermissions = FullGenericPermissions\n            | ViewContentPermission\n            | AddRemoveItemsPermission\n            | EditLayoutSettingsPermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // User-specific permissions.\n\n        // Permission to enable or disable digest.\n        WriteDigestPermission = 1 &lt;&lt; 8,\n\n        // Permission to edit associated password.\n        WritePasswordPermission = 1 &lt;&lt; 9,\n\n        // Permission to edit access rights.\n        WriteAccessRightsPermission = 1 &lt;&lt; 10,\n\n        // Permission to edit user&#x27;s email.\n        WriteEmailPermission = 1 &lt;&lt; 11,\n\n        // Permission to edit user&#x27;s full name.\n        WriteFullNamePermission = 1 &lt;&lt; 12,\n\n        // Permission to edit user&#x27;s locale.\n        WriteLocalePermission = 1 &lt;&lt; 13,\n\n        // Full set of permissions which can be available for the user resource.\n        FullUserPermissions = FullGenericPermissions\n            | WritePasswordPermission\n            | WriteDigestPermission\n            | WriteAccessRightsPermission\n            | WriteFullNamePermission\n            | WriteEmailPermission\n            | WriteLocalePermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // Media-specific permissions.\n\n        // Permission to view camera&#x27;s live stream.\n        ViewLivePermission = 1 &lt;&lt; 14,\n\n        // Permission to view camera&#x27;s footage.\n        ViewFootagePermission = 1 &lt;&lt; 15,\n\n        // Permission to export video parts.\n        ExportPermission = 1 &lt;&lt; 16,\n\n        // Permission to use camera&#x27;s PTZ controls.\n        WritePtzPermission = 1 &lt;&lt; 17,\n\n        // Permission to view camera bookmarks.\n        ViewBookmarksPermission = 1 &lt;&lt; 18,\n\n        // Permission to edit camera bookmarks.\n        ManageBookmarksPermission = 1 &lt;&lt; 19,\n\n        // Permission to toggle I/O module inputs.\n        DeviceInputPermission = 1 &lt;&lt; 20,\n\n        // Permission to invoke soft triggers.\n        SoftTriggerPermission = 1 &lt;&lt; 21,\n\n        // Permission to use two-way audio.\n        TwoWayAudioPermission = 1 &lt;&lt; 22,\n\n        // Permission to play sound from a camera\n        // (used in combination with ViewLivePermission and/or ViewFootagePermission).\n        PlayAudioPermission = 1 &lt;&lt; 23,\n\n        // Permission granted by userInput access right.\n        UserInputPermissions = WritePtzPermission\n            | DeviceInputPermission\n            | SoftTriggerPermission\n            | TwoWayAudioPermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        //-----------------------------------------------------------------------------------------\n        // Mode-specific permissions.\n\n        // Layout access permission for the running videowall instance.\n        VideoWallLayoutPermissions = ModifyLayoutPermissions,\n\n        // Locked layout access permission for the running videowall instance.\n        VideoWallLockedLayoutPermissions = ModifyLayoutPermissions\n            &amp;~ (AddRemoveItemsPermission | WriteNamePermission),\n\n        // Media access permission for the running videowall instance.\n        // PTZ is intended here.\n        VideoWallMediaPermissions = ReadPermission\n            | ViewContentPermission\n            | ViewLivePermission\n            | ViewFootagePermission\n            | WritePtzPermission,\n\n        //-----------------------------------------------------------------------------------------\n\n        // All eventually possible permissions.\n        AllPermissions = 0xFFFFFFFF\n    )\n\n    Q_DECLARE_FLAGS(Permissions, Permission)\n    Q_DECLARE_OPERATORS_FOR_FLAGS(Permissions)\n\n    NX_REFLECTION_ENUM_CLASS(FisheyeCameraProjection,\n        equidistant,\n        stereographic,\n        equisolid\n    )\n\n    inline size_t qHash(FisheyeCameraProjection value, size_t seed = 0)\n    {\n        return ::qHash(int(value), seed);\n    }\n\n    /**\n     * Helper function that can be used to &#x27;place&#x27; macros into Qn namespace.\n     */\n    template&lt;class T&gt;\n    const T &amp;_id(const T &amp;value) { return value; }\n\n    const static QLatin1String kWallpapersFolder(&quot;wallpapers&quot;);\n\n    inline QString toString(nx::vms::api::StreamIndex streamIndex)\n    {\n        switch (streamIndex)\n        {\n            case nx::vms::api::StreamIndex::primary:\n                return &quot;primary&quot;;\n            case nx::vms::api::StreamIndex::secondary:\n                return &quot;secondary&quot;;\n            default:\n                return &quot;undefined&quot;;\n        }\n    }\n\n    /** Debug representation. */\n    NX_VMS_COMMON_API QString toString(Qn::TimePeriodContent value);\n\n} // namespace Qn\n\nusing nx::vms::api::GlobalPermission;\nusing nx::vms::api::GlobalPermissions;\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/camera_resource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/camera_resource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/camera_resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;deque&gt;\n#include &lt;set&gt;\n\n#include &lt;QtCore/QElapsedTimer&gt;\n\n#include &lt;api/model/api_ioport_data.h&gt;\n#include &lt;common/common_globals.h&gt;\n#include &lt;core/dataprovider/live_stream_params.h&gt;\n#include &lt;core/misc/schedule_task.h&gt;\n#include &lt;core/ptz/ptz_constants.h&gt;\n#include &lt;core/resource/camera_media_stream_info.h&gt;\n#include &lt;core/resource/media_resource.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/core/resource/using_media2_type.h&gt;\n#include &lt;nx/fusion/model_functions_fwd.h&gt;\n#include &lt;nx/network/socket_common.h&gt;\n#include &lt;nx/utils/lockable.h&gt;\n#include &lt;nx/utils/mac_address.h&gt;\n#include &lt;nx/utils/safe_direct_connection.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/url.h&gt;\n#include &lt;nx/utils/value_cache.h&gt;\n#include &lt;nx/vms/api/analytics/device_agent_manifest.h&gt;\n#include &lt;nx/vms/api/data/device_model.h&gt;\n#include &lt;nx/vms/api/data/device_profile.h&gt;\n#include &lt;nx/vms/api/data/media_stream_capability.h&gt;\n#include &lt;nx/vms/api/types/rtp_types.h&gt;\n#include &lt;nx/vms/common/ptz/type.h&gt;\n#include &lt;nx/vms/common/resource/camera_hotspots_data.h&gt;\n#include &lt;nx_ec/ec_api_fwd.h&gt;\n#include &lt;recording/time_period_list.h&gt;\n#include &lt;utils/common/aspect_ratio.h&gt;\n\nclass QAuthenticator;\nclass QnAbstractArchiveDelegate;\nclass QnResourceData;\nclass QnMotionRegion;\n\nnamespace nx::core::resource { class AbstractRemoteArchiveManager; }\nnamespace nx::media { enum class StreamEvent; }\n\nclass NX_VMS_COMMON_API QnVirtualCameraResource:\n    public QnMediaResource,\n    public /*mixin*/ Qn::EnableSafeDirectConnection\n{\n    Q_OBJECT\n    Q_PROPERTY(nx::vms::api::DeviceCapabilities cameraCapabilities\n        READ getCameraCapabilities WRITE setCameraCapabilities)\n    Q_PROPERTY(Ptz::Capabilities ptzCapabilities\n        READ getPtzCapabilities WRITE setPtzCapabilities NOTIFY ptzCapabilitiesChanged)\n    using base_type = QnMediaResource;\n\npublic:\n    static constexpr int kDefaultMaxFps = 15;\n    static nx::Uuid makeCameraIdFromPhysicalId(const QString&amp; physicalId);\n    static QString intercomSpecificPortName();\n\n    static const QString kCompatibleAnalyticsEnginesProperty;\n    static const QString kUserEnabledAnalyticsEnginesProperty;\n    // This property kept here only because of statistics filtering.\n    static const QString kDeviceAgentsSettingsValuesProperty;\n    static const QString kDeviceAgentManifestsProperty;\n    static const QString kAnalyzedStreamIndexes;\n    static const QString kVirtualCameraIgnoreTimeZone;\n    static const QString kHttpPortParameterName;\n    static const QString kCameraNameParameterName;\n    static const QString kUsingOnvifMedia2Type;\n\n    struct NX_VMS_COMMON_API MotionStreamIndex\n    {\n        nx::vms::api::StreamIndex index = nx::vms::api::StreamIndex::undefined;\n        bool isForced = false;\n\n        bool operator==(const MotionStreamIndex&amp; other) const;\n        bool operator!=(const MotionStreamIndex&amp; other) const;\n    };\n\n    enum class StreamFpsSharingMethod\n    {\n        /**\n         * If second stream is running whatever fps it has, first stream can get\n         * `maximumFps - secondstreamFps`.\n         */\n        basic,\n\n        /**\n         * If second stream is running whatever megapixel it has, first stream can get\n         * maxMegapixels - secondstreamPixels.\n         */\n        pixels,\n\n        /** Second stream does not affect first stream&#x27;s fps. */\n        none,\n    };\n\npublic:\n    QnVirtualCameraResource();\n    virtual ~QnVirtualCameraResource() override;\n\n    QnMediaServerResourcePtr getParentServer() const;\n\n    /**\n     * Identifier of the Device type. Used to access Device read-only or default properties (e.g.\n     * the maximum fps value or sensor configuration). Such parameters are stored in a separate\n     * json file, available online. The Server regularly reads it, updates the internal values and\n     * provides them to the connecting Clients.\n     */\n    virtual nx::Uuid getTypeId() const override;\n\n    /**\n     * Updates the Device type id. Actual when the same Device is found by a\n     * new more actual driver, or when a new Resource type is added to the Device Type Pool.\n     */\n    virtual void setTypeId(const nx::Uuid&amp; id) override;\n\n    /**\n     * Helper function to check if the Device status is &quot;online&quot; or &quot;recording&quot;. Must not be used\n     * anywhere else.\n     */\n    virtual bool isOnline() const override { return isOnline(getStatus()); }\n\n    /**\n     * Helper function to check if the Device status is &quot;online&quot; or &quot;recording&quot;. Must not be used\n     * anywhere else.\n     */\n    static bool isOnline(nx::vms::api::ResourceStatus status)\n    {\n        return status == nx::vms::api::ResourceStatus::online\n            || status == nx::vms::api::ResourceStatus::recording;\n    }\n\n    virtual QString getProperty(const QString&amp; key) const override;\n\n    // TODO: #skolesnik nx::Url\n    virtual void setUrl(const QString&amp; url) override;\n\n    virtual nx::network::HostAddress getHostAddress() const;\n    virtual void setHostAddress(const nx::network::HostAddress &amp;ip);\n\n    // TODO: #skolesnik Remove unsafe QString\n    virtual void setHostAddress(const QString &amp;ip);\n\n    nx::utils::MacAddress getMAC() const;\n    void setMAC(const nx::utils::MacAddress &amp;mac);\n\n    virtual QString getPhysicalId() const;\n    void setPhysicalId(const QString&amp; physicalId);\n\n    void setAuth(const QString &amp;user, const QString &amp;password);\n    void setAuth(const QAuthenticator &amp;auth);\n\n    void setDefaultAuth(const QString &amp;user, const QString &amp;password);\n    void setDefaultAuth(const QAuthenticator &amp;auth);\n\n    /**\n     * Parse user and password from the colon-delimited string.\n     */\n    static QAuthenticator parseAuth(const QString&amp; value);\n\n    QAuthenticator getAuth() const;\n    QAuthenticator getDefaultAuth() const;\n\n    virtual std::uint16_t httpPort() const;\n    virtual void setHttpPort(std::uint16_t newPort);\n\n    /* By default, it is rtsp port (554). */\n    virtual int mediaPort() const;\n    void setMediaPort(int value);\n\n    // This value is updated by discovery process.\n    QDateTime getLastDiscoveredTime() const;\n    void setLastDiscoveredTime(const QDateTime &amp;time);\n\n    // All data readers and any sockets will use this number as timeout value in ms.\n    void setNetworkTimeout(unsigned int timeout);\n    virtual unsigned int getNetworkTimeout() const;\n\n    // In some cases it is necessary to update only a couple of field from just discovered resource.\n    virtual bool mergeResourcesIfNeeded(const QnVirtualCameraResourcePtr&amp; source);\n\n    virtual int getChannel() const;\n\n    /**\n     * Returns true if camera is accessible\n     * Default implementation just establishes connection to \\a getHostAddress() : \\a httpPort()\n     * TODO: #akolesnikov This method is used in diagnostics only. Throw it away and use \\a\n     *     QnVirtualCameraResource::checkIfOnlineAsync instead.\n     */\n    virtual bool ping();\n\n    /**\n     * Checks if camera is online\n     * \\param completionHandler Invoked on check completion. Check result is passed to the functor\n     * \\return true if async operation has been started. false otherwise\n     * \\note Implementation MUST check not only camera address:port accessibility, but also check\n     * some unique parameters of camera\n     * \\note Default implementation returns false\n     */\n    virtual void checkIfOnlineAsync(std::function&lt;void(bool)&gt; completionHandler);\n\n    static nx::Uuid physicalIdToId(const QString&amp; uniqId);\n\n    virtual QString idForToStringFromPtr() const override;\n\n    static QString mediaPortKey();\n    bool isAudioSupported() const;\n    bool isIOModule() const;\n    int motionWindowCount() const;\n    int motionMaskWindowCount() const;\n    int motionSensWindowCount() const;\n    bool hasTwoWayAudio() const;\n\n    Ptz::Capabilities getPtzCapabilities(\n        nx::vms::common::ptz::Type ptzType = nx::vms::common::ptz::Type::operational) const;\n\n    /** Check if device has any of provided capabilities. */\n    bool hasAnyOfPtzCapabilities(\n        Ptz::Capabilities capabilities,\n        nx::vms::common::ptz::Type ptzType = nx::vms::common::ptz::Type::operational) const;\n    void setPtzCapabilities(\n        Ptz::Capabilities capabilities,\n        nx::vms::common::ptz::Type ptzType = nx::vms::common::ptz::Type::operational);\n    void setPtzCapability(\n        Ptz::Capabilities capability,\n        bool value,\n        nx::vms::common::ptz::Type ptzType = nx::vms::common::ptz::Type::operational);\n\n    bool canSwitchPtzPresetTypes() const;\n\n    /**\n     * Actual motion type used when the `MotionType::default_` value is selected.\n     */\n    nx::vms::api::MotionType getDefaultMotionType() const;\n\n    /**\n     * Flags set for all motion types, supported by the Camera driver.\n     */\n    nx::vms::api::MotionTypes supportedMotionTypes() const;\n\n    /**\n     * If Camera supports motion detection, e.g. it has enabled dual streaming or forced motion\n     * detection on primary stream or uses hardware motion detection.\n     */\n    bool isMotionDetectionSupported() const;\n\n    /**\n     * If motion detection is supported and actually enabled by the User.\n     */\n    bool isMotionDetectionEnabled() const;\n\n    /**\n     * Actually used motion detection type. `MotionType::MT_None` if User disabled motion\n     * detection.\n     */\n    virtual nx::vms::api::MotionType getMotionType() const;\n\n    /**\n     * Select preferred motion detection type. `MotionType::MT_None` should be passed to disable\n     * motion detection.\n     */\n    void setMotionType(nx::vms::api::MotionType value);\n\n    virtual int getMaxFps(nx::vms::api::StreamIndex streamIndex = nx::vms::api::StreamIndex::primary) const;\n\n    virtual void setMaxFps(int fps, nx::vms::api::StreamIndex streamIndex = nx::vms::api::StreamIndex::primary);\n\n    virtual int reservedSecondStreamFps() const;\n\n    QList&lt;QnMotionRegion&gt; getMotionRegionList() const;\n    void setMotionRegionList(const QList&lt;QnMotionRegion&gt;&amp; maskList);\n\n    QnMotionRegion getMotionRegion() const;\n\n    /** Returns which stream should be used for motion detection and whether it is forced. */\n    virtual MotionStreamIndex motionStreamIndex() const;\n    MotionStreamIndex motionStreamIndexInternal() const;\n\n    /** Enable forced motion detection on a selected stream or switch to automatic mode. */\n    void setMotionStreamIndex(MotionStreamIndex value);\n\n    /**\n     * If motion detection in the remote archive is enabled. Actual for the virtual\n     * devices and for the edge devices (with RemoteArchiveCapability).\n     */\n    bool isRemoteArchiveMotionDetectionEnabled() const;\n\n    /**\n     * Enable or disable motion detection in the remote archive. Actual for the virtual\n     * devices and for the edge devices (with RemoteArchiveCapability).\n     */\n    void setRemoteArchiveMotionDetectionEnabled(bool value);\n\n    void setScheduleTasks(const QnScheduleTaskList &amp;scheduleTasks);\n    QnScheduleTaskList getScheduleTasks() const;\n\n    /** @return Whether dual streaming is supported by the device internally. */\n    virtual bool hasDualStreamingInternal() const;\n\n    /**\n     * @return Whether dual streaming is supported by the device and is not forcefully disabled by\n     * a user (@see `isDualStreamingDisabled()`).\n     */\n    virtual bool hasDualStreaming() const;\n\n    /** Returns true if device stores archive on a external system */\n    bool isDtsBased() const;\n\n    /** @return True if recording schedule can be configured for this device. */\n    bool supportsSchedule() const;\n\n    /** Returns true if it is a analog encoder (described in resource_data.json) */\n    bool isAnalogEncoder() const;\n\n    /** Returns true if it is an onvif device camera. */\n    bool isOnvifDevice() const;\n\n    /** Returns edge, analog or digital class */\n    virtual Qn::LicenseType licenseType() const;\n\n    /**\n     * Returns true if all cameras in a same camera group should share 1 license\n     */\n    bool isSharingLicenseInGroup() const;\n\n    bool isNvr() const;\n\n    bool isMultiSensorCamera() const;\n\n    static nx::vms::api::DeviceType calculateDeviceType(\n        bool isDtsBased,\n        bool isIoModule,\n        bool isAnalogEncoder,\n        bool isAnalog,\n        bool isGroupIdEmpty,\n        bool hasVideo,\n        bool hasAudioCapability);\n    void setDeviceType(nx::vms::api::DeviceType);\n    nx::vms::api::DeviceType deviceType() const;\n\n    virtual StreamFpsSharingMethod streamFpsSharingMethod() const;\n    void setStreamFpsSharingMethod(StreamFpsSharingMethod value);\n\n    // TODO: move this flags inside CameraMediaCapability struct\n    nx::vms::api::DeviceCapabilities getCameraCapabilities() const;\n    bool hasCameraCapabilities(nx::vms::api::DeviceCapabilities capabilities) const;\n    void setCameraCapabilities(nx::vms::api::DeviceCapabilities capabilities);\n    void setCameraCapability(nx::vms::api::DeviceCapability capability, bool value);\n\n    nx::vms::api::CameraMediaCapability cameraMediaCapability() const;\n    void setCameraMediaCapability(const nx::vms::api::CameraMediaCapability&amp; value);\n    void updateCameraMediaCapability(\n        std::function&lt;void(nx::vms::api::CameraMediaCapability&amp; capability)&gt; updater);\n\n    virtual QnAbstractArchiveDelegate* createArchiveDelegate() { return 0; }\n\n    // Returns user-defined camera name (if not empty), default name otherwise\n    QString getUserDefinedName() const;\n\n    // Returns user-defined group name (if not empty) or default group name\n    virtual QString getUserDefinedGroupName() const;\n    // Returns default group name\n    QString getDefaultGroupName() const;\n    virtual void setDefaultGroupName(const QString&amp; value);\n\n    /**\n     * Set group name (the one is show to the user in client)\n     * This name is set by user.\n     * \\a setDefaultGroupName name is generally set automatically (e.g., by server)\n     */\n    void setUserDefinedGroupName( const QString&amp; value );\n    virtual QString getGroupId() const;\n    virtual void setGroupId(const QString&amp; value);\n\n    virtual QString getSharedId() const;\n\n    /** Check if a license is used for the current camera. */\n    bool isScheduleEnabled() const;\n    void setScheduleEnabled(bool value);\n\n    Qn::FailoverPriority failoverPriority() const;\n    void setFailoverPriority(Qn::FailoverPriority value);\n\n    void updateAudioRequired();\n    void updateAudioRequiredOnDevice(const QString&amp; deviceId);\n\n    /**\n     * @returns True if the audio required by one of the:\n     * - audio enabled in client\n     * - audio forced\n     * - audio mapped to another device\n     * this getter should be used by data providers to decide whether to retrieve audio from source\n     * or not\n     */\n    bool isAudioRequired() const;\n\n    /** @returns True if the audio should not be disabled */\n    bool isAudioForced() const;\n\n    /**\n     * @returns True if the audio receiving is enabled. Enabled state doesn&#x27;t guarantee\n     *     availability of actual audio stream since audio input may be not configured right.\n     */\n    bool isAudioEnabled() const;\n\n    /**\n     * Sets whether audio receiving (but not transmitting) should be enabled or disabled.\n     * If &lt;tt&gt;isAudioForced()&lt;/tt&gt; returns true, audio receiving is implicitly enabled and this\n     * method has no effect.\n     */\n    void setAudioEnabled(bool enabled);\n\n    /** @return ID of device which used as audio input override for the camera. */\n    nx::Uuid audioInputDeviceId() const;\n\n    /** @return Redirected audio input (if any) or self. */\n    QnVirtualCameraResourcePtr audioInputDevice() const;\n\n    /**\n     * Sets ID of device which will be used as audio input override for the camera.\n     * @param deviceId Valid another device ID expected. Null ID should be set if this device&#x27;s\n     *     own audio input is intended to be used.\n     */\n    void setAudioInputDeviceId(const nx::Uuid&amp; deviceId);\n\n    /**\n     * @returns True if the audio transmitting is enabled. Enabled state doesn&#x27;t guarantee\n     *     actual transmission possibility since audio output may be not configured right.\n     */\n    bool isTwoWayAudioEnabled() const;\n\n    /** Sets whether audio transmitting should be enabled or disabled. */\n    void setTwoWayAudioEnabled(bool value);\n\n    /** @return ID of device which used as audio output override for the camera. */\n    nx::Uuid audioOutputDeviceId() const;\n\n    /** @return Redirected audio output (if any) or self. */\n    QnVirtualCameraResourcePtr audioOutputDevice() const;\n\n    /**\n     * Sets ID of device which will be used as audio output override for the camera.\n     * @param deviceId Valid another device ID expected. Null ID should be set if this device&#x27;s\n     *     own audio output is intended to be used.\n     */\n    void setAudioOutputDeviceId(const nx::Uuid&amp; deviceId);\n\n    bool isManuallyAdded() const;\n    void setManuallyAdded(bool value);\n\n    nx::vms::api::CameraBackupQuality getBackupQuality() const;\n    void setBackupQuality(nx::vms::api::CameraBackupQuality value);\n\n    /** Get backup qualities, substantiating default value. */\n    nx::vms::api::CameraBackupQuality getActualBackupQualities() const;\n\n    /** @return Whether camera hotspots enabled or not. */\n    bool cameraHotspotsEnabled() const;\n\n    /** Sets whether camera hotspots enabled or not. */\n    void setCameraHotspotsEnabled(bool enabled);\n\n    /** @return List of camera hotspots description data structures. */\n    nx::vms::common::CameraHotspotDataList cameraHotspots() const;\n\n    /**\n     * Sets camera hotspots descriptions to the resource as is. Data validity is the responsibility\n     * of the caller.\n     */\n    void setCameraHotspots(const nx::vms::common::CameraHotspotDataList&amp; cameraHotspots);\n\n    QString getModel() const;\n    void setModel(const QString &amp;model);\n\n    QString getFirmware() const;\n    void setFirmware(const QString &amp;firmware);\n\n    QString getSerialNumber() const;\n    void setSerialNumber(const QString&amp; serialNumber);\n\n    bool trustCameraTime() const;\n    void setTrustCameraTime(bool value);\n\n    bool keepCameraTimeSettings() const;\n    void setKeepCameraTimeSettings(bool value);\n    bool defaultKeepCameraTimeSettingsState() const;\n\n    QString getVendor() const;\n    void setVendor(const QString &amp;value);\n\n    // TODO: #skolesnik There are just a couple of places where `logicalId()` is used from\n    // `QnResource` (including Desktop client&#x27;s code)\n    /**\n     * User-defined id which primary usage purpose is to support different integrations. By using\n     * this id, the user can easily switch one Device with another, and all API requests continue\n     * to work as usual.\n     *\n     * Supported for Devices and Layouts only. Ids should be unique between the same types (not\n     * enforced though), but the same logical id for a Device and a Layout is perfectly OK as they\n     * are used in different API calls.\n     */\n    virtual int logicalId() const override;\n    virtual void setLogicalId(int value) override;\n\n    bool isGroupPlayOnly() const;\n\n    bool needsToChangeDefaultPassword() const;\n\n    /**\n     * @return Whether dual streaming is disabled by a user. Second stream is not provided by the\n     * camera in this case, so it cannot be used for motion detection.\n     */\n    bool isDualStreamingDisabled() const;\n\n    /**\n     * Completely disable dual streaming on the camera side. Second stream will not be not provided\n     * in this case, so it cannot be used for motion detection.\n     */\n    void setDisableDualStreaming(bool value);\n\n    /**\n     * @return Whether primary stream is not recorded by the server. Even if recording is\n     * disabled, the stream still can be used for motion or objects detection.\n     */\n    bool isPrimaryStreamRecorded() const;\n\n    /**\n     * Enable or disable primary stream recording. Even if recording is disabled, the stream still\n     * can be used for motion or objects detection.\n     */\n    void setPrimaryStreamRecorded(bool value);\n\n    /**\n     * @return Whether primary and secondary streams should record audio track.\n     */\n    bool isAudioRecorded() const;\n\n    /**\n     * Enable or disable audio track recording for the primary and secondary streams.\n     */\n    void setRecordAudio(bool value);\n\n    /**\n     * @return Whether secondary stream is not recorded by the server. Even if recording is\n     * disabled, the stream still can be used for motion or objects detection.\n     */\n    bool isSecondaryStreamRecorded() const;\n\n    /**\n     * Enable or disable secondary stream recording. Even if recording is disabled, the stream\n     * still can be used for motion or objects detection.\n     */\n    void setSecondaryStreamRecorded(bool value);\n\n    void setCameraControlDisabled(bool value);\n    bool isCameraControlDisabledInternal() const;\n    virtual bool isCameraControlDisabled() const;\n\n    // TODO: #2.4 #rvasilenko #High Move to runtime data\n    Qn::CameraStatusFlags statusFlags() const;\n    bool hasStatusFlags(Qn::CameraStatusFlag value) const;\n    void setStatusFlags(Qn::CameraStatusFlags value);\n    void addStatusFlags(Qn::CameraStatusFlag value);\n    void removeStatusFlags(Qn::CameraStatusFlag value);\n\n    virtual bool needCheckIpConflicts() const;\n\n    void setMaxPeriod(std::chrono::seconds value);\n    std::chrono::seconds maxPeriod() const;\n\n    void setMinPeriod(std::chrono::seconds value);\n    std::chrono::seconds minPeriod() const;\n\n    int recordBeforeMotionSec() const;\n    void setRecordBeforeMotionSec(int value);\n\n    int recordAfterMotionSec() const;\n    void setRecordAfterMotionSec(int value);\n\n    void setPreferredServerId(const nx::Uuid&amp; value);\n    nx::Uuid preferredServerId() const;\n\n    bool isRemoteArchiveSynchronizationEnabled() const;\n    void setRemoteArchiveSynchronizationEnabled(bool value);\n    bool defaultRemoteArchiveSynchronizationEnabledState() const;\n\n    /** If preferred server is not set, assigns current server as preferred. */\n    void updatePreferredServerId();\n\n    /**\n     * Returns list of time periods of DTS archive, containing motion at specified \\a regions with\n     * timestamp in region [\\a msStartTime; \\a msEndTime)\n     * \\param detailLevel Minimal time period gap (usec) that is of interest to the caller.\n     * Two time periods lying closer to each other than \\a detailLevel usec SHOULD be reported as\n     * one\n     * \\note Used only if \\a QnVirtualCameraResource::isDtsBased() is \\a true\n     * \\note Default implementation does nothing\n     */\n    virtual QnTimePeriodList getDtsTimePeriodsByMotionRegion(\n        const QList&lt;QRegion&gt;&amp; regions,\n        std::chrono::milliseconds msStartTime,\n        std::chrono::milliseconds msEndTime,\n        int detailLevel,\n        bool keepSmalChunks,\n        int limit,\n        Qt::SortOrder sortOrder);\n\n    /**\n     * @param ports Ports data to save into resource property.\n     * @param needMerge If true, overrides new ports description with saved state, because it might\n     *      be edited by client. TODO: This should be fixed by using different properties!\n     * @return true Merge has happened, false otherwise.\n     */\n    virtual bool setIoPortDescriptions(QnIOPortDataList ports, bool needMerge);\n\n    /** @param type Filters ports by type, does not filter if Qn::PT_Unknown. */\n    QnIOPortDataList ioPortDescriptions(Qn::IOPortType type = Qn::PT_Unknown) const;\n\n    bool isIntercom() const;\n\n    nx::vms::api::ExtendedCameraOutputs extendedOutputs() const;\n\n    virtual bool useBitratePerGop() const;\n\n    virtual nx::core::resource::UsingOnvifMedia2Type useMedia2ToFetchProfiles() const;\n\n    // Allow getting multi video layout directly from a RTSP SDP info\n    virtual bool allowRtspVideoLayout() const { return true; }\n\n    /** Return non zero media event error if camera resource has an issue. */\n    nx::media::StreamEvent checkForErrors() const;\n\n    virtual nx::core::resource::AbstractRemoteArchiveManager* remoteArchiveManager();\n\n    virtual float suggestBitrateKbps(\n        const QnLiveStreamParams&amp; streamParams, Qn::ConnectionRole role) const;\n    static float rawSuggestBitrateKbps(\n        Qn::StreamQuality quality, QSize resolution, int fps, const QString&amp; codec);\n\n    virtual bool hasVideo(const QnAbstractStreamDataProvider* dataProvider = nullptr) const override;\n\n    /** Whether the camera has audio, concerning redirected audio input device if it is set. */\n    virtual bool hasAudio() const;\n\n    /**\n     * Update user password at the camera. This function is able to change password for existing user only.\n     */\n    virtual bool setCameraCredentialsSync(\n        const QAuthenticator&amp; auth, QString* outErrorString = nullptr);\n\n    /** Returns true if camera credential was auto detected by media server. */\n    bool isDefaultAuth() const;\n\n    virtual int suggestBitrateForQualityKbps(Qn::StreamQuality q, QSize resolution, int fps,\n        const QString&amp; codec, Qn::ConnectionRole role = Qn::CR_Default) const;\n\n    static Qn::ConnectionRole toConnectionRole(nx::vms::api::StreamIndex index);\n    static nx::vms::api::StreamIndex toStreamIndex(Qn::ConnectionRole role);\n\n    nx::vms::api::ptz::PresetType preferredPtzPresetType() const;\n\n    nx::vms::api::ptz::PresetType userPreferredPtzPresetType() const;\n    void setUserPreferredPtzPresetType(nx::vms::api::ptz::PresetType);\n\n    nx::vms::api::ptz::PresetType defaultPreferredPtzPresetType() const;\n    void setDefaultPreferredPtzPresetType(nx::vms::api::ptz::PresetType);\n\n    Ptz::Capabilities ptzCapabilitiesUserIsAllowedToModify() const;\n\n    void setPtzCapabilitesUserIsAllowedToModify(Ptz::Capabilities);\n\n    Ptz::Capabilities ptzCapabilitiesAddedByUser() const;\n\n    void setPtzCapabilitiesAddedByUser(Ptz::Capabilities capabilities);\n\n    QPointF ptzPanTiltSensitivity() const;\n    bool isPtzPanTiltSensitivityUniform() const; //&lt; Whether pan and tilt use the same sensitivity.\n    void setPtzPanTiltSensitivity(const QPointF&amp; value);\n    void setPtzPanTiltSensitivity(const qreal&amp; uniformValue);\n\n    bool isVideoQualityAdjustable() const;\n\n    virtual QnResourceData resourceData() const;\n    nx::vms::api::BackupContentTypes getBackupContentType() const;\n    void setBackupContentType(nx::vms::api::BackupContentTypes contentTypes);\n\n    /**\n     * @return backup policy of the device. Besides the values corresponding to On and Off state,\n     *     it may be equal to the &lt;tt&gt;nx::vms::api::BackupPolicy::byDefault&lt;/tt&gt; value, which means\n     *     that actual backup enabled state will be taken from the global backup settings.\n     */\n    nx::vms::api::BackupPolicy getBackupPolicy() const;\n    void setBackupPolicy(nx::vms::api::BackupPolicy backupPolicy);\n\n    /**\n     * @return whether device should be backed up or not. Value is deduced from the backup policy\n     *     and additionally, from the global backup settings for the case when backup policy is\n     *     &lt;tt&gt;nx::vms::api::BackupPolicy::byDefault&lt;/tt&gt;.\n     */\n    bool isBackupEnabled() const;\n\n    // TODO: #skolesnik nx::Url ?\n    virtual QString getUrl() const override;\n\n    nx::vms::api::CameraAttributesData getUserAttributes() const;\n    void setUserAttributes(const nx::vms::api::CameraAttributesData&amp; attributes);\n    void setUserAttributesAndNotify(const nx::vms::api::CameraAttributesData&amp; attributes);\n\n    bool isRtspMetatadaRequired() const;\n    void forceEnableAudio();\n    void forceDisableAudio();\n    bool isForcedAudioSupported() const;\n\n    void updateDefaultAuthIfEmpty(const QString&amp; login, const QString&amp; password);\n\n    //! Camera source URL, commonly - rtsp link.\n    QString sourceUrl(Qn::ConnectionRole role) const;\n    void updateSourceUrl(const nx::Url&amp; url, Qn::ConnectionRole role, bool save = true);\n\n    bool virtualCameraIgnoreTimeZone() const;\n    /**\n     * Meaningful only for virtual camera.\n     * If the value is true, video&#x27;s timestamps is considered as local client time.\n     * Otherwise, timestamps is considered as UTC.\n     */\n    void setVirtualCameraIgnoreTimeZone(bool value);\n\n    nx::vms::api::RtpTransportType preferredRtpTransport() const;\n    CameraMediaStreams mediaStreams() const;\n    CameraMediaStreamInfo streamInfo(nx::vms::api::StreamIndex index = nx::vms::api::StreamIndex::primary) const;\n\n    /** @return frame aspect ratio of a single channel. Does not account for default rotation. */\n    virtual QnAspectRatio aspectRatio() const;\n\n    /** @return frame aspect ratio of a single channel. Accounts for default rotation. */\n    virtual QnAspectRatio aspectRatioRotated() const;\n\n    /**\n     * @return Ids of Analytics Engines which are actually compatible with the Device, enabled by\n     *     the user and active (running on the current server). Includes device-dependent Engines.\n     */\n    virtual std::set&lt;nx::Uuid&gt; enabledAnalyticsEngines() const;\n\n    /**\n     * @return Analytics Engines which are actually compatible with the Device, enabled by the user\n     * and active (running on the current server). Includes device-dependent Engines.\n     */\n    const nx::vms::common::AnalyticsEngineResourceList enabledAnalyticsEngineResources() const;\n\n    /**\n     * @return Ids of Analytics Engines which are explicitly enabled by the user. Not validated for\n     *     compatibility with the Device or if the engine is active (running on the current server).\n     */\n    std::set&lt;nx::Uuid&gt; userEnabledAnalyticsEngines() const;\n\n    /**\n     * Set ids of Analytics Engines which are explicitly enabled by the user. Not validated for\n     * compatibility with the Device or if the Engine is active (running on the current server).\n     */\n    void setUserEnabledAnalyticsEngines(const std::set&lt;nx::Uuid&gt;&amp; engines);\n\n    /**\n     * Set ids of Analytics Engines which are explicitly enabled by the user.\n     * This is the same function like &#x27;setUserEnabledAnalyticsEngines&#x27; but it returns serialized data instead of storing\n     * it to the resource properties.\n     */\n    nx::vms::api::ResourceParamData serializeUserEnabledAnalyticsEngines(\n        const std::set&lt;nx::Uuid&gt;&amp; engines);\n\n    /**\n     * @return Ids of Analytics Engines which can be potentially used with the Device. Only active\n     *     (running on the current server) Engines are included.\n     */\n    virtual const std::set&lt;nx::Uuid&gt; compatibleAnalyticsEngines() const;\n\n    /**\n     * @return Analytics Engines which can be potentially used with the Device. Only active\n     *     (running on the current server) Engines are included.\n     */\n    virtual nx::vms::common::AnalyticsEngineResourceList compatibleAnalyticsEngineResources() const;\n\n    /**\n     * Set ids of Analytics Engines which can be potentially used with the Device. Only active\n     * (running on the current server) Engines must be included.\n     */\n    void setCompatibleAnalyticsEngines(const std::set&lt;nx::Uuid&gt;&amp; engines);\n\n    using AnalyticsEntitiesByEngine = std::map&lt;nx::Uuid, std::set&lt;QString&gt;&gt;;\n\n    /**\n     * @return Map of supported Event types by the Engine id. Only actually compatible with the\n     *     Device, enabled by the user and active (running on the current Server) Engines are used.\n     */\n    virtual AnalyticsEntitiesByEngine supportedEventTypes() const;\n\n    /**\n     * @return Map of the supported Object types by the Engine id.\n     * @param filterByEngines If true, only actually compatible with the Device, enabled by the\n     *     user and active (running on the current Server) Engines are used.\n     */\n    virtual AnalyticsEntitiesByEngine supportedObjectTypes(\n        bool filterByEngines = true) const;\n\n    std::optional&lt;nx::vms::api::analytics::DeviceAgentManifest&gt; deviceAgentManifest(\n        const nx::Uuid&amp; engineId) const;\n\n    void setDeviceAgentManifest(\n        const nx::Uuid&amp; engineId,\n        const nx::vms::api::analytics::DeviceAgentManifest&amp; manifest);\n\n    nx::vms::api::StreamIndex analyzedStreamIndex(nx::Uuid engineId) const;\n\n    nx::vms::api::StreamIndex defaultAnalyzedStreamIndex() const;\n\n    void setAnalyzedStreamIndex(nx::Uuid engineId, nx::vms::api::StreamIndex streamIndex);\n\n    /** Whether this camera supports web page. */\n    bool isWebPageSupported() const;\n\n    /**\n     * Customized user-provided port for Camera Web Page.\n     * @return positive value if custom port is set; 0 if default port should be used.\n     */\n    int customWebPagePort() const;\n\n    /** Set custom port for Camera Web Page. Pass 0 to reset custom value. */\n    void setCustomWebPagePort(int value);\n\n    /**\n     * Checks if motion detection is enabled and actually can work (hardware, or not exceeding\n     * resolution limit or is forced).\n     */\n    bool isMotionDetectionActive() const;\n\n    /** Checks if schedule task is applicable: recording mode and metadata types are supported. */\n    static bool canApplyScheduleTask(\n        const QnScheduleTask&amp; task,\n        bool dualStreamingAllowed,\n        bool motionDetectionAllowed,\n        bool objectDetectionAllowed);\n\n    /** Checks if schedule task is applicable: recording mode and metadata types are supported. */\n    bool canApplyScheduleTask(const QnScheduleTask&amp; task) const;\n\n    /** Checks if all schedule tasks are applicable. */\n    static bool canApplySchedule(\n        const QnScheduleTaskList&amp; schedule,\n        bool dualStreamingAllowed,\n        bool motionDetectionAllowed,\n        bool objectDetectionAllowed);\n\n    /** Checks if all schedule tasks are applicable. */\n    bool canApplySchedule(const QnScheduleTaskList&amp; schedule) const;\n\n    static constexpr QSize kMaximumSecondaryStreamResolution{1024, 768};\n    static constexpr int kMaximumMotionDetectionPixels\n        = kMaximumSecondaryStreamResolution.width() * kMaximumSecondaryStreamResolution.height();\n\n    /**\n     * Set a list of available device profiles. It can be used on camera Expert dialog\n     * to manually setup camera profile to use\n     */\n    void setAvailableProfiles(const nx::vms::api::DeviceProfiles&amp; value);\n\n    /** Get a list of available device profiles. */\n    nx::vms::api::DeviceProfiles availableProfiles() const;\n\n    /** Manually setup a profile ID to use. */\n    void setForcedProfile(const QString&amp; id, nx::vms::api::StreamIndex index);\n\n    /** Read manually configured profile ID to use. Can be empty. */\n    QString forcedProfile(nx::vms::api::StreamIndex index) const;\n\n    using DeviceAgentManifestMap = std::map&lt;nx::Uuid, nx::vms::api::analytics::DeviceAgentManifest&gt;;\n    DeviceAgentManifestMap deviceAgentManifests() const;\n\n    int backupMegapixels() const;\n    int backupMegapixels(nx::vms::api::CameraBackupQuality quality) const;\n\n    QnLiveStreamParams streamConfiguration(nx::vms::api::StreamIndex stream) const;\n    nx::Url vmsCloudUrl() const;\n    bool isVmsCloudUrl() const;\n\n    QSize maxVideoResolution() const;\n\nsignals:\n    void ptzCapabilitiesChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void userEnabledAnalyticsEnginesChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void compatibleAnalyticsEnginesChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void deviceAgentManifestsChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void isIOModuleChanged(const QnVirtualCameraResourcePtr&amp; camera);\n\n    // TODO: Get rid of this &quot;maybe&quot; logic.\n    void compatibleEventTypesMaybeChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void compatibleObjectTypesMaybeChanged(const QnVirtualCameraResourcePtr&amp; camera);\n\n    void vendorChanged(const QnResourcePtr&amp; resource);\n    void modelChanged(const QnResourcePtr&amp; resource);\n    void scheduleEnabledChanged(const QnResourcePtr&amp; resource);\n    void scheduleTasksChanged(const QnResourcePtr&amp; resource);\n    void groupIdChanged(const QnResourcePtr&amp; resource, const QString&amp; previousGroupId);\n    void groupNameChanged(const QnResourcePtr&amp; resource);\n    void motionRegionChanged(const QnResourcePtr&amp; resource);\n    void motionTypeChanged(const QnResourcePtr&amp; resource);\n    void statusFlagsChanged(const QnResourcePtr&amp; resource);\n    void licenseTypeChanged(const QnResourcePtr&amp; resource);\n    void failoverPriorityChanged(const QnResourcePtr&amp; resource);\n    void backupQualityChanged(const QnResourcePtr&amp; resource);\n    void capabilitiesChanged(const QnResourcePtr&amp; resource);\n    void disableDualStreamingChanged(const QnResourcePtr&amp; resource);\n    void audioEnabledChanged(const QnResourcePtr&amp; resource);\n    void audioRequiredChanged(const QnResourcePtr&amp; resource);\n    void audioInputDeviceIdChanged(const QnResourcePtr&amp; resource);\n    void twoWayAudioEnabledChanged(const QnResourcePtr&amp; resource);\n    void audioOutputDeviceIdChanged(const QnResourcePtr&amp; resource);\n    void backupContentTypeChanged(const QnResourcePtr&amp; resource);\n    void backupPolicyChanged(const QnResourcePtr&amp; resource);\n    void mediaCapabilitiesChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void cameraHotspotsEnabledChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void cameraHotspotsChanged(const QnVirtualCameraResourcePtr&amp; camera);\n    void ioPortDescriptionsChanged(const QnVirtualCameraResourcePtr&amp; camera);\n\nprotected:\n    /** Returns true if it is a analog device */\n    bool isAnalog() const;\n\nprotected slots:\n    virtual void at_motionRegionChanged();\n    virtual void resetCachedValues();\n\nprotected:\n    virtual void emitPropertyChanged(\n        const QString&amp; key, const QString&amp; prevValue, const QString&amp; newValue) override;\n\n    virtual void setSystemContext(nx::vms::common::SystemContext* systemContext) override;\n\n    virtual void updateInternal(const QnResourcePtr&amp; source, NotifierList&amp; notifiers) override;\n\n    virtual void setMotionMaskPhysical(int /*channel*/) {}\n\n    virtual Qn::LicenseType calculateLicenseType() const;\n\n    nx::vms::api::DeviceType enforcedDeviceType() const;\n\nprivate:\n    nx::utils::MacAddress m_macAddress;\n    QString m_physicalId;\n\n    unsigned int m_networkTimeout = 1000 * 10;\n\n    // Initialized in cpp to avoid transitional includes.\n    std::uint16_t m_httpPort;\n\n    QDateTime m_lastDiscoveredTime;\n\n    nx::utils::CachedValue&lt;nx::network::HostAddress&gt; m_cachedHostAddress;\nprivate:\n    /** Identifier of the type of this Device. */\n    nx::Uuid m_typeId;\n\n    QString m_groupName;\n    QString m_groupId;\n    Qn::CameraStatusFlags m_statusFlags;\n    bool m_manuallyAdded;\n    bool m_audioRequired = false;\n    QString m_model;\n    QString m_vendor;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedAudioRequired;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedRtspMetadataDisabled;\n    nx::utils::CachedValue&lt;Qn::LicenseType&gt; m_cachedLicenseType;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedHasDualStreaming;\n    nx::utils::CachedValue&lt;nx::vms::api::MotionTypes&gt; m_cachedSupportedMotionTypes;\n    nx::utils::CachedValue&lt;nx::vms::api::DeviceCapabilities&gt; m_cachedCameraCapabilities;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedIsDtsBased;\n    nx::utils::CachedValue&lt;nx::vms::api::MotionType&gt; m_motionType;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedIsIOModule;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedCanConfigureRemoteRecording;\n    nx::utils::CachedValue&lt;nx::vms::api::CameraMediaCapability&gt; m_cachedCameraMediaCapabilities;\n    nx::utils::CachedValue&lt;nx::vms::api::DeviceType&gt; m_cachedExplicitDeviceType;\n    nx::utils::CachedValue&lt;MotionStreamIndex&gt; m_cachedMotionStreamIndex;\n    nx::utils::CachedValue&lt;QnIOPortDataList&gt; m_cachedIoPorts;\n    nx::utils::CachedValue&lt;bool&gt; m_cachedHasVideo;\n    nx::utils::CachedValue&lt;bool&gt; m_isIntercom;\n\n    nx::utils::CachedValue&lt;std::set&lt;nx::Uuid&gt;&gt; m_cachedUserEnabledAnalyticsEngines;\n    nx::utils::CachedValue&lt;std::set&lt;nx::Uuid&gt;&gt; m_cachedCompatibleAnalyticsEngines;\n    nx::utils::CachedValue&lt;DeviceAgentManifestMap&gt; m_cachedDeviceAgentManifests;\n    nx::utils::CachedValue&lt;std::map&lt;nx::Uuid, std::set&lt;QString&gt;&gt;&gt; m_cachedSupportedEventTypes;\n    nx::utils::CachedValue&lt;std::map&lt;nx::Uuid, std::set&lt;QString&gt;&gt;&gt; m_cachedSupportedObjectTypes;\n    mutable nx::Lockable&lt;std::map&lt;nx::Uuid, nx::vms::api::StreamIndex&gt;&gt; m_cachedAnalyzedStreamIndex;\n    nx::utils::CachedValue&lt;CameraMediaStreams&gt; m_cachedMediaStreams;\n    nx::utils::CachedValue&lt;int&gt; m_cachedBackupMegapixels;\n    nx::utils::CachedValue&lt;QnLiveStreamParams&gt; m_primaryStreamConfiguration;\n    nx::utils::CachedValue&lt;QnLiveStreamParams&gt; m_secondaryStreamConfiguration;\n\n    mutable nx::Mutex m_cachedValueMutex;\n};\n\nconstexpr QSize EMPTY_RESOLUTION_PAIR(0, 0);\nconstexpr QSize SECONDARY_STREAM_MAX_RESOLUTION =\n    QnVirtualCameraResource::kMaximumSecondaryStreamResolution;\nconstexpr QSize UNLIMITED_RESOLUTION(INT_MAX, INT_MAX);\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/media_resource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/media_resource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/media_resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QSize&gt;\n\n#include &lt;core/resource/resource.h&gt;\n#include &lt;core/resource/resource_media_layout_fwd.h&gt;\n#include &lt;nx/vms/api/data/camera_attributes_data.h&gt;\n#include &lt;nx/vms/api/data/dewarping_data.h&gt;\n#include &lt;utils/common/aspect_ratio.h&gt;\n\nclass QnAbstractStreamDataProvider;\n\n/**\n * Represents a camera or a local video file.\n * This class is baseless to prevent diamond inheritance. Its descendants are QnVirtualCameraResource\n * or local QnAbstractArchiveResource based.\n * \\note Derived class MUST call \\a initMediaResource() just after object instantiation\n*/\nclass NX_VMS_COMMON_API QnMediaResource: public QnResource\n{\npublic:\n    QnMediaResource();\n    virtual ~QnMediaResource();\n\n    virtual QnAbstractStreamDataProvider* createDataProvider(\n        Qn::ConnectionRole role = Qn::CR_Default) = 0;\n\n    // size - is size of one channel; we assume all channels have the same size\n    virtual Qn::StreamQuality getBestQualityForSuchOnScreenSize(const QSize&amp; /*size*/) const;\n\n    // returns one image best for such time\n    // in case of live video time should be ignored\n    virtual QImage getImage(int channel, QDateTime time, Qn::StreamQuality quality) const;\n\n    // resource can use DataProvider for addition info (optional)\n    virtual QnConstResourceVideoLayoutPtr getVideoLayout(const QnAbstractStreamDataProvider* dataProvider = nullptr);\n    virtual AudioLayoutConstPtr getAudioLayout(const QnAbstractStreamDataProvider* dataProvider = nullptr) const;\n    virtual bool hasVideo(const QnAbstractStreamDataProvider* dataProvider = nullptr) const = 0;\n\n    virtual nx::vms::api::dewarping::MediaData getDewarpingParams() const;\n    virtual void setDewarpingParams(const nx::vms::api::dewarping::MediaData&amp; params);\n\n    virtual QnAspectRatio customAspectRatio() const;\n    void setCustomAspectRatio(const QnAspectRatio&amp; value);\n    void clearCustomAspectRatio();\n\n    /**\n     * Returns default rotation.\n     * The class should be refactored and this function moved out.\n     */\n    virtual std::optional&lt;int&gt; forcedRotation() const;\n\n    void setForcedRotation(std::optional&lt;int&gt; value);\n\n    /** Name of the resource property key intended for the CustomAspectRatio value storage. */\n    static QString customAspectRatioKey();\n\n    static QString rtpTransportKey();\n    static QString panicRecordingKey();\n    static QString dynamicVideoLayoutKey();\n\n    static QnConstResourceVideoLayoutPtr getDefaultVideoLayout();\n\nprotected:\n    void initMediaResource();\n\n    mutable nx::Mutex m_attributesMutex;\n    nx::vms::api::CameraAttributesData m_userAttributes;\n    mutable std::optional&lt;nx::vms::api::dewarping::MediaData&gt; m_cachedDewarpingParams;\n\nprotected:\n    mutable QnCustomResourceVideoLayoutPtr m_customVideoLayout;\n    mutable nx::Mutex m_layoutMutex;\n\n    static const QString kRotationKey;\n\nprivate:\n    mutable QString m_cachedLayout;\n};\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef __MOTION_WINDOW_H__\n#define __MOTION_WINDOW_H__\n\n#include &lt;optional&gt;\n\n#include &lt;QtCore/QMultiMap&gt;\n#include &lt;QtGui/QPainterPath&gt;\n#include &lt;QtGui/QRegion&gt;\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n/*!\n    Copy-constructor and assignment operator perform deep-copy of object\n    Problem with QRegion is that cannot be used with object&#x27;s shallow copies safely in multiple threads simultaneously\n    because \\a QRegion::rects() const method is not thread-safe (due to call to \\a QRegionPrivate::vectorize function)\n*/\nclass NX_VMS_COMMON_API QnRegion\n:\n    public QRegion\n{\npublic:\n    QnRegion();\n    //!makes deep copy of QRegion\n    QnRegion(const QnRegion&amp; right);\n    QnRegion(int x, int y, int w, int h, RegionType t = Rectangle);\n    QnRegion(const QPolygon &amp; a, Qt::FillRule fillRule = Qt::OddEvenFill);\n    QnRegion(const QBitmap &amp; bm);\n    QnRegion(const QRect &amp; r, RegionType t = Rectangle);\n\n    QnRegion&amp; operator=( const QnRegion&amp; r );\n\n    QVector&lt;QRect&gt; rects() const;\n\nprivate:\n    mutable nx::Mutex m_mutex;\n};\n\nclass NX_VMS_COMMON_API QnMotionRegion\n{\npublic:\n    enum class ErrorCode {\n        Ok,\n        Windows,\n        Masks,\n        Sens\n    };\n\n    QnMotionRegion();\n    QnMotionRegion( const QnMotionRegion&amp; );\n\n    QnMotionRegion&amp; operator=( const QnMotionRegion&amp; );\n\n    static constexpr int kDefaultSensitivity = 5;\n    static constexpr int kSensitivityLevelCount = 10;\n\n    /**\n    * \\returns Windows if sum of rects in all regions in range [1..MAX] greater than maxRectCount\n    * \\returns Masks if sum of rects in motionMask region (index 0) greater than maxMaskRects OR\n    * \\returns Sens number of regions with at least 1 rect is greater than maxMotionSens\n    * \\returns Ok otherwise\n     */\n    ErrorCode isValid(int maxMotionRects, int maxMaskRects, int maxMotionSens) const;\n\n    bool operator==(const QnMotionRegion&amp; other) const;\n    bool operator!=(const QnMotionRegion&amp; other) const;\n    bool isEmpty() const;\n\n    void addRect(int sensitivity, const QRect&amp; rect);\n\n    /**\n     * Region where motion must be skipped (zero sensitivity).\n     */\n    QnRegion getMotionMask() const;\n\n    QnRegion getRegionBySens(int value) const;\n    QMultiMap&lt;int, QRect&gt; getAllMotionRects() const;\n\n    /**\n     * Returns painter path for the motion mask region.\n     */\n    QPainterPath getMotionMaskPath() const;\n\n    /**\n     * Returns painter path for the given sensitivity region.\n     * \\param value                 Target sensitivity level.\n     */\n    QPainterPath getRegionBySensPath(int value) const;\n\n    /**\n     * Returns simplified version of region&#x27;s rects\n     */\n    QVector&lt;QRect&gt; getRectsBySens(int value) const;\n\n    bool updateSensitivityAt(const QPoint&amp; pos, int sens);\n\n    int getMotionRectCount() const;\n    int getMaskRectCount() const;\n    int getMotionSensCount() const;\n\n    void removeDefaultMotion();\n\n    QString toString() const;\nprivate:\n    void updatePathCache() const;\nprivate:\n    QnRegion m_data[kSensitivityLevelCount];\n    mutable QPainterPath m_pathCache[kSensitivityLevelCount];\n    mutable bool m_dirty = false;\n};\n\nNX_VMS_COMMON_API std::optional&lt;QnMotionRegion&gt; parseMotionRegion(const QByteArray&amp; regionString);\n\nQString serializeMotionRegion(const QnMotionRegion&amp; region);\n\nNX_VMS_COMMON_API std::optional&lt;QList&lt;QnMotionRegion&gt;&gt; parseMotionRegionList(\n    const QByteArray&amp; regionsString);\n\nQString serializeMotionRegionList(const QList&lt;QnMotionRegion&gt;&amp; regions);\n\n\n#endif // __MOTION_WINDOW_H__\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;string_view&gt;\n\n#include &lt;common/common_globals.h&gt;\n#include &lt;utils/common/from_this_to_shared.h&gt;\n\n#include &quot;resource_fwd.h&quot;\n#include &quot;resource_type.h&quot;\n#include &quot;shared_resource_pointer.h&quot;\n\nclass QnResourcePool;\n\nnamespace nx::vms::common { class SystemContext; }\n\nnamespace nx::vms::api {\n\nstruct ResourceParamData;\nusing ResourceParamDataList = std::vector&lt;ResourceParamData&gt;;\n\n} // namespace nx::vms::api\n\n/**\n * One of the base VMS classes, QnResource, represents a database-stored entity and provides the\n * interface to modify it or to listen to the changes.\n *\n * Most noticeable descendant classes are:\n * - QnVirtualCameraResource - Device entity;\n * - QnUserResource - VMS User;\n * - QnMediaServerResource - VMS Server;\n * - QnLayoutResource - Layout of cameras.\n *\n * Most db-stored entities are Resources, though there are some exceptions (e.g. User Roles or\n * Showreels). Some entities are linked to others using child-parent relations by the parentId\n * field, e.g. Storages and Devices belong to Servers, and Layouts can belong to users or Video\n * Walls.\n *\n * All work with QnResource-based classes is done using special shared pointers (see\n * QnSharedResourcePointer). There are typedefs for each pointer type, e.g. QnResourcePtr for\n * the base class, or QnUserResourcePtr for the User class.\n *\n * Available Resources are stored in a special QnResourcePool instance. The primary key of the\n * Resource is its id. All work with the Resources (and listening to their changes) should be done\n * only with the Resources belonging to the Resources pool. Any class storing a shared pointer to a\n * Resource must listen to the Resource Pool signals to correctly clean up the pointer when the\n * Resource is removed from the Resource Pool.\n *\n * Some of the Resource parameters and properties are stored in separate classes but are accessible\n * using the QnResource methods. Default values for some of the properties are stored not for the\n * Resource itself but for the Resource type (see getTypeId() and QnResourceType).\n *\n * No Resource property should be modified by both the Client and Server simultaneously. That&#x27;s why\n * some properties are stored as fields and some are stored externally (for example, see\n * CameraAttributesData). The same field can be written by a Server for one Resource type and by\n * a Client for another (e.g. a camera name is modified by a Server, but a User or a Layout name -\n * by a Client).\n *\n * NOTE: All class methods are thread-safe.\n */\nclass NX_VMS_COMMON_API QnResource: public QObject, public QnFromThisToShared&lt;QnResource&gt;\n{\n    Q_OBJECT\n\n    Q_FLAGS(Qn::ResourceFlags)\n    Q_PROPERTY(nx::Uuid id READ getId CONSTANT)\n    Q_PROPERTY(QString name READ getName WRITE setName NOTIFY nameChanged)\n    Q_PROPERTY(Qn::ResourceFlags flags READ flags WRITE setFlags NOTIFY flagsChanged)\n    Q_PROPERTY(nx::vms::api::ResourceStatus status READ getStatus WRITE setStatus\n        NOTIFY statusChanged)\n\nprotected:\n    using ResourceStatus = nx::vms::api::ResourceStatus;\n\npublic:\n    //---------------------------------------------------------------------------------------------\n    // Constructing, copying and updating.\n\n    // TODO: #sivanov Remove common module from the base Resource classes.\n    /**\n     * Creates a Resource belonging to some Common Module. The link is required mostly to access\n     * various properties stored outside of the Resource.\n     */\n    QnResource();\n\n    // Resource copying is prohibited as it creates an inconsistent entity: duplicate Resource,\n    // which can contain link to Resource pool but does not belong to it.\n    QnResource(const QnResource&amp;) = delete;\n\n    virtual ~QnResource() override;\n\n    /**\n     * Converts the Resource to its shared pointer. For this method to work, the very first\n     * shared pointer must be created manually. See the QnFromThisToShared implementation.\n     */\n    template&lt;class Resource&gt;\n    static QnSharedResourcePointer&lt;Resource&gt; toSharedPointer(const Resource* resource);\n\n    /**\n     * Converts the Resource to its shared pointer. For this method to work, the very first\n     * shared pointer must be created manually. See the QnFromThisToShared implementation.\n     */\n    QnResourcePtr toSharedPointer() const;\n\n    /**\n     * Resource changes are implemented in the following way: when the new data is received (either\n     * by a network request, or by discovering user changes on the camera), a new shared pointer to\n     * the same Resource is created. Then it is sent to the Resource Pool - and if a Resource with\n     * such  id is absent, it is added, otherwise the update() method is called for the existing\n     * resource.\n     *\n     * All field data is assigned from the `source` Resource using the overloaded updateInternal()\n     * virtual method. After changes are applied, the corresponding signals are sent. Important:\n     * signals must never be sent when the Resource mutex is locked.\n     */\n    void update(const QnResourcePtr&amp; source);\n\n    /**\n     * Resource Pool the Resource belongs to. Empty when the Resource is created. Filled when the\n     * Resource is added to a Resource Pool. Corresponding signal is sent by the Resource Pool\n     * then. Shared pointers to Resources outside of the Pool must not be stored anywhere and\n     * should not be used except for temporary purposes.\n     */\n    QnResourcePool* resourcePool() const;\n\n    /**\n     * Assigns the Resource to the corresponding System Context. Normally this is done only by\n     * the Resource Pool when the Resource is added.\n     *\n     * A Resource can never be removed from the System Context or moved to another one.\n     */\n    void addToSystemContext(nx::vms::common::SystemContext* systemContext);\n\n    /**\n     * Context of the System this Resource belongs to. Used to get access to external properties\n     * of the Resource and to some tightly bound classes.\n     */\n    nx::vms::common::SystemContext* systemContext() const;\n\n    /**\n     * Debug helper for NX_LOG implementation. Used by toString(const T*).\n     */\n    virtual QString idForToStringFromPtr() const;\n\n    //---------------------------------------------------------------------------------------------\n    // Data fields.\n\n    /**\n     * Primary resource identifier. Must never be changed after the Resource is used, so it is not\n     * guarded by a mutex.\n     */\n    const nx::Uuid&amp; getId() const { return m_id; }\n\n    /**\n     * Updates the Resource id. The function is not protected by the mutex, as the existing\n     * Resource id must never be changed after the Resource is added to a Resource Pool.\n     */\n    void setIdUnsafe(const nx::Uuid&amp; id);\n\n    /**\n     * Id of the &quot;parent&quot; Resource. This relation can be used by different types of Resources with\n     * different purposes. Main examples are:\n     * - Device&#x27;s parent is a Server, which currently governs it and records its footage;\n     * - Storage&#x27;s parent is a Server which uses it;\n     * - Layout&#x27;s parent can be a User who privately owns it, or a Video Wall Resource.\n     */\n    nx::Uuid getParentId() const;\n\n    // TODO: #sivanov Make this method non-virtual, listen to the corresponding signal instead.\n    virtual void setParentId(const nx::Uuid&amp; parent);\n\n    /**\n     * Helper function to find the parent Resource in the same Resource Pool.\n     */\n    QnResourcePtr getParentResource() const;\n\n    /**\n     * Identifier of the Device type. Actually used only for Camera Resources - to access\n     * Device read-only or default properties (e.g. the maximum fps value or sensor configuration).\n     * Such parameters are stored in a separate json file, available online. The Server regularly\n     * reads it, updates the internal values and provides them to the connecting Clients. See\n     * QnResourceType.\n     */\n    virtual nx::Uuid getTypeId() const;\n\n    /**\n     * Updates the Resource type id. Actual only for Cameras, when the same Camera is found by a\n     * new more actual driver, or when a new Resource type is added to the Resource Type Pool.\n     */\n    virtual void setTypeId(const nx::Uuid&amp; id);\n\n    /**\n     * Availability of the Resource. Actual mostly for the network Resources: Devices, Servers, Web\n     * Pages - to see if it is online or not. Contains some special values for Camera-specific or\n     * Server-specific states.\n     *\n     * For local Resources, the status can also be used - e.g. to check if the file still exists.\n     */\n    virtual ResourceStatus getStatus() const;\n\n    /**\n     * The previous Resource status before the latest change. Usable only in a very limited scope,\n     * mostly when we need to do some specific action when an online Camera becomes offline, or\n     * vice versa.\n     */\n    ResourceStatus getPreviousStatus() const;\n\n    /**\n     * Updates Resource status. Behavior can differ, depending on the source of changes. The Server\n     * can change Camera status based on its own data, or when some changes are received from\n     * another network peer.\n     */\n    virtual void setStatus(\n        ResourceStatus newStatus,\n        Qn::StatusChangeReason reason = Qn::StatusChangeReason::Local);\n\n    /**\n     * Helper function to check if the Camera status is &quot;online&quot; or &quot;recording&quot;. Must not be used\n     * anywhere else.\n     */\n    virtual bool isOnline() const { return isOnline(getStatus()); }\n\n    /**\n     * Helper function to check if the Camera status is &quot;online&quot; or &quot;recording&quot;. Must not be used\n     * anywhere else.\n     */\n    static bool isOnline(ResourceStatus status)\n    {\n        return status == ResourceStatus::online || status == ResourceStatus::recording;\n    }\n\n    /**\n     * Flags are local-only bits of information about the Resource. They are used to quickly check\n     * some feature support, or filter Resources by their type. One of the most important flags is\n     * Qn::removed, which means this Resource has been removed from the Resource Pool and is going\n     * to be deleted soon.\n     */\n    virtual Qn::ResourceFlags flags() const;\n\n    /**\n     * Resets Resource flags to the provided value.\n     */\n    void setFlags(Qn::ResourceFlags flags);\n\n    /**\n     * Checks if the Resource has the full set of the provided flags.\n     */\n    bool hasFlags(Qn::ResourceFlags flags) const { return (this-&gt;flags() &amp; flags) == flags; }\n\n    /**\n     * Adds flags to the Resource.\n     */\n    void addFlags(Qn::ResourceFlags flags);\n\n    /**\n     * Removes flags from the Resource.\n     */\n    void removeFlags(Qn::ResourceFlags flags);\n\n    /**\n     * Resource name. For most of the Resource types, it can be modified by the Client directly,\n     * but for Cameras and Servers it is modified by a Server. Due to the architecture limitation,\n     * both the Client and the Server cannot modify the same field, so when it comes to the Camera\n     * or Server name, we have a separate database field (Server-side value) and user attributes\n     * field (Client-side value). An overridden virtual method provides the actual name depending\n     * on the Resource class.\n     */\n    virtual QString getName() const;\n\n    /**\n     * Updates the Resource name. Depending on the Resource type, an overridden method will write\n     * it either directly to the Resource field, or to a separate user attributes dictionary.\n     */\n    virtual void setName(const QString&amp; name);\n\n    /**\n     * Resource url. Has a different meaning depending on the Resource type: network url for\n     * Devices, Servers and Web Pages, filesystem path for Storages and local files.\n     */\n    virtual QString getUrl() const;\n    virtual void setUrl(const QString&amp; url);\n\n    /**\n     * User-defined id which primary usage purpose is to support different integrations. By using\n     * this id, the user can easily switch one Camera with another, and all API requests continue\n     * to work as usual.\n     *\n     * Supported for Cameras and Layouts only. Ids should be unique between the same types (not\n     * enforced though), but the same logical id for a Camera and a Layout is perfectly OK as they\n     * are used in different API calls.\n     */\n    virtual int logicalId() const { return 0; }\n    virtual void setLogicalId(int /*value*/) { /*Base implementation does not keep logical Id. */ }\n\n    //---------------------------------------------------------------------------------------------\n    // Properties.\n    //\n    // Note that these functions hide the property API inherited from QObject. This is intended,\n    // as QObject API cannot be used with QnResource anyway because of the threading issues.\n\n    /**\n     * Custom mutable attribute of the Resource. Stored separately in another dictionary. All\n     * properties are stored as strings. If no property value is stored for the current Resource,\n     * the default value is read from the Resource type description.\n     */\n    virtual QString getProperty(const QString&amp; key) const;\n\n    /**\n     * Full list of all properties explicitly set for the Resource.\n     */\n    nx::vms::api::ResourceParamDataList getProperties() const;\n\n    /**\n     * Set the property value. An empty string will clean the explicitly set value. Be careful, as\n     * after that a default value from the Resource type will be used.\n     *\n     * Properties are stored in a separate dictionary. If the Resource for some reason has no id\n     * set, the properties are stored locally instead.\n     *\n     * @return Whether the stored property value has been modified by this call. Return `true` if property is modified.\n     */\n    virtual bool setProperty(\n        const QString&amp; key,\n        const QString&amp; value,\n        bool markDirty = true);\n\n    /**\n    * Updates the property value using provided functor.\n    * @return Whether the stored property value has been modified by this call. Return `true` if property is modified.\n    */\n    virtual bool updateProperty(\n        const QString&amp; key,\n        std::function&lt;QString(QString)&gt; updater,\n        bool markDirty = true);\n\n    /**\n     * Save modified properties to the database (using a network transaction).\n     * @return Whether the request was finished successfully.\n     */\n    virtual bool saveProperties();\n\n    /**\n     * Save modified properties to the database.\n     */\n    virtual void savePropertiesAsync();\n\n    /**\n     * Force using local properties for the Resource. Actual mostly for the unit tests and for the\n     * temporary Resources (like Camera sub-channels).\n     */\n    void setForceUsingLocalProperties(bool value = true);\n\nsignals:\n    void statusChanged(const QnResourcePtr&amp; resource, Qn::StatusChangeReason reason);\n    void nameChanged(const QnResourcePtr&amp; resource);\n    void parentIdChanged(const QnResourcePtr&amp; resource, const nx::Uuid&amp; previousParentId);\n    void flagsChanged(const QnResourcePtr&amp; resource);\n    void urlChanged(const QnResourcePtr&amp; resource);\n    void logicalIdChanged(const QnResourcePtr&amp; resource);\n\n    // TODO: #sivanov Remove this signal. Listen only to the actual signals in all listeners.\n    void resourceChanged(const QnResourcePtr&amp; resource);\n\n    void propertyChanged(\n        const QnResourcePtr&amp; resource,\n        const QString&amp; key,\n        const QString&amp; prevValue,\n        const QString&amp; newValue);\n\n    // TODO: #sivanov Remove these signals as they belong to QnMediaResource.\n    void mediaDewarpingParamsChanged(const QnResourcePtr&amp; resource);\n    void videoLayoutChanged(const QnResourcePtr&amp; resource);\n    void rotationChanged();\n\nprotected:\n    using Notifier = std::function&lt;void(void)&gt;;\n    using NotifierList = QList&lt;Notifier&gt;;\n\n    /**\n     * Update the System Context. Intended to be overloaded in the descendant classes when some\n     * logic should be called instantly after addition.\n     */\n    virtual void setSystemContext(nx::vms::common::SystemContext* systemContext);\n\n    /**\n     * Copies all data from the source Resource and adds the corresponding signal sending to the\n     * list of notifiers.\n     *\n     * The method is called under a mutex (both Resources are locked), so the locks are not\n     * required, and no signals must be sent.\n     */\n    virtual void updateInternal(const QnResourcePtr&amp; source, NotifierList&amp; notifiers);\n\n    /**\n     * For the big part of the properties, the descendant classes can have method aliases and\n     * corresponding signals. This method should be overridden to correctly reset cached values and\n     * send a corresponding semantical signal.\n     */\n    virtual void emitPropertyChanged(\n        const QString&amp; key,\n        const QString&amp; prevValue,\n        const QString&amp; newValue);\n\n    /**\n     * Update url value without mutex locking.\n     * @return if value was actually changed.\n     */\n    bool setUrlUnsafe(const QString&amp; value);\n\n    bool setLocalPropertyUnsafe(const QString&amp; key, const QString&amp; value);\n\n    QString getLocalPropertyUnsafe(const QString&amp; key) const;\n\nprivate:\n    bool useLocalProperties() const;\n\nprotected:\n    /** Recursive mutex that is used when accessing Resource fields. */\n    mutable nx::Mutex m_mutex;\n\n    /**\n     * Identifier of the parent Resource. Use Resource Pool to retrieve the actual parent Resource.\n     */\n    nx::Uuid m_parentId;\n\n    /** Name of this Resource. */\n    QString m_name;\n\n    /** Url of this Resource, if any. */\n    QString m_url;\n\n    /** Mutex that is to be used when accessing a set of all consumers. */\n    mutable nx::Mutex m_consumersMtx;\n\n    /** Flags of this Resource that determine its type. */\n    Qn::ResourceFlags m_flags;\n\nprivate:\n    /** Identifier of this Resource. */\n    nx::Uuid m_id;\n\n    /** Identifier of the type of this Resource. */\n    nx::Uuid m_typeId;\n\n    std::unordered_map&lt;QString, QString&gt; m_locallySavedProperties;\n\n    /** System Context this Resource belongs to. */\n    std::atomic&lt;nx::vms::common::SystemContext*&gt; m_systemContext{};\n\n    std::atomic&lt;bool&gt; m_forceUseLocalProperties{false};\n    std::atomic&lt;ResourceStatus&gt; m_previousStatus = ResourceStatus::undefined;\n};\n\ntemplate&lt;class Resource&gt;\nQnSharedResourcePointer&lt;Resource&gt; toSharedPointer(const Resource* resource)\n{\n    if (!resource)\n        return QnSharedResourcePointer&lt;Resource&gt;();\n    return resource-&gt;toSharedPointer().template staticCast&lt;Resource&gt;();\n}\n\ntemplate&lt;class Resource&gt;\nQnSharedResourcePointer&lt;Resource&gt; QnResource::toSharedPointer(const Resource* resource)\n{\n    using ::toSharedPointer; //&lt; Let ADL kick in.\n    return toSharedPointer(resource);\n}\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QList&gt;\n#include &lt;QtCore/QMap&gt;\n#include &lt;QtCore/QSharedPointer&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n#include &quot;resource_property_key.h&quot;\n\nclass NX_VMS_COMMON_API QnResourceType\n{\npublic:\n    using ParamTypeMap = QMap&lt;QString, QString&gt;;\n\n    virtual ~QnResourceType();\n\n    void setId(const nx::Uuid&amp; value) { m_id = value; }\n    const nx::Uuid&amp; getId() const { return m_id;}\n\n    void setParentId(const nx::Uuid &amp;value);\n    const nx::Uuid&amp; getParentId() const { return m_parentId;}\n\n    void setName(const QString&amp; value) { m_name = value; }\n    const QString&amp; getName() const { return m_name;}\n\n    void setManufacture(const QString&amp; value) { m_manufacture = value; }\n    const QString&amp; getManufacturer() const { return m_manufacture;}\n\n    bool isCamera() const;\n    void setIsCamera(); //&lt; For tests.\n\n    void addAdditionalParent(const nx::Uuid&amp; parent);\n    QList&lt;nx::Uuid&gt; allParentList() const;\n\n    void addParamType(const QString&amp; name, const QString&amp; defaultValue);\n    bool hasParam(const QString&amp; name) const;\n\n    const ParamTypeMap&amp; paramTypeListUnsafe() const;\n    const ParamTypeMap paramTypeList() const;\n\n    QString defaultValue(const QString&amp; key) const;\n\nprivate:\n    nx::Uuid m_id;\n    nx::Uuid m_parentId;\n    QString m_name;\n    QString m_manufacture;\n    QList&lt;nx::Uuid&gt; m_additionalParentList;\n\n    ParamTypeMap m_paramTypeList;\n\n    mutable nx::Mutex m_allParamTypeListCacheMutex;\n    mutable QSharedPointer&lt;ParamTypeMap&gt; m_allParamTypeListCache;\n\n    mutable bool m_isCamera = false;\n    mutable bool m_isCameraSet = false;\n};\n\nclass NX_VMS_COMMON_API QnResourceTypePool\n{\npublic:\n    typedef QMap&lt;nx::Uuid, QnResourceTypePtr&gt; QnResourceTypeMap;\n\n    static const QString kC2pCameraTypeId;\n\n    static QnResourceTypePool *instance();\n\n    QnResourceTypePtr getResourceTypeByName(const QString&amp; name) const;\n    QnResourceTypePtr getResourceType(nx::Uuid id) const;\n\n    // TODO: Mutable methods should not be publicly accessible while this class is a\n    // singleton, because it may cause data races in multi-server Unit Tests.\n    void replaceResourceTypeList(const QnResourceTypeList&amp; resourceType);\n\n    /* exact match name */\n    nx::Uuid getResourceTypeId(const QString&amp; manufacturer, const QString&amp; name, bool showWarning = true) const;\n\n    /* match name using like operation */\n    nx::Uuid getLikeResourceTypeId(const QString&amp; manufacturer, const QString&amp; name) const;\n\n    QnResourceTypeMap getResourceTypeMap() const;\n\n    bool isEmpty() const;\n\nprivate:\n    // As long as this class is a singleton, mutability must be reduced as much as possible.\n    QnResourceTypePool();\n    ~QnResourceTypePool();\n\n    mutable nx::Mutex m_mutex;\n    QnResourceTypeMap m_resourceTypeMap;\n    mutable QnResourceTypePtr m_desktopCamResourceType;\n};\n\n#define qnResTypePool QnResourceTypePool::instance()\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/user_resource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/user_resource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/user_resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n\n#include &lt;core/resource/resource.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/reflect/instrument.h&gt;\n#include &lt;nx/utils/scrypt.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/analytics/integration_request.h&gt;\n#include &lt;nx/vms/api/data/user_data.h&gt;\n#include &lt;nx/vms/api/data/user_model.h&gt;\n#include &lt;nx/vms/common/system_health/message_type.h&gt;\n#include &lt;nx_ec/data/api_conversion_functions.h&gt;\n\nstruct PasswordHashes;\n\nstruct NX_VMS_COMMON_API QnUserHash\n{\n    enum class Type\n    {\n        none,\n\n        /**\n         * Specifies, that password is in cloud.\n         */\n        cloud,\n\n        /**\n         *  Deprecated local user storage (low security).\n         *  &quot;md5$&quot; + salt + &quot;$&quot; + md5(salt + password)\n         */\n        md5,\n\n        /**\n         *  LDAP users storage (low security, should be replaced in future).\n         *  &quot;LDAP$&quot; + salt + &quot;$&quot; + encodeSimple(password, fromHex(salt))\n         */\n        ldapPassword,\n\n        // Recommended local user storage.\n        // &quot;scrypt$&quot; + salt + &quot;$&quot; + r + &quot;$&quot; + N + &quot;$&quot; + p + &quot;$&quot; + scrypt(salt, r, N, p, password)\n        scrypt,\n\n        /**\n         * Temporary user hash - serialized TemporaryToken struct\n         */\n        temporary,\n    };\n    static QByteArray toString(const Type&amp; type);\n\n    Type type = Type::none;\n    QByteArray salt;\n    std::optional&lt;nx::scrypt::Options&gt; options; //&lt; TODO: std::variant when there are more options.\n    QByteArray hash;\n    std::optional&lt;nx::vms::api::TemporaryToken&gt; temporaryToken;\n\n    explicit QnUserHash(const QByteArray&amp; data = &quot;&quot;);\n    QByteArray toString() const;\n    QString idForToStringFromPtr() const { return toString(); }\n\n    bool operator==(const QnUserHash&amp; rhs) const;\n    bool operator!=(const QnUserHash&amp; rhs) const { return !(*this == rhs); }\n\n    QByteArray hashPassword(const QString&amp; password) const;\n    bool checkPassword(const QString&amp; password) const;\n    bool compareToPasswordHash(const QByteArray&amp; passwordHash) const;\n\n    // These should be refactored out with insecure LDAP password storage.\n    QString toLdapPassword() const;\n\n    static QnUserHash ldapPassword(const QString&amp; password);\n    static QnUserHash scryptPassword(const QString&amp; password, nx::scrypt::Options options);\n};\n\nclass NX_VMS_COMMON_API QnUserResource: public QnResource\n{\n    Q_OBJECT\n\n    typedef QnResource base_type;\n\npublic:\n    friend void ec2::fromResourceToApi(const QnUserResource&amp;, nx::vms::api::UserData&amp;);\n    friend void ec2::fromResourceToApi(const QnUserResourcePtr&amp;, nx::vms::api::UserData&amp;);\n    friend void ec2::fromApiToResource(const nx::vms::api::UserData&amp;, const QnUserResourcePtr&amp;);\n\n    static const nx::Uuid kAdminGuid;\n    static const QString kIntegrationRequestDataProperty;\n\n    QnUserResource(nx::vms::api::UserType userType, nx::vms::api::UserExternalId externalId);\n    virtual ~QnUserResource();\n\n    nx::vms::api::UserType userType() const;\n    bool isLdap()  const { return userType() == nx::vms::api::UserType::ldap;  }\n    bool isCloud() const { return userType() == nx::vms::api::UserType::cloud; }\n    bool isLocal() const { return userType() == nx::vms::api::UserType::local; }\n    bool isTemporary() const { return userType() == nx::vms::api::UserType::temporaryLocal; }\n    bool isOrg() const { return attributes().testFlag(nx::vms::api::UserAttribute::organization); }\n    bool isChannelPartner() const\n    {\n        return attributes().testFlag(nx::vms::api::UserAttribute::channelPartner);\n    }\n\n    // Returns time span by the end of which the temporary user be expired. If the user is\n    // not temporary returns null.\n    std::optional&lt;std::chrono::seconds&gt; temporarySessionExpiresIn() const;\n\n    QnUserHash getHash() const;\n\n    enum class DigestSupport\n    {\n        enable,\n        disable,\n        keep,\n    };\n\n    QString getPassword() const;\n    bool setPasswordAndGenerateHash(const QString&amp; password, DigestSupport digestSupport = DigestSupport::keep);\n    void resetPassword();\n\n    bool digestAuthorizationEnabled() const;\n    bool shouldDigestAuthBeUsed() const;\n\n    QByteArray getDigest() const;\n\n    QByteArray getCryptSha512Hash() const;\n\n    QString getRealm() const;\n\n    void setPasswordHashes(const PasswordHashes&amp; hashes);\n\n    // Do not use this method directly.\n    // Use resourceAccessManager()::globalPermissions(user) instead\n    GlobalPermissions getRawPermissions() const;\n    void setRawPermissions(GlobalPermissions permissions);\n\n    /** Administrator has maximum permissions. Can be a local or Cloud user. */\n    bool isAdministrator() const;\n\n    /**\n     * Predefined local administrator. For the `admin` user, `isAdministrator` is true and can&#x27;t be\n     * reset. Can be disabled for the login. Can&#x27;t be removed.\n     */\n    bool isBuiltInAdmin() const;\n\n    std::vector&lt;nx::Uuid&gt; allGroupIds() const;\n\n    std::vector&lt;nx::Uuid&gt; siteGroupIds() const;\n    void setSiteGroupIds(const std::vector&lt;nx::Uuid&gt;&amp; value);\n\n    std::vector&lt;nx::Uuid&gt; orgGroupIds() const;\n    void setOrgGroupIds(const std::vector&lt;nx::Uuid&gt;&amp; value);\n\n    void setResourceAccessRights(const std::map&lt;nx::Uuid, nx::vms::api::AccessRights&gt;&amp; value);\n\n    bool isEnabled() const;\n    void setEnabled(bool isEnabled);\n\n    QString getEmail() const;\n    void setEmail(const QString&amp; email);\n\n    QString fullName() const;\n    void setFullName(const QString&amp; value);\n\n    // External identification data, like dn and valid for LDAP users.\n    nx::vms::api::UserExternalId externalId() const;\n    void setExternalId(const nx::vms::api::UserExternalId&amp; value);\n\n    nx::vms::api::UserAttributes attributes() const;\n    void setAttributes(nx::vms::api::UserAttributes value);\n\n    std::optional&lt;nx::vms::api::analytics::IntegrationRequestData&gt; integrationRequestData() const;\n    void setIntegrationRequestData(\n        std::optional&lt;nx::vms::api::analytics::IntegrationRequestData&gt; integrationRequestData);\n\n    /**\n     * Preferred locale of the user. Will affect language of the emails and notifications both in\n     * desktop and mobile clients. If explicit value is not set, default Site locale is used.\n     * %example en_US\n     */\n    QString locale() const;\n\n    /** Raw locale value stored in the database. Can differ from the locale() value if empty. */\n    QString rawLocaleValue() const;\n\n    /** Update user locale or reset it to the default if empty value is passed. */\n    void setLocale(const QString&amp; value);\n\n    std::map&lt;nx::Uuid, nx::vms::api::AccessRights&gt; ownResourceAccessRights() const;\n\n    virtual nx::vms::api::ResourceStatus getStatus() const override;\n\n    /*\n     * Fill ID field.\n     * For regular users it is random value, for cloud users it&#x27;s md5 hash from email address.\n     */\n    void fillIdUnsafe();\n\n    virtual QString idForToStringFromPtr() const override; //&lt; Used by toString(const T*).\n\n    nx::vms::api::UserSettings settings() const;\n\n    QString displayEmail() const;\n    QString displayName() const;\n    virtual bool shouldMaskUser() const;\n\nsignals:\n    void permissionsChanged(const QnUserResourcePtr&amp; user);\n    void userGroupsChanged(const QnUserResourcePtr&amp; user);\n\n    void enabledChanged(const QnUserResourcePtr&amp; user);\n\n    // Emitted if the password has been changed for cloud or local user.\n    void passwordChanged(const QnUserResourcePtr&amp; user);\n    void digestChanged(const QnUserResourcePtr&amp; user);\n\n    void emailChanged(const QnResourcePtr&amp; user);\n    void fullNameChanged(const QnResourcePtr&amp; user);\n    void externalIdChanged(const QnUserResourcePtr&amp; user);\n    void attributesChanged(const QnResourcePtr&amp; user);\n    void localeChanged(const QnResourcePtr&amp; user);\n\n    // Emitted if Temporary user has any changes in the token an/or lifetime bounds.\n    void temporaryTokenChanged(const QnUserResourcePtr&amp; user);\n    void userSettingsChanged(const QnUserResourcePtr&amp; user);\n\nprotected:\n    virtual void setSystemContext(nx::vms::common::SystemContext* systemContext) override;\n    virtual void updateInternal(const QnResourcePtr&amp; source, NotifierList&amp; notifiers) override;\n    void atPropertyChanged(const QnResourcePtr&amp; self, const QString&amp; key);\n\nprivate:\n    bool setPasswordHashesInternal(const PasswordHashes&amp; hashes, bool isNewPassword);\n    bool setGroupIdsInternal(\n        std::vector&lt;nx::Uuid&gt;* dst,\n        const std::vector&lt;nx::Uuid&gt;&amp; value,\n        std::vector&lt;nx::Uuid&gt;* previousValue,\n        nx::MutexLocker&amp; lock);\nprivate:\n    nx::vms::api::UserType m_userType;\n    QString m_password;\n    QnUserHash m_hash;\n    QByteArray m_digest;\n    QByteArray m_cryptSha512Hash;\n    QString m_realm;\n    std::atomic&lt;GlobalPermissions&gt; m_permissions;\n    std::vector&lt;nx::Uuid&gt; m_groupIds;\n    std::vector&lt;nx::Uuid&gt; m_orgGroupIds;\n    std::atomic&lt;bool&gt; m_isAdministratorCache{false};\n    std::atomic&lt;bool&gt; m_isEnabled{true};\n    QString m_email;\n    QString m_fullName;\n    nx::vms::api::UserExternalId m_externalId;\n    nx::vms::api::UserAttributes m_attributes;\n    std::map&lt;nx::Uuid, nx::vms::api::AccessRights&gt; m_resourceAccessRights;\n    QString m_locale;\n};\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_attribute.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_attribute.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_attribute.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QString&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;nx/analytics/taxonomy/abstract_color_type.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_enum_type.h&gt;\n\nQ_MOC_INCLUDE(&quot;nx/analytics/taxonomy/object_type.h&quot;)\n\nnamespace nx::analytics::taxonomy {\n\nclass ObjectType;\n\nclass NX_VMS_COMMON_API AbstractAttribute: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString name READ name CONSTANT)\n    Q_PROPERTY(Type type READ type CONSTANT)\n    Q_PROPERTY(QString subtype READ subtype CONSTANT)\n    Q_PROPERTY(nx::analytics::taxonomy::AbstractEnumType* enumType READ enumType CONSTANT)\n    Q_PROPERTY(nx::analytics::taxonomy::ObjectType* objectType READ objectType CONSTANT)\n    Q_PROPERTY(nx::analytics::taxonomy::AbstractColorType* colorType READ colorType CONSTANT)\n    Q_PROPERTY(QString unit READ unit CONSTANT)\n    Q_PROPERTY(QVariant minValue READ minValue CONSTANT)\n    Q_PROPERTY(QVariant maxValue READ maxValue CONSTANT)\n\npublic:\n    enum class Type\n    {\n        undefined,\n        number,\n        boolean,\n        string,\n        color,\n        enumeration,\n        object,\n    };\n    Q_ENUM(Type)\n\npublic:\n    AbstractAttribute(QObject* parent = nullptr):\n        QObject(parent)\n    {\n    }\n\n    virtual ~AbstractAttribute() {}\n\n    virtual QString name() const = 0;\n\n    virtual Type type() const = 0;\n\n    virtual QString subtype() const = 0;\n\n    virtual AbstractEnumType* enumType() const = 0;\n\n    virtual ObjectType* objectType() const = 0;\n\n    virtual AbstractColorType* colorType() const = 0;\n\n    virtual QString unit() const = 0;\n\n    virtual QVariant minValue() const = 0;\n\n    virtual QVariant maxValue() const = 0;\n\n    virtual QString condition() const = 0;\n\n    Q_INVOKABLE virtual bool isSupported(nx::Uuid engineId, nx::Uuid deviceId) const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_color_type.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_color_type.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_color_type.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractColorType: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString id READ id CONSTANT)\n    Q_PROPERTY(QString name READ name CONSTANT)\n    Q_PROPERTY(nx::analytics::taxonomy::AbstractColorType* baseType READ base CONSTANT)\n    Q_PROPERTY(std::vector&lt;QString&gt; items READ items CONSTANT)\n    Q_PROPERTY(std::vector&lt;QString&gt; ownItems READ ownItems CONSTANT)\n    Q_PROPERTY(std::vector&lt;QString&gt; baseItems READ baseItems CONSTANT)\n\npublic:\n    struct Item\n    {\n        QString name;\n        QString rgb;\n    };\n\npublic:\n    AbstractColorType(QObject* parent = nullptr):\n        QObject(parent)\n    {\n    }\n\n    virtual ~AbstractColorType() {}\n\n    virtual QString id() const = 0;\n\n    virtual QString name() const = 0;\n\n    virtual AbstractColorType* base() const = 0;\n\n    virtual std::vector&lt;QString&gt; baseItems() const = 0;\n\n    virtual std::vector&lt;QString&gt; ownItems() const = 0;\n\n    virtual std::vector&lt;QString&gt; items() const = 0;\n\n    virtual nx::vms::api::analytics::ColorTypeDescriptor serialize() const = 0;\n\n    Q_INVOKABLE virtual QString color(const QString&amp; item) const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_engine.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_engine.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_engine.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n#include &lt;nx/vms/api/analytics/engine_manifest.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass AbstractIntegration;\n\nclass NX_VMS_COMMON_API AbstractEngine: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString id READ id CONSTANT)\n    Q_PROPERTY(QString name READ name CONSTANT)\n\npublic:\n    AbstractEngine(QObject* parent = nullptr):\n        QObject(parent)\n    {\n    }\n\n    virtual  ~AbstractEngine() {};\n\n    virtual QString id() const = 0;\n\n    virtual QString name() const = 0;\n\n    virtual AbstractIntegration* integration() const = 0;\n\n    virtual nx::vms::api::analytics::EngineCapabilities capabilities() const = 0;\n\n    virtual nx::vms::api::analytics::EngineDescriptor serialize() const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_enum_type.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_enum_type.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_enum_type.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractEnumType: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString id READ id CONSTANT)\n    Q_PROPERTY(QString name READ name CONSTANT)\n    Q_PROPERTY(nx::analytics::taxonomy::AbstractEnumType* baseType READ base CONSTANT)\n    Q_PROPERTY(std::vector&lt;QString&gt; items READ items CONSTANT)\n    Q_PROPERTY(std::vector&lt;QString&gt; ownItems READ ownItems CONSTANT)\n\npublic:\n    AbstractEnumType(QObject* parent = nullptr):\n        QObject(parent)\n    {\n    }\n\n    virtual ~AbstractEnumType() {}\n\n    virtual QString id() const = 0;\n\n    virtual QString name() const = 0;\n\n    virtual AbstractEnumType* base() const = 0;\n\n    virtual std::vector&lt;QString&gt; ownItems() const = 0;\n\n    virtual std::vector&lt;QString&gt; items() const = 0;\n\n    virtual nx::vms::api::analytics::EnumTypeDescriptor serialize() const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_group.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_group.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_group.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractGroup: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString id READ id CONSTANT)\n    Q_PROPERTY(QString name READ name CONSTANT)\n\npublic:\n    AbstractGroup(QObject* parent):\n        QObject(parent)\n    {\n    }\n\n    virtual ~AbstractGroup() {}\n\n    virtual QString id() const = 0;\n\n    virtual QString name() const = 0;\n\n    virtual nx::vms::api::analytics::GroupDescriptor serialize() const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_integration.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_integration.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_integration.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractIntegration: public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString id READ id CONSTANT)\n    Q_PROPERTY(QString name READ name CONSTANT)\n\npublic:\n    AbstractIntegration(QObject* parent = nullptr):\n        QObject(parent)\n    {\n    }\n\n    virtual ~AbstractIntegration() {}\n\n    virtual QString id() const = 0;\n\n    virtual QString name() const = 0;\n\n    virtual nx::vms::api::analytics::PluginDescriptor serialize() const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_resource_support_proxy.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_resource_support_proxy.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_resource_support_proxy.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/analytics/taxonomy/entity_type.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractResourceSupportProxy: public QObject\n{\n    Q_OBJECT\npublic:\n    virtual ~AbstractResourceSupportProxy() = default;\n\n    virtual bool isEntityTypeSupported(\n        EntityType entityType,\n        const QString&amp; entityTypeId,\n        nx::Uuid deviceId,\n        nx::Uuid engineId) const = 0;\n\n    virtual bool isEntityTypeAttributeSupported(\n        EntityType entityType,\n        const QString&amp; entityTypeId,\n        const QString&amp; fullAttributeName,\n        nx::Uuid deviceId,\n        nx::Uuid engineId) const = 0;\n\nsignals:\n    void manifestsMaybeUpdated();\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_state.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_state.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_state.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/analytics/taxonomy/abstract_color_type.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_engine.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_enum_type.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_group.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_integration.h&gt;\n#include &lt;nx/analytics/taxonomy/abstract_resource_support_proxy.h&gt;\n#include &lt;nx/analytics/taxonomy/event_type.h&gt;\n#include &lt;nx/analytics/taxonomy/object_type.h&gt;\n#include &lt;nx/vms/api/analytics/descriptors.h&gt;\n\nnamespace nx::analytics::taxonomy {\n\nclass NX_VMS_COMMON_API AbstractState: public QObject\n{\n    Q_OBJECT\n\n    Q_PROPERTY(std::vector&lt;nx::analytics::taxonomy::ObjectType*&gt; rootObjectTypes\n        READ rootObjectTypes CONSTANT)\n\n    Q_PROPERTY(std::vector&lt;nx::analytics::taxonomy::AbstractEngine*&gt; engines\n        READ engines CONSTANT)\n\npublic:\n    virtual ~AbstractState() {}\n\n    virtual std::vector&lt;AbstractIntegration*&gt; integrations() const = 0;\n\n    virtual std::vector&lt;AbstractEngine*&gt; engines() const = 0;\n\n    virtual std::vector&lt;AbstractGroup*&gt; groups() const = 0;\n\n    virtual std::vector&lt;ObjectType*&gt; objectTypes() const = 0;\n\n    virtual std::vector&lt;EventType*&gt; eventTypes() const = 0;\n\n    virtual std::vector&lt;AbstractEnumType*&gt; enumTypes() const = 0;\n\n    virtual std::vector&lt;AbstractColorType*&gt; colorTypes() const = 0;\n\n    virtual std::vector&lt;ObjectType*&gt; rootObjectTypes() const = 0;\n\n    virtual std::vector&lt;EventType*&gt; rootEventTypes() const = 0;\n\n    virtual ObjectType* objectTypeById(const QString&amp; objectTypeId) const = 0;\n\n    virtual EventType* eventTypeById(const QString&amp; eventTypeId) const = 0;\n\n    virtual AbstractIntegration* integrationById(const QString&amp; integrationId) const = 0;\n\n    virtual AbstractEngine* engineById(const QString&amp; engineId) const = 0;\n\n    virtual AbstractGroup* groupById(const QString&amp; groupId) const = 0;\n\n    virtual AbstractEnumType* enumTypeById(const QString&amp; enumTypeId) const = 0;\n\n    virtual AbstractColorType* colorTypeById(const QString&amp; colorTypeId) const = 0;\n\n    virtual nx::vms::api::analytics::Descriptors serialize() const = 0;\n\n    virtual AbstractResourceSupportProxy* resourceSupportProxy() const = 0;\n};\n\n} // namespace nx::analytics::taxonomy\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/string.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/string.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/string.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;string&gt;\n#include &lt;string_view&gt;\n\n#include &lt;QtCore/QByteArray&gt;\n#include &lt;QtCore/QJsonValue&gt;\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/utils/buffer.h&gt;\n\nclass QnJsonContext;\n\nnamespace nx {\n\n/**\n * Single-byte character string to be used across VMS code.\n * Introduces implicit conversions to/from std::string/std::string_view and QString\n * since VMS uses both single-byte and multi-byte strings and nx_network uses std::string.\n * It is recommended to assume that this string always contains UTF-8 text.\n * Can be used for all non-translatable strings.\n */\nclass NX_VMS_COMMON_API String: public QByteArray\n{\n    using base_type = QByteArray;\n\npublic:\n    using base_type::base_type;\n\n    String(const String&amp;) = default;\n    String(String&amp;&amp;) = default;\n\n    String&amp; operator=(const String&amp;) = default;\n    String&amp; operator=(String&amp;&amp;) = default;\n\n    String(const std::string&amp;);\n    String(const std::string_view&amp;);\n    String(const QString&amp;);\n    String(const char*);\n\n    String(const QByteArray&amp;);\n    String(QByteArray&amp;&amp;);\n\n    String(const nx::Buffer&amp;);\n    String(nx::Buffer&amp;&amp;);\n\n    String&amp; operator=(const std::string&amp;);\n    String&amp; operator=(const std::string_view&amp;);\n    String&amp; operator=(const QString&amp;);\n    String&amp; operator=(const char*);\n\n    String&amp; operator=(const QByteArray&amp;);\n    String&amp; operator=(QByteArray&amp;&amp;);\n\n    String&amp; operator=(const nx::Buffer&amp;);\n    String&amp; operator=(nx::Buffer&amp;&amp;);\n\n    operator std::string() const;\n    operator std::string_view() const;\n\n    String&amp; operator+=(const QString&amp; s)\n    {\n        base_type::append(s.toUtf8());\n        return *this;\n    }\n\n    // NOTE: Deleted to make nx::String assignment to std::string() unambiguous.\n    operator const char*() const = delete;\n\n    bool empty() const { return isEmpty(); };\n\n    using base_type::append;\n\n    nx::String&amp; append(const std::string_view&amp; str);\n    nx::String&amp; append(const nx::Buffer&amp; buf);\n\n    static nx::String number(std::size_t n, int base = 10)\n    {\n        return base_type::number((qulonglong) n, base);\n    }\n\n    template&lt;\n        typename Number,\n        typename = std::enable_if_t&lt;std::is_integral_v&lt;Number&gt;&gt;\n    &gt;\n    static nx::String number(Number n, int base = 10)\n    {\n        return nx::String(base_type::number(n, base));\n    }\n\n    template&lt;\n        typename Number,\n        typename = std::enable_if_t&lt;std::is_floating_point_v&lt;Number&gt;&gt;\n    &gt;\n    static nx::String number(Number n, char f = &#x27;g&#x27;, int prec = 6)\n    {\n        return nx::String(base_type::number(n, f, prec));\n    }\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const String&amp; str)\n{\n    return os &lt;&lt; std::string_view(str.data(), str.size());\n}\n\ninline nx::String operator+(const nx::String&amp; left, const nx::String&amp; right)\n{\n    nx::String result = left;\n    result += right;\n    return result;\n}\n\ninline nx::String operator+(const char* left, const nx::String&amp; right)\n{\n    nx::String result = left;\n    result += right;\n    return result;\n}\n\ninline nx::String operator+(const nx::String&amp; left, const char* right)\n{\n    nx::String result = left;\n    result += right;\n    return result;\n}\n\n//-------------------------------------------------------------------------------------------------\n// Fusion serialization helpers.\n\nNX_VMS_COMMON_API void serialize(QnJsonContext* ctx, const nx::String&amp; value, QJsonValue* target);\nNX_VMS_COMMON_API bool deserialize(QnJsonContext* ctx, const QJsonValue&amp; value, nx::String* target);\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/application_context.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/application_context.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/application_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/types/connection_types.h&gt;\n\nclass QnLongRunableCleanup;\nclass QnStoragePluginFactory;\n\nnamespace nx::metric { struct ApplicationMetricsStorage; }\nnamespace nx::i18n { class TranslationManager; }\n\nnamespace nx::vms::common {\n\n/**\n * Main context of the VMS applications. Exists through all application lifetime and is accessible\n * from anywhere using `instance()` method.\n *\n * Works as a storage for the most basic and generic singletons, needed in all common projects.\n * Initializes networking and ffmpeg library, stores pool for all long-runnable threads, keeps the\n * single synchronized time source.\n */\nclass NX_VMS_COMMON_API ApplicationContext: public QObject\n{\nprotected:\n    using PeerType = nx::vms::api::PeerType;\n\npublic:\n    enum class FeatureFlag\n    {\n        none = 0,\n        networking = 1 &lt;&lt; 0,\n        translations = 1 &lt;&lt; 1,\n\n        all = -1\n    };\n    Q_DECLARE_FLAGS(FeatureFlags, FeatureFlag)\n\n    struct Features\n    {\n        FeatureFlags flags = FeatureFlag::none;\n\n        Features() = default;\n        Features(FeatureFlags flags): flags(flags){}\n\n        Features&amp; withFlag(FeatureFlag flag)\n        {\n            flags.setFlag(flag);\n            return *this;\n        }\n\n        static Features all() { return {FeatureFlag::all}; }\n        static Features none() { return {FeatureFlag::none}; }\n    };\n\n    ApplicationContext(\n        PeerType localPeerType = PeerType::notDefined,\n        Features features = Features::none(),\n        const QString&amp; customCloudHost = QString{},\n        QObject* parent = nullptr);\n\n    virtual ~ApplicationContext() override;\n\n    /** Call before the destructor to ensure correct stop order. */\n    virtual void stopAll();\n\n    const Features&amp; commonFeatures() const;\n\n    /**\n     * Main context of the VMS applications. Exists through all application lifetime.\n     */\n    static ApplicationContext* instance();\n\n    PeerType localPeerType() const;\n\n    /** Application language locale code (in form `en_US`). */\n    QString locale() const;\n\n    /** Set application language locale code (in form `en_US`). */\n    void setLocale(const QString&amp; value);\n\n    /** Application-wide translation manager. */\n    nx::i18n::TranslationManager* translationManager() const;\n\n    void setModuleShortId(const nx::Uuid&amp; id, int number);\n    int moduleShortId(const nx::Uuid&amp; id) const;\n    QString moduleDisplayName(const nx::Uuid&amp; id) const;\n\n    QnStoragePluginFactory* storagePluginFactory() const;\n    QnLongRunableCleanup* longRunableCleanup() const;\n    nx::metric::ApplicationMetricsStorage* metrics() const;\n\n    virtual bool isCertificateValidationLevelStrict() const;\n\n    template&lt;typename ContextType&gt;\n    ContextType* as()\n    {\n        return qobject_cast&lt;ContextType*&gt;(this);\n    }\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\ninline ApplicationContext* appContext() { return ApplicationContext::instance(); }\n\n} // namespace nx::vms::common\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/ptz/types_fwd.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/ptz/types_fwd.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/ptz/types_fwd.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\nnamespace nx::vms::common {\nnamespace ptz {\n\nenum class Command;\nenum class Component;\nenum class DataField;\nenum class LimitsType;\nenum class Type;\n\nstruct Options;\nstruct Override;\nstruct Vector;\n\n} // namespace ptz\n} // namespace nx::vms::common\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scrypt.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scrypt.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scrypt.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;string&gt;\n\n#include &lt;nx/reflect/instrument.h&gt;\n\n#include &quot;exception.h&quot;\n\nnamespace nx::scrypt {\n\nclass NX_UTILS_API Exception: public nx::utils::ContextedException\n{\n    using nx::utils::ContextedException::ContextedException;\n};\n\n/**\n * SCrypt algorithm options, see https://tools.ietf.org/html/rfc7914. The defaults are taken from\n * openssl example https://www.openssl.org/docs/man1.1.1/man7/scrypt.html.\n */\nstruct NX_UTILS_API Options\n{\n    /** Block size. */\n    uint32_t r = 8;\n\n    /** CPU/Memory cost, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). */\n    uint32_t N = 1024;\n\n    /** The parallelization parameter is a positive integer less than or equal to\n     *  ((2^32-1) * 32) / (128 * r) */\n    uint32_t p = 16;\n\n    /** Output key size, it is a positive integer less than or equal to (2^32 - 1) * 32. */\n    size_t keySize = 32;\n\n    bool operator==(const Options&amp; rhs) const;\n\n    void validateOrThrow() const;\n    bool isValid() const;\n    QString toString() const;\n    static Options fromString(const std::string&amp;);\n};\n\nNX_REFLECTION_TAG_TYPE(Options, useStringConversionForSerialization)\n\nNX_UTILS_API std::string encodeOrThrow(\n    const std::string&amp; password,\n    const std::string&amp; salt,\n    const Options&amp; options = {});\n\nNX_UTILS_API std::optional&lt;std::string&gt; encode(\n    const std::string&amp; password,\n    const std::string&amp; salt,\n    const Options&amp; options = {});\n\n} // nx::scrypt\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/resource/camera_resource_stub.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/resource/camera_resource_stub.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/resource/camera_resource_stub.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;core/resource/camera_resource.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n\nnamespace nx {\n\nclass NX_VMS_COMMON_API CameraResourceStub: public QnVirtualCameraResource\n{\n    using base_type = QnVirtualCameraResource;\n    using StreamIndex = nx::vms::api::StreamIndex;\n\npublic:\n    CameraResourceStub(Qn::LicenseType licenseType = Qn::LC_Professional);\n    CameraResourceStub(const QSize&amp; primaryResolution, const QSize&amp; secondaryResolution = QSize(),\n        Qn::LicenseType licenseType = Qn::LC_Professional);\n    virtual ~CameraResourceStub() override;\n\n    virtual bool hasDualStreamingInternal() const override;\n    void setHasDualStreaming(bool value);\n\n    void markCameraAsNvr();\n    void markCameraAsVMax();\n\n    void setLicenseType(Qn::LicenseType licenseType);\n\n    virtual bool setProperty(\n        const QString&amp; key,\n        const QString&amp; value,\n        bool markDirty = true) override;\n\n    void setStreamResolution(StreamIndex index, const QSize&amp; resolution);\n\n    /** Emulate camera ability to produce analytics objects. */\n    void setAnalyticsObjectsEnabled(\n        bool value = true,\n        const nx::Uuid&amp; engineId = nx::Uuid::createUuid());\n\n    virtual AnalyticsEntitiesByEngine supportedObjectTypes(\n        bool filterByEngines = true) const override;\n    void setSupportedObjectTypes(const QMap&lt;nx::Uuid, std::set&lt;QString&gt;&gt;&amp; supportedObjectTypes);\n\n    virtual AnalyticsEntitiesByEngine supportedEventTypes() const override;\n    void setSupportedEventTypes(const QMap&lt;nx::Uuid, std::set&lt;QString&gt;&gt;&amp; eventTypesByEngine);\n\n    virtual std::set&lt;nx::Uuid&gt; enabledAnalyticsEngines() const override;\n    void setEnabledAnalyticsEngines(std::set&lt;nx::Uuid&gt; engines);\n\n    virtual nx::vms::common::AnalyticsEngineResourceList\n        compatibleAnalyticsEngineResources() const override;\n    void setCompatibleAnalyticsEngineResources(\n        nx::vms::common::AnalyticsEngineResourceList engines);\n\nprotected:\n    virtual QnAbstractStreamDataProvider* createDataProvider(Qn::ConnectionRole role) override;\n    virtual Qn::LicenseType calculateLicenseType() const override;\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\nusing CameraResourceStubPtr = QnSharedResourcePointer&lt;CameraResourceStub&gt;;\nusing StubCameraResourceList = QnSharedResourcePointerList&lt;CameraResourceStub&gt;;\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/utils/abstract_session_token_helper.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/utils/abstract_session_token_helper.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/utils/abstract_session_token_helper.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QString&gt;\n\n#include &lt;nx/network/http/auth_tools.h&gt;\n\nnamespace nx::vms::common {\n\n/**\n * This class provides an interface to issue a new Session token.\n */\nclass NX_VMS_COMMON_API AbstractSessionTokenHelper\n{\npublic:\n    virtual ~AbstractSessionTokenHelper() = default;\n\n    /* Return access token. */\n    virtual std::optional&lt;nx::network::http::AuthToken&gt; refreshSession() = 0;\n\n    virtual QString password() const = 0;\n};\n\nusing SessionTokenHelperPtr = std::shared_ptr&lt;AbstractSessionTokenHelper&gt;;\n\n} // namespace nx::vms::common\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QList&gt;\n\n#include &lt;nx/vms/api/types/smtp_types.h&gt;\n\nnamespace QnEmail {\n\nusing ConnectionType = nx::vms::api::ConnectionType;\n\n} // namespace QnEmail\n\nstruct QnEmailSmtpServerPreset;\nstruct QnEmailSettings;\nclass  QnEmailAddress;\n\nstruct SmtpOperationResult;\n\nenum SmtpReplyCode\n{\n    NoReply = 0,\n    NonStandardSuccess = 200,\n    SystemStatus = 211,\n    Help = 214,\n    ServiceReady = 220,\n    ServiceClosedChannel = 221,\n    AuthSuccessful = 235,\n    MailActionOK = 250,\n    UserNotLocal = 251,\n    CannotVerifyUser = 252,\n    ServerChallenge = 334,\n    StartMailInput = 354,\n    ServiceNotAvailable = 421,\n    MailboxTemporaryUnavailable = 450,\n    ProcessingError = 451,\n    InsufficientStorage = 452,\n    CommandSyntaxError = 500,\n    ParameterSyntaxError = 501,\n    CommandNotImplemented = 502,\n    BadCommandSequence = 503,\n    ParameterNotImplemented = 504,\n    MailIsNotAccepted = 521,\n    AccessDenied = 530,\n    MailboxUnavailable = 550,\n    UserNotLocalError = 551,\n    ActionAborted = 552,\n    InvalidMailboxName = 553,\n    TransactionFailed = 554,\n};\n\nnamespace nx::email {\n\nenum class SmtpError;\n\nstruct Attachment;\nusing AttachmentList = QList&lt;Attachment&gt;;\n\nstruct Message;\n\n} // namespace nx::email\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don&#x27;t\n// end with _ are part of Google Test&#x27;s public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don&#x27;t need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it&#x27;s necessary for a user to define some of the following\n// macros in the build script to override Google Test&#x27;s decisions.\n//\n// If the user doesn&#x27;t define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don&#x27;t use #ifdef or &quot;#if\n//     defined(...)&quot;, which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren&#x27;t available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that &lt;pthread.h&gt;\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn&#x27;t\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn&#x27;t work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_FILE_SYSTEM    - Define it to 1/0 to indicate whether or not a\n//                              file system is/isn&#x27;t available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft&#x27;s &quot;Structured\n//                              Exception Handling&quot;.\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n//   GTEST_DEFAULT_DEATH_TEST_STYLE\n//                            - The default value of --gtest_death_test_style.\n//                              The legacy default has been &quot;fast&quot; in the open\n//                              source version since 2008. The recommended value\n//                              is &quot;threadsafe&quot;, and can be set in\n//                              custom/gtest-port.h.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_DRAGONFLY - DragonFlyBSD\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_FUCHSIA  - Fuchsia\n//   GTEST_OS_GNU_HURD - GNU/Hurd\n//   GTEST_OS_GNU_KFREEBSD - GNU/kFreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_NETBSD   - NetBSD\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_OS2      - OS/2\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Mac OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don&#x27;t have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #ifdef\n// which controls that code.  For example:\n//\n// #ifdef GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_RE2         - the RE2 regular expression library is used\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above RE\\b(s) are mutually exclusive.\n//   GTEST_HAS_ABSL         - Google Test is compiled with Abseil.\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test&#x27;s INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_MUST_USE_RESULT_   - declares that a function&#x27;s result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//   GTEST_INTERNAL_HAS_ANY - for enabling UniversalPrinter&lt;std::any&gt; or\n//                            UniversalPrinter&lt;absl::any&gt; specializations.\n//                            Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_OPTIONAL - for enabling UniversalPrinter&lt;std::optional&gt;\n//   or\n//                                 UniversalPrinter&lt;absl::optional&gt;\n//                                 specializations. Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_STD_SPAN - for enabling UniversalPrinter&lt;std::span&gt;\n//                                 specializations. Always defined to 0 or 1\n//   GTEST_INTERNAL_HAS_STRING_VIEW - for enabling Matcher&lt;std::string_view&gt; or\n//                                    Matcher&lt;absl::string_view&gt;\n//                                    specializations. Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_VARIANT - for enabling UniversalPrinter&lt;std::variant&gt; or\n//                                UniversalPrinter&lt;absl::variant&gt;\n//                                specializations. Always defined to 0 or 1.\n//   GTEST_USE_OWN_FLAGFILE_FLAG_ - Always defined to 0 or 1.\n//   GTEST_HAS_CXXABI_H_ - Always defined to 0 or 1.\n//   GTEST_CAN_STREAM_RESULTS_ - Always defined to 0 or 1.\n//   GTEST_HAS_ALT_PATH_SEP_ - Always defined to 0 or 1.\n//   GTEST_WIDE_STRING_USES_UTF16_ - Always defined to 0 or 1.\n//   GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ - Always defined to 0 or 1.\n//   GTEST_HAS_NOTIFICATION_- Always defined to 0 or 1.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using\n//                     1) the RE2 syntax on all platforms when built with RE2\n//                        and Abseil as dependencies\n//                     2) the POSIX Extended Regular Expression syntax on\n//                        UNIX-like platforms,\n//                     3) A reduced regular exception syntax on other platforms,\n//                        including Windows.\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   TimeInMillis   - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an int32_t environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n//\n// Deprecation warnings:\n//   GTEST_INTERNAL_DEPRECATED(message) - attribute marking a function as\n//                                        deprecated; calling a marked function\n//                                        should generate a compiler warning\n\n// The definition of GTEST_INTERNAL_CPLUSPLUS_LANG comes first because it can\n// potentially be used as an #include guard.\n#if defined(_MSVC_LANG)\n#define GTEST_INTERNAL_CPLUSPLUS_LANG _MSVC_LANG\n#elif defined(__cplusplus)\n#define GTEST_INTERNAL_CPLUSPLUS_LANG __cplusplus\n#endif\n\n#if !defined(GTEST_INTERNAL_CPLUSPLUS_LANG) || \\\n    GTEST_INTERNAL_CPLUSPLUS_LANG &lt; 201402L\n#error C++ versions less than C++14 are not supported.\n#endif\n\n// MSVC &gt;= 19.11 (VS 2017 Update 3) supports __has_include.\n#ifdef __has_include\n#define GTEST_INTERNAL_HAS_INCLUDE __has_include\n#else\n#define GTEST_INTERNAL_HAS_INCLUDE(...) 0\n#endif\n\n// Detect C++ feature test macros as gracefully as possible.\n// MSVC &gt;= 19.15, Clang &gt;= 3.4.1, and GCC &gt;= 4.1.2 support feature test macros.\n#if GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 202002L &amp;&amp; \\\n    (!defined(__has_include) || GTEST_INTERNAL_HAS_INCLUDE(&lt;version&gt;))\n#include &lt;version&gt;  // C++20 and later\n#elif (!defined(__has_include) || GTEST_INTERNAL_HAS_INCLUDE(&lt;ciso646&gt;))\n#include &lt;ciso646&gt;  // Pre-C++20\n#endif\n\n#include &lt;ctype.h&gt;   // for isspace, etc\n#include &lt;stddef.h&gt;  // for ptrdiff_t\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cerrno&gt;\n// #include &lt;condition_variable&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n// #include &lt;mutex&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#ifndef _WIN32_WCE\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n#include &lt;AvailabilityMacros.h&gt;\n#include &lt;TargetConditionals.h&gt;\n#endif\n\n#include &quot;gtest/internal/custom/gtest-port.h&quot;\n#include &quot;gtest/internal/gtest-port-arch.h&quot;\n\n#ifndef GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n#define GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ 0\n#endif\n\n#ifndef GTEST_HAS_NOTIFICATION_\n#define GTEST_HAS_NOTIFICATION_ 0\n#endif\n\n#if defined(GTEST_HAS_ABSL) &amp;&amp; !defined(GTEST_NO_ABSL_FLAGS)\n#define GTEST_INTERNAL_HAS_ABSL_FLAGS  // Used only in this file.\n#include &quot;absl/flags/declare.h&quot;\n#include &quot;absl/flags/flag.h&quot;\n#include &quot;absl/flags/reflection.h&quot;\n#endif\n\n#if !defined(GTEST_DEV_EMAIL_)\n#define GTEST_DEV_EMAIL_ &quot;googletestframework@@googlegroups.com&quot;\n#define GTEST_FLAG_PREFIX_ &quot;gtest_&quot;\n#define GTEST_FLAG_PREFIX_DASH_ &quot;gtest-&quot;\n#define GTEST_FLAG_PREFIX_UPPER_ &quot;GTEST_&quot;\n#define GTEST_NAME_ &quot;Google Test&quot;\n#define GTEST_PROJECT_URL_ &quot;https://github.com/google/googletest/&quot;\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n#define GTEST_INIT_GOOGLE_TEST_NAME_ &quot;testing::InitGoogleTest&quot;\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n#define GTEST_GCC_VER_ \\\n  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if defined(_MSC_VER)\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n  __pragma(warning(push)) __pragma(warning(disable : warnings))\n#define GTEST_DISABLE_MSC_WARNINGS_POP_() __pragma(warning(pop))\n#else\n// Not all compilers are MSVC\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n#define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Clang on Windows does not understand MSVC&#x27;s pragma warning.\n// We need clang-specific way to disable function deprecation warning.\n#ifdef __clang__\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_()                            \\\n  _Pragma(&quot;clang diagnostic push&quot;)                                      \\\n      _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-declarations\\&quot;&quot;) \\\n          _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-implementations\\&quot;&quot;)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() _Pragma(&quot;clang diagnostic pop&quot;)\n#else\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#ifdef GTEST_OS_WINDOWS\n#ifndef GTEST_OS_WINDOWS_MOBILE\n#include &lt;direct.h&gt;\n#include &lt;io.h&gt;\n#endif\n// In order to avoid having to include &lt;windows.h&gt;, use forward declaration\n#if defined(GTEST_OS_WINDOWS_MINGW) &amp;&amp; !defined(__MINGW64_VERSION_MAJOR)\n// MinGW defined _CRITICAL_SECTION and _RTL_CRITICAL_SECTION as two\n// separate (equivalent) structs, instead of using typedef\ntypedef struct _CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#else\n// Assume CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\ntypedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#endif\n#elif defined(GTEST_OS_XTENSA)\n#include &lt;unistd.h&gt;\n// Xtensa toolchains define strcasecmp in the string.h header instead of\n// strings.h. string.h is already included.\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n#include &lt;strings.h&gt;\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#ifdef GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#include &lt;android/api-level.h&gt;  // NOLINT\n#endif\n\n// Defines this to true if and only if Google Test can use POSIX regular\n// expressions.\n#ifndef GTEST_HAS_POSIX_RE\n#ifdef GTEST_OS_LINUX_ANDROID\n// On Android, &lt;regex.h&gt; is only available starting with Gingerbread.\n#define GTEST_HAS_POSIX_RE (__ANDROID_API__ &gt;= 9)\n#else\n#if !(defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_XTENSA) || \\\n      defined(GTEST_OS_QURT))\n#define GTEST_HAS_POSIX_RE 1\n#else\n#define GTEST_HAS_POSIX_RE 0\n#endif\n#endif  // GTEST_OS_LINUX_ANDROID\n#endif\n\n// Select the regular expression implementation.\n#ifdef GTEST_HAS_ABSL\n// When using Abseil, RE2 is required.\n#include &quot;absl/strings/string_view.h&quot;\n#include &quot;re2/re2.h&quot;\n#define GTEST_USES_RE2 1\n#elif GTEST_HAS_POSIX_RE\n#include &lt;regex.h&gt;  // NOLINT\n#define GTEST_USES_POSIX_RE 1\n#else\n// Use our own simple regex implementation.\n#define GTEST_USES_SIMPLE_RE 1\n#endif\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn&#x27;t tell us whether exceptions are enabled, so we need\n// to figure it out.\n#if defined(_MSC_VER) &amp;&amp; defined(_CPPUNWIND)\n// MSVC defines _CPPUNWIND to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__BORLANDC__)\n// C++Builder&#x27;s implementation of the STL uses the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we&#x27;ll do the same.\n// Assumes that exceptions are enabled by default.\n#ifndef _HAS_EXCEPTIONS\n#define _HAS_EXCEPTIONS 1\n#endif  // _HAS_EXCEPTIONS\n#define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n#elif defined(__clang__)\n// clang defines __EXCEPTIONS if and only if exceptions are enabled before clang\n// 220714, but if and only if cleanups are enabled after that. In Obj-C++ files,\n// there can be cleanups for ObjC exceptions which also need cleanups, even if\n// C++ exceptions are disabled. clang has __has_feature(cxx_exceptions) which\n// checks for C++ exceptions starting at clang r206352, but which checked for\n// cleanups prior to that. To reliably check for C++ exception availability with\n// clang, check for\n// __EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions).\n#if defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions)\n#define GTEST_HAS_EXCEPTIONS 1\n#else\n#define GTEST_HAS_EXCEPTIONS 0\n#endif\n#elif defined(__GNUC__) &amp;&amp; defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__IBMCPP__) &amp;&amp; defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#define GTEST_HAS_EXCEPTIONS 1\n#else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#define GTEST_HAS_EXCEPTIONS 0\n#endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn&#x27;t tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// Cygwin 1.7 and below doesn&#x27;t support ::std::wstring.\n// Solaris&#x27; libc++ doesn&#x27;t support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n#if (!(defined(GTEST_OS_LINUX_ANDROID) || defined(GTEST_OS_CYGWIN) || \\\n       defined(GTEST_OS_SOLARIS) || defined(GTEST_OS_HAIKU) ||        \\\n       defined(GTEST_OS_ESP32) || defined(GTEST_OS_ESP8266) ||        \\\n       defined(GTEST_OS_XTENSA) || defined(GTEST_OS_QURT) ||          \\\n       defined(GTEST_OS_NXP_QN9090) || defined(GTEST_OS_NRF52)))\n#define GTEST_HAS_STD_WSTRING 1\n#else\n#define GTEST_HAS_STD_WSTRING 0\n#endif\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_FILE_SYSTEM\n// Most platforms support a file system.\n#define GTEST_HAS_FILE_SYSTEM 1\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn&#x27;t tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n#ifdef _MSC_VER\n\n#ifdef _CPPRTTI  // MSVC defines this macro if and only if RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI if and only if RTTI is\n// enabled.\n#elif defined(__GNUC__)\n\n#ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#if defined(GTEST_OS_LINUX_ANDROID) &amp;&amp; defined(_STLPORT_MAJOR) &amp;&amp; \\\n    !defined(__EXCEPTIONS)\n#define GTEST_HAS_RTTI 0\n#else\n#define GTEST_HAS_RTTI 1\n#endif  // GTEST_OS_LINUX_ANDROID &amp;&amp; __STLPORT_MAJOR &amp;&amp; !__EXCEPTIONS\n#else\n#define GTEST_HAS_RTTI 0\n#endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n#elif defined(__clang__)\n\n#define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n#elif defined(__IBMCPP__) &amp;&amp; (__IBMCPP__ &gt;= 900)\n\n#ifdef __RTTI_ALL__\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n#else\n\n// For all other compilers, we assume RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n\n#endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It&#x27;s this header&#x27;s responsibility to #include &lt;typeinfo&gt; when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n#include &lt;typeinfo&gt;\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn&#x27;t tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n#if (defined(GTEST_OS_LINUX) || defined(GTEST_OS_MAC) ||              \\\n     defined(GTEST_OS_HPUX) || defined(GTEST_OS_QNX) ||               \\\n     defined(GTEST_OS_FREEBSD) || defined(GTEST_OS_NACL) ||           \\\n     defined(GTEST_OS_NETBSD) || defined(GTEST_OS_FUCHSIA) ||         \\\n     defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n     defined(GTEST_OS_OPENBSD) || defined(GTEST_OS_HAIKU) ||          \\\n     defined(GTEST_OS_GNU_HURD) || defined(GTEST_OS_SOLARIS) ||       \\\n     defined(GTEST_OS_AIX) || defined(GTEST_OS_ZOS))\n#define GTEST_HAS_PTHREAD 1\n#else\n#define GTEST_HAS_PTHREAD 0\n#endif\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include &lt;pthread.h&gt; when GTEST_HAS_PTHREAD is\n// true.\n#include &lt;pthread.h&gt;  // NOLINT\n\n// For timespec and nanosleep, used below.\n#include &lt;time.h&gt;  // NOLINT\n#endif\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see https://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if defined(GTEST_OS_LINUX) &amp;&amp; !defined(__ia64__)\n#if defined(GTEST_OS_LINUX_ANDROID)\n// On Android, clone() became available at different API levels for each 32-bit\n// architecture.\n#if defined(__LP64__) || (defined(__arm__) &amp;&amp; __ANDROID_API__ &gt;= 9) || \\\n    (defined(__mips__) &amp;&amp; __ANDROID_API__ &gt;= 12) ||                    \\\n    (defined(__i386__) &amp;&amp; __ANDROID_API__ &gt;= 17)\n#define GTEST_HAS_CLONE 1\n#else\n#define GTEST_HAS_CLONE 0\n#endif\n#else\n#define GTEST_HAS_CLONE 1\n#endif\n#else\n#define GTEST_HAS_CLONE 0\n#endif  // GTEST_OS_LINUX &amp;&amp; !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile / embedded ones. Also, if the port doesn&#x27;t have\n// a file system, stream redirection is not supported.\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_WINDOWS_PHONE) || \\\n    defined(GTEST_OS_WINDOWS_RT) || defined(GTEST_OS_WINDOWS_GAMES) ||     \\\n    defined(GTEST_OS_ESP8266) || defined(GTEST_OS_XTENSA) ||               \\\n    defined(GTEST_OS_QURT) || !GTEST_HAS_FILE_SYSTEM\n#define GTEST_HAS_STREAM_REDIRECTION 0\n#else\n#define GTEST_HAS_STREAM_REDIRECTION 1\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (defined(GTEST_OS_LINUX) || defined(GTEST_OS_CYGWIN) ||           \\\n     defined(GTEST_OS_SOLARIS) || defined(GTEST_OS_ZOS) ||            \\\n     (defined(GTEST_OS_MAC) &amp;&amp; !defined(GTEST_OS_IOS)) ||             \\\n     (defined(GTEST_OS_WINDOWS_DESKTOP) &amp;&amp; _MSC_VER) ||               \\\n     defined(GTEST_OS_WINDOWS_MINGW) || defined(GTEST_OS_AIX) ||      \\\n     defined(GTEST_OS_HPUX) || defined(GTEST_OS_OPENBSD) ||           \\\n     defined(GTEST_OS_QNX) || defined(GTEST_OS_FREEBSD) ||            \\\n     defined(GTEST_OS_NETBSD) || defined(GTEST_OS_FUCHSIA) ||         \\\n     defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n     defined(GTEST_OS_HAIKU) || defined(GTEST_OS_GNU_HURD))\n// Death tests require a file system to work properly.\n#if GTEST_HAS_FILE_SYSTEM\n#define GTEST_HAS_DEATH_TEST 1\n#endif  // GTEST_HAS_FILE_SYSTEM\n#endif\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need &lt;typeinfo&gt; and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || defined(_MSC_VER) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n#define GTEST_HAS_TYPED_TEST 1\n#define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_CYGWIN) || \\\n    defined(GTEST_OS_AIX) || defined(GTEST_OS_OS2)\n#define GTEST_WIDE_STRING_USES_UTF16_ 1\n#else\n#define GTEST_WIDE_STRING_USES_UTF16_ 0\n#endif\n\n// Determines whether test results can be streamed to a socket.\n#if defined(GTEST_OS_LINUX) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n    defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_FREEBSD) ||  \\\n    defined(GTEST_OS_NETBSD) || defined(GTEST_OS_OPENBSD) ||     \\\n    defined(GTEST_OS_GNU_HURD) || defined(GTEST_OS_MAC)\n#define GTEST_CAN_STREAM_RESULTS_ 1\n#else\n#define GTEST_CAN_STREAM_RESULTS_ 0\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested &quot;if&quot; statements are followed by\n// an &quot;else&quot; statement and braces are not used to explicitly disambiguate the\n// &quot;else&quot; binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) &lt;&lt; &quot;Some message&quot;;\n//\n// The &quot;switch (0) case 0:&quot; idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  switch (0)                          \\\n  case 0:                             \\\n  default:  // NOLINT\n#endif\n\n// GTEST_HAVE_ATTRIBUTE_\n//\n// A function-like feature checking macro that is a wrapper around\n// `__has_attribute`, which is defined by GCC 5+ and Clang and evaluates to a\n// nonzero constant integer if the attribute is supported or 0 if not.\n//\n// It evaluates to zero if `__has_attribute` is not defined by the compiler.\n//\n// GCC: https://gcc.gnu.org/gcc-5/changes.html\n// Clang: https://clang.llvm.org/docs/LanguageExtensions.html\n#ifdef __has_attribute\n#define GTEST_HAVE_ATTRIBUTE_(x) __has_attribute(x)\n#else\n#define GTEST_HAVE_ATTRIBUTE_(x) 0\n#endif\n\n// GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE\n//\n// A function-like feature checking macro that accepts C++11 style attributes.\n// It&#x27;s a wrapper around `__has_cpp_attribute`, defined by ISO C++ SD-6\n// (https://en.cppreference.com/w/cpp/experimental/feature_test). If we don&#x27;t\n// find `__has_cpp_attribute`, will evaluate to 0.\n#if defined(__has_cpp_attribute)\n// NOTE: requiring __cplusplus above should not be necessary, but\n// works around https://bugs.llvm.org/show_bug.cgi?id=23435.\n#define GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n#define GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(x) 0\n#endif\n\n// GTEST_HAVE_FEATURE_\n//\n// A function-like feature checking macro that is a wrapper around\n// `__has_feature`.\n#ifdef __has_feature\n#define GTEST_HAVE_FEATURE_(x) __has_feature(x)\n#else\n#define GTEST_HAVE_FEATURE_(x) 0\n#endif\n\n// Use this annotation after a variable or parameter declaration to tell the\n// compiler the variable/parameter may be used.\n// Example:\n//\n//   GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED int foo = bar();\n//\n// This can be removed once we only support only C++17 or newer and\n// [[maybe_unused]] is available on all supported platforms.\n#if GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(maybe_unused)\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED [[maybe_unused]]\n#elif GTEST_HAVE_ATTRIBUTE_(unused)\n// This is inferior to [[maybe_unused]] as it can produce a\n// -Wused-but-marked-unused warning on optionally used symbols, but it is all we\n// have.\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED __attribute__((__unused__))\n#else\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED\n#endif\n\n// Use this annotation before a function that takes a printf format string.\n#if GTEST_HAVE_ATTRIBUTE_(format) &amp;&amp; defined(__MINGW_PRINTF_FORMAT)\n// MinGW has two different printf implementations. Ensure the format macro\n// matches the selected implementation. See\n// https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/.\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((format(__MINGW_PRINTF_FORMAT, string_index, first_to_check)))\n#elif GTEST_HAVE_ATTRIBUTE_(format)\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((format(printf, string_index, first_to_check)))\n#else\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check)\n#endif\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if GTEST_HAVE_ATTRIBUTE_(warn_unused_result)\n#define GTEST_MUST_USE_RESULT_ __attribute__((warn_unused_result))\n#else\n#define GTEST_MUST_USE_RESULT_\n#endif\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n#define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n#define GTEST_INTENTIONAL_CONST_COND_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft&#x27;s Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#define GTEST_HAS_SEH 1\n#else\n// Assume no SEH.\n#define GTEST_HAS_SEH 0\n#endif\n\n#endif  // GTEST_HAS_SEH\n\n#ifndef GTEST_IS_THREADSAFE\n\n#if (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ ||                              \\\n     (defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n      !defined(GTEST_OS_WINDOWS_RT)) ||                                \\\n     GTEST_HAS_PTHREAD)\n#define GTEST_IS_THREADSAFE 1\n#endif\n\n#endif  // GTEST_IS_THREADSAFE\n\n#ifdef GTEST_IS_THREADSAFE\n// Some platforms don&#x27;t support including these threading related headers.\n#include &lt;condition_variable&gt;  // NOLINT\n#include &lt;mutex&gt;               // NOLINT\n#endif                         // GTEST_IS_THREADSAFE\n\n// GTEST_API_ qualifies all symbols that must be exported. The definitions below\n// are guarded by #ifndef to give embedders a chance to define GTEST_API_ in\n// gtest/internal/custom/gtest-port.h\n#ifndef GTEST_API_\n\n#ifdef _MSC_VER\n#if defined(GTEST_LINKED_AS_SHARED_LIBRARY) &amp;&amp; GTEST_LINKED_AS_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllimport)\n#elif defined(GTEST_CREATE_SHARED_LIBRARY) &amp;&amp; GTEST_CREATE_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllexport)\n#endif\n#elif GTEST_HAVE_ATTRIBUTE_(visibility)\n#define GTEST_API_ __attribute__((visibility(&quot;default&quot;)))\n#endif  // _MSC_VER\n\n#endif  // GTEST_API_\n\n#ifndef GTEST_API_\n#define GTEST_API_\n#endif  // GTEST_API_\n\n#ifndef GTEST_DEFAULT_DEATH_TEST_STYLE\n#define GTEST_DEFAULT_DEATH_TEST_STYLE &quot;fast&quot;\n#endif  // GTEST_DEFAULT_DEATH_TEST_STYLE\n\n#if GTEST_HAVE_ATTRIBUTE_(noinline)\n// Ask the compiler to never inline a given function.\n#define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n#define GTEST_NO_INLINE_\n#endif\n\n#if GTEST_HAVE_ATTRIBUTE_(disable_tail_calls)\n// Ask the compiler not to perform tail call optimization inside\n// the marked function.\n#define GTEST_NO_TAIL_CALL_ __attribute__((disable_tail_calls))\n#elif defined(__GNUC__) &amp;&amp; !defined(__NVCOMPILER)\n#define GTEST_NO_TAIL_CALL_ \\\n  __attribute__((optimize(&quot;no-optimize-sibling-calls&quot;)))\n#else\n#define GTEST_NO_TAIL_CALL_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if !defined(GTEST_HAS_CXXABI_H_)\n#if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) &amp;&amp; !defined(_MSC_VER))\n#define GTEST_HAS_CXXABI_H_ 1\n#else\n#define GTEST_HAS_CXXABI_H_ 0\n#endif\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_memory)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ __attribute__((no_sanitize_memory))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_address)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n  __attribute__((no_sanitize_address))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif\n\n// A function level attribute to disable HWAddressSanitizer instrumentation.\n#if GTEST_HAVE_FEATURE_(hwaddress_sanitizer) &amp;&amp; \\\n    GTEST_HAVE_ATTRIBUTE_(no_sanitize)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ \\\n  __attribute__((no_sanitize(&quot;hwaddress&quot;)))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n#endif\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_thread)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ __attribute((no_sanitize_thread))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif\n\nnamespace testing {\n\nclass Message;\n\n// Legacy imports for backwards compatibility.\n// New code should use std:: names directly.\nusing std::get;\nusing std::make_tuple;\nusing std::tuple;\nusing std::tuple_element;\nusing std::tuple_size;\n\nnamespace internal {\n\n// A secret type that Google Test users don&#x27;t know about.  It has no\n// accessible constructors on purpose.  Therefore it&#x27;s impossible to create a\n// Secret object, which is what we want.\nclass Secret {\n  Secret(const Secret&amp;) = delete;\n};\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns &#x27;condition&#x27;.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines RE.\n\n#ifdef GTEST_USES_RE2\n\n// This is almost `using RE = ::RE2`, except it is copy-constructible, and it\n// needs to disambiguate the `std::string`, `absl::string_view`, and `const\n// char*` constructors.\nclass GTEST_API_ RE {\n public:\n  RE(absl::string_view regex) : regex_(regex) {}                  // NOLINT\n  RE(const char* regex) : RE(absl::string_view(regex)) {}         // NOLINT\n  RE(const std::string&amp; regex) : RE(absl::string_view(regex)) {}  // NOLINT\n  RE(const RE&amp; other) : RE(other.pattern()) {}\n\n  const std::string&amp; pattern() const { return regex_.pattern(); }\n\n  static bool FullMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::FullMatch(str, re.regex_);\n  }\n  static bool PartialMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::PartialMatch(str, re.regex_);\n  }\n\n private:\n  RE2 regex_;\n};\n\n#elif defined(GTEST_USES_POSIX_RE) || defined(GTEST_USES_SIMPLE_RE)\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// A simple C++ wrapper for &lt;regex.h&gt;.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE&amp; other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string&amp; regex) { Init(regex.c_str()); }  // NOLINT\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_.c_str(); }\n\n  // FullMatch(str, re) returns true if and only if regular expression re\n  // matches the entire str.\n  // PartialMatch(str, re) returns true if and only if regular expression re\n  // matches a substring of str (including str itself).\n  static bool FullMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n  static bool FullMatch(const char* str, const RE&amp; re);\n  static bool PartialMatch(const char* str, const RE&amp; re);\n\n private:\n  void Init(const char* regex);\n  std::string pattern_;\n  bool is_valid_;\n\n#ifdef GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  std::string full_pattern_;  // For FullMatch();\n\n#endif\n};\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n#endif  // ::testing::internal::RE implementation\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity { GTEST_INFO, GTEST_WARNING, GTEST_ERROR, GTEST_FATAL };\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream&amp; GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTestLog(const GTestLog&amp;) = delete;\n  GTestLog&amp; operator=(const GTestLog&amp;) = delete;\n};\n\n#if !defined(GTEST_LOG_)\n\n#define GTEST_LOG_(severity)                                           \\\n  ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                __FILE__, __LINE__)                    \\\n      .GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(nullptr); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsis:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) &lt;&lt; &quot;Additional message&quot;;\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n#define GTEST_CHECK_(condition)               \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_               \\\n  if (::testing::internal::IsTrue(condition)) \\\n    ;                                         \\\n  else                                        \\\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Condition &quot; #condition &quot; failed. &quot;\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn&#x27;t expand to a balanced &#x27;if&#x27; statement, so enclose the macro\n// in {} if you need to use it as the only statement in an &#x27;if&#x27;\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call))    \\\n  GTEST_LOG_(FATAL) &lt;&lt; #posix_call &lt;&lt; &quot;failed with error &quot; &lt;&lt; gtest_error\n\n// Transforms &quot;T&quot; into &quot;const T&amp;&quot; according to standard reference collapsing\n// rules (this is only needed as a backport for C++98 compilers that do not\n// support reference collapsing). Specifically, it transforms:\n//\n//   char         ==&gt; const char&amp;\n//   const char   ==&gt; const char&amp;\n//   char&amp;        ==&gt; char&amp;\n//   const char&amp;  ==&gt; const char&amp;\n//\n// Note that the non-const reference will not have &quot;const&quot; added. This is\n// standard, and necessary so that &quot;T&quot; can always bind to &quot;const T&amp;&quot;.\ntemplate &lt;typename T&gt;\nstruct ConstRef {\n  typedef const T&amp; type;\n};\ntemplate &lt;typename T&gt;\nstruct ConstRef&lt;T&amp;&gt; {\n  typedef T&amp; type;\n};\n\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n  typename ::testing::internal::ConstRef&lt;T&gt;::type\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertible to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_&lt;ToType&gt;(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate &lt;typename To&gt;\ninline To ImplicitCast_(To x) {\n  return x;\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate &lt;class Derived, class Base&gt;\nDerived* CheckedDowncastToActualType(Base* base) {\n  static_assert(std::is_base_of&lt;Base, Derived&gt;::value,\n                &quot;target type not derived from source type&quot;);\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(base == nullptr || dynamic_cast&lt;Derived*&gt;(base) != nullptr);\n#endif\n  return static_cast&lt;Derived*&gt;(base);\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ std::vector&lt;std::string&gt; GetArgvs();\n\n#ifdef GTEST_HAS_DEATH_TEST\n\nstd::vector&lt;std::string&gt; GetInjectableArgvs();\n// Deprecated: pass the args vector by value instead.\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;* new_argvs);\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;&amp; new_argvs);\nvoid ClearInjectableArgvs();\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#ifdef GTEST_IS_THREADSAFE\n\n#ifdef GTEST_OS_WINDOWS\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including &lt;windows.h&gt; in this header file. Including &lt;windows.h&gt; is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true if and only if the handle is a valid handle object that can be\n  // closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  AutoHandle(const AutoHandle&amp;) = delete;\n  AutoHandle&amp; operator=(const AutoHandle&amp;) = delete;\n};\n#endif\n\n#if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n#else\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test&#x27;s own constructs. Do not\n// use it in user tests, either directly or indirectly.\n// TODO(b/203539622): Replace unconditionally with absl::Notification.\nclass GTEST_API_ Notification {\n public:\n  Notification() : notified_(false) {}\n  Notification(const Notification&amp;) = delete;\n  Notification&amp; operator=(const Notification&amp;) = delete;\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    std::lock_guard&lt;std::mutex&gt; lock(mu_);\n    notified_ = true;\n    cv_.notify_all();\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    std::unique_lock&lt;std::mutex&gt; lock(mu_);\n    cv_.wait(lock, [this]() { return notified_; });\n  }\n\n private:\n  std::mutex mu_;\n  std::condition_variable cv_;\n  bool notified_;\n};\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n#endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don&#x27;t want to use MinGW&#x27;s pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n#if GTEST_HAS_PTHREAD &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() = default;\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern &quot;C&quot; inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast&lt;ThreadWithParamBase*&gt;(thread)-&gt;Run();\n  return nullptr;\n}\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam&lt;int&gt; thread(&amp;ThreadFunc, 5, &amp;thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test&#x27;s own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&amp;thread_, nullptr, &amp;ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() override { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, nullptr));\n      finished_ = true;\n    }\n  }\n\n  void Run() override {\n    if (thread_can_start_ != nullptr) thread_can_start_-&gt;WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true if and only if we know that the thread function has\n                   // finished.\n  pthread_t thread_;  // The native thread object.\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; GTEST_HAS_PTHREAD ||\n        // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n#elif defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT)\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&amp;mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per https://blogs.msdn.microsoft.com/oldnewthing/20040223-00/?p=40503,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  GTEST_CRITICAL_SECTION* critical_section_;\n\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder&lt;T&gt;.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder&lt;T&gt; object holding a default value passed to\n  // this ThreadLocal&lt;T&gt;&#x27;s constructor and returns it.  It is the caller&#x27;s\n  // responsibility not to call this when the ThreadLocal&lt;T&gt; instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  ThreadLocalBase(const ThreadLocalBase&amp;) = delete;\n  ThreadLocalBase&amp; operator=(const ThreadLocalBase&amp;) = delete;\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable* runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {}\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param) : func_(func), param_(param) {}\n    virtual ~RunnableImpl() {}\n    virtual void Run() { func_(param_); }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    RunnableImpl(const RunnableImpl&amp;) = delete;\n    RunnableImpl&amp; operator=(const RunnableImpl&amp;) = delete;\n  };\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal&lt;int&gt; tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate &lt;typename T&gt;\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() override { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  T* GetOrCreateValue() const {\n    return static_cast&lt;ValueHolder*&gt;(\n               ThreadLocalRegistry::GetValueOnCurrentThread(this))\n        -&gt;pointer();\n  }\n\n  ThreadLocalValueHolderBase* NewValueForCurrentThread() const override {\n    return default_factory_-&gt;MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&amp;mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don&#x27;t protect writing to has_owner_ here, as it&#x27;s\n    // the caller&#x27;s responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&amp;mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ &amp;&amp; pthread_equal(owner_, pthread_self()))\n        &lt;&lt; &quot;The current thread is not holding the mutex @&quot; &lt;&lt; this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there&#x27;s no\n  // guarantee that a zero&#x27;d pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n// The initialization list here does not explicitly initialize each field,\n// instead relying on default initialization for the unspecified fields. In\n// particular, the owner_ field (a pthread_t) is not explicitly initialized.\n// This allows initialization to work whether pthread_t is a scalar or struct.\n// The flag -Wmissing-field-initializers must not be specified for this to work.\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::MutexBase mutex = {PTHREAD_MUTEX_INITIALIZER, false, 0}\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&amp;mutex_, nullptr));\n    has_owner_ = false;\n  }\n  ~Mutex() { GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&amp;mutex_)); }\n\n private:\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal&lt;T&gt;.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass GTEST_API_ ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() = default;\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern &quot;C&quot; inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast&lt;ThreadLocalValueHolderBase*&gt;(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&amp;key, &amp;DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast&lt;ThreadLocalValueHolderBase*&gt;(pthread_getspecific(key_));\n    if (holder != nullptr) {\n      return CheckedDowncastToActualType&lt;ValueHolder&gt;(holder)-&gt;pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_-&gt;MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder-&gt;pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() = default;\n    virtual ~ValueHolderFactory() = default;\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() = default;\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T&amp; value) : value_(value) {}\n  T* pointer() { return &amp;value_; }\n  const T* pointer() const { return &amp;value_; }\n  const T&amp; get() const { return value_; }\n  void set(const T&amp; value) { value_ = value; }\n\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n#ifdef GTEST_OS_WINDOWS\n#define GTEST_PATH_SEP_ &quot;\\\\&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 1\n#else\n#define GTEST_PATH_SEP_ &quot;/&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 0\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#ifdef __cpp_lib_char8_t\ninline bool IsXDigit(char8_t ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#endif\ninline bool IsXDigit(char16_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(char32_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast&lt;char&gt;(tolower(static_cast&lt;unsigned char&gt;(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast&lt;char&gt;(toupper(static_cast&lt;unsigned char&gt;(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() &amp;&amp; IsSpace(*--it)) it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// File system porting.\n// Note: Not every I/O-related function is related to file systems, so don&#x27;t\n// just disable all of them here. For example, fileno() and isatty(), etc. must\n// always be available in order to detect if a pipe points to a terminal.\n#ifdef GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast&lt;int&gt;(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n#else\ninline int FileNo(FILE* file) { return _fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return (_S_IFDIR &amp; st.st_mode) != 0; }\n#endif\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n#elif defined(GTEST_OS_ESP8266)\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) {\n  // stat function not implemented on ESP8266\n  return 0;\n}\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n#endif\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\n#ifdef GTEST_OS_QURT\n// QuRT doesn&#x27;t support any directory functions, including rmdir\ninline int RmDir(const char*) { return 0; }\n#else\ninline int RmDir(const char* dir) { return rmdir(dir); }\n#endif\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n#endif\n\n#endif  // GTEST_OS_WINDOWS\n\n// Other functions with a different name on Windows.\n\n#ifdef GTEST_OS_WINDOWS\n\n#ifdef __BORLANDC__\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\n#else  // !__BORLANDC__\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_ZOS) || \\\n    defined(GTEST_OS_IOS) || defined(GTEST_OS_WINDOWS_PHONE) ||  \\\n    defined(GTEST_OS_WINDOWS_RT) || defined(ESP_PLATFORM)\ninline int DoIsATTY(int /* fd */) { return 0; }\n#else\ninline int DoIsATTY(int fd) { return _isatty(fd); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\n#endif  // __BORLANDC__\n\n#else\n\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\n\n#endif  // GTEST_OS_WINDOWS\n\ninline int IsATTY(int fd) {\n  // DoIsATTY might change errno (for example ENOTTY in case you redirect stdout\n  // to a file on Linux), which is unexpected, so save the previous value, and\n  // restore it after the call.\n  int savedErrno = errno;\n  int isAttyValue = DoIsATTY(fd);\n  errno = savedErrno;\n\n  return isAttyValue;\n}\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_DEPRECATED_PUSH_()\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren&#x27;t needed on Windows CE at this time and thus not\n// defined there.\n#if GTEST_HAS_FILE_SYSTEM\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT) &amp;&amp; !defined(GTEST_OS_WINDOWS_GAMES) &amp;&amp;     \\\n    !defined(GTEST_OS_ESP8266) &amp;&amp; !defined(GTEST_OS_XTENSA) &amp;&amp;               \\\n    !defined(GTEST_OS_QURT)\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n  struct wchar_codecvt : public std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; {};\n  std::wstring_convert&lt;wchar_codecvt&gt; converter;\n  std::wstring wide_path = converter.from_bytes(path);\n  std::wstring wide_mode = converter.from_bytes(mode);\n  return _wfopen(wide_path.c_str(), wide_mode.c_str());\n#else   // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n  return fopen(path, mode);\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n}\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline FILE* FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\n\ninline const char* GetEnv(const char* name) {\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_WINDOWS_PHONE) || \\\n    defined(GTEST_OS_ESP8266) || defined(GTEST_OS_XTENSA) ||               \\\n    defined(GTEST_OS_QURT)\n  // We are on an embedded platform, which has no environment variables.\n  static_cast&lt;void&gt;(name);  // To prevent &#x27;unused argument&#x27; warning.\n  return nullptr;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != nullptr &amp;&amp; env[0] != &#x27;\\0&#x27;) ? env : nullptr;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_DEPRECATED_POP_()\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\n[[noreturn]] void Abort();\n#else\n[[noreturn]] inline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC &quot;deprecates&quot; snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if defined(_MSC_VER) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE)\n// MSVC 2005 and above support variadic macros.\n#define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n  _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s\n#define GTEST_SNPRINTF_ _snprintf\n#else\n#define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The biggest signed integer type the compiler supports.\n//\n// long long is guaranteed to be at least 64-bits in C++11.\nusing BiggestInt = long long;  // NOLINT\n\n// The maximum number a BiggestInt can represent.\nconstexpr BiggestInt kMaxBiggestInt = (std::numeric_limits&lt;BiggestInt&gt;::max)();\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize&lt;4&gt;::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that&#x27;s all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate &lt;size_t size&gt;\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize&lt;N&gt; with incorrect\n  // values of N.\n  using UInt = void;\n};\n\n// The specialization for size 4.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;4&gt; {\n public:\n  using Int = std::int32_t;\n  using UInt = std::uint32_t;\n};\n\n// The specialization for size 8.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;8&gt; {\n public:\n  using Int = std::int64_t;\n  using UInt = std::uint64_t;\n};\n\n// Integer types of known sizes.\nusing TimeInMillis = int64_t;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n#define GTEST_FLAG_NAME_(name) gtest_##name\n#define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n// Pick a command line flags implementation.\n#ifdef GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n  ABSL_FLAG(bool, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n  ABSL_FLAG(int32_t, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n  ABSL_FLAG(std::string, GTEST_FLAG_NAME_(name), default_val, doc)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name) \\\n  ABSL_DECLARE_FLAG(bool, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_int32_(name) \\\n  ABSL_DECLARE_FLAG(int32_t, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_string_(name) \\\n  ABSL_DECLARE_FLAG(std::string, GTEST_FLAG_NAME_(name))\n\n#define GTEST_FLAG_SAVER_ ::absl::FlagSaver\n\n#define GTEST_FLAG_GET(name) ::absl::GetFlag(GTEST_FLAG(name))\n#define GTEST_FLAG_SET(name, value) \\\n  (void)(::absl::SetFlag(&amp;GTEST_FLAG(name), value))\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 0\n\n#undef GTEST_INTERNAL_HAS_ABSL_FLAGS\n#else  // ndef GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc)  \\\n  namespace testing {                               \\\n  GTEST_API_ bool GTEST_FLAG(name) = (default_val); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_int32_(name, default_val, doc)         \\\n  namespace testing {                                       \\\n  GTEST_API_ std::int32_t GTEST_FLAG(name) = (default_val); \\\n  }                                                         \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_string_(name, default_val, doc)         \\\n  namespace testing {                                        \\\n  GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val); \\\n  }                                                          \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name)          \\\n  namespace testing {                      \\\n  GTEST_API_ extern bool GTEST_FLAG(name); \\\n  }                                        \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_int32_(name)                 \\\n  namespace testing {                              \\\n  GTEST_API_ extern std::int32_t GTEST_FLAG(name); \\\n  }                                                \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_string_(name)                 \\\n  namespace testing {                               \\\n  GTEST_API_ extern ::std::string GTEST_FLAG(name); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n#define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n#define GTEST_FLAG_GET(name) ::testing::GTEST_FLAG(name)\n#define GTEST_FLAG_SET(name, value) (void)(::testing::GTEST_FLAG(name) = value)\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n\n#endif  // GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n#define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n#define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses &#x27;str&#x27; for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\nGTEST_API_ bool ParseInt32(const Message&amp; src_text, const char* str,\n                           int32_t* value);\n\n// Parses a bool/int32_t/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ int32_t Int32FromGTestEnv(const char* flag, int32_t default_val);\nstd::string OutputFlagAlsoCheckEnvVar();\nconst char* StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#if !defined(GTEST_INTERNAL_DEPRECATED)\n\n// Internal Macro to mark an API deprecated, for googletest usage only\n// Usage: class GTEST_INTERNAL_DEPRECATED(message) MyClass or\n// GTEST_INTERNAL_DEPRECATED(message) &lt;return_type&gt; myFunction(); Every usage of\n// a deprecated entity will trigger a warning when compiled with\n// `-Wdeprecated-declarations` option (clang, gcc, any __GNUC__ compiler).\n// For msvc /W3 option will need to be used\n// Note that for &#x27;other&#x27; compilers this macro evaluates to nothing to prevent\n// compilations errors.\n#if defined(_MSC_VER)\n#define GTEST_INTERNAL_DEPRECATED(message) __declspec(deprecated(message))\n#elif defined(__GNUC__)\n#define GTEST_INTERNAL_DEPRECATED(message) __attribute__((deprecated(message)))\n#else\n#define GTEST_INTERNAL_DEPRECATED(message)\n#endif\n\n#endif  // !defined(GTEST_INTERNAL_DEPRECATED)\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::any for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &quot;absl/types/any.h&quot;\nnamespace testing {\nnamespace internal {\nusing Any = ::absl::any;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_any) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;any&gt;) &amp;&amp;        \\\n                               GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L &amp;&amp; \\\n                               (!defined(_MSC_VER) || GTEST_HAS_RTTI))\n// Otherwise for C++17 and higher use std::any for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &lt;any&gt;\nnamespace testing {\nnamespace internal {\nusing Any = ::std::any;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::any is not\n// supported.\n#endif  // __cpp_lib_any\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_ANY\n#define GTEST_INTERNAL_HAS_ANY 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::optional for UniversalPrinter&lt;&gt; specializations if\n// googletest is built with absl support.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &quot;absl/types/optional.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::absl::optional&lt;T&gt;;\ninline ::absl::nullopt_t Nullopt() { return ::absl::nullopt; }\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_optional) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;optional&gt;) &amp;&amp; \\\n                                    GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::optional for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &lt;optional&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::std::optional&lt;T&gt;;\ninline ::std::nullopt_t Nullopt() { return ::std::nullopt; }\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::optional is not\n// supported.\n#endif  // __cpp_lib_optional\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_OPTIONAL\n#define GTEST_INTERNAL_HAS_OPTIONAL 0\n#endif\n\n#if defined(__cpp_lib_span) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;span&gt;) &amp;&amp; \\\n                                GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 202002L)\n#define GTEST_INTERNAL_HAS_STD_SPAN 1\n#endif  // __cpp_lib_span\n\n#ifndef GTEST_INTERNAL_HAS_STD_SPAN\n#define GTEST_INTERNAL_HAS_STD_SPAN 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::string_view for Matcher&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &quot;absl/strings/string_view.h&quot;\nnamespace testing {\nnamespace internal {\nusing StringView = ::absl::string_view;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_string_view) ||             \\\n    (GTEST_INTERNAL_HAS_INCLUDE(&lt;string_view&gt;) &amp;&amp; \\\n     GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::string_view for Matcher&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &lt;string_view&gt;\nnamespace testing {\nnamespace internal {\nusing StringView = ::std::string_view;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::string_view is not\n// supported.\n#endif  // __cpp_lib_string_view\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_STRING_VIEW\n#define GTEST_INTERNAL_HAS_STRING_VIEW 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::variant for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &quot;absl/types/variant.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::absl::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_variant) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;variant&gt;) &amp;&amp; \\\n                                   GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::variant for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &lt;variant&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::std::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::variant is not supported.\n#endif  // __cpp_lib_variant\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_VARIANT\n#define GTEST_INTERNAL_HAS_VARIANT 0\n#endif\n\n#if (defined(__cpp_constexpr) &amp;&amp; !defined(__cpp_inline_variables)) || \\\n    (defined(GTEST_INTERNAL_CPLUSPLUS_LANG) &amp;&amp;                        \\\n     GTEST_INTERNAL_CPLUSPLUS_LANG &lt; 201703L)\n#define GTEST_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL 1\n#endif\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines the Message class.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#ifdef GTEST_HAS_ABSL\n#include &lt;type_traits&gt;\n\n#include &quot;absl/strings/has_absl_stringify.h&quot;\n#include &quot;absl/strings/str_cat.h&quot;\n#endif  // GTEST_HAS_ABSL\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Ensures that there is at least one operator&lt;&lt; in the global namespace.\n// See Message&amp; operator&lt;&lt;(...) below for why.\nvoid operator&lt;&lt;(const testing::internal::Secret&amp;, int);\n\nnamespace testing {\n\n// The Message class works like an ostream repeater.\n//\n// Typical usage:\n//\n//   1. You stream a bunch of values to a Message object.\n//      It will remember the text in a stringstream.\n//   2. Then you stream the Message object to an ostream.\n//      This causes the text in the Message to be streamed\n//      to the ostream.\n//\n// For example;\n//\n//   testing::Message foo;\n//   foo &lt;&lt; 1 &lt;&lt; &quot; != &quot; &lt;&lt; 2;\n//   std::cout &lt;&lt; foo;\n//\n// will print &quot;1 != 2&quot;.\n//\n// Message is not intended to be inherited from.  In particular, its\n// destructor is not virtual.\n//\n// Note that stringstream behaves differently in gcc and in MSVC.  You\n// can stream a NULL char pointer to it in the former, but not in the\n// latter (it causes an access violation if you do).  The Message\n// class hides this difference by treating a NULL char pointer as\n// &quot;(null)&quot;.\nclass GTEST_API_ Message {\n private:\n  // The type of basic IO manipulators (endl, ends, and flush) for\n  // narrow streams.\n  typedef std::ostream&amp; (*BasicNarrowIoManip)(std::ostream&amp;);\n\n public:\n  // Constructs an empty Message.\n  Message();\n\n  // Copy constructor.\n  Message(const Message&amp; msg) : ss_(new ::std::stringstream) {  // NOLINT\n    *ss_ &lt;&lt; msg.GetString();\n  }\n\n  // Constructs a Message from a C-string.\n  explicit Message(const char* str) : ss_(new ::std::stringstream) {\n    *ss_ &lt;&lt; str;\n  }\n\n  // Streams a non-pointer value to this object. If building a version of\n  // GoogleTest with ABSL, this overload is only enabled if the value does not\n  // have an AbslStringify definition.\n  template &lt;\n      typename T\n#ifdef GTEST_HAS_ABSL\n      ,\n      typename std::enable_if&lt;!absl::HasAbslStringify&lt;T&gt;::value,  // NOLINT\n                              int&gt;::type = 0\n#endif  // GTEST_HAS_ABSL\n      &gt;\n  inline Message&amp; operator&lt;&lt;(const T&amp; val) {\n        // Some libraries overload &lt;&lt; for STL containers.  These\n    // overloads are defined in the global namespace instead of ::std.\n    //\n    // C++&#x27;s symbol lookup rule (i.e. Koenig lookup) says that these\n    // overloads are visible in either the std namespace or the global\n    // namespace, but not other namespaces, including the testing\n    // namespace which Google Test&#x27;s Message class is in.\n    //\n    // To allow STL containers (and other types that has a &lt;&lt; operator\n    // defined in the global namespace) to be used in Google Test\n    // assertions, testing::Message must access the custom &lt;&lt; operator\n    // from the global namespace.  With this using declaration,\n    // overloads of &lt;&lt; defined in the global namespace and those\n    // visible via Koenig lookup are both exposed in this function.\n    using ::operator&lt;&lt;;\n    *ss_ &lt;&lt; val;\n    return *this;\n  }\n\n#ifdef GTEST_HAS_ABSL\n  // Streams a non-pointer value with an AbslStringify definition to this\n  // object.\n  template &lt;typename T,\n            typename std::enable_if&lt;absl::HasAbslStringify&lt;T&gt;::value,  // NOLINT\n                                    int&gt;::type = 0&gt;\n  inline Message&amp; operator&lt;&lt;(const T&amp; val) {\n    // ::operator&lt;&lt; is needed here for a similar reason as with the non-Abseil\n    // version above\n    using ::operator&lt;&lt;;\n    *ss_ &lt;&lt; absl::StrCat(val);\n    return *this;\n  }\n#endif  // GTEST_HAS_ABSL\n\n  // Streams a pointer value to this object.\n  //\n  // This function is an overload of the previous one.  When you\n  // stream a pointer to a Message, this definition will be used as it\n  // is more specialized.  (The C++ Standard, section\n  // [temp.func.order].)  If you stream a non-pointer, then the\n  // previous definition will be used.\n  //\n  // The reason for this overload is that streaming a NULL pointer to\n  // ostream is undefined behavior.  Depending on the compiler, you\n  // may get &quot;0&quot;, &quot;(nil)&quot;, &quot;(null)&quot;, or an access violation.  To\n  // ensure consistent result across compilers, we always treat NULL\n  // as &quot;(null)&quot;.\n  template &lt;typename T&gt;\n  inline Message&amp; operator&lt;&lt;(T* const&amp; pointer) {  // NOLINT\n    if (pointer == nullptr) {\n      *ss_ &lt;&lt; &quot;(null)&quot;;\n    } else {\n      *ss_ &lt;&lt; pointer;\n    }\n    return *this;\n  }\n\n  // Since the basic IO manipulators are overloaded for both narrow\n  // and wide streams, we have to provide this specialized definition\n  // of operator &lt;&lt;, even though its body is the same as the\n  // templatized version above.  Without this definition, streaming\n  // endl or other basic IO manipulators to Message will confuse the\n  // compiler.\n  Message&amp; operator&lt;&lt;(BasicNarrowIoManip val) {\n    *ss_ &lt;&lt; val;\n    return *this;\n  }\n\n  // Instead of 1/0, we want to see true/false for bool values.\n  Message&amp; operator&lt;&lt;(bool b) { return *this &lt;&lt; (b ? &quot;true&quot; : &quot;false&quot;); }\n\n  // These two overloads allow streaming a wide C string to a Message\n  // using the UTF-8 encoding.\n  Message&amp; operator&lt;&lt;(const wchar_t* wide_c_str);\n  Message&amp; operator&lt;&lt;(wchar_t* wide_c_str);\n\n#if GTEST_HAS_STD_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message&amp; operator&lt;&lt;(const ::std::wstring&amp; wstr);\n#endif  // GTEST_HAS_STD_WSTRING\n\n  // Gets the text streamed to this object so far as an std::string.\n  // Each &#x27;\\0&#x27; character in the buffer is replaced with &quot;\\\\0&quot;.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  std::string GetString() const;\n\n private:\n  // We&#x27;ll hold the text streamed to this object here.\n  const std::unique_ptr&lt; ::std::stringstream&gt; ss_;\n\n  // We declare (but don&#x27;t implement) this to prevent the compiler\n  // from implementing the assignment operator.\n  void operator=(const Message&amp;);\n};\n\n// Streams a Message to an ostream.\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Message&amp; sb) {\n  return os &lt;&lt; sb.GetString();\n}\n\nnamespace internal {\n\n// Converts a streamable value to an std::string.  A NULL pointer is\n// converted to &quot;(null)&quot;.  When the input value is a ::string,\n// ::std::string, ::wstring, or ::std::wstring object, each NUL\n// character in it is replaced with &quot;\\\\0&quot;.\ntemplate &lt;typename T&gt;\nstd::string StreamableToString(const T&amp; streamable) {\n  return (Message() &lt;&lt; streamable).GetString();\n}\n\n}  // namespace internal\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;gtest/gtest.h&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/vms/common/system_context.h&gt;\n\n#include &quot;resource/resource_pool_test_helper.h&quot;\n\nclass QnCommonModule;\n\nnamespace nx::vms::common::test {\n\nclass MessageProcessorMock;\n\ntemplate&lt;typename ContextType, typename... ContextCreationArgs&gt;\nclass ContextHolder\n{\npublic:\n    ContextHolder(ContextCreationArgs... args): m_context(std::make_unique&lt;ContextType&gt;(args...)) {}\n    ContextType* context() const { return m_context.get(); }\n\nprivate:\n    const std::unique_ptr&lt;ContextType&gt; m_context;\n};\n\ntemplate&lt;typename ContextType, typename...ContextCreationArgs&gt;\nclass GenericContextBasedTest:\n    public ::testing::Test,\n    public ContextHolder&lt;ContextType, ContextCreationArgs...&gt;,\n    protected QnResourcePoolTestHelper\n{\npublic:\n    explicit GenericContextBasedTest(ContextCreationArgs... args):\n        ContextHolder&lt;ContextType, ContextCreationArgs...&gt;(args...),\n        QnResourcePoolTestHelper(this-&gt;context()-&gt;systemContext())\n    {\n    }\n\n    auto systemContext() const { return this-&gt;context()-&gt;systemContext(); }\n    virtual void TearDown() override { clear(); }\n};\n\nclass NX_VMS_COMMON_TEST_SUPPORT_API Context\n{\npublic:\n    Context();\n    virtual ~Context();\n\n    QnCommonModule* commonModule() const;\n    SystemContext* systemContext() const;\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\nclass NX_VMS_COMMON_TEST_SUPPORT_API ContextBasedTest:\n    public GenericContextBasedTest&lt;Context&gt;\n{\npublic:\n    ContextBasedTest();\n    virtual ~ContextBasedTest() override;\n\n    MessageProcessorMock* createMessageProcessor();\n};\n\n} // namespace nx::vms::common::test\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h", "reportHash": "44ecec424f6c201e10f3c4b9feca3117", "checker": {"name": "readability-container-data-pointer", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-data-pointer.html"}, "analyzerName": "clang-tidy", "line": 82, "column": 14, "message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "events": [{"message": "|              result.data() (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h", "line": 82, "column": 7}, {"message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "fileId": "/home/misha/nika/nx_open/artifacts/nx_kit/src/nx/kit/utils.h", "line": 82, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "f90ea162637f8d2355ac2d96ca901351", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 31, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 31, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "34d43d4c7b10c6ba58e375ff3423a5da", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 31, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 31, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "b1973e2ab1dcb89fca44fcfcc4b133a6", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 32, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "d52eb86b3dd3c3999ea7de91bc122fec", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 32, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "382f0003d38db49b3006e7e6c25dfd7f", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 33, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "32da8649b5c5f4a2b9534c3b8e02bdf7", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 33, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "37a446a9c5575374375b04cdfcef88ce", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 34, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 34, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "8d5b9f370dd959149dada886ffd705d9", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 34, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 34, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "18ca2e6983688ed6ba56ba7912a21742", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 35, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 35, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "41b3e47b4b900b75ebafd13ff6e7b1c1", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 35, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 35, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "eae30b5d1b08d3976aba71210bd7231e", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 36, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 36, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "ca9fd77109d850abfcd8dfd1302065eb", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 36, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 36, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "3e69fc797f1f43515785cad9503ae14e", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 37, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 37, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "0e7d00395c187440033b411728505b54", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 37, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 37, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "90f577a469792573beecf1b43ac66c6f", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 38, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 38, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "35307aad648cfafb907a7c58c93df69d", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 38, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 38, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "f608ec902e056256f136cceabd52e742", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 39, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 39, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "c41d8e939707064350da23f9ff2c179e", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 39, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 39, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "e18323ea4d81fe0e365075bbebf3567a", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 40, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 40, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "224079dbc88e755c35864e25d43cb90b", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 40, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 40, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "750ca51c4423739e964c32fc038f42b1", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 41, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 41, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "f451eaf19374ec74eb950a359d51d640", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 41, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 41, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "294146c7d42c13a61ebd97cd4a07c5d4", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 42, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 42, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "8c85c410e6499f466b7d5847351f9a47", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 42, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 42, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "57b91da42178b01fbf9cafde72fac4f5", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 43, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 43, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "687d01346edb8bda1017208eded43701", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 43, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 43, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "27c90acdc71448ee0aba0a9192bee26d", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 44, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 44, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "ac66339a9560f3882950cd011992a615", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 44, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 44, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "ddf5060de0c934985b313cc965f0eaf8", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 45, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "reportHash": "66cac23e92ec24fd7333afff6e497710", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "expanded from macro 'QN_FUSION_DEFINE_KEY'", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 19, "column": 5}, {"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/fusion/fusion_keys.h", "line": 45, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h", "reportHash": "1a830771773c7bfb83e99fcd2dfa6c7c", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 77, "column": 67, "message": "use 'contains' to check for membership", "events": [{"message": "|                                                  !                contains (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h", "line": 77, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json.h", "line": 77, "column": 67}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h", "reportHash": "ea2fa4e70e9aa22bcaf1404a38472993", "checker": {"name": "bugprone-move-forwarding-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"}, "analyzerName": "clang-tidy", "line": 635, "column": 59, "message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "events": [{"message": "|                                                           std::forward<decltype(arg)> (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h", "line": 635, "column": 7}, {"message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_functions.h", "line": 635, "column": 59}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_macros.h", "reportHash": "62119cd7bffde3f3c91a506291e9ed06", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 52, "column": 7, "message": "class 'SerializationVisitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SerializationVisitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/json_macros.h", "line": 52, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/serialization.h", "reportHash": "d2616809bb90e063392eac6d53a37294", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 54, "column": 7, "message": "class 'QnSerializerBase' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnSerializerBase' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_fusion/src/nx/fusion/serialization/serialization.h", "line": 54, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/abstract_data_packet.h", "reportHash": "7aeb440c3cdd5d0233f0d5a67552afb3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 26, "message": "class 'QnAbstractDataPacket' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractDataPacket' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/abstract_data_packet.h", "line": 11, "column": 26}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/aligned_allocator.h", "reportHash": "ba86f80e41c1d3cee4d5c22bda6a34cd", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 7, "message": "class 'QnAlignedAllocator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAlignedAllocator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/aligned_allocator.h", "line": 11, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/codec_parameters.h", "reportHash": "a7e12e652d6ad214d307b96d44b0ac8d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 25, "message": "class 'CodecParameters' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'CodecParameters' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/codec_parameters.h", "line": 17, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/media_data_packet.h", "reportHash": "10612a46081b99eb20d1a42bf20622aa", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 56, "column": 26, "message": "class 'QnAbstractMediaData' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractMediaData' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/media_data_packet.h", "line": 56, "column": 26}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/auth_tools.h", "reportHash": "89a7431c7dc874722180e232302abe0d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 288, "column": 22, "message": "class 'AbstractCredentialsProvider' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractCredentialsProvider' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/auth_tools.h", "line": 288, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "c4d110e8fb409cf1f49c3798d82f0956", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 221, "column": 22, "message": "class 'Method' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'Method' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 221, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "be7a7bd8437a592f18047f123ab1fae0", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 366, "column": 22, "message": "class 'StatusLine' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'StatusLine' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 366, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "53808ed8df4979734bbe500dcf32e6e3", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 525, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                              noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 525, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 525, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "99e49f78666e96ecfcc64e552ed8609e", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 529, "column": 14, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                         noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 529, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 529, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "415e57b978164a124afa491b2bea34f6", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 651, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                          noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 651, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 651, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "1a6d862ba6bf48100d6eb611f7a1db67", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 655, "column": 20, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                                     noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 655, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 655, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "d0b80cbddec1418c03e95fd2a257262a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 682, "column": 22, "message": "class 'DigestAuthorization' defines a copy constructor and a move constructor but does not define a destructor, a copy assignment operator or a move assignment operator", "events": [{"message": "class 'DigestAuthorization' defines a copy constructor and a move constructor but does not define a destructor, a copy assignment operator or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 682, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "reportHash": "79d8b4b423bb8ae1a5d509407c39333b", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 687, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                                      noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 687, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 687, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "reportHash": "c4292ed5815d5404877f8f669de41b73", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 7, "message": "class 'AbstractComposer' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractComposer' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "line": 24, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "reportHash": "026b6479d3e536615e2f4e9c61fc1732", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 295, "column": 7, "message": "class 'Visitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Visitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/basic_serializer.h", "line": 295, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/json/deserializer.h", "reportHash": "a7aca69c9950371a87a06ea6a8d24c13", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 271, "column": 29, "message": "std::move of the variable 'keyStd' of the trivially-copyable type 'std::string_view' (aka 'basic_string_view<char>') has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'keyStd' of the trivially-copyable type 'std::string_view' (aka 'basic_string_view<char>') has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/json/deserializer.h", "line": 271, "column": 29}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/type_utils.h", "reportHash": "60ee8ff413266ad94aa21fc4d59acc79", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 276, "column": 5, "message": "constructor accepting a forwarding reference can hide the copy and move constructors", "events": [{"message": "constructor accepting a forwarding reference can hide the copy and move constructors", "fileId": "/home/misha/nika/nx_open/libs/nx_reflect/src/nx/reflect/type_utils.h", "line": 276, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "reportHash": "32d145494f4e7e80a9718af6f6b1117d", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "line": 23, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "line": 23, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "reportHash": "05eec5b2871b4fcf6623447cfb7da64c", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 25, "column": 16, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                             noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "line": 25, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/exception.h", "line": 25, "column": 16}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/flat_storage.h", "reportHash": "17b7c0a23c5af4670e4f38d3cb51504c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 16, "column": 7, "message": "class 'QnFlatStorage' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'QnFlatStorage' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/flat_storage.h", "line": 16, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/json.h", "reportHash": "80cbec5612f2cc2bd6b19c4b96c03b65", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 190, "column": 7, "message": "class 'Visitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Visitor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/json.h", "line": 190, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h", "reportHash": "a28a45f02c415e106d09594688686434", "checker": {"name": "cert-dcl58-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl58-cpp.html"}, "analyzerName": "clang-tidy", "line": 202, "column": 8, "message": "modification of 'std' namespace can result in undefined behavior", "events": [{"message": "'std' namespace opened here", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h", "line": 198, "column": 11}, {"message": "modification of 'std' namespace can result in undefined behavior", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/json/qt_containers_reflect.h", "line": 202, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "reportHash": "433238fb5ee115d700c6eb185d1c621d", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                       noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "line": 19, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "line": 19, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "reportHash": "ed6683159f86b4a0cbd18689dfd27fb8", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 25, "column": 18, "message": "move assignment operators should be marked noexcept", "events": [{"message": "26 |     { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "line": 25, "column": 4}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "line": 25, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/lockable.h", "line": 25, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/abstract_logger.h", "reportHash": "52f2020e0f4a511ea0abbc0142deb588", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 20, "message": "class 'AbstractLogger' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractLogger' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/abstract_logger.h", "line": 17, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_level.h", "reportHash": "1cf088cb5e827529bf38521c0d554462", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 76, "column": 20, "message": "class 'Filter' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Filter' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_level.h", "line": 76, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_main.h", "reportHash": "539892fd2baf5a7c3855220c3e7fc68d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 127, "column": 7, "message": "class 'Stream' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'Stream' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_main.h", "line": 127, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "reportHash": "86fab2a9dac22a3d546b56f7355b9488", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 20, "message": "class 'AbstractWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "line": 24, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "reportHash": "8140baf6728366b0020cf288a8eb6c78", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 49, "column": 20, "message": "class 'File' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'File' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/log/log_writers.h", "line": 49, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "reportHash": "c9ba147df16376474c862a8d4c1f6565", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'MoveOnlyFunc' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'MoveOnlyFunc' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "reportHash": "4eea0a19b9b4ab9f9c75ec9b6794f99f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 11, "message": "class 'MoveOnlyFuncWrapper' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'MoveOnlyFuncWrapper' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 23, "column": 11}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "reportHash": "bce2a0793dbbf607ed2b12728c95a3c3", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 53, "column": 30, "message": "move assignment operators should be marked noexcept", "events": [{"message": "54 |         { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 53, "column": 4}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 53, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 53, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "reportHash": "8914baa5e6646ee67048e3246535fa6e", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 30, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "line": 30, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "line": 30, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "reportHash": "10c460b63a3d8b1042bb94fa4ba902b3", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 36, "column": 17, "message": "move assignment operators should be marked noexcept", "events": [{"message": "37 |     { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "line": 36, "column": 4}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "line": 36, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scope_guard.h", "line": 36, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "9f7f0646ef55f1e7ca587568365585d1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 20, "message": "class 'AbstractAttributeReader' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAttributeReader' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 24, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "fd8c165670503553dda8d5d25e312441", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 103, "column": 20, "message": "class 'AbstractAttributeWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAttributeWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 103, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "9ab79ff0768442061ce3b6424b680085", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 126, "column": 20, "message": "class 'AbstractConstIterator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractConstIterator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 126, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "86454a3085532e5ab71331483ee28381", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 162, "column": 20, "message": "class 'AbstractIteratableContainer' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractIteratableContainer' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 162, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "af8601e2894f760c165778ff7ec20e78", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 324, "column": 20, "message": "class 'AttributeDictionary' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'AttributeDictionary' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 324, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "b481bdc45da3ff9d4a09d0ede112bee7", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 351, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                                noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 351, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 351, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "reportHash": "5575d21e5b9a5c4a941f8145abe13e97", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 354, "column": 26, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                                           noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 354, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/stree/attribute_dictionary.h", "line": 354, "column": 26}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/synchronized_flat_storage.h", "reportHash": "82cb454c1e8d361436a926aef4cdad6f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 7, "message": "class 'QnSynchronizedFlatStorage' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'QnSynchronizedFlatStorage' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/synchronized_flat_storage.h", "line": 15, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "06d7cb7e7a724a64ab4c9415906e0752", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 96, "column": 7, "message": "class 'shared_state_base' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'shared_state_base' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 96, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "d3816bf04ffa5a33e026a5264fa5c91c", "checker": {"name": "cert-err09-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/err09-cpp.html"}, "analyzerName": "clang-tidy", "line": 327, "column": 14, "message": "catch handler catches by value; should catch by reference instead", "events": [{"message": "catch handler catches by value; should catch by reference instead", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 327, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "8779374f785b0abfe8735b8357b16580", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 336, "column": 7, "message": "class 'future' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'future' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 336, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "f38a760c247424bae959fa048f3d313e", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 354, "column": 3, "message": "move constructors should be marked noexcept", "events": [{"message": "355 |     : state_(std::move(other.state_)) {} (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 354, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 354, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 354, "column": 3}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "74a837099774838fbcea62291a0273ec", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 357, "column": 14, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                              noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 357, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 357, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "534f584ee0b87f7809645f87aefac14e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 740, "column": 7, "message": "class 'promise' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "events": [{"message": "class 'promise' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 740, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "bf3a77dd68274243510e002bfee7ccbc", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 745, "column": 3, "message": "move constructors should be marked noexcept", "events": [{"message": "746 |     : state_(std::move(other.state_)) {} (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 745, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 745, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 745, "column": 3}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "07a5acaf05a676030a9fbd4a09a013db", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 748, "column": 12, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                          noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 748, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 748, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "d970266af91a247063cca8426139ec16", "checker": {"name": "bugprone-move-forwarding-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"}, "analyzerName": "clang-tidy", "line": 1007, "column": 34, "message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "events": [{"message": "|                                  std::forward<Future> (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 1007, "column": 7}, {"message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 1007, "column": 34}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "reportHash": "713cc0d10495a311134dff6fd3fb0c54", "checker": {"name": "bugprone-move-forwarding-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"}, "analyzerName": "clang-tidy", "line": 1161, "column": 43, "message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "events": [{"message": "|                                           std::forward<FirstFuture> (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 1161, "column": 7}, {"message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/cfuture.h", "line": 1161, "column": 43}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "reportHash": "5cc4725293c1191c525aaf86394fe62f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'movable_func' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'movable_func' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "reportHash": "67a1e894cb7f2b65a98a560f5f034b39", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 10, "message": "class 'base_holder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'base_holder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/cf/common.h", "line": 19, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "reportHash": "7b46c8c9440c5095a41df7ac66319dbf", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 20, "message": "class 'MutexDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'MutexDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "line": 12, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "reportHash": "3fac11d630b15ffa60c74415ed834ce6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 58, "column": 20, "message": "class 'ReadWriteLockDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ReadWriteLockDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "line": 58, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "reportHash": "cc9923cd7bf3633370c344a1ce8ba247", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 119, "column": 20, "message": "class 'WaitConditionDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'WaitConditionDelegate' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex.h", "line": 119, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "reportHash": "893ca1dcfb4bfb5d0fb659b08f42f4ef", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 20, "message": "class 'Locker' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "events": [{"message": "class 'Locker' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "line": 10, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "reportHash": "92c9432a58cd4c3c8fce93e182366b87", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 89, "column": 20, "message": "class 'Unlocker' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "events": [{"message": "class 'Unlocker' defines a non-default destructor, a move constructor and a move assignment operator but does not define a copy constructor or a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/mutex_locker.h", "line": 89, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "reportHash": "5311c6600ec3086331ced70ffe89aa42", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 254, "column": 21, "message": "class 'ScopedUtcTimeFix' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ScopedUtcTimeFix' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "line": 254, "column": 21}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "reportHash": "813f8635ce6a4435897ec7b0ce4dd748", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 264, "column": 20, "message": "class 'ScopedSyntheticMonotonicTime' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ScopedSyntheticMonotonicTime' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/time.h", "line": 264, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/value_cache.h", "reportHash": "6cef2f30777927d99b9324397e4ad2a4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 175, "column": 7, "message": "class 'ValueCacheUnSafe' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ValueCacheUnSafe' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/value_cache.h", "line": 175, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/analytics/analytics_taxonomy_manager.h", "reportHash": "1fb38844165d9066d1dacabddc0711f7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 30, "message": "class 'TaxonomyManager' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'TaxonomyManager' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/analytics/analytics_taxonomy_manager.h", "line": 33, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/application_context.h", "reportHash": "6ccc9ccdd4dc267946ce7da9629e09db", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 30, "message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/application_context.h", "line": 45, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h", "reportHash": "4f2396cc057281d85d56658de286277b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 53, "column": 30, "message": "class 'SystemContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SystemContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h", "line": 53, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/application_context.h", "reportHash": "bd57131f28562d4b56b8dc3fee35fb04", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 50, "column": 33, "message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/application_context.h", "line": 50, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "reportHash": "2d2eceeae846e3ca9bb2a8599ea875ec", "checker": {"name": "bugprone-forward-declaration-namespace", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"}, "analyzerName": "clang-tidy", "line": 36, "column": 7, "message": "declaration 'VideoCache' is never referenced, but a declaration with the same name found in another namespace 'nx::vms::client::core'", "events": [{"message": "a declaration of 'VideoCache' is found here", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/system_context.h", "line": 44, "column": 7}, {"message": "declaration 'VideoCache' is never referenced, but a declaration with the same name found in another namespace 'nx::vms::client::core'", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "line": 36, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "reportHash": "707c250cbffcbcf2d0ce703d845fde8c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 41, "column": 33, "message": "class 'SystemContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SystemContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/system_context.h", "line": 41, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_test_fixture.h", "reportHash": "c9df5ff70fc098d15dae03a702b180ec", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 7, "message": "class 'CameraSettingsTestFixture' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CameraSettingsTestFixture' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/resource_properties/camera/flux/camera_settings_test_fixture.h", "line": 15, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/test_support/test_context.h", "reportHash": "4539bf2d62f1f60363eb7db3e34bd715", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 7, "message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/unit_tests/src/nx/vms/client/desktop/test_support/test_context.h", "line": 18, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "reportHash": "b3f9c27ef6703bd554ff868a87e92c3d", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 77, "column": 22, "message": "std::move of the variable 'engineId' of the trivially-copyable type 'nx::Uuid' has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'engineId' of the trivially-copyable type 'nx::Uuid' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "line": 77, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "reportHash": "c2be1204b029fa137a8dbb902b9a88e0", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 166, "column": 12, "message": "std::move of the variable 'id' of the trivially-copyable type 'nx::Uuid' has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'id' of the trivially-copyable type 'nx::Uuid' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "line": 166, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "reportHash": "eacc9f9ba7122dafedbb327c8ae2bcea", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 296, "column": 22, "message": "std::move of the expression of the trivially-copyable type 'ObjectActionRequirements' has no effect; remove std::move()", "events": [{"message": "std::move of the expression of the trivially-copyable type 'ObjectActionRequirements' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/descriptors.h", "line": 296, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "reportHash": "d0bc79f4a10841c144cbf7a10969b912", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 113, "column": 8, "message": "class 'AttributeDescriptionCommon' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AttributeDescriptionCommon' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "line": 113, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "reportHash": "6adac0692b0fc8ba5d7e5ab2969cee6f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 190, "column": 8, "message": "class 'AttributeDescription' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AttributeDescription' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/analytics/manifest_items.h", "line": 190, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/analytics_data.h", "reportHash": "4eba166266a3b730b06c2b9a7cb0fbe4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 265, "column": 19, "message": "class 'PluginInfoEx' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'PluginInfoEx' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/analytics_data.h", "line": 265, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/media_server_data.h", "reportHash": "fb25dfe36c642dcfb8463d29db13fc19", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 276, "column": 19, "message": "class 'MediaServerDataEx' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'MediaServerDataEx' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/media_server_data.h", "line": 276, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "reportHash": "ba28b81800ec7e5cb48d5b51fee743a0", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 117, "column": 19, "message": "class 'ModuleInformationWithAddresses' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ModuleInformationWithAddresses' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "line": 117, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "reportHash": "d4b10c88884ef10928ce8dc9076aea18", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 151, "column": 19, "message": "class 'ServerInformationBase' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'ServerInformationBase' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "line": 151, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "reportHash": "bed4cb5b0ed0e1f9c1fa1fa33e4e2c1e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 212, "column": 19, "message": "class 'ServerInformationV4' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'ServerInformationV4' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "line": 212, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "reportHash": "f1c6ed8f5f256ec798bcf13808f13101", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 243, "column": 19, "message": "class 'ServerInformationV1' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'ServerInformationV1' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "line": 243, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "reportHash": "5ed9c59ed6b13e4994becfa5311ae257", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 281, "column": 19, "message": "class 'ServerRuntimeInformation' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ServerRuntimeInformation' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/module_information.h", "line": 281, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/user_data.h", "reportHash": "c00f44b7d2fe7a41b3331c3331e3e37d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 69, "column": 19, "message": "class 'UserData' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'UserData' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_api/src/nx/vms/api/data/user_data.h", "line": 69, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "reportHash": "ed5f50fef3d3690ccb0f832a9f806bf6", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 63, "column": 14, "message": "std::move of the variable 'from' of the trivially-copyable type 'std::optional<RangePoint>' has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'from' of the trivially-copyable type 'std::optional<RangePoint>' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "line": 63, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "reportHash": "d59d3885055373b2aa81239edc237c41", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 63, "column": 35, "message": "std::move of the variable 'to' of the trivially-copyable type 'std::optional<RangePoint>' has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'to' of the trivially-copyable type 'std::optional<RangePoint>' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/common/object_metadata.h", "line": 63, "column": 35}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/db/abstract_object_type_dictionary.h", "reportHash": "4f639998ad2d0678f923261796e7e2c1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 7, "message": "class 'AbstractObjectTypeDictionary' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractObjectTypeDictionary' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/analytics/db/abstract_object_type_dictionary.h", "line": 11, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "reportHash": "76d9cc755caec6c2314d33531fa100d4", "checker": {"name": "google-global-names-in-headers", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/global-names-in-headers.html"}, "analyzerName": "clang-tidy", "line": 644, "column": 1, "message": "using declarations in the global namespace in headers are prohibited", "events": [{"message": "using declarations in the global namespace in headers are prohibited", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "line": 644, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "reportHash": "60d3e760523ff19cfa642741d3f4fa98", "checker": {"name": "google-global-names-in-headers", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/global-names-in-headers.html"}, "analyzerName": "clang-tidy", "line": 645, "column": 1, "message": "using declarations in the global namespace in headers are prohibited", "events": [{"message": "using declarations in the global namespace in headers are prohibited", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/common/common_globals.h", "line": 645, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/camera_resource.h", "reportHash": "74e1a36dbf6e7617663f9d94147a630a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 46, "column": 25, "message": "class 'QnVirtualCameraResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnVirtualCameraResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/camera_resource.h", "line": 46, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/media_resource.h", "reportHash": "6a104d6b9c0f6da1b2b7db2526febab1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 21, "column": 25, "message": "class 'QnMediaResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnMediaResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/media_resource.h", "line": 21, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "reportHash": "20e640465d697fc5312bc29b651b13e4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 25, "message": "class 'QnRegion' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'QnRegion' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "line": 19, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "reportHash": "14d82631419dca0fec59c746f2f61331", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 40, "column": 25, "message": "class 'QnMotionRegion' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'QnMotionRegion' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/motion_window.h", "line": 40, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource.h", "reportHash": "9e3ca671c022551ce136957d10aa70d3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 63, "column": 25, "message": "class 'QnResource' defines a destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnResource' defines a destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource.h", "line": 63, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "reportHash": "51fc649c47ddc30f7dcd9834a0cb8c67", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'QnResourceType' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnResourceType' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "reportHash": "88c7f18df672033ae3179fb09e105174", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 63, "column": 25, "message": "class 'QnResourceTypePool' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnResourceTypePool' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/resource_type.h", "line": 63, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/user_resource.h", "reportHash": "f2941cd4ea88b3d6b086ca2286ec2f63", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 78, "column": 25, "message": "class 'QnUserResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnUserResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/resource/user_resource.h", "line": 78, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_attribute.h", "reportHash": "7d0484812d6dcb8194b1c6230a99d35d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 25, "message": "class 'AbstractAttribute' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAttribute' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_attribute.h", "line": 17, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_color_type.h", "reportHash": "7432734d1eb2c874ae786fe3206b07d3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'AbstractColorType' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractColorType' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_color_type.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_engine.h", "reportHash": "57a1128905874e84563e96e0b99ca936", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'AbstractEngine' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractEngine' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_engine.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_enum_type.h", "reportHash": "c0a40e9b35053df7f3c29ecd8d1ca576", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'AbstractEnumType' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractEnumType' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_enum_type.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_group.h", "reportHash": "61db6873a3d3b5bc1e8d8f66d5a016c6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 25, "message": "class 'AbstractGroup' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractGroup' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_group.h", "line": 11, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_integration.h", "reportHash": "a3a5ef3257d4864418c3416edba8cc4d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 25, "message": "class 'AbstractIntegration' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractIntegration' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_integration.h", "line": 12, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_resource_support_proxy.h", "reportHash": "26fb0ba16cc30373cc01761e2a8ebbc5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 25, "message": "class 'AbstractResourceSupportProxy' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractResourceSupportProxy' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_resource_support_proxy.h", "line": 13, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_state.h", "reportHash": "61162c5adca8d31e20fae2c366b0d978", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 21, "column": 25, "message": "class 'AbstractState' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractState' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/analytics/taxonomy/abstract_state.h", "line": 21, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/string.h", "reportHash": "1e30e48388e3914b9d5ca43ad92370a7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 25, "column": 25, "message": "class 'String' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'String' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/string.h", "line": 25, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/application_context.h", "reportHash": "2f73fc5e83bef8e3c1b896b40cd709c9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 27, "column": 25, "message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ApplicationContext' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/application_context.h", "line": 27, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/ptz/types_fwd.h", "reportHash": "f17831bf614814312dbab79b7987a26a", "checker": {"name": "bugprone-forward-declaration-namespace", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 8, "message": "no definition found for 'Options', but a definition with the same name 'Options' found in another namespace 'nx::scrypt'", "events": [{"message": "a definition of 'Options' is found here", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/scrypt.h", "line": 22, "column": 21}, {"message": "no definition found for 'Options', but a definition with the same name 'Options' found in another namespace 'nx::scrypt'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/ptz/types_fwd.h", "line": 14, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/resource/camera_resource_stub.h", "reportHash": "74e6b27d835cb592e53a28e629b3aa32", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 25, "message": "class 'CameraResourceStub' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CameraResourceStub' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/common/resource/camera_resource_stub.h", "line": 11, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/utils/abstract_session_token_helper.h", "reportHash": "d2c39f4710a5ddeecc0d98f578eb721a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'AbstractSessionTokenHelper' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractSessionTokenHelper' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/vms/utils/abstract_session_token_helper.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "reportHash": "2c4e10c2a430baeac97f5808ce2ee08a", "checker": {"name": "bugprone-forward-declaration-namespace", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"}, "analyzerName": "clang-tidy", "line": 60, "column": 8, "message": "declaration 'Message' is never referenced, but a declaration with the same name found in another namespace 'testing'", "events": [{"message": "a declaration of 'Message' is found here", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 950, "column": 7}, {"message": "declaration 'Message' is never referenced, but a declaration with the same name found in another namespace 'testing'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "line": 60, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "reportHash": "ff684a9313c766e71f06082b4d67f12e", "checker": {"name": "bugprone-forward-declaration-namespace", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"}, "analyzerName": "clang-tidy", "line": 60, "column": 8, "message": "no definition found for 'Message', but a definition with the same name 'Message' found in another namespace 'nx::network::http'", "events": [{"message": "a definition of 'Message' is found here", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/http/http_types.h", "line": 513, "column": 22}, {"message": "no definition found for 'Message', but a definition with the same name 'Message' found in another namespace 'nx::network::http'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "line": 60, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "reportHash": "337bcc230457def5b7eedb94215479e2", "checker": {"name": "bugprone-forward-declaration-namespace", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forward-declaration-namespace.html"}, "analyzerName": "clang-tidy", "line": 60, "column": 8, "message": "no definition found for 'Message', but a definition with the same name 'Message' found in another namespace 'testing'", "events": [{"message": "a definition of 'Message' is found here", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "line": 101, "column": 18}, {"message": "no definition found for 'Message', but a definition with the same name 'Message' found in another namespace 'testing'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/email/email_fwd.h", "line": 60, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "reportHash": "66cb40eda12ec0f8f7c558d6c84e9f4f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 46, "column": 38, "message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "line": 46, "column": 38}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "reportHash": "a037601c015b84991c082099a16dcad2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 60, "column": 38, "message": "class 'ContextBasedTest' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ContextBasedTest' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/test_support/src/nx/vms/common/test_support/test_context.h", "line": 60, "column": 38}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
