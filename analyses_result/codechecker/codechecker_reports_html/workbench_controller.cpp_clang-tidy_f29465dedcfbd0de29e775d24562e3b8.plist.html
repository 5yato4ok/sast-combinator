<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/artifacts/qt_graphics_items/src/qt_graphics_items/graphics_widget.h": {"id": "/home/misha/nika/nx_open/artifacts/qt_graphics_items/src/qt_graphics_items/graphics_widget.h", "filePath": "/home/misha/nika/nx_open/artifacts/qt_graphics_items/src/qt_graphics_items/graphics_widget.h", "content": "// Modified by Network Optix, Inc. Original copyright notice follows.\n\n/****************************************************************************\n**\n** Copyright (C) 1992-2005 Trolltech AS. All rights reserved.\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** This file may be used under the terms of the GNU General Public\n** License version 2.0 as published by the Free Software Foundation\n** and appearing in the file LICENSE.GPL included in the packaging of\n** this file.  Please review the following information to ensure GNU\n** General Public Licensing requirements will be met:\n** http://www.trolltech.com/products/qt/opensource.html\n**\n** If you are unsure which license is appropriate for your use, please\n** review the following information:\n** http://www.trolltech.com/products/qt/licensing.html or contact the\n** sales department at sales@trolltech.com.\n**\n** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE\n** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n**\n****************************************************************************/\n\n#ifndef QN_GRAPHICS_WIDGET_H\n#define QN_GRAPHICS_WIDGET_H\n\n#include &lt;QtWidgets/QGraphicsWidget&gt;\n\n#include &lt;ui/common/frame_section_queryable.h&gt;\n\nclass GraphicsWidgetPrivate;\n\nclass GraphicsWidget: public QGraphicsWidget, public FrameSectionQueryable\n{\n    Q_OBJECT\n\n    typedef QGraphicsWidget base_type;\n\npublic:\n    enum HandlingFlag {\n        /**\n         * Item&#x27;s event handlers provide default implementation of item\n         * movement with left mouse button. Note that this implementation\n         * respects the &lt;tt&gt;QGraphicsItem::ItemIsMovable&lt;/tt&gt; flag.\n         *\n         * This flag is not set by default.\n         */\n        ItemHandlesMovement = 0x1,\n\n        /**\n         * Item&#x27;s event handlers provide default implementation of item\n         * resizing with left mouse button for windows.\n         * Note that window is a widget with &lt;tt&gt;Qt::Window&lt;/tt&gt; and\n         * &lt;tt&gt;Qt::WindowTitleHint&lt;/tt&gt; flags set.\n         *\n         * This flag is not set by default.\n         */\n        ItemHandlesResizing = 0x2,\n\n        /**\n         * Item&#x27;s layout changes are handled by default implementation in\n         * &lt;tt&gt;QGraphicsWidget&lt;/tt&gt;. If this flag is not set,\n         * &lt;tt&gt;handlePendingLayoutRequests()&lt;/tt&gt; function can be used to\n         * force immediate processing of all pending layout requests,\n         * e.g. before a paint event.\n         *\n         * Note that this flag has no effect if\n         * &lt;tt&gt;QGraphicsLayout::instantInvalidatePropagation()&lt;/tt&gt; is &lt;tt&gt;false&lt;/tt&gt;.\n         * In this case layout changes are always handled by default implementation.\n         *\n         * This flag is not set by default.\n         */\n        ItemHandlesLayoutRequests = 0x4\n    };\n    Q_DECLARE_FLAGS(HandlingFlags, HandlingFlag);\n\n    enum TransformOrigin {\n        Legacy,\n        TopLeft,\n        Top,\n        TopRight,\n        Left,\n        Center,\n        Right,\n        BottomLeft,\n        Bottom,\n        BottomRight\n    };\n\n    /* Note that it is important for these values to fit into unsigned char as sizeof(GraphicsItemChange) may equal 1. */\n    static const GraphicsItemChange ItemHandlingFlagsChange = static_cast&lt;GraphicsItemChange&gt;(0x80u);\n    static const GraphicsItemChange ItemHandlingFlagsHaveChanged = static_cast&lt;GraphicsItemChange&gt;(0x81u);\n\n    /* Get basic syntax highlighting. */\n#define ItemHandlingFlagsChange ItemHandlingFlagsChange\n#define ItemHandlingFlagsHaveChanged ItemHandlingFlagsHaveChanged\n\n    GraphicsWidget(QGraphicsItem* parent = nullptr, Qt::WindowFlags windowFlags = {});\n    virtual ~GraphicsWidget();\n\n    HandlingFlags handlingFlags() const;\n    void setHandlingFlags(HandlingFlags handlingFlags);\n    void setHandlingFlag(HandlingFlag flag, bool value);\n\n    TransformOrigin transformOrigin() const;\n    void setTransformOrigin(TransformOrigin transformOrigin);\n\n    qreal resizeEffectRadius() const;\n    void setResizeEffectRadius(qreal resizeEffectRadius);\n\n    QMarginsF contentsMargins() const;\n    using base_type::setContentsMargins;\n    void setContentsMargins(const QMarginsF &amp;margins);\n\n    /**\n     * \\returns                         The area inside the widget&#x27;s margins.\n     */\n    QRectF contentsRect() const;\n\n    virtual void setGeometry(const QRectF &amp;rect) override;\n\n    /**\n     * Processes pending layout requests for all graphics widgets on the given\n     * scene that have &lt;tt&gt;ItemHandlesLayoutRequests&lt;/tt&gt; flag unset.\n     *\n     * \\param scene                     Graphics scene to process items at.\n     */\n    static void handlePendingLayoutRequests(QGraphicsScene *scene);\n\n    void selectThisWidget(bool clearOtherSelection = true);\n\nsignals:\n    void transformOriginChanged();\n\nprotected:\n    GraphicsWidget(\n        GraphicsWidgetPrivate&amp; dd, QGraphicsItem* parent, Qt::WindowFlags windowFlags = {});\n\n    virtual void updateGeometry() override;\n\n    virtual QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value) override;\n\n    virtual bool event(QEvent *event) override;\n    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event) override;\n    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override;\n    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;\n    virtual bool windowFrameEvent(QEvent *event) override;\n\n    virtual void initStyleOption(QStyleOption *option) const override;\n\n    using FrameSectionQueryable::windowFrameSectionAt;\n    using FrameSectionQueryable::windowCursorAt;\n    virtual Qt::WindowFrameSection windowFrameSectionAt(const QPointF&amp; pos) const override;\n    virtual Qn::WindowFrameSections windowFrameSectionsAt(const QRectF &amp;region) const override;\n\nprotected:\n    QScopedPointer&lt;GraphicsWidgetPrivate&gt; d_ptr;\n\nprivate:\n    Q_DECLARE_PRIVATE(GraphicsWidget);\n};\n\nQ_DECLARE_OPERATORS_FOR_FLAGS(GraphicsWidget::HandlingFlags);\n\n#endif // QN_GRAPHICS_WIDGET_H\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/abstract_video_decoder.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/abstract_video_decoder.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/abstract_video_decoder.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/media/decoder_types.h&gt;\n#include &lt;nx/media/ffmpeg/frame_info.h&gt;\n#include &lt;nx/media/media_data_packet.h&gt;\n#include &lt;nx/media/video_data_packet.h&gt;\n\nextern &quot;C&quot; {\n#include &lt;libavutil/pixfmt.h&gt;\n}\n\nstatic constexpr int kMaxDecodeThread = 4;\n\nclass QGLContext;\n\nstruct DecoderConfig\n{\n    MultiThreadDecodePolicy mtDecodePolicy = MultiThreadDecodePolicy::autoDetect;\n    bool forceGrayscaleDecoding = false; //&lt; Force grayscale decoding if true. Don&#x27;t change current value if false.\n    bool forceRgbaFormat = false; //&lt; Forces YUV -&gt; RGB conversion on decoder thread.\n};\n\n//!Abstract interface. Every video decoder MUST implement this interface.\n/*!\n    Implementation of this class does not have to be thread-safe.\n\n    Methods getWidth() and getHeight() return actual picture size (after scaling).\\n\n    To find out, whether decoder supports scaling, one must check output picture size.\n*/\nclass QnAbstractVideoDecoder\n{\npublic:\n    // for movies: full = IPB, fast == IP only, fastest = I only\n    enum DecodeMode {\n        DecodeMode_NotDefined,\n        DecodeMode_Full,\n        DecodeMode_Fast,\n        DecodeMode_Fastest\n    };\n\n    virtual ~QnAbstractVideoDecoder() {}\n    //!Returns video decoder type, GPU or CPU.\n    virtual bool hardwareDecoder() const = 0;\n\n    /**\n      * Decode video frame.\n      * Set hardwareAccelerationEnabled flag if hardware acceleration was used\n      * \\param outFrame Made a pointer to pointer to allow in future return internal object to increase performance\n      * \\return true If \\a outFrame is filled, false if no output frame\n      * \\note No error information is returned!\n      */\n    virtual bool decode( const QnConstCompressedVideoDataPtr&amp; data, QSharedPointer&lt;CLVideoDecoderOutput&gt;* const outFrame ) = 0;\n\n    virtual void setLightCpuMode( DecodeMode val ) = 0;\n\n    //!Use multi-threaded decoding (if supported by implementation)\n    virtual void setMultiThreadDecodePolicy(MultiThreadDecodePolicy mtDecodingPolicy) = 0;\n\n    //!Returns output picture size in pixels (after scaling if it is present)\n    virtual int getWidth() const  { return 0; }\n    //!Returns output picture height in pixels (after scaling if it is present)\n    virtual int getHeight() const { return 0; }\n    virtual double getSampleAspectRatio() const { return 1; };\n    //!Reset decoder state (e.g. to reposition source stream)\n    /*!\n        \\param data First encoded frame of new stream. It is recommended that this frame be IDR and contain sequence header\n    */\n    virtual bool resetDecoder(const QnConstCompressedVideoDataPtr&amp; data) = 0;\n\n    // return status of last decode call. Success - 0, Error - other value.\n    virtual int getLastDecodeResult() const = 0;\n\n    virtual void setGreyOnlyMode(bool /*value*/) {};\n};\n"}, "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h": {"id": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "filePath": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n\n#include &lt;QtCore/QSharedPointer&gt;\n#include &lt;QtCore/QSize&gt;\n\nextern &quot;C&quot; {\n#include &lt;libavcodec/avcodec.h&gt;\n#include &lt;libswscale/swscale.h&gt;\n\n} // extern &quot;C&quot;\n\n#include &lt;nx/media/ffmpeg_helper.h&gt;\n#include &lt;nx/media/media_data_packet.h&gt;\n\nclass QVideoFrame;\n\nenum class MemoryType\n{\n    SystemMemory,\n    VideoMemory,\n};\n\nenum class SurfaceType\n{\n    Intel,\n    Nvidia,\n    VideoFrame,\n};\n\nclass AbstractVideoSurface\n{\npublic:\n    virtual ~AbstractVideoSurface() {}\n    virtual AVFrame lockFrame() = 0;\n    virtual void unlockFrame() = 0;\n    virtual SurfaceType type() = 0;\n    virtual QVideoFrame* frame() { return nullptr; }\n};\n\nclass CLVideoDecoderOutput;\nusing CLVideoDecoderOutputPtr = QSharedPointer&lt;CLVideoDecoderOutput&gt;;\nusing CLConstVideoDecoderOutputPtr = QSharedPointer&lt;const CLVideoDecoderOutput&gt;;\n\n/**\n * Decoded frame, ready to be rendered.\n *\n * ATTENTION: AVFrame&#x27;s field pkt_dts is filled with the time since epoch in microseconds, instead\n * of time_base units as ffmpeg states in the documentation.\n */\nclass NX_MEDIA_CORE_API CLVideoDecoderOutput: public AVFrame\n{\npublic:\n    //!Stores picture data. If NULL, picture data is stored in \\a AVFrame fields\n\n    CLVideoDecoderOutput();\n    CLVideoDecoderOutput(int targetWidth, int targetHeight, int targetFormat);\n    CLVideoDecoderOutput(const QImage&amp; image);\n    ~CLVideoDecoderOutput();\n\n    MemoryType memoryType() const { return m_memoryType; }\n    void setMemoryType(MemoryType memoryType) { m_memoryType = memoryType; }\n    bool isEmpty() const;\n    void attachVideoSurface(std::unique_ptr&lt;AbstractVideoSurface&gt; surface);\n    AbstractVideoSurface* getVideoSurface() const { return m_surface.get(); }\n\n    QImage toImage() const;\n    CLVideoDecoderOutputPtr toSystemMemory();\n\n    /**\n     * Copies the frame to another already allocated frame, converting to the required pixel format\n     * if needed.\n     */\n    bool convertTo(const AVFrame* avFrame) const;\n\n    void copyFrom(const CLVideoDecoderOutput* src);\n    void copyDataOnlyFrom(const AVFrame* src);\n    static bool isPixelFormatSupported(AVPixelFormat format);\n\n    void saveToFile(const char* filename); //&lt; Is used for debugging.\n    void clean();\n    void setUseExternalData(bool value);\n    bool isExternalData() const { return m_useExternalData; }\n    bool reallocate(int newWidth, int newHeight, int format);\n    bool reallocate(const QSize&amp; size, int format);\n    void memZero();\n\n    /** Scale frame to new size */\n    CLVideoDecoderOutputPtr scaled(\n        const QSize&amp; newSize,\n        AVPixelFormat newFormat = AV_PIX_FMT_NONE,\n        bool keepAspectRatio = false,\n        int scaleFlags = SWS_BICUBIC) const;\n\n    QSize size() const { return QSize(width, height); }\n    int64_t sizeBytes() const;\n\n    /** Assign misc fields except but no video data */\n    void assignMiscData(const CLVideoDecoderOutput* other);\n\n    static AVPixelFormat fixDeprecatedPixelFormat(AVPixelFormat original);\n\n    /**\n     * Return raw data of the image data.\n     * @return All planes without padding.\n     */\n    QByteArray rawData() const;\n\npublic:\n\n    QnAbstractMediaData::MediaFlags flags = QnAbstractMediaData::MediaFlags_None;\n\n    /** Pixel width to pixel height ratio. Some videos have non-square pixels, we support that. */\n    double sample_aspect_ratio = 0.0;\n\n    /** Number of the video channel in video layout. */\n    int channel = 0;\n\n    /* Needed to downscale video memory surface on rendering stage.\n     * Using scale factor instead of output texture size help to reduce VPP reinitialization\n     */\n    int scaleFactor = 1;\n\nprivate:\n    bool m_useExternalData = false; // pointers only copied to this frame\n    std::unique_ptr&lt;AbstractVideoSurface&gt; m_surface;\n    MemoryType m_memoryType = MemoryType::SystemMemory;\n\nprivate:\n    bool invalidScaleParameters(const QSize&amp; size) const;\n    static void copyPlane(\n        uint8_t* dst, const uint8_t* src, int width, int dstStride, int srcStride, int height);\n\n    CLVideoDecoderOutput(const CLVideoDecoderOutput&amp;) = delete;\n    const CLVideoDecoderOutput&amp; operator=(const CLVideoDecoderOutput&amp;) = delete;\n\n    bool convertUsingSimdIntrTo(const AVFrame* avFrame) const;\n};\n\nclass ScreenshotInterface\n{\npublic:\n    virtual CLVideoDecoderOutputPtr getScreenshot(bool anyQuality) = 0;\n    virtual QImage getGrayscaleScreenshot() = 0;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/access/access_controller.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/access/access_controller.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/access/access_controller.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;common/common_globals.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/scoped_connections.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/common/system_context_aware.h&gt;\n\nnamespace nx::vms::api { struct UserGroupData; }\n\nnamespace nx::vms::client::core {\n\n//-------------------------------------------------------------------------------------------------\n// AccessController\n\nclass NX_VMS_CLIENT_CORE_API AccessController:\n    public QObject,\n    private nx::vms::common::SystemContextAware\n{\n    Q_OBJECT\n    using base_type = QObject;\n\nprotected:\n    using GlobalPermissions = nx::vms::api::GlobalPermissions;\n    using SystemContext = nx::vms::common::SystemContext;\n    using UserGroupData = nx::vms::api::UserGroupData;\n\npublic:\n    explicit AccessController(SystemContext* systemContext, QObject* parent = nullptr);\n    virtual ~AccessController() override;\n\n    using SystemContextAware::systemContext;\n\n    /** Get/set current authority user. */\n    QnUserResourcePtr user() const;\n    void setUser(const QnUserResourcePtr&amp; value);\n\n    /** Get current permissions for given target. */\n    Qn::Permissions permissions(const QnResourcePtr&amp; targetResource) const;\n    Qn::Permissions permissions(const UserGroupData&amp; targetUserGroup) const;\n    bool hasPermissions(const QnResourcePtr&amp; targetResource, Qn::Permissions desired) const;\n    bool hasPermissions(const UserGroupData&amp; targetUserGroup, Qn::Permissions desired) const;\n    bool hasPermissions(const nx::Uuid&amp; subjectId, Qn::Permissions desired) const;\n    bool hasAnyPermission(const QnResourcePtr&amp; targetResource, Qn::Permissions desired) const;\n\n    /** Get current user&#x27;s global permissions. */\n    GlobalPermissions globalPermissions() const;\n    bool hasGlobalPermissions(GlobalPermissions desired) const;\n    bool hasPowerUserPermissions() const;\n\n    /**\n     * Checks whether specified access rights are currently relevant for any device to determine\n     * what global operations are available (e.g. show Bookmarks panel or not, etc.)\n     */\n    virtual bool isDeviceAccessRelevant(nx::vms::api::AccessRights requiredAccessRights) const;\n\n    /**\n     * Create or return existing shared notifier of permission changes for specified resource.\n     * While a notifier exists for a resource, permissions for that resource are cached.\n     *\n     * Notes:\n     *     - you may not create a notifier for a resource not in a resource pool or from\n     *       a different system context;\n     *     - in such erroneous cases a valid pointer to a dummy notifier will be returned;\n     *     - when notifier&#x27;s watched resource is removed from the pool, the notifier is detached\n     *       from the access controller and stops emitting signals;\n     *     - notifier does NOT emit `permissionsChanged` when resource is removed from the pool,\n     *       but AccessController does emit its collective `permissionsMaybeChanged` signal;\n     *     - as notifiers are shared, before clearing shared pointers always disconnect notifiers\n     *       from your receivers.\n     */\n    class Notifier;\n    using NotifierPtr = std::shared_ptr&lt;Notifier&gt;;\n    class NotifierHelper;\n    NotifierPtr createNotifier(const QnResourcePtr&amp; targetResource);\n\nprotected:\n    virtual GlobalPermissions calculateGlobalPermissions() const;\n    virtual Qn::Permissions calculatePermissions(const QnResourcePtr&amp; targetResource) const;\n    virtual Qn::Permissions calculatePermissions(const UserGroupData&amp; targetUserGroup) const;\n\n    void updatePermissions(const QnResourceList&amp; targetResources);\n    void updateAllPermissions();\n\nsignals:\n    void userChanged();\n\n    /**\n     * Emitted if client current permissions could have been changed.\n     * For precise per-resource permissions tracking use notifiers instead.\n     * Note that this signal is also emitted when resources are added to or removed from the pool.\n     * `resourcesHint` indicates affected resources if not empty; if empty, any resource can be\n     * affected.\n     */\n    void permissionsMaybeChanged(const QnResourceList&amp; resourcesHint, QPrivateSignal);\n    void permissionsForGroupsMaybeChanged(const QSet&lt;nx::Uuid&gt;&amp; groupIdsHint, QPrivateSignal);\n\n    void globalPermissionsChanged(GlobalPermissions current, GlobalPermissions old, QPrivateSignal);\n\n    void administrativePermissionsChanged(GlobalPermissions current, GlobalPermissions old,\n        QPrivateSignal);\n\nprivate:\n    class Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n//-------------------------------------------------------------------------------------------------\n// AccessController::Notifier\n\nclass NX_VMS_CLIENT_CORE_API AccessController::Notifier: public QObject\n{\n    Q_OBJECT\n\nsignals:\n    void permissionsChanged(const QnResourcePtr&amp; targetResource, Qn::Permissions current,\n        Qn::Permissions old, AccessController::QPrivateSignal);\n};\n\n//-------------------------------------------------------------------------------------------------\n// AccessController::NotifierHelper\n\nclass NX_VMS_CLIENT_CORE_API AccessController::NotifierHelper\n{\npublic:\n    NotifierHelper() = default;\n    NotifierHelper(NotifierPtr newNotifier): notifier(newNotifier) {}\n\n    void reset(NotifierPtr newNotifier = {})\n    {\n        connections = {};\n        notifier = newNotifier;\n    }\n\n    template&lt;typename Receiver, typename Handler&gt;\n    void callOnPermissionsChanged(Receiver receiver, Handler handler,\n        Qt::ConnectionType connectionType = Qt::AutoConnection)\n    {\n        connections &lt;&lt; QObject::connect(notifier.get(),\n            &amp;AccessController::Notifier::permissionsChanged,\n            receiver,\n            handler,\n            connectionType);\n    }\n\nprivate:\n    NotifierPtr notifier;\n    nx::utils::ScopedConnections connections;\n};\n\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/camera/iomodule/io_module_monitor.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/camera/iomodule/io_module_monitor.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/camera/iomodule/io_module_monitor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;api/model/api_ioport_data.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n\nnamespace nx::vms::client::core {\n\nclass NX_VMS_CLIENT_CORE_API IOModuleMonitor: public QObject\n{\n    Q_OBJECT\n    using base_type = QObject;\n\npublic:\n    IOModuleMonitor(const QnVirtualCameraResourcePtr &amp;camera, QObject* parent = nullptr);\n    virtual ~IOModuleMonitor() override;\n\n    bool open();\n    bool connectionIsOpened() const;\n\nsignals:\n    void connectionClosed();\n    void connectionOpened();\n    void ioStateChanged(const QnIOStateData&amp; value);\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\nusing IOModuleMonitorPtr = QSharedPointer&lt;IOModuleMonitor&gt;;\n\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/media/abstract_analytics_metadata_provider.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/media/abstract_analytics_metadata_provider.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/media/abstract_analytics_metadata_provider.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;limits&gt;\n\n#include &lt;analytics/common/object_metadata.h&gt;\n\n#include &quot;analytics_fwd.h&quot;\n\nnamespace nx::vms::client::core {\n\nclass NX_VMS_CLIENT_CORE_API AbstractAnalyticsMetadataProvider\n{\npublic:\n    AbstractAnalyticsMetadataProvider();\n    virtual ~AbstractAnalyticsMetadataProvider();\n\n    virtual nx::common::metadata::ObjectMetadataPacketPtr metadata(\n        std::chrono::microseconds timestamp,\n        int channel) const = 0;\n\n    virtual QList&lt;nx::common::metadata::ObjectMetadataPacketPtr&gt; metadataRange(\n        std::chrono::microseconds startTimestamp,\n        std::chrono::microseconds endTimestamp,\n        int channel,\n        int maximumCount = std::numeric_limits&lt;int&gt;::max()) const = 0;\n};\n\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/resource/screen_recording/desktop_resource.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/resource/screen_recording/desktop_resource.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/resource/screen_recording/desktop_resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;core/resource/resource.h&gt;\n#include &lt;nx/streaming/abstract_archive_resource.h&gt;\n#include &lt;nx/vms/client/core/resource/resource_fwd.h&gt;\n\nnamespace nx::vms::client::core {\n\nclass DesktopCameraConnection;\n\nclass NX_VMS_CLIENT_CORE_API DesktopResource: public QnAbstractArchiveResource\n{\n    Q_OBJECT\n\npublic:\n    DesktopResource();\n    virtual ~DesktopResource();\n\n    static nx::Uuid getDesktopResourceUuid();\n\n    bool isConnected() const;\n    void initializeConnection(const QnMediaServerResourcePtr&amp; server, const nx::Uuid&amp; userId);\n    void disconnectFromServer();\n\n    virtual bool isRendererSlow() const = 0;\n    virtual AudioLayoutConstPtr getAudioLayout(\n        const QnAbstractStreamDataProvider* dataProvider) const override;\n\n    static QString calculateUniqueId(const nx::Uuid&amp; moduleId, const nx::Uuid&amp; userId);\n\nprivate:\n    std::unique_ptr&lt;DesktopCameraConnection&gt; m_connection;\n};\n\n} // namespace nx::vms::client::core\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/cam_display.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/cam_display.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/cam_display.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_CAM_DISPLAY_H\n#define QN_CAM_DISPLAY_H\n\n#include &lt;chrono&gt;\n\n#include &lt;QtCore/QElapsedTimer&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;core/resource/resource_media_layout.h&gt;\n#include &lt;nx/media/audio_data_packet.h&gt;\n#include &lt;nx/media/ffmpeg/abstract_video_decoder.h&gt;\n#include &lt;nx/streaming/abstract_data_consumer.h&gt;\n#include &lt;utils/common/adaptive_sleep.h&gt;\n#include &lt;utils/media/externaltimesource.h&gt;\n\n#include &quot;video_stream_display.h&quot;\n\n// TODO: #sivanov use forward declaration.\n#include &lt;nx/core/transcoding/filters/legacy_transcoding_settings.h&gt;\n#include &lt;nx/media/audio/format.h&gt;\n#include &lt;nx/media/stream_event.h&gt;\n#include &lt;nx/utils/elapsed_timer.h&gt;\n#include &lt;nx/utils/lockable.h&gt;\n#include &lt;nx/vms/client/desktop/camera/abstract_video_display.h&gt;\n#include &lt;nx/vms/client/desktop/camera/audio_decode_mode.h&gt;\n\nclass QnResourceWidgetRenderer;\nclass QnVideoStreamDisplay;\nclass QnAudioStreamDisplay;\nclass QnCompressedVideoData;\nclass QnAbstractArchiveStreamReader;\n\nnamespace nx::vms::client::core { struct SpectrumData; }\n\n/**\n  * Stores QnVideoStreamDisplay for each channel/sensor\n  */\nclass QnCamDisplay:\n    public QnAbstractDataConsumer,\n    public QnlTimeSource,\n    public nx::vms::client::desktop::AbstractVideoDisplay\n{\n    using base_type = QnAbstractDataConsumer;\n    Q_OBJECT\npublic:\n    /** Owns and stops reader in display thread. */\n    QnCamDisplay(QnMediaResourcePtr resource, QnAbstractArchiveStreamReader* reader);\n    ~QnCamDisplay();\n\n    void addVideoRenderer(int channelCount, QnResourceWidgetRenderer* vw, bool canDownscale);\n    void removeVideoRenderer(QnResourceWidgetRenderer* vw);\n    int channelsCount() const;\n\n    void addMetadataConsumer(const nx::media::AbstractMetadataConsumerPtr&amp; metadataConsumer);\n    void removeMetadataConsumer(const nx::media::AbstractMetadataConsumerPtr&amp; metadataConsumer);\n\n    virtual bool processData(const QnAbstractDataPacketPtr&amp; data) override ;\n\n    virtual void pleaseStop() override;\n\n    void setLightCPUMode(QnAbstractVideoDecoder::DecodeMode val);\n\n    bool doDelayForAudio(QnConstCompressedAudioDataPtr ad, float speed);\n    bool isAudioBuffering() const;\n    void playAudio(bool play);\n    virtual float getSpeed() const override; //&lt; From AbstractVideoDisplay\n\n    // schedule to clean up buffers all;\n    // schedule - coz I do not want to introduce mutexes\n    //I assume that first incoming frame after jump is keyframe\n\n    /**\n     * \\returns                         Current time in microseconds.\n     */\n\n    virtual qint64 getCurrentTime() const override;\n    virtual qint64 getDisplayedTime() const override;\n    virtual qint64 getExternalTime() const override;\n    virtual qint64 getNextTime() const override;\n\n    virtual void endOfRun() override;\n\n    void setMTDecoding(bool value);\n\n    QSize getFrameSize(int channel) const;\n    QImage getScreenshot(const QnLegacyTranscodingSettings&amp; imageProcessingParams, bool anyQuality);\n    QImage getGrayscaleScreenshot(int channel);\n    virtual QSize getVideoSize() const override; //&lt; From AbstractVideoDisplay\n    virtual bool isRealTimeSource() const override; //&lt; From AbstractVideoDisplay\n\n    void setExternalTimeSource(QnlTimeSource* value);\n\n    virtual bool canAcceptData() const override;\n    bool isLongWaiting() const;\n    bool isEOFReached() const;\n    bool isStillImage() const;\n    virtual void putData(const QnAbstractDataPacketPtr&amp; data) override;\n    virtual QSize getMaxScreenSize() const override; //&lt; From AbstractVideoDisplay\n    QnAbstractArchiveStreamReader* getArchiveReader() const;\n    virtual bool isFullScreen() const override; //&lt; From AbstractVideoDisplay\n    virtual bool isZoomWindow() const override; //&lt; From AbstractVideoDisplay\n    void setFullScreen(bool fullScreen);\n\n    virtual bool isFisheyeEnabled() const override; //&lt; From AbstractVideoDisplay\n    void setFisheyeEnabled(bool fisheyeEnabled);\n\n    virtual bool isBuffering() const override; //&lt; From AbstractVideoDisplay &amp; QnlTimeSource\n\n    QnAspectRatio overridenAspectRatio() const;\n    void setOverridenAspectRatio(QnAspectRatio aspectRatio);\n\n    const QSize&amp; getRawDataSize() const {\n        return m_display[0]-&gt;getRawDataSize();\n    }\n\n    QnMediaResourcePtr resource() const;\n\n    nx::media::StreamEventPacket lastMediaEvent() const;\n\n    virtual QString getName() const override;\n    virtual bool isRadassSupported() const override;\n\n    virtual CameraID getCameraID() const override;\n    // Forwarded to reader\n    virtual MediaQuality getQuality() const override;\n    virtual void setQuality(MediaQuality quality, bool fastSwitch) override;\n    virtual bool isPaused() const override;\n    virtual bool isMediaPaused() const override;\n\n    // Forwarded to QnAbstractDataConsumer\n    virtual int dataQueueSize() const override;\n    virtual int maxDataQueueSize() const override;\n\n    virtual void setCallbackForStreamChanges(std::function&lt;void()&gt; callback) override;\n\n    nx::vms::client::desktop::AudioDecodeMode audioDecodeMode() const;\n    void setAudioDecodeMode(nx::vms::client::desktop::AudioDecodeMode decodeMode);\n    nx::vms::client::core::SpectrumData audioSpectrum() const;\n    QString codecName();\n\npublic slots:\n    void onBeforeJump(qint64 time);\n    void onSkippingFrames(qint64 time);\n    void onJumpOccurred(qint64 time);\n    void onRealTimeStreamHint(bool value);\n    void onReaderPaused();\n    void onReaderResumed();\n    void onPrevFrameOccurred();\n    void onNextFrameOccurred();\n\nsignals:\n    void liveMode(bool value);\n    void stillImageChanged();\n\nprotected:\n    virtual void setSingleShotMode(bool single) override;\n    virtual void setSpeed(float speed) override;\n\n    bool haveAudio(float speed) const;\n\n    // puts in queue and returns first in queue\n    QnCompressedVideoDataPtr nextInOutVideodata(QnCompressedVideoDataPtr incoming, int channel);\n\n    // this function doest not change any queues; it just returns time of next frame been displayed\n    quint64 nextVideoImageTime(QnCompressedVideoDataPtr incoming, int channel) const;\n\n    quint64 nextVideoImageTime(int channel) const;\n\n    void clearVideoQueue();\n    void enqueueVideo(QnCompressedVideoDataPtr vd);\n    QnCompressedVideoDataPtr dequeueVideo(int channel);\n    bool isAudioHoleDetected(QnCompressedVideoDataPtr vd);\n    void afterJump(QnAbstractMediaDataPtr media);\n    void processNewSpeed(float speed);\n    bool useSync(QnConstAbstractMediaDataPtr md);\n    int getBufferingMask();\n\n    void at_finished() override;\n\nprivate:\n    /** Process incoming video frame and clear the video queue if possible. */\n    bool processVideoData(QnCompressedVideoDataPtr incoming, int channel, float speed);\n\n    /** Push video frame to decode and display the video frame and create the appropriate delay.*/\n    bool display(QnCompressedVideoDataPtr vd, bool sleep, float speed);\n\n    void hurryUpCheck(QnCompressedVideoDataPtr vd, float speed, qint64 needToSleep, qint64 realSleepTime);\n    void hurryUpCheckForCamera(QnCompressedVideoDataPtr vd, float speed, qint64 needToSleep, qint64 realSleepTime);\n    void hurryUpCheckForLocalFile(QnCompressedVideoDataPtr vd, float speed, qint64 needToSleep, qint64 realSleepTime);\n    void hurryUpCkeckForCamera2(QnAbstractMediaDataPtr media);\n    qint64 getMinReverseTime() const;\n\n    qint64 getDisplayedMax() const;\n    qint64 getDisplayedMin() const;\n    void setAudioBufferSize(int bufferSize, int prebufferMs);\n\n    void blockTimeValue(qint64 time);\n    void blockTimeValueSafe(qint64 time); // can be called from other thread\n    void unblockTimeValue();\n    void waitForFramesDisplayed();\n    void restoreVideoQueue(QnCompressedVideoDataPtr incoming, QnCompressedVideoDataPtr vd, int channel);\n    template &lt;class T&gt; void markIgnoreBefore(const T&amp; queue, qint64 time);\n    bool needBuffering(qint64 vTime) const;\n    void processSkippingFramesTime();\n    qint64 doSmartSleep(const qint64 needToSleep, float speed);\n\n    int maxDataQueueSize(bool live) const;\n\n    static qint64 initialLiveBufferUsec();\n    static qint64 maximumLiveBufferUsec();\n\n    void moveTimestampTo(qint64 timestampUs);\n    void processFillerPacket(\n        qint64 timestampUs,\n        QnAbstractStreamDataProvider* dataProvider,\n        QnAbstractMediaData::MediaFlags flags);\n    bool useRealTimeHurryUp() const;\n    void processMetadata(const QnAbstractCompressedMetadataPtr&amp; metadata);\n    void notifyExternalTimeSrcAboutEof(bool isEof);\n    bool isNvrFillerPacket(qint64 timestampUs) const;\n    void pushMetadataToConsumers(const QnAbstractCompressedMetadataPtr&amp; metadata);\nprotected:\n\n    struct AudioFormat\n    {\n        bool operator==(const AudioFormat&amp;) const = default;\n\n        nx::media::audio::Format format;\n        int bitsPerCodedSample = -1;\n    };\n\n    QnVideoStreamDisplay* m_display[CL_MAX_CHANNELS];\n    QQueue&lt;QnCompressedVideoDataPtr&gt; m_videoQueue[CL_MAX_CHANNELS];\n\n    QnAudioStreamDisplay* m_audioDisplay;\n\n    QnAdaptiveSleep m_delay;\n\n    float m_speed;\n    float m_prevSpeed;\n\n    bool m_playAudio;\n    bool m_shouldPlayAudio = false;\n    bool m_needChangePriority;\n    bool m_hadAudio; // got at least one audio packet\n\n    qint64 m_lastAudioPacketTime;\n    qint64 m_syncAudioTime;\n    int m_totalFrames;\n    int m_iFrames;\n    qint64 m_lastVideoPacketTime;\n    qint64 m_lastDecodedTime;\n    qint64 m_previousVideoTime;\n    quint64 m_lastNonZerroDuration;\n    qint64 m_lastSleepInterval;\n    bool m_afterJump;\n    bool m_bofReceived;\n    bool m_ignoringVideo;\n    bool m_isRealTimeSource;\n    nx::media::audio::Format m_expectedAudioFormat;\n    mutable nx::Mutex m_audioChangeMutex;\n    bool m_videoBufferOverflow;\n    bool m_singleShotMode;\n    bool m_singleShotQuantProcessed;\n    qint64 m_jumpTime;\n    AudioFormat m_playingFormat;\n    QnAbstractVideoDecoder::DecodeMode m_lightCpuMode;\n    QnVideoStreamDisplay::FrameDisplayStatus m_lastFrameDisplayed;\n    bool m_realTimeHurryUp;\n    int m_delayedFrameCount;\n    QnlTimeSource* m_extTimeSrc;\n\n    bool m_useMtDecoding;\n    int m_buffering;\n    int m_processedPackets;\n    qint64 m_nextReverseTime[CL_MAX_CHANNELS];\n    int m_emptyPacketCounter;\n    bool m_isStillImage;\n    bool m_isLongWaiting;\n    qint64 m_skippingFramesTime;\n\n    bool m_executingChangeSpeed;\n    bool m_eofSignalSent;\n    int m_audioBufferSize;\n    qint64 m_minAudioDetectJumpInterval;\n    qint64 m_videoQueueDuration;\n    bool m_useMTRealTimeDecode; // multi thread decode for live temporary allowed\n    bool m_forceMtDecoding; // force multi thread decode in any case\n\n    mutable nx::Mutex m_timeMutex;\n    QnMediaResourcePtr m_resource;\n    QElapsedTimer m_afterJumpTimer;\n    qint64 m_firstAfterJumpTime;\n    qint64 m_receivedInterval;\n    std::unique_ptr&lt;QnAbstractArchiveStreamReader&gt; m_archiveReader;\n\n    bool m_fullScreen;\n    int m_prevLQ;\n    bool m_doNotChangeDisplayTime;\n    bool m_multiView;\n    bool m_fisheyeEnabled;\n    int m_channelsCount;\n\n    qint64 m_lastQueuedVideoTime;\n    int m_liveBufferSizeUsec;\n    bool m_liveMaxLenReached;\n    bool m_hasVideo;\n    nx::media::StreamEventPacket m_lastMediaEvent;\n    mutable nx::Mutex m_lastMediaEventMutex;\n    nx::utils::ElapsedTimer m_lastMediaEventTimeout;\n\n    mutable nx::Mutex m_metadataConsumersHashMutex;\n    QMultiMap&lt;MetadataType, QWeakPointer&lt;nx::media::AbstractMetadataConsumer&gt;&gt;\n        m_metadataConsumerByType;\n    QVector&lt;bool&gt; m_gotKeyDataInfo;\n    std::function&lt;void()&gt; m_streamsChangedCallback;\n\n    nx::vms::client::desktop::AudioDecodeMode m_audioDecodeMode =\n        nx::vms::client::desktop::AudioDecodeMode::normal;\n    nx::Lockable&lt;QString&gt; m_codecName;\n    AVCodecID m_codecId = AV_CODEC_ID_NONE;\n};\n\n#endif //QN_CAM_DISPLAY_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/video_stream_display.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/video_stream_display.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/video_stream_display.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n\n#include &lt;QtCore/QQueue&gt;\n\n#include &lt;nx/media/abstract_metadata_consumer.h&gt;\n#include &lt;nx/media/ffmpeg/abstract_video_decoder.h&gt;\n#include &lt;nx/media/frame_scaler.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/thread/stoppable.h&gt;\n#include &lt;transcoding/filters/filter_helper.h&gt;\n\n\nextern &quot;C&quot; {\nstruct SwsContext;\n}\n\nclass QnAbstractVideoDecoder;\nclass QnCompressedVideoData;\nclass QnResourceWidgetRenderer;\n\nconstexpr int kMaxQueueTime = 1000 * 200;\n\n/**\n  * Display one video stream. Decode the video and pass it to video window.\n  */\nclass QnVideoStreamDisplay: public ScreenshotInterface\n{\npublic:\n    enum FrameDisplayStatus {Status_Displayed, Status_Skipped, Status_Buffered};\n\n    QnVideoStreamDisplay(const QnMediaResourcePtr&amp; resource, bool can_downscale, int channelNumber);\n    virtual ~QnVideoStreamDisplay();\n\n    int addRenderer(QnResourceWidgetRenderer* draw);\n    int removeRenderer(QnResourceWidgetRenderer* draw);\n\n    FrameDisplayStatus display(\n        QnCompressedVideoDataPtr data,\n        bool draw,\n        QnFrameScaler::DownscaleFactor force_factor = QnFrameScaler::factor_any);\n\n    void setLightCPUMode(QnAbstractVideoDecoder::DecodeMode val);\n\n    QnFrameScaler::DownscaleFactor getCurrentDownscaleFactor() const;\n\n    void setMTDecoding(bool value);\n\n    void setSpeed(float value);\n    virtual CLVideoDecoderOutputPtr getScreenshot(bool anyQuality) override;\n    virtual QImage getGrayscaleScreenshot() override;\n    qint64 nextReverseTime() const;\n    QSize getImageSize() const;\n\n    QSize getMaxScreenSize() const;\n\n    QnAspectRatio overridenAspectRatio() const;\n    void setOverridenAspectRatio(QnAspectRatio aspectRatio);\n    void endOfRun();\n\npublic: // used only by QnCamDisplay\n    void waitForFramesDisplayed();\n    QSize getMaxScreenSizeUnsafe() const;\n\n    QnVideoStreamDisplay::FrameDisplayStatus flushFrame(\n        int channel, QnFrameScaler::DownscaleFactor force_factor);\n    //!Blocks until all frames passed to \\a display have been rendered\n    void flushFramesToRenderer();\n    void overrideTimestampOfNextFrameToRender(qint64 value);\n    //!Returns timestamp of frame that will be rendered next. It can be already displayed frame (if no new frames available)\n    qint64 getTimestampOfNextFrameToRender() const;\n\n    void blockTimeValue(qint64 time);\n    void blockTimeValueSafe(qint64 time);\n    void setPausedSafe(bool value);\n    void unblockTimeValue();\n    bool isTimeBlocked() const;\n    void afterJump();\n    void onNoVideo();\n\n    void updateRenderList();\n    const QSize&amp; getRawDataSize() const { return m_rawDataSize; }\n    MultiThreadDecodePolicy toEncoderPolicy(bool useMtDecoding) const;\n\nprivate:\n    struct Decoder\n    {\n        AVCodecID compressionType = AVCodecID::AV_CODEC_ID_NONE;\n        std::unique_ptr&lt;QnAbstractVideoDecoder&gt; decoder;\n    };\n    Decoder m_decoderData;\n\n    std::set&lt;QnResourceWidgetRenderer*&gt; m_newList;\n    std::set&lt;QnResourceWidgetRenderer*&gt; m_renderList;\n    bool m_renderListModified;\n    QnMediaResourcePtr m_resource;\n\n    QnAbstractVideoDecoder::DecodeMode m_decodeMode;\n    bool m_canDownscale;\n    const int m_channelNumber;\n\n    QnFrameScaler::DownscaleFactor m_prevFactor;\n    QnFrameScaler::DownscaleFactor m_scaleFactor;\n    QSize m_previousOnScreenSize;\n\n    SwsContext* m_scaleContext;\n    int m_outputWidth;\n    int m_outputHeight;\n    std::atomic_bool m_mtDecoding = false;\n    std::atomic_bool m_needReinitDecoders = false;\n    bool m_reverseMode;\n    bool m_prevReverseMode;\n    QQueue&lt;QSharedPointer&lt;CLVideoDecoderOutput&gt;&gt; m_reverseQueue;\n    bool m_flushedBeforeReverseStart;\n    qint64 m_reverseSizeInBytes;\n    bool m_timeChangeEnabled;\n    QSize m_rawDataSize;\n    float m_speed;\n    bool m_needResetDecoder;\n    mutable nx::Mutex m_lastDisplayedFrameMutex;\n    CLConstVideoDecoderOutputPtr m_lastDisplayedFrame;\n    QSize m_imageSize;\n    mutable nx::Mutex m_imageSizeMtx;\n    int m_prevSrcWidth;\n    int m_prevSrcHeight;\n    qint64 m_lastIgnoreTime;\n    mutable nx::Mutex m_renderListMtx;\n    bool m_isPaused;\n    bool m_isLive = false;\n    QnAspectRatio m_overridenAspectRatio;\n    std::optional&lt;std::chrono::microseconds&gt; m_blockedTimeValue;\n\nprivate:\n    void reorderPrevFrames();\n    bool allocScaleContext(const CLVideoDecoderOutput&amp; outFrame, int newWidth, int newHeight);\n    void freeScaleContext();\n    bool rescaleFrame(const CLVideoDecoderOutput&amp; srcFrame, CLVideoDecoderOutput&amp; outFrame, int newWidth, int newHeight);\n    void flushReverseBlock(\n        QnAbstractVideoDecoder* dec, QnCompressedVideoDataPtr data, QnFrameScaler::DownscaleFactor forceScaleFactor);\n    bool shouldUpdateDecoder(\n        const QnConstCompressedVideoDataPtr&amp; data, bool reverseMode);\n\n    QnAbstractVideoDecoder* createVideoDecoder(\n        const QnConstCompressedVideoDataPtr&amp; data, bool mtDecoding) const;\n\n    QnFrameScaler::DownscaleFactor determineScaleFactor(\n        std::set&lt;QnResourceWidgetRenderer*&gt; renderList,\n        int channelNumber,\n        int srcWidth,\n        int srcHeight,\n        QnFrameScaler::DownscaleFactor forceFactor);\n    bool processDecodedFrame(const CLConstVideoDecoderOutputPtr&amp; outFrame);\n    void checkQueueOverflow();\n    void clearReverseQueue();\n\n    void calcSampleAR(QSharedPointer&lt;CLVideoDecoderOutput&gt; outFrame, double decoderSar);\n\n    bool downscaleOrForward(\n        const CLConstVideoDecoderOutputPtr&amp; src,\n        CLVideoDecoderOutputPtr&amp; dst,\n        QnFrameScaler::DownscaleFactor forceScaleFactor);\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/client/client_runtime_settings.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/client/client_runtime_settings.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/client/client_runtime_settings.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/reflect/enum_string_conversion.h&gt;\n#include &lt;nx/vms/client/desktop/settings/types/graphics_api.h&gt;\n#include &lt;utils/common/property_storage.h&gt;\n\n#include &quot;client_globals.h&quot;\n\nstruct QnStartupParameters;\n\nclass NX_VMS_CLIENT_DESKTOP_API QnClientRuntimeSettings: public QnPropertyStorage\n{\n    Q_OBJECT\n\n    typedef QnPropertyStorage base_type;\npublic:\n    enum Variable {\n        /** YUV-shader emulation mode. */\n        SOFTWARE_YUV,\n\n        /** Debug value. */\n        DEBUG_COUNTER,\n\n        /** Light client mode - no animations, no background, no opacity, no notifications, 1 camera only allowed. */\n        LIGHT_MODE,\n\n        /** If does not equal -1 then its value will be copied to LIGHT_MODE.\n         *  It should be set from command-line and it disables light mode auto detection. */\n        LIGHT_MODE_OVERRIDE,\n\n        /** Videowall client mode - client should not be controlled manually. */\n        VIDEO_WALL_MODE,\n\n        /** Allow timeline to be displayed on the Video Wall. */\n        VIDEO_WALL_WITH_TIMELINE,\n\n        /** ACS mode - client is run as a separate camera view-only window. */\n        ACS_MODE,\n\n        /** Always display full info on cameras. */\n        SHOW_FULL_INFO,\n\n        /** Use OpenGL double buffering. */\n        GL_DOUBLE_BUFFER,\n\n        /** Maximum simultaneous scene items overridden value. 0 means default. */\n        MAX_SCENE_ITEMS_OVERRIDE,\n\n        /** Allow client updates. */\n        ALLOW_CLIENT_UPDATE,\n\n        /** Maximum live buffer size in ms. */\n        MAXIMUM_LIVE_BUFFER,\n\n        /** Qt graphics API. */\n        GRAPHICS_API,\n\n        VARIABLE_COUNT\n    };\n\n    explicit QnClientRuntimeSettings(\n        const QnStartupParameters&amp; startupParameters,\n        QObject* parent = nullptr);\n    virtual ~QnClientRuntimeSettings() override;\n\n    static QnClientRuntimeSettings* instance();\n\n    bool isDesktopMode() const;\n\n    /**\n     * Actual maximum value of scene items.\n     */\n    int maxSceneItems() const;\n\n    /** Compatibility function. */\n    QString locale() const; //&lt; TODO: #sivanov Remove in the next release.\n\nprivate:\n    QN_BEGIN_PROPERTY_STORAGE(VARIABLE_COUNT)\n        QN_DECLARE_RW_PROPERTY(bool, isSoftwareYuv, setSoftwareYuv, SOFTWARE_YUV, false)\n        QN_DECLARE_RW_PROPERTY(int, debugCounter, setDebugCounter, DEBUG_COUNTER, 0)\n        QN_DECLARE_RW_PROPERTY(Qn::LightModeFlags, lightMode, setLightMode, LIGHT_MODE, {})\n        QN_DECLARE_RW_PROPERTY(int, lightModeOverride, setLightModeOverride,\n            LIGHT_MODE_OVERRIDE, -1)\n        QN_DECLARE_RW_PROPERTY(bool, isVideoWallMode, setVideoWallMode, VIDEO_WALL_MODE, false)\n        QN_DECLARE_RW_PROPERTY(bool, videoWallWithTimeline, setVideoWallWithTimeLine,\n            VIDEO_WALL_WITH_TIMELINE, true)\n        QN_DECLARE_RW_PROPERTY(bool, isAcsMode, setAcsMode, ACS_MODE, false)\n        QN_DECLARE_RW_PROPERTY(bool, showFullInfo, setShowFullInfo, SHOW_FULL_INFO, false)\n        QN_DECLARE_RW_PROPERTY(bool, isGlDoubleBuffer, setGLDoubleBuffer, GL_DOUBLE_BUFFER, true)\n        QN_DECLARE_RW_PROPERTY(int, maxSceneItemsOverride, setMaxSceneItemsOverride,\n            MAX_SCENE_ITEMS_OVERRIDE, 0)\n        QN_DECLARE_RW_PROPERTY(bool, isClientUpdateAllowed, setClientUpdateAllowed,\n            ALLOW_CLIENT_UPDATE, true)\n        QN_DECLARE_RW_PROPERTY(int, maximumLiveBufferMs, setMaximumLiveBufferMs,\n            MAXIMUM_LIVE_BUFFER, 0)\n        QN_DECLARE_RW_PROPERTY(nx::vms::client::desktop::GraphicsApi, graphicsApi, setGraphicsApi,\n            GRAPHICS_API, nx::vms::client::desktop::GraphicsApi::opengl)\n    QN_END_PROPERTY_STORAGE()\n};\n\n#define qnRuntime QnClientRuntimeSettings::instance()\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/local_resources_directory_model.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/local_resources_directory_model.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/local_resources_directory_model.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QFileSystemWatcher&gt;\n#include &lt;QtCore/QHash&gt;\n#include &lt;QtCore/QSet&gt;\n#include &lt;QtCore/QTimer&gt;\n\nnamespace nx::vms::client::desktop {\n\nclass LocalResourcesDirectoryModel: public QObject\n{\n    Q_OBJECT\n    using base_type = QObject;\n\npublic:\n    LocalResourcesDirectoryModel(QObject* parent = nullptr);\n    virtual ~LocalResourcesDirectoryModel() override;\n\n    QStringList getLocalResourcesDirectories() const;\n    void setLocalResourcesDirectories(const QStringList&amp; paths);\n\nsignals:\n    void filesAdded(const QStringList&amp; newFiles);\n    void layoutFileChanged(const QString&amp; filePath);\n    void videoFileChanged(const QString&amp; filePath);\n\nprivate:\n    void addWatchedDirectory(const QString&amp; path);\n    void removeWatchedDirectory(const QString&amp; path);\n    void onDirectoryChanged(const QString&amp; path);\n    void onFileChanged(const QString&amp; path);\n    void processPendingDirectoryChanges();\n    void processPendingFileChanges();\n\nprivate:\n    QFileSystemWatcher m_fileSystemWatcher;\n\n    QTimer m_deferredDirectoryChangeHandlerTimer;\n    QTimer m_deferredFileChangeHandlerTimer;\n\n    QSet&lt;QString&gt; m_pendingDirectoryChanges;\n    QSet&lt;QString&gt; m_pendingFileChanges;\n\n    QStringList m_localResourcesDirectories;\n    QHash&lt;QString, QStringList&gt; m_childFiles;\n    QHash&lt;QString, QStringList&gt; m_childDirectories;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/resource_directory_browser.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/resource_directory_browser.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/resource_directory_browser.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;mutex&gt;\n\n#include &lt;QtCore/QPointer&gt;\n#include &lt;nx/vms/client/core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/common/system_context_aware.h&gt;\n\n#include &quot;local_resources_directory_model.h&quot;\n\nnamespace nx::vms::client::desktop {\n\nclass UpdateFileLayoutHelper: public QObject, public nx::vms::common::SystemContextAware\n{\n    Q_OBJECT\n\npublic:\n    UpdateFileLayoutHelper(\n        nx::vms::common::SystemContext* systemContext,\n        QObject* parent = nullptr);\n\n    // These methods must be called from the main thread.\n    Q_INVOKABLE void startUpdateLayout(const QnFileLayoutResourcePtr&amp; sourceLayout);\n    Q_INVOKABLE void finishUpdateLayout(const QnFileLayoutResourcePtr&amp; loadedLayout);\n};\n\nclass LocalResourceProducer: public QObject, public nx::vms::common::SystemContextAware\n{\n    Q_OBJECT\n    using base_type = QObject;\n\npublic:\n    LocalResourceProducer(\n        nx::vms::common::SystemContext* systemContext,\n        UpdateFileLayoutHelper* helper,\n        QObject* parent = nullptr);\n    void createLocalResources(const QStringList&amp; pathList);\n    void updateFileLayoutResource(const QString&amp; path);\n    void updateVideoFileResource(const QString&amp; path);\n\nprivate:\n    UpdateFileLayoutHelper* m_updateFileLayoutHelper;\n};\n\nclass ResourceDirectoryBrowser: public QObject, public nx::vms::common::SystemContextAware\n{\n    Q_OBJECT\n    using base_type = QObject;\n\npublic:\n    ResourceDirectoryBrowser(\n        nx::vms::common::SystemContext* systemContext,\n        QObject* parent = nullptr);\n    virtual ~ResourceDirectoryBrowser() override;\n\n    void stop();\n\n    void setLocalResourcesDirectories(const QStringList&amp; paths);\n\n    static QnFileLayoutResourcePtr layoutFromFile(const QString&amp; filename,\n        const QPointer&lt;QnResourcePool&gt;&amp; resourcePool);\n\n    static QnResourcePtr createArchiveResource(const QString&amp; filename,\n        const QPointer&lt;QnResourcePool&gt;&amp; resourcePool);\n\nsignals:\n    void layoutUpdatedFromFile(const QnFileLayoutResourcePtr&amp; layout);\n\nprivate:\n    void dropResourcesFromDirectory(const QString&amp; path);\n    void stopInternal();\n\nprivate:\n    LocalResourcesDirectoryModel* m_localResourceDirectoryModel;\n    QThread* m_resourceProducerThread;\n    LocalResourceProducer* m_resourceProducer;\n    std::once_flag m_stopOnceFlag;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/access_controller.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/access_controller.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/access_controller.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;vector&gt;\n\n#include &lt;nx/vms/client/core/access/access_controller.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n\nnamespace nx::vms::api { struct LayoutData; }\n\nnamespace nx::vms::client::desktop {\n\nclass NX_VMS_CLIENT_DESKTOP_API AccessController: public client::core::AccessController\n{\n    Q_OBJECT\n    using base_type = client::core::AccessController;\n\npublic:\n    explicit AccessController(SystemContext* systemContext, QObject* parent = nullptr);\n    virtual ~AccessController() override;\n\n    /** Resource creation checkers. */\n    bool canCreateStorage(const nx::Uuid&amp; serverId) const;\n    bool canCreateLayout(const nx::vms::api::LayoutData&amp; layoutData) const;\n    bool canCreateUser(\n        GlobalPermissions targetPermissions, const std::vector&lt;nx::Uuid&gt;&amp; targetGroups) const;\n    bool canCreateVideoWall() const;\n    bool canCreateWebPage() const;\n\n    virtual bool isDeviceAccessRelevant(nx::vms::api::AccessRights requiredAccessRights) const;\n\nprotected:\n    virtual GlobalPermissions calculateGlobalPermissions() const override;\n\n    virtual Qn::Permissions calculatePermissions(\n        const QnResourcePtr&amp; targetResource) const override;\nprivate:\n    class Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/caching_access_controller.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/caching_access_controller.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/caching_access_controller.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &quot;access_controller.h&quot;\n\nnamespace nx::vms::client::desktop {\n\nclass NX_VMS_CLIENT_DESKTOP_API CachingAccessController: public AccessController\n{\n    Q_OBJECT\n    using base_type = AccessController;\n\npublic:\n    explicit CachingAccessController(SystemContext* systemContext, QObject* parent = nullptr);\n    virtual ~CachingAccessController() override;\n\nsignals:\n    void permissionsChanged(const QnResourcePtr&amp; resource, Qn::Permissions old,\n        Qn::Permissions current, QPrivateSignal);\n\nprivate:\n    class Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/camera/abstract_video_display.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/camera/abstract_video_display.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/camera/abstract_video_display.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n\n#include &lt;nx/media/media_data_packet.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nnamespace nx::vms::client::desktop\n{\n\nclass AbstractVideoDisplay\n{\npublic:\n    virtual ~AbstractVideoDisplay() = default;\n\n    typedef nx::Uuid CameraID;\n    virtual CameraID getCameraID() const = 0;\n\n    virtual bool isFullScreen() const = 0;\n    virtual bool isZoomWindow() const = 0;\n    virtual bool isFisheyeEnabled() const = 0;\n    virtual float getSpeed() const = 0;\n    virtual bool isRadassSupported() const = 0;\n    /** @returns largest width and heights if there are several renderers for one video stream. */\n    virtual QSize getMaxScreenSize() const = 0;\n    virtual QSize getVideoSize() const = 0;\n    virtual QString getName() const = 0;\n\n    virtual MediaQuality getQuality() const = 0;\n    virtual void setQuality(MediaQuality quality, bool fastSwitch) = 0;\n\n    virtual bool isRealTimeSource() const = 0;\n\n    virtual int dataQueueSize() const = 0;\n    virtual int maxDataQueueSize() const = 0;\n\n    virtual bool isPaused() const = 0;\n    virtual bool isMediaPaused() const = 0;\n\n    virtual bool isBuffering() const = 0;\n\n// Cannot derive from QObject so cannot use signals.\n    virtual void setCallbackForStreamChanges(std::function&lt;void()&gt; callback) = 0;\n};\n\n} // namespace vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/common/utils/accessor.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/common/utils/accessor.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/common/utils/accessor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QSharedPointer&gt;\n#include &lt;QtCore/QVariant&gt;\n\nnamespace nx::vms::client::desktop {\n\n/**\n * Abstract accessor class.\n */\nclass AbstractAccessor\n{\npublic:\n    virtual QVariant get(const QObject* object) const = 0;\n    virtual void set(QObject* object, const QVariant&amp; value) const = 0;\n    virtual ~AbstractAccessor() {}\n};\n\n/**\n * Accessor that wraps the given functors.\n */\ntemplate&lt;class Getter, class Setter&gt;\nclass AccessorAdaptor: public AbstractAccessor\n{\npublic:\n    AccessorAdaptor(const Getter&amp; getter, const Setter&amp; setter):\n        m_getter(getter), m_setter(setter)\n    {\n    }\n\n    virtual QVariant get(const QObject* object) const override\n    {\n        return m_getter(object);\n    }\n\n    virtual void set(QObject* object, const QVariant&amp; value) const override\n    {\n        m_setter(object, value);\n    }\n\nprivate:\n    Getter m_getter;\n    Setter m_setter;\n};\n\n/**\n * Factory function for accessor adaptors.\n *\n * \\param getter                        Getter functor to adapt.\n * \\param setter                        Setter functor to adapt.\n */\ntemplate&lt;class Getter, class Setter&gt;\nAbstractAccessor* newAccessor(const Getter&amp; getter, const Setter&amp; setter)\n{\n    return new AccessorAdaptor&lt;Getter, Setter&gt;(getter, setter);\n}\n\n/**\n * Accessor for Qt properties.\n */\nclass PropertyAccessor: public AbstractAccessor\n{\npublic:\n    using AccessorPtr = QSharedPointer&lt;PropertyAccessor&gt;;\n\n    static const AccessorPtr create(const QByteArray&amp; propertyName)\n    {\n        return AccessorPtr(new PropertyAccessor(propertyName));\n    }\n\n    PropertyAccessor(const QByteArray&amp; propertyName): m_propertyName(propertyName)\n    {\n    }\n\n    virtual QVariant get(const QObject* object) const override\n    {\n        return object-&gt;property(m_propertyName.constData());\n    }\n\n    virtual void set(QObject* object, const QVariant&amp; value) const override\n    {\n        object-&gt;setProperty(m_propertyName.constData(), value);\n    }\n\nprivate:\n    QByteArray m_propertyName;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/help/help_handler.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/help/help_handler.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/help/help_handler.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QUrl&gt;\n\n#include &quot;help_topic.h&quot;\n\nnamespace nx::vms::client::desktop {\n\nclass HelpDialog;\n\n// This class should not depend on any singletons.\n// If it must, it should be changed to our QnSingleton descendant.\nclass HelpHandler: public QObject\n{\n    Q_OBJECT\n\npublic:\n    HelpHandler(QObject* parent = nullptr);\n    virtual ~HelpHandler() override;\n\n    // Sets help topic and opens a browser for it.\n    void setHelpTopic(int topic);\n    void setHelpTopic(HelpTopic::Id topic);\n\n    virtual bool eventFilter(QObject* watched, QEvent* event) override;\n\n    Q_INVOKABLE static void openHelpTopic(int topic);\n    Q_INVOKABLE static void openHelpTopic(HelpTopic::Id topic);\n\n    static HelpHandler&amp; instance();\n\nprotected:\n    static QUrl urlForTopic(HelpTopic::Id topic);\n\n    void openHelpTopicInternal(HelpTopic::Id topic);\n\nprivate:\n    std::unique_ptr&lt;HelpDialog&gt; m_helpDialog;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtGui/QAction&gt;\n\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n\n#include &quot;action_conditions.h&quot;\n#include &quot;action_fwd.h&quot;\n#include &quot;action_types.h&quot;\n#include &quot;actions.h&quot;\n\nnamespace nx::vms::client::desktop {\nnamespace menu {\n\n/**\n * Action class that hooks into actions infrastructure to correctly check conditions and provide\n * proper action parameters even if it was triggered with a hotkey.\n */\nclass Action: public QAction, public WindowContextAware\n{\n    Q_OBJECT\n\npublic:\n    Action(IDType id, WindowContext* context, QObject* parent = nullptr);\n    virtual ~Action() override;\n\n    /**\n     * Identifier of this action.\n     */\n    IDType id() const;\n\n    /**\n     * Scope of this action.\n     */\n    ActionScopes scope() const;\n\n    /**\n     * Possible types of this action&#x27;s default parameter.\n     */\n    ActionParameterTypes defaultParameterTypes() const;\n\n    /**\n     * @param target Action parameter key.\n     * @return Permissions that are required for the provided parameter.\n     */\n    Qn::Permissions requiredTargetPermissions(int target = -1) const;\n\n    /**\n     * Set permissions required for some specific resource, passed as target.\n     * @param target Action parameter key.\n     * @param requiredPermissions Permissions required for the provided parameter.\n     */\n    void setRequiredTargetPermissions(int target, Qn::Permissions requiredPermissions);\n\n    /**\n     * Set permissions required for the target resources.\n     */\n    void setRequiredTargetPermissions(Qn::Permissions requiredPermissions);\n\n    /**\n     * Set global permissions that the current user must have.\n     */\n    void setRequiredGlobalPermission(GlobalPermission requiredPermissions);\n\n    bool isPowerUserRequired() const;\n    void setPowerUserRequired(bool value = true);\n\n    ClientModes mode() const;\n    void setMode(ClientModes mode);\n\n    ActionFlags flags() const;\n    void setFlags(ActionFlags flags);\n\n    Qn::ButtonAccent accent() const;\n    void setAccent(Qn::ButtonAccent value);\n\n    /**\n     * Default text of this action.\n     */\n    const QString&amp; normalText() const;\n\n    /**\n     * Set default text of this action.\n     */\n    void setNormalText(const QString&amp; normalText);\n\n    /**\n     * Text for this action that is to be used when it is toggled.\n     */\n    const QString&amp; toggledText() const;\n\n    /**\n     * Text for this action that is to be used when it is toggled. If empty, default text will be\n     * used.\n     */\n    void setToggledText(const QString&amp; toggledText);\n\n    /**\n     * Text for this action that is to be used when it is pulled into the enclosing menu.\n     */\n    const QString&amp; pulledText() const;\n\n    /**\n     * Set text for this action that is to be used when it is pulled into the enclosing menu. If\n     * empty, default text will be used.\n     */\n    void setPulledText(const QString&amp; pulledText);\n\n    /**\n     * Condition associated with this action, of nullptr if none.\n     */\n    bool hasCondition() const;\n\n    /**\n     * Set condition for this action.\n     */\n    void setCondition(ConditionWrapper&amp;&amp; condition);\n\n    FactoryPtr childFactory() const;\n    void setChildFactory(const FactoryPtr&amp; childFactory);\n\n    TextFactoryPtr textFactory() const;\n    void setTextFactory(const TextFactoryPtr&amp; textFactory);\n\n    /**\n     * Child actions. These action will appear in a submenu for this action.\n     */\n    const QList&lt;Action*&gt;&amp; children() const;\n\n    void addChild(Action* action);\n\n    void removeChild(Action* action);\n\n    QString disabledToolTip() const;\n    void setDisabledToolTip(const QString&amp; toolTip);\n\n    QString toolTipFormat() const;\n    void setToolTipFormat(const QString&amp; toolTipFormat);\n\n    /**\n     * \\param scope                     Scope in which action is to be executed.\n     * \\param parameters                Parameters for action execution.\n     * \\returns                         Action visibility that determines whether\n     *                                  action can be executed and how it will\n     *                                  appear in context menu.\n     */\n    ActionVisibility checkCondition(ActionScopes scope, const Parameters&amp; parameters) const;\n\n    void addConditionalText(ConditionWrapper&amp;&amp; condition, const QString&amp; text);\n\n    /**\n     * \\returns true if there is at least one conditional text\n     */\n    bool hasConditionalTexts() const;\n\n    /**\n     * \\param parameters                Parameters for action execution.\n     * \\returns                         New text if condition is executed;\n     *                                  empty string otherwise.\n     */\n    QString checkConditionalText(const Parameters&amp; parameters) const;\n\nprotected:\n    virtual bool event(QEvent* event) override;\n\nprivate slots:\n    void updateText();\n    void updateToolTip(bool notify);\n    void updateToolTipSilent();\n\nprivate:\n    QString defaultToolTipFormat() const;\n\nprivate:\n    const IDType m_id;\n    ActionFlags m_flags;\n    Qn::ButtonAccent m_accent{Qn::ButtonAccent::NoAccent};\n    ClientModes m_mode;\n    QHash&lt;int, Qn::Permissions&gt; m_targetPermissions;\n    GlobalPermission m_globalPermission;\n    bool m_powerUserRequired = false;\n    QString m_normalText, m_toggledText, m_pulledText;\n    QString m_disabledToolTip;\n    QString m_toolTipFormat, m_toolTipMarker;\n    ConditionWrapper m_condition;\n    FactoryPtr m_childFactory;\n    TextFactoryPtr m_textFactory;\n\n    QList&lt;Action*&gt; m_children;\n\n    struct ConditionalText\n    {\n        ConditionWrapper condition;\n        QString text;\n        ConditionalText() = delete;\n        ConditionalText(ConditionalText&amp;&amp; conditionalText);\n        ConditionalText(ConditionWrapper&amp;&amp; condition, const QString&amp; text);\n        ~ConditionalText();\n    };\n    std::vector&lt;ConditionalText&gt; m_conditionalTexts;\n};\n\n} // namespace menu\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action_conditions.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action_conditions.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action_conditions.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QSet&gt;\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;common/common_globals.h&gt;\n#include &lt;core/ptz/ptz_constants.h&gt;\n#include &lt;core/ptz/ptz_fwd.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/resource_views/data/resource_tree_globals.h&gt;\n\n#include &quot;action_fwd.h&quot;\n#include &quot;action_parameter_types.h&quot;\n#include &quot;action_types.h&quot;\n\nnamespace nx::vms::client::desktop {\n\nclass WindowContext;\n\nnamespace menu {\n\nenum TimePeriodType\n{\n    NullTimePeriod = 0x1,  /**&lt; No period. */\n    EmptyTimePeriod = 0x2,  /**&lt; Period of zero length. */\n    NormalTimePeriod = 0x4,  /**&lt; Normal period with non-zero length. */\n};\nQ_DECLARE_FLAGS(TimePeriodTypes, TimePeriodType)\nQ_DECLARE_OPERATORS_FOR_FLAGS(TimePeriodTypes)\n\n/**\n * Base class for implementing conditions that must be satisfied for the\n * action to be triggerable via hotkey or visible in the menu.\n */\nclass Condition\n{\npublic:\n    Condition();\n    virtual ~Condition();\n    /**\n     * Main condition checking function.\n     *\n     * By default it forwards control to one of the specialized functions\n     * based on the type of the default parameter. Note that these\n     * specialized functions cannot access other parameters.\n     *\n     * \\param parameters                Parameters to check.\n     * \\returns                         Check result.\n     */\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context);\n\n    /**\n     * Specialized condition function that catches all action parameters that\n     * are convertible to a resource list (&lt;tt&gt;Qn::ResourceType&lt;/tt&gt;).\n     */\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context);\n\n    /**\n     * Specialized condition function that catches all action parameters that\n     * are convertible to a list of layout items (&lt;tt&gt;Qn::LayoutItemType&lt;/tt&gt;).\n     */\n    virtual ActionVisibility check(const LayoutItemIndexList&amp; layoutItems, WindowContext* context);\n\n    /**\n     * Specialized condition function that catches all action parameters that\n     * are convertible to a list of resource widgets. (&lt;tt&gt;Qn::WidgetType&lt;/tt&gt;).\n     */\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context);\n\n    /**\n     * Specialized condition function that catches all action parameters that\n     * are convertible to a list of workbench layouts. (&lt;tt&gt;Qn::LayoutType&lt;/tt&gt;).\n     */\n    virtual ActionVisibility check(const QnWorkbenchLayoutList&amp; layouts, WindowContext* context);\n};\n\nclass ConditionWrapper\n{\npublic:\n    ConditionWrapper();\n    /** Wrapper will take ownership of the condition. */\n    ConditionWrapper(Condition* condition);\n    Condition* operator-&gt;() const;\n    explicit operator bool() const;\nprivate:\n    std::unique_ptr&lt;Condition&gt; m_condition;\n};\n\nConditionWrapper operator&amp;&amp;(ConditionWrapper&amp;&amp; l, ConditionWrapper&amp;&amp; r);\nConditionWrapper operator||(ConditionWrapper&amp;&amp; l, ConditionWrapper&amp;&amp; r);\nConditionWrapper operator!(ConditionWrapper&amp;&amp; l);\n\nclass ResourceCondition: public Condition\n{\npublic:\n    using CheckDelegate = std::function&lt;bool(const QnResourcePtr&amp; resource)&gt;;\n\n    ResourceCondition(CheckDelegate delegate, MatchMode matchMode);\n\n    ActionVisibility check(const QnResourceList&amp; resources,\n        WindowContext* /*context*/);\n\n    ActionVisibility check(const QnResourceWidgetList&amp; widgets,\n        WindowContext* /*context*/);\n\nprivate:\n    CheckDelegate m_delegate;\n    MatchMode m_matchMode;\n};\n\nclass PreventWhenFullscreenTransition: public Condition\n{\npublic:\n    static ConditionWrapper condition();\n\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\n/** Base condition class for actions that should be visible in videowall review mode only. */\nclass VideoWallReviewModeCondition: public Condition\n{\npublic:\n    bool isVideoWallReviewMode(WindowContext* context) const;\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\n/** Condition class for actions, that require Administrator privileges. */\nclass RequiresAdministratorCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\n/**\n * Condition for a single resource widget that checks its zoomed state.\n */\nclass ItemZoomedCondition: public Condition\n{\npublic:\n    ItemZoomedCondition(bool requiredZoomedState);\n    virtual ActionVisibility check(\n        const QnResourceWidgetList&amp; widgets,\n        WindowContext* context) override;\n\nprivate:\n    bool m_requiredZoomedState;\n};\n\nclass SmartSearchCondition: public Condition\n{\npublic:\n    SmartSearchCondition();\n    SmartSearchCondition(bool requiredGridDisplayValue);\n    virtual ActionVisibility check(\n        const QnResourceWidgetList&amp; widgets,\n        WindowContext* context) override;\n\nprivate:\n    bool m_hasRequiredGridDisplayValue;\n    bool m_requiredGridDisplayValue;\n};\n\nclass DisplayInfoCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\nclass ClearMotionSelectionCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\n/**\n * Condition for resource removal.\n */\nclass ResourceRemovalCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\n/**\n * Base class for edge-specific action conditions.\n */\nclass EdgeServerCondition: public Condition\n{\npublic:\n    EdgeServerCondition(bool isEdgeServer);\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n\nprivate:\n    /** If this flag is true action is visible for edge servers only,\n     *  in the other case - action is hidden for edge servers.\n     */\n    bool m_isEdgeServer;\n};\n\n/**\n * Condition for resource rename.\n */\nclass RenameResourceCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\n/**\n * Condition for removal of a layout item.\n */\nclass LayoutItemRemovalCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const LayoutItemIndexList&amp; layoutItems,\n        WindowContext* context) override;\n};\n\n\n/**\n * Condition for saving of a layout.\n */\nclass SaveLayoutCondition: public Condition\n{\npublic:\n    SaveLayoutCondition(bool isCurrent);\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n\nprivate:\n    bool m_current;\n};\n\n/**\n * Condition based on the count of layouts that are currently open.\n */\nclass LayoutCountCondition: public Condition\n{\npublic:\n    LayoutCountCondition(int minimalRequiredCount);\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n\nprivate:\n    int m_minimalRequiredCount;\n};\n\n\n/**\n * Condition for taking screenshot of a resource widget.\n */\nclass TakeScreenshotCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\n\n/**\n * Condition for adjust video dialog of a resource widget.\n */\nclass AdjustVideoCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\n/**\n * Condition that is based on the type of the time period provided as one\n * of the arguments of the parameters pack.\n */\nclass TimePeriodCondition: public Condition\n{\npublic:\n    TimePeriodCondition(\n        TimePeriodTypes periodTypes,\n        ActionVisibility nonMatchingVisibility);\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n\nprivate:\n    TimePeriodTypes m_periodTypes;\n    ActionVisibility m_nonMatchingVisibility;\n};\n\nclass AddBookmarkCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass ModifyBookmarkCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass RemoveBookmarksCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass PreviewCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass StartCurrentShowreelCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass ArchiveCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass TimelineVisibleCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass ToggleTitleBarCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass NoArchiveCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass OpenInFolderCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n    virtual ActionVisibility check(const LayoutItemIndexList&amp; layoutItems, WindowContext* context) override;\n};\n\nclass LayoutSettingsCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass CreateZoomWindowCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\nclass ResourceStatusCondition: public Condition\n{\npublic:\n    ResourceStatusCondition(const QSet&lt;nx::vms::api::ResourceStatus&gt; statuses, bool allResources);\n    ResourceStatusCondition(nx::vms::api::ResourceStatus status, bool allResources);\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n\nprivate:\n    QSet&lt;nx::vms::api::ResourceStatus&gt; m_statuses;\n    bool m_all;\n};\n\nclass NewUserLayoutCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass OpenInLayoutCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n\nprotected:\n    bool canOpen(const QnResourceList&amp; resources, const QnLayoutResourcePtr&amp; layout) const;\n};\n\nclass OpenInCurrentLayoutCondition: public OpenInLayoutCondition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass OpenInNewEntityCondition: public OpenInLayoutCondition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n    virtual ActionVisibility check(const LayoutItemIndexList&amp; layoutItems, WindowContext* context) override;\n};\n\nclass SetAsBackgroundCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n    virtual ActionVisibility check(const LayoutItemIndexList&amp; layoutItems, WindowContext* context) override;\n};\n\nclass ChangeResolutionCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters,\n        WindowContext* context) override;\n};\n\nclass PtzCondition: public Condition\n{\npublic:\n    PtzCondition(Ptz::Capabilities capabilities, bool disableIfPtzDialogVisible);\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n\nprivate:\n    bool checkInternal(const QnPtzControllerPtr&amp; controller);\n\nprivate:\n    Ptz::Capabilities m_capabilities;\n    bool m_disableIfPtzDialogVisible;\n};\n\nclass NonEmptyVideowallCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass SaveVideowallReviewCondition: public Condition\n{\npublic:\n    SaveVideowallReviewCondition(bool isCurrent);\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\nprivate:\n    bool m_current;\n};\n\nclass StartVideowallCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass IdentifyVideoWallCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass DetachFromVideoWallCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass StartVideoWallControlCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass RotateItemCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceWidgetList&amp; widgets, WindowContext* context) override;\n};\n\nclass AutoStartAllowedCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass LightModeCondition: public Condition\n{\npublic:\n    LightModeCondition(Qn::LightModeFlags flags);\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n\nprivate:\n    Qn::LightModeFlags m_lightModeFlags;\n};\n\nclass ItemsCountCondition: public Condition\n{\npublic:\n    enum Count\n    {\n        MultipleItems = -1,\n        NoItems = 0,\n        OneItem = 1\n    };\n\n    ItemsCountCondition(int count);\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n\nprivate:\n    int m_count;\n};\n\nclass IoModuleCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass CloudServerCondition: public Condition\n{\npublic:\n    CloudServerCondition(MatchMode matchMode);\n    virtual ActionVisibility check(const QnResourceList&amp; resources, WindowContext* context) override;\n\nprivate:\n    MatchMode m_matchMode;\n};\n\nclass ReachableServerCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass HideServersInTreeCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass ToggleProxiedResourcesCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const Parameters&amp; parameters,\n        WindowContext* context) override;\n};\n\n/**\n * Calculates visual state of &quot;Replace Camera...&quot; context menu action.\n * @return &lt;tt&gt;Enabled&lt;/tt&gt; if parameters have camera, camera is offline, it&#x27;s not a virtual\n *     camera, it&#x27;s not a multisensor camera, it&#x27;s not the one attached to an NVR, it&#x27;s not an\n *     I/O module and camera&#x27;s parent server is online. &lt;tt&gt;Disabled&lt;/tt&gt; if all the same as above\n *     except camera&#x27;s parent server is offline. &lt;tt&gt;Invisible&lt;/tt&gt; otherwise.\n */\nclass ReplaceCameraCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass ItemMuteActionCondition: public Condition\n{\npublic:\n    ItemMuteActionCondition(bool mute);\n\n    virtual ActionVisibility check(\n        const Parameters&amp; parameters, WindowContext* context) override;\n\nprivate:\n    bool m_mute = false;\n};\n\n\n//-------------------------------------------------------------------------------------------------\n// Declarations of resource grouping related actions conditions.\n//-------------------------------------------------------------------------------------------------\n\nclass CreateNewResourceTreeGroupCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(const Parameters&amp; parameters, WindowContext* context);\n};\n\nclass AssignResourceTreeGroupIdCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass MoveResourceTreeGroupIdCondition: public Condition {\npublic:\n    virtual ActionVisibility check(\n        const QnResourceList&amp; resources, WindowContext* context) override;\n};\n\nclass RenameResourceTreeGroupCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nclass RemoveResourceTreeGroupCondition: public Condition\n{\npublic:\n    virtual ActionVisibility check(\n        const Parameters&amp; parameters, WindowContext* context) override;\n};\n\nnamespace condition {\n\n/** Visible always. */\nConditionWrapper always();\n\n/** Visible when value is true. */\nConditionWrapper isTrue(bool value);\n\n/** Enabled when user is logged in (or at least logging in). defaultVisibility otherwise. */\nConditionWrapper isLoggedIn(ActionVisibility defaultVisibility = InvisibleAction);\n\n/** Enabled if Tier doesn&#x27;t limit videowall access. */\nConditionWrapper hasVideoWallFeature();\n\n/** Visible when user is logged in as Cloud User (or at least logging in). */\nConditionWrapper isLoggedInAsCloudUser();\n\n/** Visible when user is logged in to Cloud. */\nConditionWrapper isLoggedInToCloud();\n\n/** Check a condition only in the given scope */\nConditionWrapper scoped(ActionScope scope, ConditionWrapper&amp;&amp; condition);\n\n/** Check if current layout fits the provided condition. */\nConditionWrapper applyToCurrentLayout(ConditionWrapper&amp;&amp; condition);\n\n/** Check if current user has certain global permission. */\nConditionWrapper hasGlobalPermission(GlobalPermission permission);\n\n/** Visible in preview search mode only. */\nConditionWrapper isPreviewSearchMode();\n\n/** Allowed only for resource parameters with corresponding flags. */\nConditionWrapper hasFlags(Qn::ResourceFlags flags, MatchMode matchMode);\nConditionWrapper hasFlags(Qn::ResourceFlags includeFlags, Qn::ResourceFlags excludeFlags,\n    MatchMode matchMode);\n\n/** Target resources have the video stream. */\nConditionWrapper hasVideo(MatchMode matchMode, bool value = true);\n\nConditionWrapper treeNodeType(QSet&lt;ResourceTree::NodeType&gt; types);\ninline ConditionWrapper treeNodeType(ResourceTree::NodeType type)\n{\n    return treeNodeType(QSet&lt;ResourceTree::NodeType&gt;{type});\n}\n\nConditionWrapper parentTreeNodeType(ResourceTree::NodeType type);\n\n/** Visible in Showreel preview mode only. */\nConditionWrapper isShowreelReviewMode();\n\n/** Check that fisheye cameras can save position only when dewarping is enabled. */\nConditionWrapper canSavePtzPosition();\n\nConditionWrapper hasTimePeriod();\n\nConditionWrapper hasArgument(int key, int targetTypeId = -1);\n\ntemplate&lt;class T&gt;\nConditionWrapper hasArgumentOfType(int key)\n{\n    return hasArgument(key, qMetaTypeId&lt;T&gt;());\n}\n\n/** Check if the resource is Analytics Engine. */\nConditionWrapper isAnalyticsEngine();\n\n/** Playback sync is forced. */\nConditionWrapper syncIsForced();\n\nConditionWrapper canExportLayout();\n\nConditionWrapper canExportBookmark();\nConditionWrapper canExportBookmarks();\n\nConditionWrapper canCopyBookmarkToClipboard();\nConditionWrapper canCopyBookmarksToClipboard();\n\nConditionWrapper isDeviceAccessRelevant(nx::vms::api::AccessRights requiredAccessRights);\n\nConditionWrapper hasRemoteArchiveCapability();\n\n/** Whether virtual camera upload is enabled. */\nConditionWrapper virtualCameraUploadEnabled();\n\n/** Whether virtual camera upload can be cancelled. */\nConditionWrapper canCancelVirtualCameraUpload();\n\nConditionWrapper currentLayoutIsVideowallScreen();\n\nConditionWrapper canForgetPassword();\n\n/** Whether showreel can be created using the given resources. */\nConditionWrapper canMakeShowreel();\n\nConditionWrapper isWorkbenchVisible();\n\nConditionWrapper layoutIsLocked();\n\nConditionWrapper selectedItemsContainLockedLayout();\n\n/** Check if there is a saved Session State for the current system-user pair. */\nConditionWrapper hasSavedWindowsState();\n\n/** Check if there are other opened windows with the same system-user pair. */\nConditionWrapper hasOtherWindowsInSession();\n\n/** Check if there are other opened windows. */\nConditionWrapper hasOtherWindows();\n\n/**\n * Check if current user is allowed to see servers in the resources tree such feature may be\n * restricted for users without power user permissions by the global setting)\n */\nConditionWrapper allowedToShowServersInResourceTree();\n\nConditionWrapper joystickConnected();\n\n/**\n * Checks if the client uses non-prod (test/stage/etc) cloud host.\n * Used for showing warning for the customers.\n */\nConditionWrapper showBetaUpgradeWarning();\n\n/** Checks whether the provided id belongs to a cloud system which requires user interaction. */\nConditionWrapper isCloudSystemConnectionUserInteractionRequired();\n\nConditionWrapper videowallIsRunning();\n\n/** Checks if &quot;Save Layout As...&quot; action is applicable. */\nConditionWrapper canSaveLayoutAs();\n\n/** Checks if the layout is owned by the current user. */\nConditionWrapper isOwnLayout();\n\n/** Checks if the user has cameras with editable settings. */\nConditionWrapper userHasCamerasWithEditableSettings();\n\n/**\n * Checks if all resources have the permissions.\n * If no resources are provided, the check fails.\n */\nConditionWrapper hasPermissionsForResources(Qn::Permissions permissions);\n\n/**\n * Checks whether a resource is Web Page.\n */\nConditionWrapper isWebPage();\n\n/**\n * Checks whether a resource is Integration.\n */\nConditionWrapper isIntegration();\n\n/**\n * Check whether a resource is Web Page or Integration.\n */\nConditionWrapper isWebPageOrIntegration();\n\n/**\n * Check if the Home tab is not active in multi-system mode.\n */\nConditionWrapper homeTabIsNotActive(ActionVisibility defaultVisibility = InvisibleAction);\n\n/**\n * Check if tier limits allow to merge sites.\n */\nConditionWrapper tierLimitsAllowMerge();\n\nConditionWrapper screenRecordingSupported();\n\n/**\n * Check whether custom cell spacing is set.\n */\nConditionWrapper customCellSpacingIsSet();\n\nConditionWrapper hardwareVideoDecodingDisabled();\n\nConditionWrapper parentServerHasActiveBackupStorage();\n\n} // namespace condition\n\n} // namespace menu\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/scene/resource_widget/overlays/rewind_widget.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/scene/resource_widget/overlays/rewind_widget.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/scene/resource_widget/overlays/rewind_widget.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtWidgets/QGraphicsWidget&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;ui/animation/animated.h&gt;\n\nnamespace nx::vms::client::desktop {\n\nclass RewindOverlay;\n\nclass RewindWidget: public Animated&lt;QGraphicsWidget&gt;\n{\n    Q_OBJECT\n    using base_type = Animated&lt;QGraphicsWidget&gt;;\n\n    static constexpr int kStopped = -1;\n\npublic:\n    RewindWidget(QGraphicsItem* parent = nullptr, bool fastForward = true);\n    ~RewindWidget();\n\n    void updateSize(QSizeF size);\n\n    void blink();\n    void tick(int deltaMs);\n\nprivate:\n    virtual void paint(\n        QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget) override;\n\nprivate:\n    QGraphicsWidget* m_triangle1;\n    QGraphicsWidget* m_triangle2;\n    QGraphicsWidget* m_triangle3;\n    QPixmap icon;\n\n    QSizeF m_size;\n    bool m_fastForward;\n\n    class BackgroundWidget;\n    BackgroundWidget* m_background;\n\n    AnimationTimerListenerPtr m_animationTimerListener = AnimationTimerListener::create();\n    int m_totalMs = kStopped;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;optional&gt;\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtGui/QFont&gt;\n\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/singleton.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n\nclass QWidget;\n\nnamespace nx::vms::client::desktop {\n\nclass SceneBanners:\n    public QObject,\n    public Singleton&lt;SceneBanners&gt;\n{\n    Q_OBJECT\n\npublic:\n    SceneBanners(QWidget* parentWidget);\n    virtual ~SceneBanners() override;\n\n    nx::Uuid add(const QString&amp; text,\n        std::optional&lt;std::chrono::milliseconds&gt; timeout = {},\n        std::optional&lt;QFont&gt; font = {});\n\n    bool remove(const nx::Uuid&amp; id, bool immediately = false);\n\n    bool changeText(const nx::Uuid&amp; id, const QString&amp; newText);\n\nsignals:\n    void removed(const nx::Uuid&amp; id);\n\nprivate:\n    class Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\nclass SceneBanner: public QObject\n{\n    Q_OBJECT\n\npublic:\n    static SceneBanner* show(const QString&amp; text,\n        std::optional&lt;std::chrono::milliseconds&gt; timeout = {},\n        std::optional&lt;QFont&gt; font = {});\n\n    virtual ~SceneBanner() override;\n\n    bool hide(bool immediately = false);\n\n    bool changeText(const QString&amp; value);\n\nprotected:\n    explicit SceneBanner(const nx::Uuid&amp; id, QObject* parent = nullptr);\n\nprivate:\n    nx::Uuid m_id;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/workbench/workbench.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/workbench/workbench.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/workbench/workbench.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/vms/client/core/system_finder/system_description_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n#include &lt;nx/vms/client/desktop/workbench/state/workbench_state.h&gt;\n\nQ_MOC_INCLUDE(&quot;nx/vms/client/desktop/window_context.h&quot;)\nQ_MOC_INCLUDE(&quot;ui/workbench/workbench_layout.h&quot;)\n\nclass QnWorkbenchLayout;\nclass QnWorkbenchGridMapper;\nclass QnWorkbenchItem;\nclass QQuickItem;\n\nnamespace nx::vms::client::desktop {\n\nstruct LogonData;\n\n/**\n * Workbench ties layout, items and current UI-related &quot;state&quot; together.\n *\n * It abstracts away the fact that layout can be changed &quot;on the fly&quot; by\n * providing copies of layout signals that remove the necessity to\n * watch for layout changes.\n *\n * It also ensures that current layout is never nullptr by replacing nullptr layout\n * supplied by the user with internally stored empty layout.\n *\n * Workbench state consists of:\n * &lt;ul&gt;\n * &lt;li&gt;A list of layouts that are currently loaded.&lt;/li&gt;\n * &lt;li&gt;Current layout that defines how items are placed.&lt;/li&gt;\n * &lt;li&gt;A grid mapper that maps integer layout coordinates into floating-point\n *     surface coordinates.&lt;/li&gt;\n * &lt;li&gt;Currently raised item - an item that is enlarged and is shown on top of other items.&lt;/li&gt;\n * &lt;li&gt;Currently zoomed item - an item that is shown in full screen.&lt;/li&gt;\n * &lt;/ul&gt;\n */\nclass Workbench: public QObject, public WindowContextAware\n{\n    Q_OBJECT\n    Q_PROPERTY(QnWorkbenchLayout* currentLayout\n        READ currentLayout\n        WRITE setCurrentLayout\n        NOTIFY currentLayoutChanged)\n    Q_PROPERTY(nx::vms::client::desktop::WindowContext* context READ windowContext CONSTANT)\n\npublic:\n    Workbench(WindowContext* windowContext, QObject* parent = nullptr);\n    virtual ~Workbench() override;\n\n    /**\n     * Size of a single unit of workbench grid, in scene coordinates. This basically is the width\n     * of a single video item in scene coordinates.\n     * Graphics scene has problems with handling mouse events on small scales, so the larger this\n     * number, the better.\n     */\n    static constexpr qreal kUnitSize = 10000.0;\n\n    /**\n     * Clears this workbench by setting all of its properties to their initial\n     * values.\n     * Note that this function does not reset parameters of the grid mapper.\n     */\n    void clear();\n\n    /**\n     * Note that this function never returns nullptr.\n     * @return Layout of this workbench.\n     */\n    QnWorkbenchLayout* currentLayout() const;\n\n    /**\n     * Resource for the current layout.\n     * Note that this function never returns nullptr.\n     */\n    core::LayoutResourcePtr currentLayoutResource() const;\n\n    /**\n     * @return Index of the current layout. May return -1 if dummy layout is currently in use.\n     */\n    int currentLayoutIndex() const { return layoutIndex(currentLayout()); }\n\n    /**\n     * @param index Index of the layout to get.\n     * @return Layout for the given index.\n     */\n    QnWorkbenchLayout* layout(int index) const;\n\n    /** Find existing layout, corresponding to the provided resource. */\n    QnWorkbenchLayout* layout(const core::LayoutResourcePtr&amp; resource);\n\n    /**\n     * @return All layouts of this workbench. May be empty.\n     */\n    const std::vector&lt;std::unique_ptr&lt;QnWorkbenchLayout&gt;&gt;&amp; layouts() const;\n\n    /**\n     * Create a new layout in this workbench.\n     */\n    QnWorkbenchLayout* addLayout(const core::LayoutResourcePtr&amp; resource);\n\n    /**\n     * Create a new layout in this workbench and insert it to the given position.\n     */\n    QnWorkbenchLayout* insertLayout(const core::LayoutResourcePtr&amp; resource, int index);\n\n    /**\n     * If provided layout based on &#x27;replaceableLayout&#x27; is opened on the workbench, it is replaced\n     * with the new WorkbenchLayout, based on the `newLayout` resource.\n     * @return Newly created layout if any, nullptr otherwise.\n     */\n    QnWorkbenchLayout* replaceLayout(\n        const core::LayoutResourcePtr&amp; replaceableLayout,\n        const core::LayoutResourcePtr&amp; newLayout);\n\n    /**\n     * Remove this resource&#x27;s layout if it exists.\n     */\n    void removeLayout(const core::LayoutResourcePtr&amp; resource);\n\n    /**\n     * Remove these resources&#x27; layouts if exists.\n     */\n    void removeLayouts(const core::LayoutResourceList&amp; resources);\n\n    /**\n     * @param index Index of the layout to remove from the list of this workbench&#x27;s layouts.\n     */\n    void removeLayout(int index);\n\n    /**\n     * @param layout Layout to move to a new position in the list of this workbench&#x27;s layouts.\n     * @param index New position for the given layout.\n     */\n    void moveLayout(QnWorkbenchLayout* layout, int index);\n\n    /**\n     * @param layout Layout to find in the list of this workbench&#x27;s layouts.\n     * @return Index of the given layout in the list of this workbench&#x27;s layouts, or -1 if it is\n     *     not there.\n     */\n    int layoutIndex(QnWorkbenchLayout* layout) const;\n\n    /**\n     * Note that workbench does not take ownership of the supplied layout.\n     * If supplied layout is not in this workbench&#x27;s layout list,\n     * it will be added to it.\n     * @param layout New layout for this workbench. If nullptr is specified, a new empty layout\n     *     will be created.\n     */\n    void setCurrentLayout(QnWorkbenchLayout* layout);\n\n    /**\n     * Sets the index of the current layout. Note that index does not need to be valid as it will\n     * be bounded to the closest valid value.\n     * @param index New current layout index.\n     */\n    void setCurrentLayoutIndex(int index);\n\n    /**\n     * @return Grid mapper for this workbench.\n     */\n    QnWorkbenchGridMapper* mapper() const;\n\n    /**\n     * @param role Role to get item for.\n     * @return Item for the given item role.\n     */\n    QnWorkbenchItem* item(Qn::ItemRole role);\n\n    /**\n     * @param role Role to set an item for.\n     * @param item New item for the given role.\n     */\n    void setItem(Qn::ItemRole role, QnWorkbenchItem* item);\n\n    void update(const WorkbenchState&amp; state);\n    void submit(WorkbenchState&amp; state);\n    void applyLoadedState();\n    bool isInLayoutChangeProcess() const;\n\n    /**\n     * Whether workbench is in intended clear process. Flag is used to avoid unnecessary new tab\n     * creation on resources deletion.\n     */\n    bool inClearProcess() const;\n\nsignals:\n    /**\n     * This signal is emitted whenever the layout of this workbench is about to be changed.\n     */\n    void currentLayoutAboutToBeChanged();\n\n    /**\n     * This signal is emitted whenever the layout of this workbench changes.\n     *\n     * In most cases there is no need to listen to this signal as\n     * workbench emits &lt;tt&gt;itemRemoved&lt;/tt&gt; signal for each of the\n     * old layout items and &lt;tt&gt;itemAdded&lt;/tt&gt; for each of the new\n     * layout items when layout is changed.\n     */\n    void currentLayoutChanged();\n\n    /**\n     * Emitted when an item is added to the current layout.\n     */\n    void currentLayoutItemAdded(QnWorkbenchItem* item);\n\n    /**\n     * Emitted when an item is removed from the current layout.\n     */\n    void currentLayoutItemRemoved(QnWorkbenchItem* item);\n\n    /**\n     * Emitted when an item is added to or removed from the current layout.\n     */\n    void currentLayoutItemsChanged();\n\n    void layoutsChanged();\n\n    /**\n     * This signal is emitted whenever a new item is about to be assigned to the role.\n     *\n     * @param role Item role.\n     */\n    void itemAboutToBeChanged(Qn::ItemRole role);\n\n    /**\n     * This signal is emitted whenever a new item is assigned to the role.\n     *\n     * @param role Item role.\n     */\n    void itemChanged(Qn::ItemRole role);\n\n    /**\n     * This signal is emitted whenever current cell aspect ratio changes.\n     */\n    void cellAspectRatioChanged();\n\n    /**\n     * This signal is emitted whenever current cell spacing changes.\n     */\n    void cellSpacingChanged();\n\nprivate slots:\n    void at_layout_itemAdded(QnWorkbenchItem* item);\n    void at_layout_itemRemoved(QnWorkbenchItem* item);\n    void at_layout_cellAspectRatioChanged();\n    void at_layout_cellSpacingChanged();\n\n    void updateSingleRoleItem();\n    void updateActiveRoleItem(const QnWorkbenchItem* removedItem = nullptr);\n    void updateCentralRoleItem();\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/abstract_animator.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/abstract_animator.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/abstract_animator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &quot;animation_timer_listener.h&quot;\n\nclass AnimatorGroup;\n\n/**\n * Base class for animators.\n */\nclass AbstractAnimator: public QObject\n{\n    Q_OBJECT\npublic:\n    /**\n     * Constructor.\n     *\n     * \\param parent                    Parent object.\n     */\n    AbstractAnimator(QObject* parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~AbstractAnimator() override;\n\n    /**\n     * Animator state.\n     */\n    enum State {\n        Stopped = 0, /**&lt; Animator is stopped. */\n        Paused  = 1, /**&lt; Animator is paused. */\n        Running = 2  /**&lt; Animator is running. */\n    };\n\n    /**\n     * \\returns                         Time limit for a single animation, in milliseconds.\n     *                                  -1 if there is no time limit.\n     */\n    int timeLimit() const {\n        return m_timeLimitMSec;\n    }\n\n    /**\n     * \\param timeLimitMSec             New time limit for a single animation, in milliseconds.\n     *                                  Pass -1 to remove time limit.\n     */\n    void setTimeLimit(int timeLimitMSec);\n\n    /**\n     * \\returns                         Current state of this animator.\n     */\n    State state() const {\n        return m_state;\n    }\n\n    /**\n     * \\param newState                  New state for this animator.\n     */\n    void setState(State newState);\n\n    /**\n     * \\returns                         Whether this animator is running.\n     */\n    bool isRunning() const {\n        return state() == Running;\n    }\n\n    /**\n     * \\returns                         Whether this animator is paused.\n     */\n    bool isPaused() const {\n        return state() == Paused;\n    }\n\n    /**\n     * \\returns                         Whether this animator is stopped.\n     */\n    bool isStopped() const {\n        return state() == Stopped;\n    }\n\n    /**\n     * \\returns                         Duration of the current animation.\n     */\n    int duration() const;\n\n    /**\n     * \\returns                         Time that has passed since the start of the\n     *                                  current animation.\n     */\n    int currentTime() const {\n        return m_currentTime;\n    }\n\n    /**\n     * \\returns                         Group that this animator belongs to.\n     */\n    AnimatorGroup *group() {\n        return m_group;\n    }\n\n    /**\n     * \\param durationOverride          Duration that is to be used for this animation.\n     *                                  Pass -1 to disable duration overriding.\n     */\n    void setDurationOverride(int durationOverride);\n\n    AnimationTimerListenerPtr animationTimerListener() const { return m_animationTimerListener; }\n    void setTimer(AnimationTimer* timer) { m_animationTimerListener-&gt;setTimer(timer); }\n\npublic slots:\n    /**\n     * Starts this animator.\n     */\n    void start();\n\n    /**\n     * Pauses this animator.\n     */\n    void pause();\n\n    /**\n     * Stops this animator.\n     */\n    void stop();\n\nsignals:\n    /**\n     * This signal is emitted whenever this animator is started.\n     */\n    void started();\n\n    /**\n     * This signals is emitted whenever this animator is stopped.\n     */\n    void finished();\n\n    /**\n     * This signals is emitted whenever animation tick occurs.\n     */\n    void animationTick(int time);\n\nprotected:\n    /**\n     * This function updates the state of this animator.\n     *\n     * Note that this function will always be called for transitions to\n     * &quot;neighboring&quot; states. That is, in case of a Stopped to Running transition,\n     * it will be called twice - first with Paused and then with Running as\n     * a parameter.\n     *\n     * It can be overridden in derived class in case special processing is needed.\n     * If derived implementation doesn&#x27;t call the base one, then the transition\n     * won&#x27;t take place.\n     */\n    virtual void updateState(State newState);\n\n    /**\n     * This functions performs the actual animation. It is to be overridden in\n     * derived class.\n     *\n     * \\param currentTime               New current time, in milliseconds.\n     */\n    virtual void updateCurrentTime(int currentTime) = 0;\n\n    /**\n     * This function is to be overridden in derived class. It should return the\n     * duration that best suits the derived animation. Actual duration may differ\n     * because of time limit and duration overrides.\n     *\n     * \\returns                         Estimated duration of the animation, based\n     *                                  on parameters specific to the derived class.\n     */\n    virtual int estimatedDuration() const = 0;\n\n\n\n    void setCurrentTime(int currentTime);\n\n    /**\n     * Marks stored duration as invalid. It will be recalculated on request.\n     */\n    void invalidateDuration();\n\nprivate:\n    void tick(int deltaTime);\n\n    void ensureDuration() const;\n\nprivate:\n    friend class AnimatorGroup;\n\n    /* &#x27;Stable&#x27; state. */\n\n    AnimatorGroup* m_group = nullptr;\n    State m_state = Stopped;\n    int m_timeLimitMSec = -1;\n    int m_durationOverride = -1;\n\n    /* &#x27;Working&#x27; state. */\n\n    mutable bool m_durationValid = false;\n    mutable int m_duration = -1;\n    int m_currentTime = 0;\n\n    AnimationTimerListenerPtr m_animationTimerListener = AnimationTimerListener::create();\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/animator_group.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/animator_group.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/animator_group.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_ANIMATOR_GROUP_H\n#define QN_ANIMATOR_GROUP_H\n\n#include &quot;abstract_animator.h&quot;\n\nclass AnimatorGroup: public AbstractAnimator {\n    Q_OBJECT;\n\n    typedef AbstractAnimator base_type;\n\npublic:\n    AnimatorGroup(QObject *parent = nullptr);\n\n    virtual ~AnimatorGroup();\n\n    void addAnimator(AbstractAnimator *animator);\n\n    AbstractAnimator *animatorAt(int index) const;\n\n    int animatorCount() const;\n\n    void clear();\n\n    int indexOfAnimator(AbstractAnimator *animator) const;\n\n    void insertAnimator(int index, AbstractAnimator *animator);\n\n    void removeAnimator(AbstractAnimator *animator);\n\n    AbstractAnimator *takeAnimator(int index);\n\n    QList&lt;AbstractAnimator*&gt; animators() const;\nprotected:\n    virtual bool event(QEvent *event) override;\n\n    virtual void updateState(State newState) override;\n\n    virtual void updateCurrentTime(int currentTime) override;\n\n    virtual int estimatedDuration() const override;\n\nprivate:\n    QList&lt;AbstractAnimator *&gt; m_animators;\n};\n\n#endif // QN_ANIMATOR_GROUP_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/rect_animator.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/rect_animator.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/rect_animator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_RECT_ANIMATOR_H\n#define QN_RECT_ANIMATOR_H\n\n#include &quot;variant_animator.h&quot;\n\n/**\n * When animating &lt;tt&gt;QRectF&lt;/tt&gt; properties, single speed value has little\n * sense. This class introduces new speed values that can be\n * adjusted to change transition times.\n */\nclass RectAnimator: public VariantAnimator {\n    Q_OBJECT;\n\n    typedef VariantAnimator base_type;\n\npublic:\n    RectAnimator(QObject *parent = nullptr);\n\n    virtual ~RectAnimator();\n\n    /**\n     * \\returns                         Scaling speed, scaling factor per second.\n     */\n    qreal scalingSpeed() const;\n\n    /**\n     * \\returns                         Relative part of the movement speed,\n     *                                  in rects per second.\n     */\n    qreal relativeMovementSpeed() const {\n        return m_relativeMovementSpeed;\n    }\n\n    /**\n     * \\returns                         Absolute part of the movement speed,\n     *                                  in rectangle&#x27;s space coordinates per second.\n     */\n    qreal absoluteMovementSpeed() const {\n        return m_absoluteMovementSpeed;\n    }\n\n    /**\n     * \\param scalingSpeed              New scaling speed, scaling factor per second.\n     */\n    void setScalingSpeed(qreal scalingSpeed);\n\n    /**\n     * \\param relativeMovementSpeed     New relative part of the movement speed,\n     *                                  in rects per second.\n     */\n    void setRelativeMovementSpeed(qreal relativeMovementSpeed);\n\n    /**\n     * \\param absoluteMovementSpeed     New absolute part of the movement speed,\n     *                                  in rectangle&#x27;s space coordinates per second.\n     */\n    void setAbsoluteMovementSpeed(qreal absoluteMovementSpeed);\n\nprotected:\n    virtual void updateInternalType(QMetaType newType) override;\n\n    virtual int estimatedDuration(const QVariant &amp;from, const QVariant &amp;to) const override;\n\nprivate:\n    qreal m_logScalingSpeed;\n    qreal m_relativeMovementSpeed;\n    qreal m_absoluteMovementSpeed;\n};\n\n#endif // QN_RECT_ANIMATOR_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/variant_animator.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/variant_animator.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/variant_animator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_ANIMATOR_H\n#define QN_ANIMATOR_H\n\n#include &lt;QtCore/QEasingCurve&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QScopedPointer&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;nx/vms/client/desktop/common/utils/accessor.h&gt;\n#include &lt;ui/common/converter.h&gt;\n\n#include &quot;abstract_animator.h&quot;\n\nclass MagnitudeCalculator;\nclass LinearCombinator;\nclass AbstractConverter;\nnamespace nx::vms::client::desktop { class AbstractAccessor; }\n\n/**\n * Animator that animates QObject&#x27;s parameters. Parameters do not need to\n * be Qt properties, as they can be set and read using specialized accessor.\n */\nclass VariantAnimator: public AbstractAnimator {\n    Q_OBJECT\n\n    typedef AbstractAnimator base_type;\n\npublic:\n    /**\n     * Constructor.\n     *\n     * \\param parent                    Parent object.\n     */\n    VariantAnimator(QObject *parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~VariantAnimator();\n\n    /**\n     * \\returns                         Speed of this animator, in the units of a type used for intermediate computations.\n     */\n    qreal speed() const {\n        return m_speed;\n    }\n\n    /**\n     * Note that animation&#x27;s speed is measured in units of type used for\n     * intermediate computations, which may differ from the type of the parameter\n     * being animated if converter is set.\n     *\n     * \\param speed                     New speed of this animator, in the units of a type used for intermediate computations.\n     */\n    void setSpeed(qreal speed);\n\n    /**\n     * \\returns                         Accessor used by this animator, of nullptr if none.\n     */\n    nx::vms::client::desktop::AbstractAccessor *accessor() const { return m_accessor.data(); }\n\n    /**\n     * \\param accessor                  Accessor to use. Animator will take ownership of the given accessor.\n     */\n    void setAccessor(nx::vms::client::desktop::AbstractAccessor *accessor);\n\n    /**\n     * \\returns                         Converter used by this animator, or nullptr if none.\n     */\n    AbstractConverter *converter() const {\n        return m_converter.data();\n    }\n\n    /**\n     * Sets the converter for this animator.\n     *\n     * All internal computations will be performed in converter&#x27;s target type.\n     * Values of converter&#x27;s source type will be fed to the setter and accepted\n     * from the outside world.\n     *\n     * This may be useful when animating integer or bounded types.\n     * The drawback is that speed must be specified in terms of type used for\n     * internal computations (converter&#x27;s target type).\n     *\n     * \\param converter                 Converter to use.\n     */\n    void setConverter(AbstractConverter *converter);\n\n    /**\n     * \\returns                         Easing curve used by this animator.\n     */\n    const QEasingCurve &amp;easingCurve() const {\n        return m_easingCurve;\n    }\n\n    /**\n     * \\param easingCurve               New easing curve to use.\n     */\n    void setEasingCurve(const QEasingCurve &amp;easingCurve);\n\n    /**\n     * \\returns                         Object being animated, or nullptr if none.\n     */\n    QObject *targetObject() const {\n        return m_target;\n    }\n\n    /**\n     * \\param target                    New object to animate.\n     */\n    void setTargetObject(QObject *target);\n\n    /**\n     * \\returns                         Target value of the current animation.\n     */\n    QVariant targetValue() const;\n\n    /**\n     * \\returns                         Starting value of the current animation.\n     */\n    QVariant startValue() const;\n\n    /**\n     * \\param targetValue               New target value to animate to.\n     */\n    void setTargetValue(const QVariant &amp;targetValue);\n\n    /**\n     * Convenience function that sets animator&#x27;s target value and starts it if\n     * it is not running.\n     *\n     * \\param value                     Target value.\n     */\n    void animateTo(const QVariant &amp;value) {\n        setTargetValue(value);\n        start();\n    }\n\nsignals:\n    // TODO: #sivanov This one should not exist.\n    /**\n     * This signals is emitted whenever animated value changed.\n     */\n    void valueChanged(const QVariant &amp;value);\n\nprotected:\n    MagnitudeCalculator *magnitudeCalculator() const {\n        return m_magnitudeCalculator;\n    }\n\n    LinearCombinator *linearCombinator() const {\n        return m_linearCombinator;\n    }\n\n    QMetaType internalType() const;\n\n    QMetaType externalType() const;\n\n    QVariant toInternal(const QVariant &amp;external) const;\n\n    QVariant toExternal(const QVariant &amp;internal) const;\n\n    QVariant internalTargetValue() const;\n\n    QVariant internalStartValue() const;\n\n    virtual int estimatedDuration() const override;\n\n    virtual void updateCurrentTime(int currentTime) override;\n\n    virtual int estimatedDuration(const QVariant &amp;from, const QVariant &amp;to) const;\n\n    virtual QVariant currentValue() const;\n\n    virtual void updateCurrentValue(const QVariant &amp;value);\n\n    virtual void updateTargetValue(const QVariant &amp;newTargetValue);\n\n    virtual void updateInternalType(QMetaType newType);\n\n    virtual void updateState(State newState) override;\n\n    virtual QVariant interpolated(const QVariant &amp;from, const QVariant &amp;to, qreal progress) const;\n\nprivate slots:\n    void at_target_destroyed();\n\nprivate:\n    void setTargetObjectInternal(QObject *target);\n\n    void setInternalTypeInternal(QMetaType newInternalType);\n\n    qreal easingCurveProgress(int currentTime) const;\n\n    qreal easingCurveValue(qreal progress) const;\n\nprivate:\n    QScopedPointer&lt;nx::vms::client::desktop::AbstractAccessor&gt; m_accessor;\n    QScopedPointer&lt;AbstractConverter&gt; m_converter;\n    QEasingCurve m_easingCurve;\n    qreal m_easingCurveCorrection;\n    QMetaType m_internalType;\n    QVariant m_internalStartValue;\n    QVariant m_internalTargetValue;\n    QObject *m_target;\n    qreal m_speed;\n    MagnitudeCalculator *m_magnitudeCalculator;\n    LinearCombinator *m_linearCombinator;\n};\n\n#endif // QN_ANIMATOR_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/viewport_animator.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/viewport_animator.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/viewport_animator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QMargins&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QRect&gt;\n\n#include &lt;client/client_globals.h&gt;\n\n#include &quot;rect_animator.h&quot;\n#include &quot;viewport_geometry_accessor.h&quot;\n\nclass QGraphicsView;\nclass QMargins;\n\nclass ViewportAnimator: public RectAnimator {\n    Q_OBJECT\n\n    typedef RectAnimator base_type;\n\npublic:\n    /**\n     * Constructor.\n     *\n     * \\param view                      View that this viewport animator will be assigned to.\n     * \\param parent                    Parent object.\n     */\n    ViewportAnimator(QObject* parent = nullptr);\n\n    virtual ~ViewportAnimator() override;\n\n    /**\n     * \\returns                         View that this viewport animator is assigned to.\n     */\n    QGraphicsView *view() const;\n\n    void setView(QGraphicsView *view);\n\n    QMargins viewportMargins(Qn::MarginTypes marginTypes = Qn::CombinedMargins) const;\n\n    void setViewportMargins(const QMargins&amp; margins, Qn::MarginType marginType);\n\n    Qn::MarginFlags marginFlags() const;\n\n    void setMarginFlags(Qn::MarginFlags marginFlags);\n\n    /**\n     * \\param rect                      Target viewport rectangle.\n     */\n    void setTargetRect(const QRectF &amp;rect);\n\n    QRectF targetRect() const;\n\n    /**\n     * Starts animated move of a viewport to the given rect, taking margins and margin flags into account.\n     * When animation finishes, viewport&#x27;s bounding rect will include the given rect.\n     *\n     * Note that this function animates position and scale only. It does not\n     * take rotation and more complex transformations into account.\n     *\n     * \\param rect                      Rectangle to move adjusted viewport to,\n     *                                  in scene coordinates.\n     * \\param animate                   Whether transition should be animated.\n     */\n    void moveTo(const QRectF &amp;rect, bool animate);\n\n    QRectF adjustedToReal(const QRectF &amp;adjustedRect) const;\n\nprotected:\n    virtual int estimatedDuration(const QVariant &amp;from, const QVariant &amp;to) const override;\n\n    virtual void updateTargetValue(const QVariant &amp;newTargetValue) override;\n\n    QRectF realToAdjusted(const QGraphicsView *view, const QRectF &amp;realRect) const;\n    QRectF adjustedToReal(const QGraphicsView *view, const QRectF &amp;adjustedRect) const;\n\nprivate:\n    /** Accessor for viewport rect. */\n    ViewportGeometryAccessor *m_accessor;\n\n    QMargins m_panelMargins;\n    QMargins m_layoutMargins;\n\n    Qn::MarginFlags m_marginFlags;\n\n    QRectF m_adjustedTargetRect;\n    bool m_adjustedTargetRectValid;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_geometrically.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_geometrically.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_geometrically.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_CONSTRAINED_GEOMETRICALLY_H\n#define QN_CONSTRAINED_GEOMETRICALLY_H\n\n#include &lt;QtCore/QRectF&gt;\n\n#include &lt;common/common_globals.h&gt;\n\n/**\n * This class is a workaround for a lack of mechanism that would allow to constrain\n * the widget&#x27;s geometry when dragging and/or resizing.\n */\nclass ConstrainedGeometrically {\npublic:\n    virtual ~ConstrainedGeometrically() {}\n\n    /**\n     * \\param geometry                  Desired new geometry.\n     * \\param pinSection                Section that is currently pinned, if any.\n     * \\param pinPoint                  If there is no pinned section,\n     *                                  then parent coordinates of the pinned point are passed here.\n     * \\returns                         New geometry for the widget that satisfies the constraints.\n     */\n    virtual QRectF constrainedGeometry(const QRectF &amp;geometry, Qt::WindowFrameSection pinSection, const QPointF &amp;pinPoint = QPointF()) const = 0;\n};\n\n\n#endif // QN_CONSTRAINED_GEOMETRICALLY_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_resizable.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_resizable.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_resizable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_CONSTRAINED_RESIZABLE\n#define QN_CONSTRAINED_RESIZABLE\n\n#include &lt;nx/utils/math/fuzzy.h&gt;\n\n#include &quot;constrained_geometrically.h&quot;\n#include &quot;frame_section.h&quot;\n\n/**\n * This class is a workaround for a lack of mechanisms that would allow to\n * create widgets with constant aspect ratio.\n *\n * Default sizeHint / sizePolicy system cannot help here because when passing\n * constraint to effectiveSizeHint function, either width or height must not be set.\n * If both are set, then you get your constraint back and the control never\n * reaches the virtual sizeHint function.\n *\n * That is, there is no simple way to implement constant aspect ratio\n * resizing using Qt-supplied functionality. So we introduce a separate\n * interface for that.\n */\nclass ConstrainedResizable: public ConstrainedGeometrically {\npublic:\n    /**\n     * Virtual destructor.\n     */\n    virtual ~ConstrainedResizable();\n\n    /**\n     * This function is to be called just before the derived class&#x27;s geometry\n     * is to be changed.\n     *\n     * Given a size constraint, it returns a preferred size that satisfies it.\n     * The result of this function must not exceed \\a constraint, but it need\n     * not be equal to it.\n     *\n     * Note that it is user&#x27;s responsibility to make sure that minimal size hint\n     * satisfies the constraint.\n     *\n     * \\param constraint                Constraint for the result. Must be a valid size.\n     * \\returns                         Preferred size for the given constraint.\n     */\n    virtual QSizeF constrainedSize(const QSizeF constraint, Qt::WindowFrameSection pinSection) const = 0;\n\n    static QRectF constrainedGeometry(const QRectF &amp;geometry, Qt::WindowFrameSection pinSection, const QPointF &amp;pinPoint, const QSizeF &amp;constrainedSize);\n\nprotected:\n    virtual QRectF constrainedGeometry(const QRectF &amp;geometry, Qt::WindowFrameSection pinSection, const QPointF &amp;pinPoint = QPointF()) const override {\n        return constrainedGeometry(geometry, pinSection, pinPoint, constrainedSize(geometry.size(), pinSection));\n    }\n};\n\n\n#endif // QN_CONSTRAINED_RESIZABLE\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/converter.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/converter.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/converter.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_CONVERTER_H\n#define QN_CONVERTER_H\n\n#include &lt;typeinfo&gt;\n\n#include &lt;nx/utils/log/log.h&gt;\n\nclass QVariant;\n\ntemplate&lt;class Target, class Source&gt;\nvoid convert(const Source&amp; /*source*/, Target* /*target*/) {\n    NX_ASSERT(false,\n        &quot;convert function is not implemented for source type &#x27;%1&#x27; and target type &#x27;%2&#x27;.&quot;,\n        typeid(Source).name(),\n        typeid(Target).name());\n}\n\ntemplate&lt;class Target, class Source&gt;\nTarget convert(const Source &amp;source) {\n    using ::convert;\n\n    Target result;\n    convert(source, &amp;result);\n    return result;\n}\n\n\n/**\n * Abstract converter class.\n */\nclass AbstractConverter {\npublic:\n    AbstractConverter(QMetaType sourceType, QMetaType targetType):\n        m_sourceType(sourceType),\n        m_targetType(targetType)\n    {}\n\n    QMetaType sourceType() const { return m_sourceType; }\n\n    QMetaType targetType() const { return m_targetType; }\n\n    QVariant convertSourceToTarget(const QVariant &amp;source) const;\n\n    QVariant convertTargetToSource(const QVariant &amp;target) const;\n\n    virtual ~AbstractConverter() {}\n\nprotected:\n    virtual QVariant doConvertSourceToTarget(const QVariant &amp;source) const = 0;\n\n    virtual QVariant doConvertTargetToSource(const QVariant &amp;target) const = 0;\n\nprivate:\n    QMetaType m_sourceType;\n    QMetaType m_targetType;\n};\n\n#endif // QN_CONVERTER_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/frame_section_queryable.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/frame_section_queryable.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/frame_section_queryable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_FRAME_SECTION_QUERYABLE_H\n#define QN_FRAME_SECTION_QUERYABLE_H\n\n#include &lt;QtCore/QRectF&gt;\n#include &lt;QtGui/QCursor&gt;\n\n#include &quot;frame_section.h&quot;\n\n/**\n * This class is a workaround for pixel-hunting problems when resizing zoomed-out\n * graphics widgets.\n *\n * Default frame section detection algorithm works on point level, so when zoomed\n * out it becomes really difficult (and sometimes even impossible) to hit the\n * resizing grip area with a mouse.\n *\n * This problem is solved by introducing a separate function that returns a set\n * of all window frame sections that intersect the given rectangle.\n */\nclass FrameSectionQueryable {\npublic:\n    /**\n     * Virtual destructor.\n     */\n    virtual ~FrameSectionQueryable() {}\n\n    /**\n     * \\param region                    Region to get frame sections for, in widget coordinates.\n     * \\returns                         Window frame sections that intersect the given region.\n     */\n    virtual Qn::WindowFrameSections windowFrameSectionsAt(const QRectF &amp;region) const = 0;\n\n    /**\n     * \\param section                   Frame section to get cursor for.\n     * \\returns                         Cursor to use for the given section.\n     */\n    virtual QCursor windowCursorAt(Qn::WindowFrameSection section) const {\n        return Qn::calculateHoverCursorShape(section);\n    }\n\n    /**\n     * This function calculates frame section with the highest priority that\n     * intersects the given region. Section are prioritized in &quot;natural&quot; order,\n     * e.g. corner sections are prioritized over side ones.\n     *\n     * \\param region                    Region to get prioritized section for.\n     * \\returns                         Window frame section with highest priority that intersects the given region.\n     */\n    Qt::WindowFrameSection windowFrameSectionAt(const QRectF &amp;region) const {\n        return toNaturalQtFrameSection(windowFrameSectionsAt(region));\n    }\n\n    /**\n     * Helper overload for Qt frame sections.\n     *\n     * \\param section                   Frame section to get cursor for.\n     * \\returns                         Cursor to use for the given section.\n     */\n    QCursor windowCursorAt(Qt::WindowFrameSection section) const {\n        return windowCursorAt(Qn::toQnFrameSection(section));\n    }\n\n};\n\n#endif // QN_FRAME_SECTION_QUERYABLE_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/help_topic_queryable.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/help_topic_queryable.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/help_topic_queryable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_HELP_TOPIC_QUERYABLE_H\n#define QN_HELP_TOPIC_QUERYABLE_H\n\n#include &lt;QtCore/QPointF&gt;\n\nclass HelpTopicQueryable {\npublic:\n    virtual ~HelpTopicQueryable() {}\n\n    virtual int helpTopicAt(const QPointF &amp;pos) const = 0;\n};\n\n#endif // QN_HELP_TOPIC_QUERYABLE_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/weak_graphics_item_pointer.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/weak_graphics_item_pointer.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/weak_graphics_item_pointer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_WEAK_GRAPHICS_ITEM_POINTER_H\n#define QN_WEAK_GRAPHICS_ITEM_POINTER_H\n\n#include &lt;QtCore/QList&gt;\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtCore/QVector&gt;\n#include &lt;QtCore/QWeakPointer&gt;\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nclass QGraphicsItem;\n\n/**\n * This class presents functionality similar to that of a &lt;tt&gt;QWeakPointer&lt;/tt&gt;,\n * but also works for non-&lt;tt&gt;QObject&lt;/tt&gt; derived &lt;tt&gt;QGraphicsItem&lt;/tt&gt;s.\n */\nclass WeakGraphicsItemPointer\n{\npublic:\n    WeakGraphicsItemPointer();\n\n    WeakGraphicsItemPointer(const WeakGraphicsItemPointer&amp; other);\n\n    WeakGraphicsItemPointer(QGraphicsItem* item);\n\n    ~WeakGraphicsItemPointer();\n\n    WeakGraphicsItemPointer&amp; operator=(const WeakGraphicsItemPointer&amp; other)\n    {\n        this-&gt;~WeakGraphicsItemPointer();\n        new (this) WeakGraphicsItemPointer(other);\n        return *this;\n    }\n\n    WeakGraphicsItemPointer&amp; operator=(QGraphicsItem* item)\n    {\n        this-&gt;~WeakGraphicsItemPointer();\n        new (this) WeakGraphicsItemPointer(item);\n        return *this;\n    }\n\n    bool isNull() const\n    {\n        return m_guard.isNull();\n    }\n\n    QGraphicsItem* data() const\n    {\n        return isNull() ? nullptr : m_item;\n    }\n\n    operator bool() const\n    {\n        return !isNull();\n    }\n\n    bool operator!() const\n    {\n        return isNull();\n    }\n\n    void clear()\n    {\n        m_guard.clear();\n        m_item = nullptr;\n    }\n\n    operator QGraphicsItem*() const\n    {\n        return isNull() ? nullptr : m_item;\n    }\n\n    QGraphicsItem&amp; operator*() const\n    {\n        NX_ASSERT(!isNull());\n        return *m_item;\n    }\n\n    QGraphicsItem* operator-&gt;() const\n    {\n        return isNull() ? nullptr : m_item;\n    }\n\nprivate:\n    QPointer&lt;QObject&gt; m_guard;\n    QGraphicsItem *m_item;\n};\n\n\nclass WeakGraphicsItemPointerList: public QVector&lt;WeakGraphicsItemPointer&gt;\n{\n    typedef QVector&lt;WeakGraphicsItemPointer&gt; base_type;\n\npublic:\n    WeakGraphicsItemPointerList() {}\n    WeakGraphicsItemPointerList(int size): base_type(size) {}\n    WeakGraphicsItemPointerList(int size, const WeakGraphicsItemPointer&amp; value): base_type(size, value) {}\n    WeakGraphicsItemPointerList(const QList&lt;QGraphicsItem*&gt;&amp; items);\n\n    /**\n     * Compressed this list by removing all null items.\n     */\n    void compress();\n\n    /**\n     * \\returns                         A copy of this list with all null items removed.\n     */\n    WeakGraphicsItemPointerList compressed() const;\n\n    /**\n     * \\returns                         A list of graphics items that this list contains,\n     *                                  excluding null items and items that were already\n     *                                  destroyed.\n     */\n    QList&lt;QGraphicsItem*&gt; materialized() const;\n\n    using base_type::indexOf;\n    using base_type::lastIndexOf;\n    using base_type::contains;\n\n    int indexOf(QGraphicsItem* value, int from = 0) const;\n\n    int lastIndexOf(QGraphicsItem* value, int from = -1) const;\n\n    bool contains(QGraphicsItem* value) const;\n\n    int removeAll(QGraphicsItem* value);\n\n    bool removeOne(QGraphicsItem *value);\n};\n\n#endif // QN_WEAK_GRAPHICS_ITEM_POINTER_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/dialogs/sign_dialog.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/dialogs/sign_dialog.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/dialogs/sign_dialog.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtWidgets/QDialog&gt;\n#include &lt;QtWidgets/QVBoxLayout&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;ui/dialogs/common/session_aware_dialog.h&gt;\n\nclass QDataWidgetMapper;\nclass QStandardItemModel;\nclass QUrl;\n\nclass QnWorkbenchContext;\nclass QnAbstractArchiveStreamReader;\nclass QnResourceWidgetRenderer;\nclass QnSignDialogGlWidget;\nclass QnSignDialogDisplay;\nclass QnSignInfo;\n\nclass QnAviResource;\n\nnamespace Ui {\nclass SignDialog;\n}\n\nclass QnSignDialogVideoOutput;\n\nclass SignDialog: public QnSessionAwareButtonBoxDialog\n{\n    Q_OBJECT\n    using base_type = QnSessionAwareButtonBoxDialog;\n\npublic:\n    explicit SignDialog(QnResourcePtr resource, QWidget *parent);\n    virtual ~SignDialog();\n\n    static QRect calcVideoRect(double windowWidth, double windowHeight, double textureWidth, double textureHeight);\n\nprivate:\n    void at_calcSignInProgress(QByteArray sign, int progress);\n    void at_gotImageSize(int width, int height);\n    void at_gotSignature(QByteArray calculatedSign, QByteArray signFromFrame);\n\nprotected:\n    virtual void changeEvent(QEvent *event) override;\n\nprivate:\n    Q_DISABLE_COPY(SignDialog)\n\n    QScopedPointer&lt;Ui::SignDialog&gt; ui;\n\n    QnSharedResourcePointer&lt;QnAviResource&gt; m_resource;\n\n    QScopedPointer&lt;QnSignDialogDisplay&gt; m_camDispay;\n    QScopedPointer&lt;QnAbstractArchiveStreamReader&gt; m_reader;\n    QScopedPointer&lt;QnSignDialogVideoOutput&gt; m_videoOutputWidget;\n    QnResourceWidgetRenderer *m_renderer = nullptr;\n    QnSignInfo* m_srcVideoInfo = nullptr;\n    QVBoxLayout* m_layout = nullptr;\n    int m_requestHandle = -1;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/bounding_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/bounding_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/bounding_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_BOUNDING_INSTRUMENT_H\n#define QN_BOUNDING_INSTRUMENT_H\n\n#include &lt;QtCore/QRect&gt;\n#include &lt;QtCore/QSet&gt;\n#include &lt;QtGui/QTransform&gt;\n\n#include &lt;ui/animation/animation_timer.h&gt;\n\n#include &quot;instrument.h&quot;\n\nclass BoundingInstrument: public Instrument\n{\n    Q_OBJECT\n\npublic:\n    /**\n     * Constructor.\n     *\n     * \\param parent                    Parent object.\n     */\n    BoundingInstrument(QObject *parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~BoundingInstrument();\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param positionBounds            Rectangular area to which viewport movement is restricted, in scene coordinates.\n     */\n    void setPositionBounds(QGraphicsView *view, const QRectF &amp;positionBounds);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\returns                         Rectangular area to which viewport movement is restricted, in scene coordinates.\n     */\n    QRectF positionBounds(QGraphicsView *view) const;\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param extension                 Extension of the area to which viewport movement is restricted, in viewports.\n     */\n    void setPositionBoundsExtension(QGraphicsView *view, const QMarginsF &amp;extension);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\returns                         Extension of the area to which viewport movement is restricted, in viewports.\n     */\n    QMarginsF positionBoundsExtension(QGraphicsView *view) const;\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param sizeLowerBound            Lower bound of viewport size, in scene coordinates.\n     * \\param lowerMode                 Mode for the lower bound.\n     * \\param sizeUpperBound            Upper bound of viewport size, in scene coordinates.\n     * \\param upperMode                 Mode for the upper bound.\n     */\n    void setSizeBounds(QGraphicsView *view, const QSizeF &amp;sizeLowerBound, Qt::AspectRatioMode lowerMode, const QSizeF &amp;sizeUpperBound, Qt::AspectRatioMode upperMode);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param sizeLowerExtension        Extension of the lower bound of viewport size, relative to this lower bound.\n     * \\param sizeLowerExtension        Extension of the upper bound of viewport size, relative to this upper bound.\n     */\n    void setSizeBoundsExtension(QGraphicsView *view, const QSizeF &amp;sizeLowerExtension, const QSizeF &amp;sizeUpperExtension);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param multiplier                Viewport movement speed, in viewports per second.\n     */\n    void setMovementSpeed(QGraphicsView *view, qreal multiplier);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param multiplier                Scale speed, factor per second.\n     */\n    void setScalingSpeed(QGraphicsView *view, qreal multiplier);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param positionEnforced          Whether position boundary is enforced with animation.\n     */\n    void setPositionEnforced(QGraphicsView *view, bool positionEnforced = true);\n\n    /**\n     * \\param view                      Graphics view to use.\n     * \\param sizeEnforced              Whether size boundary is enforced with animation.\n     */\n    void setSizeEnforced(QGraphicsView *view, bool sizeEnforced = true);\n\n    /**\n     * Enforces the given graphics view to preserve its current scale, even if\n     * it lies outside the scale boundaries. Thus, the scale boundaries are\n     * effectively extended to include the current scale. However, they\n     * will automatically be contracted once the graphics view&#x27;s scale changes.\n     *\n     * \\param view                      Graphics view to use.\n     */\n    void stickScale(QGraphicsView *view);\n\npublic slots:\n    void enforcePosition(QGraphicsView *view);\n    void dontEnforcePosition(QGraphicsView *view);\n    void enforceSize(QGraphicsView *view);\n    void dontEnforceSize(QGraphicsView *view);\n\nprotected:\n    virtual void enabledNotify() override;\n\n    virtual bool registeredNotify(QGraphicsView *view) override;\n    virtual void unregisteredNotify(QGraphicsView *view) override;\n\n    virtual bool paintEvent(QWidget *viewport, QPaintEvent *event) override;\n\nprivate:\n    class ViewData;\n\n    ViewData *checkView(QGraphicsView *view) const;\n\nprivate:\n    /** View to data mapping. */\n    QHash&lt;QGraphicsView *, ViewData *&gt; m_data;\n};\n\n#endif // QN_BOUNDING_INSTRUMENT_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/click_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/click_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/click_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;ui/common/weak_pointer.h&gt;\n\n#include &quot;click_info.h&quot;\n#include &quot;drag_processing_instrument.h&quot;\n\n/**\n * This instrument listens to click events and emits corresponding signals\n * when the mouse button is released. Note that it uses application&#x27;s\n * start drag distance to distinguish click from a drag.\n */\nclass ClickInstrument: public DragProcessingInstrument\n{\n    Q_OBJECT\n    using base_type = DragProcessingInstrument;\n\npublic:\n    /**\n     * @param buttons Mouse buttons to handle.\n     * @param clickDelayMSec Delay in milliseconds to wait for the double click before emitting the\n     *     click signal. If the double click arrives before the delay times out, click signal won&#x27;t\n     *     be emitted at all.\n     * @param watchedType Type of click events that this instrument will watch. Note that only\n     *     SCENE and ITEM types are supported.\n     * @param parent Parent object for this instrument.\n     */\n    ClickInstrument(\n        Qt::MouseButtons buttons,\n        int clickDelayMSec,\n        WatchedType watchedType,\n        QObject* parent = nullptr);\n    virtual ~ClickInstrument();\n\nsignals:\n    /**\n     * This signal is emitted when the mouse is pressed over an item. After that itemClicked,\n     * itemDoubleClicked or both may be emitted, depending on the click delay.\n     *\n     * @param view View where the click originated.\n     * @param item Item that was clicked.\n     * @param info Additional click information.\n     */\n    void itemPressed(QPointer&lt;QGraphicsView&gt; view, WeakPointer&lt;QGraphicsItem&gt; item, ClickInfo info);\n    void itemClicked(QPointer&lt;QGraphicsView&gt; view, WeakPointer&lt;QGraphicsItem&gt; item, ClickInfo info);\n    void itemDoubleClicked(\n        QPointer&lt;QGraphicsView&gt; view, WeakPointer&lt;QGraphicsItem&gt; item, ClickInfo info);\n\n    void scenePressed(QPointer&lt;QGraphicsView&gt; view, ClickInfo info);\n    void sceneClicked(QPointer&lt;QGraphicsView&gt; view, ClickInfo info);\n    void sceneDoubleClicked(QPointer&lt;QGraphicsView&gt; view, ClickInfo info);\n\nprotected:\n    virtual void timerEvent(QTimerEvent *event) override;\n\n    virtual void aboutToBeDisabledNotify() override;\n\n    virtual bool mousePressEvent(QGraphicsScene *scene, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseDoubleClickEvent(QGraphicsScene *scene, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseMoveEvent(QGraphicsScene *scene, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseReleaseEvent(QGraphicsScene *scene, QGraphicsSceneMouseEvent *event) override;\n\n    virtual bool mousePressEvent(QGraphicsItem *item, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseDoubleClickEvent(QGraphicsItem *item, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseMoveEvent(QGraphicsItem *item, QGraphicsSceneMouseEvent *event) override;\n    virtual bool mouseReleaseEvent(QGraphicsItem *item, QGraphicsSceneMouseEvent *event) override;\n\n    virtual bool registeredNotify(QGraphicsItem *) override { return true; }\n\n    virtual void startDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\nprivate:\n    void storeClickData(QGraphicsView *view, QGraphicsItem *item, QGraphicsSceneMouseEvent *event);\n    void storeClickData(QGraphicsView *view, QGraphicsScene *scene, QGraphicsSceneMouseEvent *event);\n    void killClickTimer();\n    void restartClickTimer();\n\n    template&lt;class T&gt;\n    bool mousePressEventInternal(T *object, QGraphicsSceneMouseEvent *event);\n\n    template&lt;class T&gt;\n    bool mouseDoubleClickEventInternal(T *object, QGraphicsSceneMouseEvent *event);\n\n    template&lt;class T&gt;\n    bool mouseMoveEventInternal(T *object, QGraphicsSceneMouseEvent *event);\n\n    template&lt;class T&gt;\n    bool mouseReleaseEventInternal(T *object, QGraphicsSceneMouseEvent *event);\n\n    void emitSignals(QGraphicsView* view, QGraphicsItem* item, ClickInfo info);\n    void emitSignals(QGraphicsView* view, QGraphicsScene* scene, ClickInfo info);\n\n    void emitInitialSignal(QGraphicsView* view, QGraphicsItem* item, ClickInfo info);\n    void emitInitialSignal(QGraphicsView* view, QGraphicsScene* scene, ClickInfo info);\n\nprivate:\n    struct ClickData;\n\n    Qt::MouseButtons m_buttons;\n    int m_clickDelayMSec;\n    int m_clickTimer;\n    QScopedPointer&lt;ClickData&gt; m_clickData;\n    bool m_isClick;\n    bool m_isDoubleClick;\n    bool m_nextDoubleClickIsClick;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drag_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drag_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drag_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_DRAG_INSTRUMENT_H\n#define QN_DRAG_INSTRUMENT_H\n\n#include &lt;ui/common/weak_graphics_item_pointer.h&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass DragInstrument: public DragProcessingInstrument {\n    Q_OBJECT;\npublic:\n    DragInstrument(QObject *parent = nullptr);\n\n    virtual ~DragInstrument();\n\nsignals:\n    void dragProcessStarted(QGraphicsView *view);\n    void dragStarted(QGraphicsView *view);\n    void dragFinished(QGraphicsView *view);\n    void dragProcessFinished(QGraphicsView *view);\n\nprotected:\n    virtual bool mousePressEvent(QWidget *viewport, QMouseEvent *event) override;\n\n    virtual void startDragProcess(DragInfo *info) override;\n    virtual void startDrag(DragInfo *info) override;\n    virtual void dragMove(DragInfo *info) override;\n    virtual void finishDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\nprivate:\n    WeakGraphicsItemPointer m_itemToSelect;\n};\n\n\n#endif // QN_DRAG_INSTRUMENT_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drop_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drop_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drop_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;core/resource/videowall_item_index.h&gt;\n#include &lt;nx/vms/client/desktop/menu/action_manager.h&gt;\n#include &lt;ui/workbench/workbench_context_aware.h&gt;\n\n#include &quot;instrument.h&quot;\n#include &quot;scene_event_filter.h&quot;\n\nclass QnWorkbenchContext;\nclass DropSurfaceItem;\nclass DestructionGuardItem;\n\nnamespace nx::vms::client::desktop {\n\nclass MimeData;\n\n} // namespace nx::vms::client::desktop\n\nclass DropInstrument:\n    public Instrument,\n    public SceneEventFilter,\n    public QnWorkbenchContextAware\n{\n    Q_OBJECT\npublic:\n    DropInstrument(bool intoNewLayout, QnWorkbenchContext *context, QObject *parent = nullptr);\n    virtual ~DropInstrument() override;\n\n    /**\n     * \\returns                         Graphics item that serves as a surface for\n     *                                  drag and drop. Is never nullptr, unless explicitly deleted by user.\n     */\n    QGraphicsObject *surface() const;\n\n    void setSurface(QGraphicsObject *surface);\n\nprotected:\n    friend class DropSurfaceItem;\n\n    virtual void installedNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n\n    virtual bool sceneEventFilter(QGraphicsItem *watched, QEvent *event) override;\n\n    virtual bool dragEnterEvent(QGraphicsItem *item, QGraphicsSceneDragDropEvent *event) override;\n    virtual bool dragMoveEvent(QGraphicsItem *item, QGraphicsSceneDragDropEvent *event) override;\n    virtual bool dragLeaveEvent(QGraphicsItem *item, QGraphicsSceneDragDropEvent *event) override;\n    virtual bool dropEvent(QGraphicsItem *item, QGraphicsSceneDragDropEvent *event) override;\n\n    DestructionGuardItem *guard() const;\n    SceneEventFilterItem *filterItem() const;\n\nprivate:\n    bool delayedTriggerIfPossible(nx::vms::client::desktop::menu::IDType id,\n        const nx::vms::client::desktop::menu::Parameters&amp; parameters);\n\n    bool isDragValid() const;\n\nprivate:\n    std::unique_ptr&lt;nx::vms::client::desktop::MimeData&gt; m_mimeData;\n\n    QScopedPointer&lt;SceneEventFilterItem&gt; m_filterItem;\n    QPointer&lt;DestructionGuardItem&gt; m_guard;\n    QPointer&lt;QGraphicsObject&gt; m_surface;\n    bool m_intoNewLayout;\n};\n\n/** Name of the mimetype to add to a drag object to forbid its dropping on the scene. */\n#define NoSceneDrop _id(lit(&quot;_qn_noSceneDrop&quot;))\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/hand_scroll_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/hand_scroll_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/hand_scroll_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;common/common_globals.h&gt;\n#include &lt;ui/processors/kinetic_process_handler.h&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass HandScrollInstrument:\n    public DragProcessingInstrument,\n    protected KineticProcessHandler\n{\n    Q_OBJECT\n    using base_type = DragProcessingInstrument;\n\npublic:\n    explicit HandScrollInstrument(QObject* parent);\n    virtual ~HandScrollInstrument() override;\n\n    Qt::MouseButtons mouseButtons() const;\n    void setMouseButtons(Qt::MouseButtons mouseButtons);\n\n    void emulate(QPoint viewportDelta);\n\nsignals:\n    void scrollProcessStarted(QGraphicsView* view);\n    void scrollStarted(QGraphicsView* view);\n    void scrollFinished(QGraphicsView* view);\n    void scrollProcessFinished(QGraphicsView* view);\n\nprotected:\n    virtual void aboutToBeDisabledNotify() override;\n\n    virtual bool mousePressEvent(QWidget* viewport, QMouseEvent* event) override;\n\n    virtual void startDragProcess(DragInfo* info) override;\n    virtual void startDrag(DragInfo* info) override;\n    virtual void dragMove(DragInfo* info) override;\n    virtual void finishDrag(DragInfo* info) override;\n    virtual void finishDragProcess(DragInfo* info) override;\n\n    virtual void kineticMove(const QVariant&amp; distance) override;\n    virtual void finishKinetic() override;\n\nprivate:\n    Qt::MouseButtons m_mouseButtons;\n    QPointer&lt;QGraphicsView&gt; m_currentView;\n};\n\n/**\n * Name of the property to set on a graphics object to forbid hand scrolling\n * on top of it. By default, this property is not set, and hand scrolling is\n * thus enabled.\n */\n#define NoHandScrollOver _id(&quot;_qn_noHandScrollOver&quot;)\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrument_manager.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrument_manager.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrument_manager.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_INSTRUMENT_MANAGER_H\n#define QN_INSTRUMENT_MANAGER_H\n\n#include &lt;QtCore/QList&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QSet&gt;\n\n#include &quot;installation_mode.h&quot;\n#include &quot;instrument.h&quot;\n\nclass QGraphicsItem;\nclass QGraphicsScene;\nclass QGraphicsView;\n\nclass InstrumentManagerPrivate;\n\n/**\n * Instrument manager ties graphics scene, views and items and instruments together.\n *\n * It supports multiple graphics views per instrument manager.\n */\nclass InstrumentManager: public QObject, public InstallationMode {\n    Q_OBJECT;\npublic:\n    /**\n     * Constructor.\n     *\n     * \\param scene                    Graphics scene that this instrument manager\n     *                                 will work with.\n     * \\param parent                   Parent object for this instrument manager.\n     */\n    InstrumentManager(QObject *parent = nullptr);\n\n    /**\n     * Destructor.\n     */\n    virtual ~InstrumentManager();\n\n    /**\n     * Installs the given instrument to the associated graphics view.\n     *\n     * \\param instrument               Instrument to install.\n     * \\param mode                     Where to install the given instrument.\n     * \\param reference                Reference instrument for the given installation mode.\n     * \\returns                        Whether the instrument was successfully installed.\n     */\n    bool installInstrument(Instrument *instrument, InstallationMode::Mode mode = InstallFirst, Instrument *reference = nullptr);\n\n    /**\n     * Uninstalls the given instrument from the associated graphics view.\n     *\n     * \\param instrument               Instrument to uninstall.\n     * \\returns                        Whether the instrument was successfully uninstalled.\n     */\n    bool uninstallInstrument(Instrument *instrument);\n\n    /**\n     * Registers the given graphics scene with this instrument manager.\n     *\n     * If the given scene is destroyed, it will be unregistered automatically.\n     *\n     * \\param scene                    Graphics scene to register.\n     */\n    void registerScene(QGraphicsScene *scene);\n\n    /**\n     * Unregisters the given graphics scene from this instrument manager.\n     *\n     * Unregistering a scene automatically unregisters all its views and items.\n     *\n     * \\param scene                    Graphics scene to unregister.\n     */\n    void unregisterScene(QGraphicsScene *scene);\n\n    /**\n     * Registers the given graphics view with this instrument manager.\n     *\n     * If the given view is destroyed, it will be unregistered automatically.\n     *\n     * \\param view                     Graphics view to register.\n     */\n    void registerView(QGraphicsView *view);\n\n    /**\n     * Unregisters the given graphics view from this instrument manager.\n     *\n     * \\param view                     Graphics view to unregister.\n     */\n    void unregisterView(QGraphicsView *view);\n\n    /**\n     * Registers the given graphics item with this instrument manager.\n     *\n     * Note that the given item won&#x27;t be unregistered automatically if it is\n     * destroyed. Unregistering it is up to the user.\n     *\n     * \\param item                     Graphics item to register.\n     * \\param delayed                  Whether delayed registration is to be performed.\n     *                                 It may be necessary when item is registered when\n     *                                 it is not yet fully constructed.\n     */\n    void registerItem(QGraphicsItem *item, bool delayed = false);\n\n    /**\n     * Unregisters the given graphics item from this instrument manager.\n     *\n     * \\param item                     Graphics item to unregister.\n     */\n    void unregisterItem(QGraphicsItem *item);\n\n    /**\n     * \\returns                        Graphics scene that is registered with\n     *                                 this instrument manager.\n     */\n    QGraphicsScene *scene() const;\n\n    /**\n     * \\returns                        Graphics views that are registered with\n     *                                 this instrument manager.\n     */\n    const QSet&lt;QGraphicsView *&gt; &amp;views() const;\n\n    /**\n     * \\returns                        Graphics items that are registered with\n     *                                 this instrument manager.\n     */\n    const QSet&lt;QGraphicsItem *&gt; &amp;items() const;\n\n    /**\n     * \\returns                        All instruments installed into this\n     *                                 instrument manager.\n     */\n    const QList&lt;Instrument *&gt; &amp;instruments() const;\n\n    /**\n     * \\tparam                         Type of the instrument to get.\n     * \\returns                        The first instrument in instrument queue\n     *                                 that has the given type, or nullptr if no such\n     *                                 instrument exists.\n     */\n    template&lt;class T&gt;\n    T *instrument() const {\n        const QList&lt;Instrument *&gt; &amp;instruments = this-&gt;instruments();\n\n        for (int i = instruments.size() - 1; i &gt;= 0; i--) {\n            T *result = dynamic_cast&lt;T *&gt;(instruments[i]);\n            if(result != nullptr)\n                return result;\n        }\n\n        return nullptr;\n    }\n\n    bool isAnimationEnabled() const;\n    void setAnimationsEnabled(bool enabled = true);\n\n    AnimationTimer *animationTimer() const;\n\n    /**\n     * \\param scene                    Scene.\n     * \\returns                        List of all instrument managers managing\n     *                                 the given scene.\n     */\n    static InstrumentManager *instance(QGraphicsScene *scene);\n\n    static AnimationTimer *animationTimer(QGraphicsScene *scene);\n\n    /**\n     * Limit viewport updates generated via animation timer.\n     */\n    void setFpsLimit(int limit);\n\nsignals:\n    void sceneChanged();\n\nprivate slots:\n    void at_view_destroyed(QObject *view);\n    void at_viewport_destroyed(QObject *viewport);\n    void at_viewportWatcher_destroyed(QObject *viewportWatcher);\n    void at_delayedItemRegistrationRequested();\n\nprivate:\n    InstrumentManagerPrivate *const d_ptr;\n\nprivate:\n    Q_DECLARE_PRIVATE(InstrumentManager);\n};\n\n\n\n#endif // QN_INSTRUMENT_MANAGER_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_INSTRUMENTED_H\n#define QN_INSTRUMENTED_H\n\n#ifndef Q_MOC_RUN\n    #include &lt;boost/type_traits/is_base_of.hpp&gt;\n#endif\n\n#include &lt;QtWidgets/QGraphicsItem&gt;\n\n#include &lt;utils/common/forward.h&gt;\n\ntemplate&lt;class Base, bool baseIsInstrumented&gt;\nclass Instrumented;\n\n/**\n * Support class for &lt;tt&gt;Instrumented&lt;/tt&gt; template. In most cases there is no\n * need to use this class directly. The only possible use is to\n * &lt;tt&gt;dynamic_cast&lt;/tt&gt; to it.\n */\nclass InstrumentedBase {\nprivate:\n    InstrumentedBase(): m_scene(nullptr) {}\n    virtual ~InstrumentedBase() {}\n\n    void updateScene(QGraphicsScene *scene, QGraphicsItem *item);\n\n    template&lt;class Base, bool baseIsInstrumented&gt;\n    friend class ::Instrumented; /* So that only this class can access our methods. */\n\nprivate:\n    QGraphicsScene *m_scene;\n};\n\n\n/**\n * Base class for items that wish to be automatically registered with their\n * scene&#x27;s instrument managers.\n */\ntemplate&lt;class Base, bool baseIsInstrumented = boost::is_base_of&lt;InstrumentedBase, Base&gt;::value&gt;\nclass Instrumented: public Base, public InstrumentedBase {\npublic:\n    QN_FORWARD_CONSTRUCTOR(Instrumented, Base, { InstrumentedBase::updateScene(this-&gt;scene(), this); });\n\n    virtual ~Instrumented() {\n        InstrumentedBase::updateScene(nullptr, this);\n    }\n\nprotected:\n    virtual QVariant itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant &amp;value) override {\n        if(change == QGraphicsItem::ItemSceneHasChanged)\n            InstrumentedBase::updateScene(this-&gt;scene(), this);\n\n        return Base::itemChange(change, value);\n    }\n};\n\n\n/**\n * Specialization that prevents creation of two instrumented data instances in\n * a single class, even if it was tagged as &#x27;Instrumented&#x27; several times\n * (e.g. one of its bases is instrumented).\n */\ntemplate&lt;class Base&gt;\nclass Instrumented&lt;Base, true&gt;: public Base {\npublic:\n    using Base::Base;\n};\n\n#endif // QN_INSTRUMENTED_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/motion_selection_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/motion_selection_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/motion_selection_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass QnMediaResourceWidget;\nclass SelectionItem;\n\nclass MotionSelectionInstrument: public DragProcessingInstrument\n{\n    Q_OBJECT\n    using base_type = DragProcessingInstrument;\n\npublic:\n    explicit MotionSelectionInstrument(QObject* parent = nullptr);\n    virtual ~MotionSelectionInstrument() override;\n\n    void setPen(const QPen&amp; pen);\n    QPen pen() const;\n\n    void setBrush(const QBrush&amp; brush);\n    QBrush brush() const;\n\n    /**\n     * \\param selectionModifiers        Keyboard modifiers that must be pressed for the\n     *                                  selection process to start. Defaults to 0.\n     */\n    void setSelectionModifiers(Qt::KeyboardModifiers selectionModifiers);\n    Qt::KeyboardModifiers selectionModifiers() const;\n\n    /**\n     * \\param multiSelectionModifiers   Additional keyboard modifiers that must be\n     *                                  pressed for the new selection to be added\n     *                                  to existing selection. Defaults to &lt;tt&gt;Qn::ControlModifier&lt;/tt&gt;.\n     */\n    void setMultiSelectionModifiers(Qt::KeyboardModifiers multiSelectionModifiers);\n    Qt::KeyboardModifiers multiSelectionModifiers() const;\n\nsignals:\n    void selectionProcessStarted(QGraphicsView* view, QnMediaResourceWidget* widget);\n    void selectionStarted(QGraphicsView* view, QnMediaResourceWidget* widget);\n    void motionRegionCleared(QGraphicsView* view, QnMediaResourceWidget* widget);\n    void motionRegionSelected(QGraphicsView* view, QnMediaResourceWidget* widget, const QRect&amp; rect);\n    void selectionFinished(QGraphicsView* view, QnMediaResourceWidget* widget);\n    void selectionProcessFinished(QGraphicsView* view, QnMediaResourceWidget* widget);\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeDisabledNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n\n    virtual bool mousePressEvent(QWidget* viewport, QMouseEvent* event) override;\n    virtual bool mouseMoveEvent(QWidget* viewport, QMouseEvent* event) override;\n    virtual bool mouseReleaseEvent(QWidget* viewport, QMouseEvent* event) override;\n    virtual bool paintEvent(QWidget* viewport, QPaintEvent* event) override;\n\n    virtual void startDragProcess(DragInfo* info) override;\n    virtual void startDrag(DragInfo* info) override;\n    virtual void dragMove(DragInfo* info) override;\n    virtual void finishDrag(DragInfo* info) override;\n    virtual void finishDragProcess(DragInfo* info) override;\n\n    SelectionItem* selectionItem() const;\n\n    QnMediaResourceWidget* target() const;\n\n    Qt::KeyboardModifiers selectionModifiers(QnMediaResourceWidget* target) const;\n\n    void ensureSelectionItem();\n\nprivate:\n    void updateWidgetUnderCursor(QWidget* viewport, QMouseEvent* event);\n    void updateCursor();\n    void setWidget(QnMediaResourceWidget* widget);\n    void setItemUnderMouse(QGraphicsWidget* item);\n\n    void updateButtonUnderCursor(QWidget* viewport, QMouseEvent* event);\n\nprivate:\n    QBrush m_brush;\n    QPen m_pen;\n    QPointer&lt;SelectionItem&gt; m_selectionItem;\n    QPointer&lt;QnMediaResourceWidget&gt; m_widget;\n    QPointer&lt;QGraphicsWidget&gt; m_itemUnderMouse;\n    QPointer&lt;QGraphicsWidget&gt; m_buttonUnderMouse;\n    bool m_selectionStartedEmitted = false;\n    Qt::KeyboardModifiers m_selectionModifiers;\n    Qt::KeyboardModifiers m_multiSelectionModifiers;\n    QRect m_gridRect;\n};\n\n/**\n * Name of the property to set on a &lt;tt&gt;QnResourceWidget&lt;/tt&gt; to change\n * the keyboard modifiers that must be pressed to activate the\n * motion selection instrument.\n *\n * If not set, default modifiers set for the motion selection instrument\n * will be used.\n */\n#define MotionSelectionModifiers _id(&quot;_qn_motionSelectionModifiers&quot;)\n\n/**\n * Name of the property to set on a graphics item to block motion selection.\n */\n#define BlockMotionSelection _id(&quot;_qn_blockMotionSelection&quot;)\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/move_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/move_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/move_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_MOVE_INSTRUMENT_H\n#define QN_MOVE_INSTRUMENT_H\n\n#include &lt;QtCore/QPoint&gt;\n\n#include &lt;ui/common/weak_graphics_item_pointer.h&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nQ_MOC_INCLUDE(&quot;QtWidgets/QGraphicsItem&quot;)\n\nclass MoveInstrument: public DragProcessingInstrument {\n    Q_OBJECT;\npublic:\n    MoveInstrument(QObject *parent);\n\n    virtual ~MoveInstrument();\n\nsignals:\n    void moveProcessStarted(QGraphicsView *view);\n    void moveStarted(QGraphicsView *view, const QList&lt;QGraphicsItem *&gt; &amp;items);\n    void move(QGraphicsView *view, const QPointF &amp;totalDelta);\n    void moveFinished(QGraphicsView *view, const QList&lt;QGraphicsItem *&gt; &amp;items);\n    void moveProcessFinished(QGraphicsView *view);\n\nprotected:\n    virtual bool mousePressEvent(QWidget *viewport, QMouseEvent *event) override;\n\n    virtual void startDragProcess(DragInfo *info) override;\n    virtual void startDrag(DragInfo *info) override;\n    virtual void dragMove(DragInfo *info) override;\n    virtual void finishDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\nprivate:\n    QGraphicsItem *draggedItem() const {\n        return m_draggedItem.data();\n    }\n\n    void moveItem(QGraphicsItem *item, const QPointF &amp;sceneDeltaPos) const;\n\nprivate:\n    bool m_moveStartedEmitted;\n    WeakGraphicsItemPointer m_draggedItem;\n    WeakGraphicsItemPointerList m_draggedItems;\n};\n\n#endif // QN_MOVE_INSTRUMENT_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/object_tracking_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/object_tracking_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/object_tracking_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &quot;click_instrument.h&quot;\n\n/**\n * This instrument listens to click events and sends &quot;start object tracking&quot; command to the server,\n * when it&#x27;s needed.\n */\nclass ObjectTrackingInstrument: public ClickInstrument\n{\n    Q_OBJECT\n    using base_type = ClickInstrument;\n\npublic:\n    ObjectTrackingInstrument(QObject* parent = nullptr);\n    virtual ~ObjectTrackingInstrument() override;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/ptz_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/ptz_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/ptz_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QBasicTimer&gt;\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtCore/QTimer&gt;\n#include &lt;QtCore/QVector&gt;\n#include &lt;QtGui/QVector3D&gt;\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/ptz/abstract_ptz_controller.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass FixedArSelectionItem;\nclass PtzOverlayWidget;\nclass PtzElementsWidget;\nclass PtzManipulatorWidget;\n\nclass QnSplashItem;\nclass QnMediaResourceWidget;\nclass QnResourceWidget;\n\nnamespace nx::vms::client::desktop {\nclass PtzPromoOverlay;\nclass SceneBanner;\n} // namespace nx::vms::client::desktop\n\nclass PtzInstrument:\n    public DragProcessingInstrument,\n    public nx::vms::client::desktop::WindowContextAware\n{\n    Q_OBJECT\n    using base_type = DragProcessingInstrument;\n\npublic:\n    PtzInstrument(\n        nx::vms::client::desktop::WindowContext* windowContext,\n        QObject* parent = nullptr);\n\n    virtual ~PtzInstrument() override;\n\n    // This instrument operates PTZ via mouse interaction with PTZ overlay.\n\n    // Also, continuous PTZ can be controlled externally using the following function.\n\n    enum class DirectionFlag\n    {\n        panLeft = 0x01,\n        panRight = 0x02,\n        tiltUp = 0x04,\n        tiltDown = 0x08,\n        zoomIn = 0x10,\n        zoomOut = 0x20\n    };\n    Q_FLAG(DirectionFlag) //&lt; For lexical debug output.\n    Q_DECLARE_FLAGS(DirectionFlags, DirectionFlag)\n\n    bool supportsContinuousPtz(QnMediaResourceWidget* widget, DirectionFlag direction) const;\n    void toggleContinuousPtz(QnMediaResourceWidget* widget, DirectionFlag direction, bool on);\n\nsignals:\n    void ptzProcessStarted(QnMediaResourceWidget* widget);\n    void ptzStarted(QnMediaResourceWidget* widget);\n    void ptzFinished(QnMediaResourceWidget* widget);\n    void ptzProcessFinished(QnMediaResourceWidget* widget);\n\n    void doubleClicked(QPointer&lt;QnMediaResourceWidget&gt; widget);\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeDisabledNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n    virtual bool registeredNotify(QGraphicsItem* item) override;\n    virtual void unregisteredNotify(QGraphicsItem* item) override;\n\n    virtual void timerEvent(QTimerEvent* event) override;\n\n    virtual bool animationEvent(AnimationEvent* event) override;\n\n    virtual bool mousePressEvent(QWidget* viewport, QMouseEvent* event) override;\n    virtual bool mousePressEvent(QGraphicsItem* item, QGraphicsSceneMouseEvent* event) override;\n    virtual bool mouseDoubleClickEvent(QGraphicsItem* item, QGraphicsSceneMouseEvent* event) override;\n\n    virtual void startDragProcess(DragInfo* info) override;\n    virtual void startDrag(DragInfo* info) override;\n    virtual void dragMove(DragInfo* info) override;\n    virtual void finishDrag(DragInfo* info) override;\n    virtual void finishDragProcess(DragInfo* info) override;\n\n    virtual bool wheelEvent(QGraphicsScene* scene, QGraphicsSceneWheelEvent* event) override;\n\nprivate slots:\n    void at_splashItem_destroyed();\n\n    void at_modeButton_clicked();\n\n    void at_zoomInButton_pressed();\n    void at_zoomInButton_released();\n    void at_zoomOutButton_pressed();\n    void at_zoomOutButton_released();\n    void at_zoomButton_activated(qreal speed);\n\n    void at_focusInButton_pressed();\n    void at_focusInButton_released();\n    void at_focusOutButton_pressed();\n    void at_focusOutButton_released();\n    void at_focusButton_activated(qreal speed);\n\n    void at_focusAutoButton_clicked();\n\n    void at_display_widgetAboutToBeChanged(Qn::ItemRole role);\n\n    void resetIfTargetIsInvisible();\n\n    void updateOverlayWidget();\n    void updateWidgetPtzController(QnMediaResourceWidget* widget);\n    void updateOverlayWidgetInternal(QnMediaResourceWidget* widget);\n    void updateOverlayCursor(QnMediaResourceWidget* widget);\n    void updateCapabilities(QnMediaResourceWidget* widget);\n    void updateTraits(QnMediaResourceWidget* widget);\n\nprivate:\n    QnMediaResourceWidget* target() const;\n    void setTarget(QnMediaResourceWidget* target);\n    PtzManipulatorWidget* targetManipulator() const;\n\n    QnSplashItem* newSplashItem(QGraphicsItem* parentItem);\n\n    FixedArSelectionItem* selectionItem() const;\n    void ensureSelectionItem();\n\n    PtzElementsWidget* elementsWidget() const;\n    void ensureElementsWidget();\n\n    PtzOverlayWidget* overlayWidget(QnMediaResourceWidget* widget) const;\n    PtzOverlayWidget* ensureOverlayWidget(QnMediaResourceWidget* widget);\n\n    /**\n     * Check if current camera is a static sensor of a ptz-redirected camera.\n     */\n    void handlePtzRedirect(QnMediaResourceWidget* widget);\n    bool ensurePtzRedirectedCameraIsOnLayout(\n        QnMediaResourceWidget* staticSensor,\n        const QnVirtualCameraResourcePtr&amp; dynamicSensor);\n\n    bool processMousePress(QGraphicsItem* item, QGraphicsSceneMouseEvent* event);\n\n    void ptzMoveTo(QnMediaResourceWidget* widget, const QPointF&amp; pos);\n    void ptzMoveTo(QnMediaResourceWidget* widget, const QRectF&amp; rect, bool unzooming = false);\n    void ptzUnzoom(QnMediaResourceWidget* widget);\n    void ptzMove(\n        QnMediaResourceWidget* widget,\n        const nx::vms::common::ptz::Vector&amp; speed,\n        bool instant = false);\n\n    void focusMove(QnMediaResourceWidget* widget, qreal speed);\n    void focusAuto(QnMediaResourceWidget* widget);\n\n    void processPtzClick(const QPointF&amp; pos);\n    void processPtzDrag(const QRectF&amp; rect);\n    void processPtzDoubleClick();\n\n    QnResourceWidget* findPtzWidget(const QPointF&amp; scenePos) const;\n    void updateExternalPtzSpeed();\n\n    QString actionText(QnMediaResourceWidget* widget) const;\n    void updateActionText(QnMediaResourceWidget* widget);\n\n    bool checkPlayingLive(QnMediaResourceWidget* widget) const;\n    void updatePromo(QnMediaResourceWidget* widget);\n\nprivate:\n    struct PtzData\n    {\n        bool hasCapabilities(Ptz::Capabilities value) const;\n        bool isFisheye() const;\n        bool hasContinuousPanOrTilt() const;\n        bool hasAdvancedPtz() const;\n\n        Ptz::Capabilities capabilities = Ptz::Capability::none;\n        QnPtzAuxiliaryTraitList traits;\n        nx::vms::common::ptz::Vector currentSpeed;\n        nx::vms::common::ptz::Vector requestedSpeed;\n        PtzOverlayWidget* overlayWidget = nullptr;\n        QGraphicsWidget* cursorOverlay = nullptr;\n        QPointer&lt;nx::vms::client::desktop::PtzPromoOverlay&gt; promoOverlay;\n        QMetaObject::Connection capabilitiesConnection;\n    };\n\n    struct SplashItemAnimation\n    {\n        SplashItemAnimation()\n        {}\n        SplashItemAnimation(QnSplashItem* item):\n            item(item)\n        {}\n        SplashItemAnimation(QnSplashItem* item, qreal expansionMultiplier, qreal opacityMultiplier):\n            item(item),\n            expansionMultiplier(expansionMultiplier),\n            opacityMultiplier(opacityMultiplier)\n        {}\n\n        QnSplashItem* item = nullptr;\n        bool fadingIn = true;\n        qreal expansionMultiplier = 0.0; //&lt; Expansion speed relative to standard expansion speed.\n        qreal opacityMultiplier = 0.0;\n\n        friend bool operator==(const SplashItemAnimation&amp; l, const SplashItemAnimation&amp; r)\n        {\n            return l.item == r.item;\n        }\n    };\n\n    enum Movement\n    {\n        NoMovement,\n        ContinuousMovement,\n        ViewportMovement,\n        VirtualMovement\n    };\n\n    int m_clickDelayMSec;\n    qreal m_expansionSpeed;\n\n    QPointer&lt;FixedArSelectionItem&gt; m_selectionItem;\n    QPointer&lt;PtzElementsWidget&gt; m_elementsWidget;\n    QPointer&lt;QWidget&gt; m_viewport;\n    QPointer&lt;QnMediaResourceWidget&gt; m_target;\n    QHash&lt;QObject*, PtzData&gt; m_dataByWidget;\n    QBasicTimer m_movementTimer;\n\n    Movement m_movement;\n    Qt::Orientations m_movementOrientations;\n\n    bool m_isClick = false;\n    bool m_isDoubleClick = false;\n    bool m_ptzStartedEmitted = false;\n    bool m_skipNextAction = false;\n\n    QBasicTimer m_clickTimer;\n    QPointF m_clickPos;\n\n    class MovementFilter;\n    QScopedPointer&lt;MovementFilter&gt; m_movementFilter;\n\n    QList&lt;SplashItemAnimation&gt; m_freeAnimations, m_activeAnimations;\n\n    DirectionFlags m_externalPtzDirections;\n\n    int m_wheelZoomDirection = 0;\n    QTimer* const m_wheelZoomTimer;\n    QHash&lt;QnMediaResourceWidget*, QTimer*&gt; m_hideActionTextTimers;\n\n    QPointer&lt;nx::vms::client::desktop::SceneBanner&gt; m_noAdvancedPtzWarning;\n    mutable QPointer&lt;nx::vms::client::desktop::SceneBanner&gt; m_ptzInArchiveMessageBox;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/resizing_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/resizing_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/resizing_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtGui/QTransform&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass ConstrainedGeometrically;\nclass ResizeHoverInstrument;\nclass ResizingInstrument;\n\nclass ResizingInfo\n{\npublic:\n    Qt::WindowFrameSection frameSection() const;\n\n    QPoint mouseScreenPos() const;\n    QPoint mouseViewportPos() const;\n    QPointF mouseScenePos() const;\n\nprotected:\n    friend class ResizingInstrument;\n\n    ResizingInfo(DragInfo* info, ResizingInstrument* instrument):\n        m_info(info),\n        m_instrument(instrument)\n    {}\n\nprivate:\n    DragInfo* m_info;\n    ResizingInstrument* m_instrument;\n};\n\ntypedef QPointer&lt;QGraphicsWidget&gt; QGraphicsWidgetPtr;\ntypedef QList&lt;QGraphicsWidgetPtr&gt; WidgetsList;\n\n\n/**\n * This instrument implements resizing of QGraphicsWidget.\n * Unlike default resizing algorithm, it allows resizing to non-integer sizes.\n * Size hints are currently not supported.\n *\n * This instrument implements the following resizing process:\n * &lt;ol&gt;\n * &lt;li&gt;User presses a mouse button on a widget&#x27;s frame.&lt;/li&gt;\n * &lt;li&gt;User moves a mouse pointer several pixels away intending to resize a widget.&lt;/li&gt;\n * &lt;li&gt;Resizing starts. &lt;/li&gt;\n * &lt;li&gt;User resizes a widget and releases the mouse button.&lt;/li&gt;\n * &lt;li&gt;Resizing ends. &lt;/li&gt;\n * &lt;/ol&gt;\n *\n * Provided signals can be used to track what is happening.\n *\n * Note that resizing process may finish before the actual resizing starts if the user\n * releases the mouse button before moving the mouse pointer several pixels away.\n * In this case resizingStarted() signal will not be emitted.\n */\nclass ResizingInstrument: public DragProcessingInstrument\n{\n    Q_OBJECT\n\n    using base_type = DragProcessingInstrument;\n\npublic:\n    ResizingInstrument(QObject* parent = nullptr);\n    virtual ~ResizingInstrument();\n\n    qreal innerEffectRadius() const;\n    void setInnerEffectRadius(qreal effectRadius);\n\n    qreal outerEffectRadius() const;\n    void setOuterEffectRadius(qreal effectRadius);\n\n    void rehandle();\n\nsignals:\n    void resizingProcessStarted(QGraphicsView* view, QGraphicsWidget* widget, ResizingInfo* info);\n    void resizingStarted(QGraphicsView* view, QGraphicsWidget* widget, ResizingInfo* info);\n    void resizing(QGraphicsView* view, QGraphicsWidget* widget, ResizingInfo* info);\n    void resizingFinished(QGraphicsView* view, QGraphicsWidget* widget, ResizingInfo* info);\n    void resizingProcessFinished(QGraphicsView* view, QGraphicsWidget* widget, ResizingInfo* info);\n\nprotected:\n    virtual bool mousePressEvent(QWidget* viewport, QMouseEvent* event) override;\n    virtual bool hoverEnterEvent(QWidget* viewport, QHoverEvent* event) override;\n    virtual bool hoverLeaveEvent(QWidget* viewport, QHoverEvent* event) override;\n    virtual bool hoverMoveEvent(QWidget* viewport, QHoverEvent* event) override;\n\n    virtual void startDragProcess(DragInfo* info) override;\n    virtual void startDrag(DragInfo* info) override;\n    virtual void dragMove(DragInfo* info) override;\n    virtual void finishDrag(DragInfo* info) override;\n    virtual void finishDragProcess(DragInfo* info) override;\n\nprivate:\n    void updateCursor(QWidget* viewport, const QPoint&amp; viewportPos);\n\n    void getWidgetAndFrameSection(\n        QWidget* viewport,\n        const QPoint&amp; pos,\n        Qt::WindowFrameSection&amp; section,\n        QGraphicsWidget*&amp; widget,\n        QPoint&amp; correctedPos) const;\n\n    QGraphicsWidget* resizableWidgetAtPos(\n        QGraphicsView* view,\n        const QPoint&amp; pos\n    ) const;\n\n    Qt::WindowFrameSection queryFrameSection(\n        QGraphicsView* view,\n        QGraphicsWidget* widget,\n        const QPoint&amp; pos,\n        qreal effectRadius) const;\n\n    WidgetsList getAffectedWidgets(QWidget* viewport, const QPoint&amp; pos) const;\n\nprivate:\n    friend class ResizingInfo;\n\n    qreal m_innerEffectRadius;\n    qreal m_outerEffectRadius;\n\n    QPointF m_startPinPoint;\n    QSizeF m_startSize;\n    QTransform m_startTransform;\n    bool m_resizingStartedEmitted;\n    Qt::WindowFrameSection m_section;\n    QGraphicsWidgetPtr m_widget;\n    ConstrainedGeometrically* m_constrained;\n\n    bool m_cursorOverridden = false;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rotation_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rotation_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rotation_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_ROTATION_INSTRUMENT_H\n#define QN_ROTATION_INSTRUMENT_H\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass QGraphicsWidget;\n\nclass RotationItem;\n\nclass RotationInstrument: public DragProcessingInstrument {\n    Q_OBJECT;\n\n    typedef DragProcessingInstrument base_type;\npublic:\n    RotationInstrument(QObject *parent = nullptr);\n    virtual ~RotationInstrument();\n\n    qreal rotationItemZValue() const {\n        return m_rotationItemZValue;\n    }\n\n    void setRotationItemZValue(qreal rotationItemZValue);\n\npublic slots:\n    void start(QGraphicsWidget *target);\n    void start(QGraphicsView *view, QGraphicsWidget *target);\n\n    /* Use DragProcessingInstrument::reset to stop rotation. */\n\nsignals:\n    void rotationProcessStarted(QGraphicsView *view, QGraphicsWidget *widget);\n    void rotationStarted(QGraphicsView *view, QGraphicsWidget *widget);\n    void rotationFinished(QGraphicsView *view, QGraphicsWidget *widget);\n    void rotationProcessFinished(QGraphicsView *view, QGraphicsWidget *widget);\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n\n    virtual bool mousePressEvent(QWidget *viewport, QMouseEvent *event) override;\n    virtual bool paintEvent(QWidget *viewport, QPaintEvent *event) override;\n\n    virtual void startDragProcess(DragInfo *info) override;\n    virtual void startDrag(DragInfo *info) override;\n    virtual void dragMove(DragInfo *info) override;\n    virtual void finishDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\nprivate:\n    RotationItem *rotationItem() const;\n    QGraphicsWidget *target() const;\n\n    void startInternal(QGraphicsView *view, QMouseEvent *event, QGraphicsWidget *target, bool instantStart);\n\nprivate:\n    QPointer&lt;RotationItem&gt; m_rotationItem;\n    QPointer&lt;QGraphicsWidget&gt; m_target;\n    bool m_rotationStartedEmitted;\n    qreal m_originAngle;\n    qreal m_lastRotation;\n    qreal m_rotationItemZValue;\n    QPointF m_sceneOrigin;\n};\n\n#endif // QN_ROTATION_INSTRUMENT_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rubber_band_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rubber_band_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rubber_band_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_RUBBER_BAND_INSTRUMENT_H\n#define QN_RUBBER_BAND_INSTRUMENT_H\n\n#include &lt;QtCore/QPoint&gt;\n#include &lt;QtCore/QRect&gt;\n#include &lt;QtCore/QScopedPointer&gt;\n#include &lt;QtCore/QSet&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass QGraphicsItem;\n\nclass RubberBandItem;\n\nclass RubberBandInstrument: public DragProcessingInstrument {\n    Q_OBJECT;\n\n    typedef DragProcessingInstrument base_type;\n\npublic:\n    RubberBandInstrument(QObject *parent);\n    virtual ~RubberBandInstrument();\n\n    qreal rubberBandZValue() const {\n        return m_rubberBandZValue;\n    }\n\n    void setRubberBandZValue(qreal rubberBandZValue);\n\nsignals:\n    void rubberBandProcessStarted(QGraphicsView *view);\n    void rubberBandStarted(QGraphicsView *view);\n    void rubberBandFinished(QGraphicsView *view);\n    void rubberBandProcessFinished(QGraphicsView *view);\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n\n    virtual bool mousePressEvent(QWidget *viewport, QMouseEvent *event) override;\n    virtual bool paintEvent(QWidget *viewport, QPaintEvent *event) override;\n    virtual bool focusOutEvent(QGraphicsView *view, QFocusEvent *event) override;\n\n    virtual void startDragProcess(DragInfo *info) override;\n    virtual void startDrag(DragInfo *info) override;\n    virtual void dragMove(DragInfo *info) override;\n    virtual void finishDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\n    static QSet&lt;QGraphicsItem *&gt; toSet(QList&lt;QGraphicsItem *&gt; items);\n\n    RubberBandItem *rubberBand() const;\n\nprivate slots:\n    void at_scene_selectionChanged();\n\nprivate:\n    /* Rubber band item. */\n    QPointer&lt;RubberBandItem&gt; m_rubberBand;\n\n    /** Set of items that were selected when rubber banding has started.\n     *\n     * Note that it is unsafe to store pointers as items may get deleted before\n     * they are used. However, this scenario is extremely rare, so we don&#x27;t handle it. */\n    QSet&lt;QGraphicsItem *&gt; m_originallySelected;\n\n    /** Whether the original selection needs to be restored. */\n    bool m_protectSelection;\n\n    /** Whether the control is currently inside selection change handler. */\n    bool m_inSelectionChanged;\n\n    /** Z value of the rubber band item. */\n    qreal m_rubberBandZValue;\n};\n\n#endif // QN_RUBBER_BAND_INSTRUMENT_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/selection_overlay_tune_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/selection_overlay_tune_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/selection_overlay_tune_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QPointer&gt;\n\n#include &quot;instrument.h&quot;\n\nclass QnResourceWidget;\n\n/**\n * This instrument implements some corrections to when selection overlay\n * (the blue tint that you get for selected items) is displayed.\n *\n * Generally, selection overlay is not displayed when there is only one item\n * selected, but there are exceptions.\n */\nclass SelectionOverlayTuneInstrument: public Instrument {\n    Q_OBJECT;\n    typedef Instrument base_type;\n\npublic:\n    SelectionOverlayTuneInstrument(QObject *parent = nullptr);\n\n    virtual ~SelectionOverlayTuneInstrument();\n\nprotected slots:\n    void at_scene_selectionChanged();\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n    virtual void enabledNotify() override;\n    virtual void aboutToBeDisabledNotify() override;\n    virtual bool registeredNotify(QGraphicsItem *item) override;\n    virtual void unregisteredNotify(QGraphicsItem *item) override;\n\n    QnResourceWidget *singleSelectedWidget();\n\n    void showSelectedOverlay(QnResourceWidget *widget, bool show);\n\nprivate:\n    QPointer&lt;QnResourceWidget&gt; m_singleSelectedWidget;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/wheel_zoom_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/wheel_zoom_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/wheel_zoom_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtWidgets/QWidget&gt;\n\n#include &lt;ui/processors/kinetic_processor.h&gt;\n\n#include &quot;instrument.h&quot;\n\n/**\n * Wheel zoom instrument implements scene zooming with a mouse wheel.\n *\n * It is to be installed after a scene forwarding instrument.\n */\nclass WheelZoomInstrument: public Instrument, protected KineticProcessHandler\n{\n    Q_OBJECT\n\npublic:\n    WheelZoomInstrument(QObject *parent);\n    virtual ~WheelZoomInstrument();\n\n    void emulate(qreal degrees);\n\nprotected:\n    virtual void aboutToBeDisabledNotify() override;\n\n    virtual bool wheelEvent(QWidget *viewport, QWheelEvent *event) override;\n    virtual bool wheelEvent(QGraphicsScene *scene, QGraphicsSceneWheelEvent *event) override;\n\n    virtual void kineticMove(const QVariant &amp;degrees) override;\n    virtual void finishKinetic() override;\n\nprivate:\n    QPointer&lt;QWidget&gt; m_currentViewport;\n    QPoint m_viewportAnchor;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/zoom_window_instrument.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/zoom_window_instrument.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/zoom_window_instrument.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n\n#include &quot;drag_processing_instrument.h&quot;\n\nclass FixedArSelectionItem;\nclass ZoomOverlayWidget;\nclass ZoomWindowWidget;\nclass ResizingInfo;\nclass ResizingInstrument;\nclass QnResourceWidget;\nclass QnMediaResourceWidget;\n\nclass ZoomWindowInstrument:\n    public DragProcessingInstrument,\n    public nx::vms::client::desktop::WindowContextAware\n{\n    Q_OBJECT\n    using base_type = DragProcessingInstrument;\n\npublic:\n    ZoomWindowInstrument(\n        nx::vms::client::desktop::WindowContext* windowContext,\n        QObject *parent = nullptr);\n    virtual ~ZoomWindowInstrument();\n\nsignals:\n    void zoomRectCreated(QnMediaResourceWidget *widget, const QColor &amp;color, const QRectF &amp;zoomRect);\n    void zoomRectChanged(QnMediaResourceWidget *widget, const QRectF &amp;zoomRect);\n    void zoomTargetChanged(QnMediaResourceWidget *widget, const QRectF &amp;zoomRect, QnMediaResourceWidget *zoomTargetWidget);\n\n    void zoomWindowProcessStarted(QnMediaResourceWidget *widget);\n    void zoomWindowStarted(QnMediaResourceWidget *widget);\n    void zoomWindowFinished(QnMediaResourceWidget *widget);\n    void zoomWindowProcessFinished(QnMediaResourceWidget *widget);\n\nprotected:\n    virtual void installedNotify() override;\n    virtual void aboutToBeUninstalledNotify() override;\n    virtual bool registeredNotify(QGraphicsItem *item) override;\n    virtual void unregisteredNotify(QGraphicsItem *item) override;\n\n    virtual bool mousePressEvent(QWidget* viewport, QMouseEvent*event) override;\n    virtual bool mousePressEvent(QGraphicsItem* item, QGraphicsSceneMouseEvent* event) override;\n    virtual bool mouseMoveEvent(QWidget* viewport, QMouseEvent* event) override;\n\n    virtual void startDragProcess(DragInfo *info) override;\n    virtual void startDrag(DragInfo *info) override;\n    virtual void dragMove(DragInfo *info) override;\n    virtual void finishDrag(DragInfo *info) override;\n    virtual void finishDragProcess(DragInfo *info) override;\n\nprivate:\n    void at_windowWidget_geometryChanged();\n    void at_windowWidget_doubleClicked();\n\n    void at_display_widgetChanged(Qn::ItemRole role);\n    void at_display_zoomLinkAdded(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n    void at_display_zoomLinkAboutToBeRemoved(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n\n    void at_resizingStarted(QGraphicsView *view, QGraphicsWidget *widget, ResizingInfo *info);\n    void at_resizing(QGraphicsView *view, QGraphicsWidget *widget, ResizingInfo *info);\n    void at_resizingFinished(QGraphicsView *view, QGraphicsWidget *widget, ResizingInfo *info);\n\n    /** Called when layout access parameters has changed. */\n    void at_layoutAccessChanged();\n\nprivate:\n    QColor nextZoomWindowColor() const;\n\n    QPointer&lt;ZoomOverlayWidget&gt; overlayWidget(QnMediaResourceWidget *widget) const;\n    QPointer&lt;ZoomOverlayWidget&gt; ensureOverlayWidget(QnMediaResourceWidget *widget);\n    QPointer&lt;ZoomWindowWidget&gt; windowWidget(QnMediaResourceWidget *widget) const;\n\n    QPointer&lt;QnMediaResourceWidget&gt; target() const;\n\n    QPointer&lt;ZoomWindowWidget&gt; windowTarget() const;\n\n    QPointer&lt;FixedArSelectionItem&gt; selectionItem() const;\n    void ensureSelectionItem();\n\n    void registerWidget(QnMediaResourceWidget *widget);\n    void unregisterWidget(QnMediaResourceWidget *widget);\n    void registerLink(QnMediaResourceWidget* widget, QnMediaResourceWidget* zoomTargetWidget);\n    void unregisterLink(QnMediaResourceWidget* widget, bool deleteWindowWidget = true);\n\n    void updateOverlayMode(QnMediaResourceWidget *widget);\n    void updateWindowFromWidget(QnMediaResourceWidget *widget);\n    void updateWidgetFromWindow(ZoomWindowWidget *windowWidget);\n\nprivate:\n    struct ZoomData\n    {\n        QPointer&lt;ZoomOverlayWidget&gt; overlayWidget;\n        QPointer&lt;ZoomWindowWidget&gt; windowWidget;\n    };\n\n    bool m_zoomWindowStartedEmitted;\n    QPointer&lt;ResizingInstrument&gt; m_resizingInstrument;\n    QPointer&lt;FixedArSelectionItem&gt; m_selectionItem;\n    QPointer&lt;QWidget&gt; m_viewport;\n    QColor m_zoomWindowColor;\n    /** Cached value for selected widget. */\n    QPointer&lt;QnMediaResourceWidget&gt; m_target;\n    /** Maps zoomed widget to a pair of overlay/zoom rectangle. */\n    QHash&lt;QObject*, ZoomData&gt; m_dataByWidget;\n    QSet&lt;QObject*&gt; m_processingWidgets;\n    QPointer&lt;QnMediaResourceWidget&gt; m_zoomedWidget;\n    QPointer&lt;ZoomWindowWidget&gt; m_windowTarget;\n    QPointer&lt;ZoomWindowWidget&gt; m_storedWindowWidget;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/grid/grid_item.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/grid/grid_item.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/grid/grid_item.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_GRID_ITEM_H\n#define QN_GRID_ITEM_H\n\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtWidgets/QGraphicsObject&gt;\n\n#include &lt;ui/animation/animated.h&gt;\n#include &lt;ui/utils/viewport_scale_watcher.h&gt;\n#include &lt;utils/common/hash.h&gt; /* For qHash(QPoint). */\n\nclass AnimationTimer;\n\nclass QnWorkbenchGridMapper;\nclass VariantAnimator;\nclass QnGridHighlightItem;\n\nclass QnGridItem: public Animated&lt;QGraphicsObject&gt;\n{\n    Q_OBJECT\n\n    typedef Animated&lt;QGraphicsObject&gt; base_type;\n\npublic:\n    enum CellState {\n        Initial,\n        Allowed,\n        Disallowed,\n        Custom\n    };\n\n    QnGridItem(QGraphicsItem *parent = nullptr);\n\n    virtual ~QnGridItem();\n\n    virtual QRectF boundingRect() const override;\n\n    QnWorkbenchGridMapper *mapper() const;\n    void setMapper(QnWorkbenchGridMapper *mapper);\n\n    QColor stateColor(int cellState) const;\n\n    int cellState(const QPoint &amp;cell) const;\n    void setCellState(const QPoint &amp;cell, int cellState);\n    void setCellState(const QSet&lt;QPoint&gt; &amp;cells, int cellState);\n    void setCellState(const QRect &amp;cells, int cellState);\n    void setCellState(const QList&lt;QRect&gt; &amp;cells, int cellState);\n\nprotected:\n    virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;\n\n    QnGridHighlightItem *newHighlightItem();\n\n    QPoint itemCell(QnGridHighlightItem *item) const;\n    void setItemCell(QnGridHighlightItem *item, const QPoint &amp;cell) const;\n    VariantAnimator *itemAnimator(QnGridHighlightItem *item);\n\nprotected slots:\n    void at_itemAnimator_finished();\n\nprivate:\n    QVariant itemChange(GraphicsItemChange change, const QVariant&amp; value) override;\n\nprivate:\n    struct PointData {\n        PointData(): state(Initial), item(nullptr) {}\n\n        int state;\n        QnGridHighlightItem *item;\n    };\n\n    QRectF m_boundingRect;\n    QPointer&lt;QnWorkbenchGridMapper&gt; m_mapper;\n    qreal m_lineWidth = 0.0;\n    QHash&lt;int, QColor&gt; m_colorByState;\n    QHash&lt;QPoint, PointData&gt; m_dataByCell;\n    QList&lt;QnGridHighlightItem *&gt; m_freeItems;\n    QnViewportScaleWatcher m_scaleWatcher;\n};\n\n\n#endif // QN_GRID_ITEM_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/overlays/overlayed.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/overlays/overlayed.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/overlays/overlayed.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_OVERLAYED_H\n#define QN_OVERLAYED_H\n\n#include &lt;QtCore/QEvent&gt;\n#include &lt;QtWidgets/QGraphicsItem&gt;\n\n#include &lt;ui/common/fixed_rotation.h&gt;\n#include &lt;utils/common/forward.h&gt;\n\ntemplate&lt;class Base&gt;\nclass Overlayed;\n\nclass QnViewportBoundWidget;\n\nnamespace detail {\n\nstruct OverlayParams;\n\nclass OverlayedBase\n{\npublic:\n    // TODO: #sivanov Refactoring needed.\n    enum OverlayVisibility\n    {\n        Invisible,\n        Visible,\n        AutoVisible,\n        UserVisible,\n    };\n\n    enum OverlayLayer\n    {\n        BaseLayer = 0,\n        StatusLayer,\n        SelectionLayer,\n        RewindLayer,\n        InfoLayer,\n        TopControlsLayer,\n    };\n\n    enum class OverlayFlag\n    {\n        none = 0,\n        autoRotate = 0x01,\n        bindToViewport = 0x02\n    };\n    Q_DECLARE_FLAGS(OverlayFlags, OverlayFlag)\n\n    bool isOverlayVisible() const;\n    void setOverlayVisible(bool visible, bool animate);\n\n    void addOverlayWidget(QGraphicsWidget* widget, const OverlayParams&amp; params);\n\n    void removeOverlayWidget(QGraphicsWidget* widget);\n\n    OverlayVisibility overlayWidgetVisibility(QGraphicsWidget* widget) const;\n    void setOverlayWidgetVisibility(\n        QGraphicsWidget* widget,\n        OverlayVisibility visibility,\n        bool animate);\n    void updateOverlayWidgetsVisibility(bool animate);\n\n    void updateOverlayWidgetMargins(const QGraphicsWidget* widget, const QMargins&amp; margins);\n\n    static void setOverlayWidgetVisible(QGraphicsWidget* widget, bool visible, bool animate);\n    static bool isOverlayWidgetVisible(QGraphicsWidget* widget);\n\nprivate:\n    template&lt;class Base&gt;\n    friend class ::Overlayed;\n\n    void initOverlayed(QGraphicsWidget* widget);\n\n    int overlayWidgetIndex(QGraphicsWidget* widget) const;\n\n    void updateOverlaysRotation();\n    void updateOverlayWidgetsGeometry();\n\nprivate:\n    struct OverlayWidget\n    {\n        OverlayVisibility visibility;\n        QGraphicsWidget* widget;\n        QGraphicsWidget* childWidget;\n        QnViewportBoundWidget* boundWidget;\n        QnFixedRotationTransform* rotationTransform;\n\n        OverlayWidget();\n    };\n\n    QGraphicsWidget* m_widget;\n\n    /** List of overlay widgets. */\n    QList&lt;OverlayWidget&gt; m_overlayWidgets;\n\n    bool m_overlayVisible;\n\n    /** Fixed rotation angle in degrees. Used to rotate static text and images. */\n    nx::vms::client::core::Rotation m_overlayRotation;\n};\n\nstruct OverlayParams\n{\n    OverlayedBase::OverlayVisibility visibility;\n    OverlayedBase::OverlayFlags flags;\n    qreal z;\n    QMarginsF margins;\n\n    OverlayParams(\n        OverlayedBase::OverlayVisibility visibility = OverlayedBase::UserVisible,\n        OverlayedBase::OverlayFlags = OverlayedBase::OverlayFlag::none,\n        qreal z = OverlayedBase::BaseLayer,\n        const QMarginsF &amp;margins = QMarginsF());\n};\n\nQ_DECLARE_OPERATORS_FOR_FLAGS(OverlayedBase::OverlayFlags);\n\n} // namespace detail\n\n\ntemplate&lt;class Base&gt;\nclass Overlayed: public Base, public detail::OverlayedBase {\n    typedef Base base_type;\n\npublic:\n    QN_FORWARD_CONSTRUCTOR(Overlayed, Base, { initOverlayed(this); });\n\n    virtual ~Overlayed() { }\nprotected:\n    virtual QVariant itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant &amp;value) override {\n        if (change == QGraphicsItem::ItemRotationHasChanged) {\n            updateOverlaysRotation();\n        }\n        return base_type::itemChange(change, value);\n    }\n\n    virtual void setGeometry(const QRectF &amp;geometry) override {\n        base_type::setGeometry(geometry);\n        updateOverlayWidgetsGeometry();\n    }\n};\n\n\n#endif // QN_OVERLAYED_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/media_resource_widget.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/media_resource_widget.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/media_resource_widget.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;functional&gt;\n\n#include &lt;QtCore/QByteArray&gt;\n#include &lt;QtCore/QHash&gt;\n#include &lt;QtGui/QStaticText&gt;\n\n#include &lt;api/server_rest_connection_fwd.h&gt;\n#include &lt;camera/camera_bookmarks_manager_fwd.h&gt;\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/ptz/ptz_fwd.h&gt;\n#include &lt;core/resource/camera_bookmark_fwd.h&gt;\n#include &lt;core/resource/motion_window.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/core/watermark/watermark.h&gt;\n#include &lt;nx/media/sse_helper.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/api/data/dewarping_data.h&gt;\n#include &lt;nx/vms/api/data/image_correction_data.h&gt;\n#include &lt;nx/vms/client/core/camera/iomodule/io_module_monitor.h&gt;\n#include &lt;nx/vms/client/core/common/data/motion_selection.h&gt;\n#include &lt;nx/vms/client/core/media/abstract_analytics_metadata_provider.h&gt;\n#include &lt;nx/vms/client/core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/camera/camera_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/help/help_topic.h&gt;\n#include &lt;nx/vms/client/desktop/ui/graphics/items/overlays/figure/types.h&gt;\n#include &lt;nx/vms/common/ptz/datafield.h&gt;\n#include &lt;nx/vms/event/event_fwd.h&gt;\n#include &lt;ui/common/speed_range.h&gt;\n#include &lt;ui/graphics/items/resource/button_ids.h&gt;\n\n#include &quot;nx/vms/client/core/skin/skin.h&quot;\n#include &quot;resource_widget.h&quot;\n\nstruct QnMetaDataV1;\nusing QnMetaDataV1Ptr = std::shared_ptr&lt;QnMetaDataV1&gt;;\n\nnamespace nx::vms::client::core { class RecordingStatusHelper; }\n\nnamespace nx::vms::client::desktop {\n\nclass VoiceSpectrumPainter;\nclass MediaResourceWidgetPrivate;\nclass AnalyticsOverlayWidget;\nclass AreaSelectOverlayWidget;\nclass RoiFiguresOverlayWidget;\nclass AudioSpectrumOverlayWidget;\nclass WatermarkPainter;\nclass SoftwareTriggerButton;\nclass EncryptedArchivePasswordDialog;\nclass CameraHotspotsOverlayWidget;\nclass CameraButtonManager;\nclass BlurMask;\n\n} // namespace nx::vms::client::desktop\n\nclass QnCamDisplay;\nclass QnResourceDisplay;\nclass QnResourceWidgetRenderer;\nclass QnIoModuleOverlayWidget;\nclass QnScrollableItemsWidget;\nclass QnScrollableTextItemsWidget;\nclass QnGraphicsStackedWidget;\n\nstruct QnHtmlTextItemOptions;\n\nnamespace nx::analytics::db { struct Filter; }\n\n/**\n * Widget to show media from a camera or disk file (from QnMediaResource).\n */\nclass QnMediaResourceWidget: public QnResourceWidget\n{\n    Q_OBJECT\n    typedef QnResourceWidget base_type;\n    using MotionSelection = nx::vms::client::core::MotionSelection;\n\npublic:\n    enum class PtzEnabledBy\n    {\n        nothing,\n        joystick,\n        user\n    };\n\npublic:\n    QnMediaResourceWidget(\n        nx::vms::client::desktop::SystemContext* systemContext,\n        nx::vms::client::desktop::WindowContext* windowContext,\n        QnWorkbenchItem* item,\n        QGraphicsItem* parent = nullptr);\n    virtual ~QnMediaResourceWidget();\n\n    /**\n     * Disconnect all data changes handlers to avoid unneeded processing while saving layout state.\n     */\n    void beforeDestroy();\n\n    /**\n     * @return Resource associated with this widget.\n     */\n    const QnMediaResourcePtr&amp; resource() const;\n\n    /**\n     * @return Display associated with this widget.\n     */\n    QnResourceDisplayPtr display() const;\n\n    /** CamDisplay for the widget display (if exists). */\n    QnCamDisplay* camDisplay() const;\n\n    QnResourceWidgetRenderer* renderer() const;\n\n    /** Returns default camera rotation angle or 0 if does not exist or invalid. */\n    int defaultRotation() const;\n\n    /** Returns default camera rotation plus fisheye rotation if needed. */\n    int defaultFullRotation() const;\n\n    /**\n     * @param itemPos Point in item coordinates to map to grid coordinates.\n     * @return Coordinates of the motion cell that the given point belongs to. Note that motion\n     *     grid is finite, so even if the passed coordinate lies outside the item boundary, the\n     *     returned joint will lie inside it.\n     */\n    QPoint mapToMotionGrid(const QPointF&amp; itemPos);\n\n    /**\n     * @param gridPos Coordinate of the motion grid cell.\n     * @return Position in scene coordinates of the top left corner of the grid cell.\n     */\n    QPointF mapFromMotionGrid(const QPoint&amp; gridPos);\n\n    /**\n     * @param gridRect Rectangle in grid coordinates to add to the selected motion region of this\n     *     widget.\n     */\n    void addToMotionSelection(const QRect&amp; gridRect);\n\n    /**\n     * Clears this widget&#x27;s motion selection region.\n     */\n    void clearMotionSelection(bool sendMotionChanged = true);\n\n    bool isMotionSelectionEmpty() const;\n\n    void setMotionSelection(const MotionSelection&amp; regions);\n\n    /**\n     * Current motion selection regions.\n     */\n    const MotionSelection&amp; motionSelection() const;\n\n    nx::vms::api::ImageCorrectionData imageEnhancement() const;\n    void setImageEnhancement(const nx::vms::api::ImageCorrectionData&amp; imageEnhancement);\n\n    /**\n     * @return PTZ controller associated with this widget. Never returns null.\n     */\n    QnPtzControllerPtr ptzController() const;\n\n    bool supportsBasicPtz() const;\n    bool canControlPtzFocus() const;\n    bool canControlPtzMove() const;\n    bool canControlPtzZoom() const;\n\n    nx::vms::api::dewarping::MediaData dewarpingParams() const;\n    void setDewarpingParams(const nx::vms::api::dewarping::MediaData&amp; params);\n\n    bool dewarpingApplied() const;\n\n    /** Check if the widget has video. It can be absent in I/O Module, for example. */\n    bool hasVideo() const;\n\n    QnScrollableTextItemsWidget* bookmarksContainer();\n\n    void hideTextOverlay(const nx::Uuid&amp; id);\n    void showTextOverlay(\n        const nx::Uuid&amp; id,\n        const QString&amp; text,\n        const QnHtmlTextItemOptions&amp; options);\n\n    void setZoomWindowCreationModeEnabled(bool enabled);\n    void setMotionSearchModeEnabled(bool enabled);\n    bool isMotionSearchModeEnabled() const;\n\n    void setPtzMode(bool value);\n\n    PtzEnabledBy ptzActivationReason();\n    void setPtzActivationReason(PtzEnabledBy reason);\n\n    QnSpeedRange speedRange() const;\n    static const QnSpeedRange&amp; availableSpeedRange();\n\n    bool isScheduleEnabled() const;\n\n    bool isRoiVisible() const;\n    void setRoiVisible(bool visible, bool animate);\n\n    bool isAnalyticsSupported() const;\n\n    bool isAnalyticsObjectsVisible() const;\n    void setAnalyticsObjectsVisible(bool visible, bool animate = true);\n    bool isAnalyticsObjectsVisibleForcefully() const;\n    /**\n     * The same as setAnalyticsObjectsVisible, but the state cannot be deactivated by\n     * setAnalyticsObjectsVisible and it is not saved in the layout.\n     * Useful to temporarily enable objects display, e.g. when analytics search is enabled in the\n     * application.\n     */\n    void setAnalyticsObjectsVisibleForcefully(bool visible, bool animate = true);\n\n    bool isAnalyticsModeEnabled() const;\n\n    bool canDisplayHotspots() const;\n\n    bool hotspotsVisible() const;\n    void setHotspotsVisible(bool visible);\n\n    enum class AreaType\n    {\n        none,\n        motion,\n        analytics\n    };\n\n    AreaType areaSelectionType() const;\n    void setAreaSelectionType(AreaType value);\n    void unsetAreaSelectionType(AreaType value);\n\n    bool areaSelectionEnabled() const;\n    void setAreaSelectionEnabled(bool value);\n    void setAreaSelectionEnabled(AreaType areaType, bool value);\n    QRectF analyticsFilterRect() const;\n    void setAnalyticsFilterRect(const QRectF&amp; value);\n\n    nx::vms::client::core::AbstractAnalyticsMetadataProviderPtr analyticsMetadataProvider() const;\n\n    void setAnalyticsFilter(const nx::analytics::db::Filter&amp; value);\n\n    bool isPlayingLive() const;\n\n    void setPosition(qint64 timestampMs);\n    std::chrono::milliseconds position() const;\n\n    void setSpeed(double value);\n    double speed() const;\n\n    nx::vms::client::core::IOModuleMonitorPtr getIOModuleMonitor();\n\n    bool isTitleUnderMouse() const;\n\n    nx::vms::client::desktop::RewindOverlay* rewindOverlay() const;\n\n    bool hasAudio() const;\n    bool canBeMuted() const;\n    bool isMuted() const;\n    void setMuted(bool muted);\n\n    void updateAudioPlaybackState();\n\nsignals:\n    void speedChanged();\n    void motionSelectionChanged();\n    void areaSelectionTypeChanged();\n    void areaSelectionEnabledChanged();\n    void analyticsFilterRectChanged();\n    void areaSelectionFinished();\n    void displayChanged();\n    void fisheyeChanged();\n    void dewarpingParamsChanged();\n    void colorsChanged();\n    void positionChanged(qint64 positionUtcMs);\n    void motionSearchModeEnabled(bool enabled);\n    void zoomWindowCreationModeEnabled(bool enabled);\n    void licenseStatusChanged();\n    void ptzControllerChanged();\n    void analyticsSupportChanged();\n    void analyticsObjectsVisibleForcefullyChanged();\n\nprotected:\n    virtual int helpTopicAt(const QPointF&amp; pos) const override;\n\n    virtual void channelLayoutChangedNotify() override;\n    virtual void channelScreenSizeChangedNotify() override;\n    virtual void optionsChangedNotify(Options changedFlags) override;\n\n    virtual QString calculateDetailsText() const override;\n    virtual QString calculatePositionText() const override;\n    virtual QString calculateTitleText() const override;\n    virtual int calculateButtonsVisibility() const override;\n    virtual Qn::ResourceStatusOverlay calculateStatusOverlay() const override;\n\n    virtual Qn::ResourceOverlayButton calculateOverlayButton(\n        Qn::ResourceStatusOverlay statusOverlay) const override;\n\n    virtual QString overlayCustomButtonText(\n        Qn::ResourceStatusOverlay statusOverlay) const override;\n\n    virtual void paint(\n        QPainter* painter,\n        const QStyleOptionGraphicsItem* option,\n        QWidget* widget) override;\n\n    virtual Qn::RenderStatus paintChannelBackground(\n        QPainter* painter,\n        int channel,\n        const QRectF&amp; channelRect,\n        const QRectF&amp; paintRect) override;\n\n    virtual void paintChannelForeground(\n        QPainter* painter,\n        int channel,\n        const QRectF&amp; rect) override;\n\n    virtual void paintEffects(QPainter* painter) override;\n\n    void paintMotionGrid(\n        QPainter* painter,\n        int channel,\n        const QRectF&amp; rect,\n        const QnMetaDataV1Ptr&amp; motion);\n\n    void paintWatermark(QPainter* painter, const QRectF&amp; rect);\n\n    void paintFilledRegionPath(\n        QPainter* painter,\n        const QRectF&amp; rect,\n        const QPainterPath&amp; path,\n        const QColor&amp; color,\n        const QColor&amp; penColor);\n\n    void paintProgress(QPainter* painter, const QRectF&amp; rect, int progress);\n\n    void paintAnalyticsObjectsDebugOverlay(\n        std::chrono::milliseconds timestamp,\n        QPainter* painter,\n        const QRectF&amp; rect);\n\n    void ensureMotionSelectionCache();\n    void invalidateMotionSelectionCache();\n\n    QSize motionGridSize() const;\n    QPoint channelGridOffset(int channel) const;\n\n    Q_SIGNAL void updateInfoTextLater();\n\n    void suspendHomePtzController();\n    void resumeHomePtzController();\n\n    virtual bool forceShowPosition() const override;\n    virtual void updateHud(bool animate) override;\n\n    bool animationAllowed() const;\n\n    rest::Handle invokeTrigger(\n        const QString&amp; id,\n        std::function&lt;void(bool, rest::Handle)&gt; resultHandler,\n        nx::vms::api::EventState toggleState = nx::vms::api::EventState::undefined);\n\n    void setAnalyticsModeEnabled(bool enabled, bool animate);\n\n    virtual void atItemDataChanged(int role) override;\n\n    nx::vms::client::core::CameraResourcePtr camera() const;\n\nprivate slots:\n    void at_resource_propertyChanged(const QnResourcePtr&amp; resource, const QString&amp; key);\n    void at_screenshotButton_clicked();\n    void at_fishEyeButton_toggled(bool checked);\n    void at_imageEnhancementButton_toggled(bool checked);\n    void at_ioModuleButton_toggled(bool checked);\n    void at_camDisplay_liveChanged();\n    void processSettingsRequest();\n    void processDiagnosticsRequest();\n    void processEnableLicenseRequest();\n    void processMoreLicensesRequest();\n    void processEncryptedArchiveUnlockRequst();\n    void processAuthorizationRequest();\n    void processCloudAuthorizationRequest();\n    void processSetUp2FARequest();\n    void at_renderWatcher_widgetChanged(QnResourceWidget* widget);\n    void at_zoomRectChanged();\n    void at_ptzController_changed(nx::vms::common::ptz::DataFields fields);\n\n    void at_item_imageEnhancementChanged();\n    void at_videoLayoutChanged();\n\nprivate:\n    void handleItemDataChanged(const nx::Uuid&amp; id, int role, const QVariant&amp; data);\n    void handleDewarpingParamsChanged();\n\n    void setDisplay(const QnResourceDisplayPtr&amp; display);\n    void createButtons();\n\n    void updatePtzController();\n\n    qreal calculateVideoAspectRatio() const;\n\n    void updateDisplay();\n    void updateAspectRatio();\n    void updateIconButton();\n    void updateRendererEnabled();\n    void updateFisheye();\n    void updateDewarpingParams();\n    void updateCustomAspectRatio();\n    void updateIoModuleVisibility(bool animate);\n    void updateAnalyticsVisibility(bool animate = false);\n    void handleSyncStateChanged(bool enabled);\n    void updateHotspotsState();\n\n    void updateCompositeOverlayMode();\n\n    qint64 getUtcCurrentTimeUsec() const;\n    qint64 getUtcCurrentTimeMs() const;\n\n    void updateCurrentUtcPosMs();\n\n    void updateZoomWindowDewarping();\n\n    void setupHud();\n\n    void setTextOverlayParameters(\n        const nx::Uuid&amp; id,\n        bool visible,\n        const QString&amp; text,\n        const QnHtmlTextItemOptions&amp; options);\n\n    Qn::RenderStatus paintVideoTexture(\n        QPainter* painter,\n        int channel,\n        const QRectF&amp; sourceSubRect,\n        const QRectF&amp; targetRect);\n\nprivate:\n    struct SoftwareTriggerInfo\n    {\n        nx::Uuid ruleId;\n        QString name;\n        QString icon;\n        bool enabled = false;\n        bool prolonged = false;\n        std::function&lt;void()&gt; clientSideHandler;\n    };\n\n    void initRenderer();\n    void initDisplay();\n    void initBlurMask();\n    void initIoModuleOverlay();\n    void initAreaSelectOverlay();\n    void initAnalyticsOverlays();\n    void initStatusOverlayController();\n    void initCameraHotspotsOverlay();\n    void initAudioSpectrumOverlay();\n\n    bool mightShowAudioSpectrum() const;\n    bool shouldShowAudioSpectrum() const;\n\n    void updateWatermark();\n\n    using ButtonHandler = void (QnMediaResourceWidget::*)(bool checked);\n    QAction* createActionAndButton(\n        const nx::vms::client::core::ColorizedIconDeclaration&amp; iconDecl,\n        bool checked,\n        const QKeySequence&amp; shortcut,\n        const QString&amp; toolTip,\n        nx::vms::client::desktop::HelpTopic::Id helpTopic,\n        Qn::WidgetButtons buttonId,\n        const QString&amp; buttonName,\n        ButtonHandler executor);\n\n    void updateSelectedArea();\n    void handleSelectedAreaChanged();\n\nprivate:\n    nx::utils::ImplPtr&lt;nx::vms::client::desktop::MediaResourceWidgetPrivate&gt; d;\n\n    /** Associated renderer. */\n    QnResourceWidgetRenderer* m_renderer = nullptr;\n\n    std::unique_ptr&lt;nx::vms::client::desktop::BlurMask&gt; m_blurMask;\n\n    /** Selected region for search-by-motion, in parrots. */\n    MotionSelection m_motionSelection;\n\n    /** Painter path cache for the list of selected regions. */\n    QVector&lt;QPainterPath&gt; m_motionSelectionPathCache;\n\n    QVector&lt;bool&gt; m_paintedChannels;\n\n    /** Whether motion selection cached paths are valid. */\n    mutable bool m_motionSelectionCacheValid = false;\n\n    nx::vms::client::core::RecordingStatusHelper* m_recordingStatusHelper;\n\n    QnPtzControllerPtr m_ptzController;\n\n    PtzEnabledBy m_ptzActivationReason = PtzEnabledBy::nothing;\n\n    nx::vms::api::dewarping::MediaData m_dewarpingParams;\n\n    QHash&lt;Qn::ItemDataRole, QVariant&gt; m_savedItemDataState;\n\n    QnIoModuleOverlayWidget* m_ioModuleOverlayWidget = nullptr;\n    bool m_ioCouldBeShown = false;\n\n    qint64 m_posUtcMs;\n\n    QnScrollableTextItemsWidget* m_bookmarksContainer = nullptr;\n    QnScrollableTextItemsWidget* m_textOverlayWidget = nullptr;\n    QnGraphicsStackedWidget* m_compositeOverlay = nullptr;\n\n    QScopedPointer&lt;nx::vms::client::desktop::WatermarkPainter&gt; m_watermarkPainter;\n\n    nx::vms::client::desktop::RoiFiguresOverlayWidget* m_roiFiguresOverlayWidget = nullptr;\n    nx::vms::client::desktop::AnalyticsOverlayWidget* m_analyticsOverlayWidget = nullptr;\n    nx::vms::client::desktop::AreaSelectOverlayWidget* m_areaSelectOverlayWidget = nullptr;\n    QScopedPointer&lt;nx::vms::client::desktop::EncryptedArchivePasswordDialog&gt;\n        m_encryptedArchivePasswordDialog;\n    mutable QByteArray m_encryptedArchiveData;\n\n    nx::vms::client::desktop::CameraHotspotsOverlayWidget* m_cameraHotspotsOverlayWidget = nullptr;\n    nx::vms::client::desktop::AudioSpectrumOverlayWidget* m_audioSpectrumOverlayWidget = nullptr;\n\n    AreaType m_areaSelectionType{AreaType::none};\n    QRectF m_analyticsFilterRect;\n\n    nx::Uuid m_itemId;\n\n    QAction* const m_toggleImageEnhancementAction;\n    std::unique_ptr&lt;nx::vms::client::desktop::CameraButtonManager&gt; m_buttonManager;\n    bool m_muted = false;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/resource_widget.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/resource_widget.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/resource_widget.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtCore/QVector&gt;\n\n#include &lt;qt_graphics_items/graphics_widget.h&gt;\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;core/resource/resource_media_layout_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/client/desktop/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/system_context_aware.h&gt;\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n#include &lt;ui/animation/animated.h&gt;\n#include &lt;ui/common/constrained_resizable.h&gt;\n#include &lt;ui/common/fixed_rotation.h&gt;\n#include &lt;ui/common/frame_section_queryable.h&gt;\n#include &lt;ui/common/help_topic_queryable.h&gt;\n#include &lt;ui/graphics/instruments/instrumented.h&gt;\n#include &lt;ui/graphics/items/overlays/overlayed.h&gt;\n\nclass QGraphicsLinearLayout;\nclass QGraphicsScene;\n\nclass QnViewportBoundWidget;\nclass QnWorkbenchItem;\nclass QnStatusOverlayController;\nclass QnImageButtonWidget;\nclass QnImageButtonBar;\nclass QnProxyLabel;\nclass QnHtmlTextItem;\nclass QnResourceTitleItem;\nclass GraphicsLabel;\nclass QnStatusOverlayWidget;\nclass QnHudOverlayWidget;\nclass QnFixedWidthTooltipWidget;\n\nnamespace nx::vms::client::desktop { class RewindOverlay; }\n\nclass QnResourceWidget:\n    public Overlayed&lt;Animated&lt;Instrumented&lt;GraphicsWidget&gt;&gt;&gt;,\n    public nx::vms::client::desktop::SystemContextAware,\n    public nx::vms::client::desktop::WindowContextAware,\n    public ConstrainedResizable,\n    public HelpTopicQueryable\n{\n    Q_OBJECT\n    Q_PROPERTY(qreal frameOpacity READ frameOpacity WRITE setFrameOpacity)\n    Q_PROPERTY(QColor frameDistinctionColor READ frameDistinctionColor WRITE setFrameDistinctionColor)\n    Q_PROPERTY(bool localActive READ isLocalActive WRITE setLocalActive)\n    Q_PROPERTY(nx::Uuid uuid READ uuid)\n    Q_PROPERTY(QString uuidString READ uuidString)\n    Q_PROPERTY(bool isZoomWindow READ isZoomWindow)\n    Q_PROPERTY(bool selected READ isSelected WRITE setSelected)\n    Q_FLAGS(Options Option)\n\n    using base_type = Overlayed&lt;Animated&lt;Instrumented&lt;GraphicsWidget&gt;&gt;&gt;;\n\npublic:\n    enum Option\n    {\n        /** Whether selected / not selected state should be displayed. */\n        DisplaySelection = 1 &lt;&lt; 0,\n\n        // TODO: #sivanov This flag also handles smart search, separate.\n        /** Whether motion is to be displayed. */\n        DisplayMotion = 1 &lt;&lt; 1,\n\n        /** Whether info panel is to be displayed. */\n        DisplayInfo = 1 &lt;&lt; 2,\n\n        /** Whether detected analytics objects are displayed. */\n        DisplayAnalyticsObjects = 1 &lt;&lt; 3,\n\n        /** Whether regions of interest (ROI) are displayed. */\n        DisplayRoi = 1 &lt;&lt; 4,\n\n        /** Whether the video is to be dewarped. */\n        DisplayDewarped = 1 &lt;&lt; 5,\n\n        /** Whether PTZ state can be controlled. */\n        ControlPtz = 1 &lt;&lt; 6,\n\n        /** Whether zoom windows can be created by dragging the mouse. */\n        ControlZoomWindow = 1 &lt;&lt; 7,\n\n        WindowRotationForbidden = 1 &lt;&lt; 8,\n        WindowResizingForbidden = 1 &lt;&lt; 9,\n\n        FullScreenMode = 1 &lt;&lt; 10,\n        ActivityPresence = 1 &lt;&lt; 11,\n\n        AlwaysShowName = 1 &lt;&lt; 12,\n        InfoOverlaysForbidden = 1 &lt;&lt; 13,\n        AllowFocus = 1 &lt;&lt; 14,\n\n        /** Whether camera hotspots are displayed. */\n        DisplayHotspots = 1 &lt;&lt; 15,\n    };\n\n    Q_DECLARE_FLAGS(Options, Option)\n\n    enum AspectRatioFlag\n    {\n        SingleChannel           = 0x0,\n        WithRotation            = 0x01,\n        WithChannelLayout       = 0x02\n    };\n    Q_DECLARE_FLAGS(AspectRatioFlags, AspectRatioFlag)\n\n    static constexpr qreal kInvalidAspectRatio = -1.0;\n\n    enum class SelectionState\n    {\n        invalid,\n        notSelected,\n        inactiveFocused,\n        focused,\n        selected,\n        focusedAndSelected,\n    };\n\n    /**\n     * Constructor.\n     *\n     * \\param context                   Context in which this resource widget operates.\n     * \\param item                      Workbench item that this widget represents.\n     * \\param parent                    Parent item.\n     */\n    QnResourceWidget(\n        nx::vms::client::desktop::SystemContext* systemContext,\n        nx::vms::client::desktop::WindowContext* windowContext,\n        QnWorkbenchItem* item,\n        QGraphicsItem* parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~QnResourceWidget();\n\n    /**\n     * \\returns                         Resource associated with this widget.\n     */\n    const QnResourcePtr &amp;resource() const;\n\n    /** Layout resource, owning this item. */\n    nx::vms::client::core::LayoutResourcePtr layoutResource() const;\n\n    /**\n     * \\returns                         Workbench item associated with this widget. Never returns nullptr.\n     */\n    QnWorkbenchItem *item() const;\n\n    /**\n     * Layout of channels in this widget. May be empty for non-video widgets.\n     */\n    QnConstResourceVideoLayoutPtr channelLayout() const {\n        return m_channelsLayout;\n    }\n\n    /** Total count of channels in video layout (if exists). */\n    int channelCount() const;\n\n    const QRectF &amp;zoomRect() const;\n    void setZoomRect(const QRectF &amp;zoomRect);\n    QnResourceWidget *zoomTargetWidget() const;\n\n    bool isZoomWindow() const;\n\n    /**\n     * \\returns                         Frame opacity of this widget.\n     */\n    qreal frameOpacity() const;\n\n    /**\n     * \\param frameOpacity              New frame opacity for this widget.\n     */\n    void setFrameOpacity(qreal frameOpacity);\n\n    QColor frameDistinctionColor() const;\n    void setFrameDistinctionColor(const QColor &amp;frameColor);\n\n    /**\n     * \\returns                         Aspect ratio of this widget.\n     *                                  Negative value will be returned if this\n     *                                  widget does not have aspect ratio.\n     */\n    float aspectRatio() const;\n\n    void setAspectRatio(float aspectRatio);\n\n    /**\n     * \\returns                         Whether this widget has an aspect ratio.\n     */\n    bool hasAspectRatio() const;\n\n    /**\n     * \\returns                         Aspect ratio of this widget taking its rotation into account.\n     */\n    virtual float visualAspectRatio() const;\n\n    /**\n     * \\return                          Default visual aspect ratio for widgets of this type.\n     *                                  Visual aspect ratio differs from aspect ratio in that it is always valid.\n     */\n    virtual float defaultVisualAspectRatio() const;\n\n    /**\n     * \\return                          Aspect ratio of one channel.\n     */\n    float visualChannelAspectRatio() const;\n\n    /**\n     * \\returns                         Geometry of the enclosing rectangle for this widget.\n     */\n    QRectF enclosingGeometry() const;\n\n    /**\n     * Every widget is considered to be inscribed into an enclosing rectangle.\n     * Item will be inscribed even if it is rotated.\n     * \\param enclosingGeometry         Geometry of the enclosing rectangle for this widget.\n     */\n    void setEnclosingGeometry(const QRectF &amp;enclosingGeometry, bool updateGeometry = true);\n\n    /**\n     * Calculate real item geometry according to the specified enclosing geometry.\n     * \\see setEnclosingGeometry\n     */\n    QRectF calculateGeometry(const QRectF &amp;enclosingGeometry, qreal rotation) const;\n    QRectF calculateGeometry(const QRectF &amp;enclosingGeometry) const;\n\n    /**\n     * \\returns                         Options for this widget.\n     */\n    Options options() const;\n\n    /**\n     * \\param option                    Affected option.\n     * \\param value                     New value for the affected option.\n     */\n    void setOption(Option option, bool value = true);\n\n    /**\n     * \\param options                   New options for this widget.\n     */\n    void setOptions(Options options);\n\n    /**\n     * \\returns                         Status of the last rendering operation.\n     */\n    Qn::RenderStatus renderStatus() const;\n\n    /**\n     * \\returns                         Text of this window&#x27;s title.\n     */\n    QString titleText() const;\n\n    /**\n     * \\returns                         Format string of this widget&#x27;s title text.\n     */\n    QString titleTextFormat() const;\n\n    /**\n     * Sets format of the title text.\n     *\n     * If &lt;tt&gt;&#x27;\\t&#x27;&lt;/tt&gt; symbol is used in the text, it will be split in two parts\n     * at the position of this symbol, and these parts will be aligned to the sides of the title bar.\n     *\n     * If &lt;tt&gt;&quot;%1&quot;&lt;/tt&gt; placeholder is used, it will be replaced with this widget&#x27;s\n     * default autogenerated text. Note that &lt;tt&gt;&quot;%1&quot;&lt;/tt&gt; is the default format.\n     *\n     * \\param titleTextFormat           New title text for this window.\n     */\n    void setTitleTextFormat(const QString &amp;titleTextFormat);\n\n    bool isInfoVisible() const;\n    Q_SLOT void setInfoVisible(bool visible, bool animate);\n\n    bool isLocalActive() const;\n    void setLocalActive(bool localActive);\n\n    QnResourceTitleItem* titleBar() const;\n\n    QnHudOverlayWidget* hudOverlay() const;\n\n    void setCheckedButtons(int buttons);\n\n    int checkedButtons() const;\n\n    int visibleButtons() const;\n\n    SelectionState selectionState() const;\n\n    QPixmap placeholderPixmap() const;\n    void setPlaceholderPixmap(const QPixmap&amp; pixmap);\n\n    /** Current action indicator text. When empty, action indication is hidden. */\n    QString actionText() const;\n    void setActionText(const QString&amp; value);\n    void clearActionText(std::chrono::milliseconds after);\n\n    using base_type::mapRectToScene;\n\n    /** Returns corresponding workbench item id. */\n    nx::Uuid uuid() const;\n\n    /** Returns corresponding workbench item id as a string. */\n    QString uuidString() const;\n\n    /** Debug string representation. */\n    QString toString() const;\n\n    void moveToDedicatedWindow();\n\n    void deinitialize();\n\nsignals:\n    void painted();\n    void aspectRatioChanged();\n    void optionsChanged(Options changedOptions, QPrivateSignal);\n    void zoomRectChanged();\n    void zoomTargetWidgetChanged();\n    void rotationStartRequested();\n    void rotationStopRequested();\n    void displayInfoChanged();\n    void selectionStateChanged(SelectionState state, QPrivateSignal);\n    void placeholderPixmapChanged();\n\nprotected:\n    virtual int helpTopicAt(const QPointF &amp;pos) const override;\n\n    virtual void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;\n    virtual void hoverMoveEvent(QGraphicsSceneHoverEvent *event) override;\n    virtual void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;\n\n    virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;\n    virtual void paintWindowFrame(QPainter* painter, const QStyleOptionGraphicsItem* option,\n        QWidget* widget) override;\n    virtual Qn::RenderStatus paintBackground(QPainter* painter, const QRectF&amp; paintRect);\n    virtual Qn::RenderStatus paintChannelBackground(QPainter* painter, int channel,\n        const QRectF&amp; channelRect, const QRectF&amp; paintRect);\n    virtual void paintChannelForeground(QPainter *painter, int channel, const QRectF &amp;rect);\n    virtual void paintEffects(QPainter* painter);\n\n    virtual QSizeF constrainedSize(const QSizeF constraint, Qt::WindowFrameSection pinSection) const override;\n    virtual QSizeF sizeHint(Qt::SizeHint which, const QSizeF &amp;constraint) const override;\n\n    const QSize &amp;channelScreenSize() const;\n    void setChannelScreenSize(const QSize &amp;size);\n    virtual void channelScreenSizeChangedNotify() {}\n\n    virtual bool forceShowPosition() const;\n    virtual void updateHud(bool animate);\n\n    virtual bool isHovered() const;\n\n    Qn::ResourceStatusOverlay calculateStatusOverlay(\n        nx::vms::api::ResourceStatus resourceStatus, bool hasVideo, bool showsAudioSpectrum) const;\n    virtual Qn::ResourceStatusOverlay calculateStatusOverlay() const;\n    void updateStatusOverlay(bool animate);\n\n    virtual Qn::ResourceOverlayButton calculateOverlayButton(\n        Qn::ResourceStatusOverlay statusOverlay) const;\n    virtual QString overlayCustomButtonText(\n        Qn::ResourceStatusOverlay statusOverlay) const;\n\n    void updateOverlayButton();\n    void updateCustomOverlayButton();\n\n    virtual QString calculateTitleText() const;\n    Q_SLOT void updateTitleText();\n\n    virtual QString calculateDetailsText() const;\n    virtual QPixmap calculateDetailsIcon() const;\n    void updateDetailsText();\n\n    virtual QString calculatePositionText() const;\n    void updatePositionText();\n\n    void updateInfoText();\n\n    QString infoButtonTooltip() const;\n    QString closeButtonTooltip() const;\n\n    QnStatusOverlayController *statusOverlayController() const;\n\n    virtual int calculateButtonsVisibility() const;\n    Q_SLOT void updateButtonsVisibility();\n\n    void setChannelLayout(QnConstResourceVideoLayoutPtr channelLayout);\n    virtual void channelLayoutChangedNotify() {}\n\n    virtual void optionsChangedNotify(Options changedFlags);\n\n    QRectF channelRect(int channel) const;\n    QRectF exposedRect(int channel, bool accountForViewport = true, bool accountForVisibility = true, bool useRelativeCoordinates = false);\n\n    void registerButtonStatisticsAlias(QnImageButtonWidget* button, const QString&amp; alias);\n    QnImageButtonWidget* createStatisticAwareButton(const QString&amp; alias);\n\n    virtual void atItemDataChanged(int role);\n\n    float defaultAspectRatio() const;\n\n    virtual QVariant itemChange(GraphicsItemChange change, const QVariant&amp; value) override;\n    QString tooltipText(const QString&amp; toolTip, const QString&amp; hotkey) const;\n    QString tooltipText(const QString&amp; toolTip, const QKeySequence&amp; hotkey) const;\n\n    bool isVideoWallLicenseValid() const;\n\n    QIcon loadSvgIcon(const QString&amp; name) const;\n\nprivate:\n    void setupOverlayButtonsHandlers();\n    void setupOverlayTooltip();\n\n    void setupHud();\n    void setupSelectionOverlay();\n    void createButtons();\n\n    void setTitleTextInternal(const QString &amp;titleText);\n\n    /*\n    void setupIconButton(QGraphicsLinearLayout *layout\n        , QnImageButtonWidget *button);\n        */\n    Q_SLOT void updateCheckedButtons();\n\n    Q_SLOT void at_infoButton_toggled(bool toggled);\n\n    Q_SLOT void at_buttonBar_checkedButtonsChanged();\n\n    Q_SLOT void atOverlayTooltipChanged(const QPoint&amp; pos);\n\nprivate:\n    void updateSelectedState();\n    void updateFullscreenButton();\n\nprotected:\n    nx::vms::client::desktop::RewindOverlay* const m_rewindOverlay;\n    QnHudOverlayWidget* m_hudOverlay;\n    QnStatusOverlayWidget* m_statusOverlay;\n\nprivate:\n    friend class QnWorkbenchDisplay;\n\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n\n    /** Layout item. */\n    QPointer&lt;QnWorkbenchItem&gt; m_item;\n\n    /** Resource associated with this widget. */\n    QnResourcePtr m_resource;\n\n    /** Options that control display &amp; behavior. */\n    Options m_options;\n\n    /** Whether this item is &#x27;locally active&#x27;. This affects the color of item&#x27;s border. */\n    bool m_localActive;\n\n    /** Layout of this widget&#x27;s channels. */\n    QnConstResourceVideoLayoutPtr m_channelsLayout;\n\n    /** Aspect ratio. Negative value means that aspect ratio is not enforced. */\n    float m_aspectRatio;\n\n    /** Virtual enclosing rectangle. */\n    QRectF m_enclosingGeometry;\n\n    /** Cached size of a single media channel, in screen coordinates. */\n    QSize m_channelScreenSize;\n\n    /** Frame opacity. */\n    qreal m_frameOpacity;\n\n    QString m_titleTextFormat;\n    bool m_titleTextFormatHasPlaceholder;\n\n    /* Widgets for overlaid stuff. */\n\n    QnStatusOverlayController* m_statusController;\n\n    /** Whether mouse cursor is in widget. Usable to show/hide decorations. */\n    bool m_mouseInWidget;\n\n    QRectF m_zoomRect;\n\n    /** Current overlay. */\n    Qn::RenderStatus m_renderStatus;\n\n    qint64 m_lastNewFrameTimeMSec;\n\n    SelectionState m_selectionState;\n\n    QPixmap m_placeholderPixmap;\n\n    static QnFixedWidthTooltipWidget* s_overlayTooltip;\n    static QGraphicsScene* s_tooltipScene;\n    static QGraphicsWidget* s_tooltipWidget;\n};\n\ntypedef QList&lt;QnResourceWidget *&gt; QnResourceWidgetList;\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/web_resource_widget.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/web_resource_widget.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/web_resource_widget.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/network/ssl/helpers.h&gt;\n#include &lt;ui/graphics/items/resource/resource_widget.h&gt;\n\nnamespace nx::vms::client::desktop { class GraphicsWebEngineView; }\n\nclass QnWebResourceWidget: public QnResourceWidget\n{\n    Q_OBJECT\n    using base_type = QnResourceWidget;\n\npublic:\n    QnWebResourceWidget(\n        nx::vms::client::desktop::SystemContext* systemContext,\n        nx::vms::client::desktop::WindowContext* windowContext,\n        QnWorkbenchItem* item,\n        QGraphicsItem *parent = nullptr);\n    virtual ~QnWebResourceWidget();\n\n    virtual bool eventFilter(QObject* object, QEvent* event) override;\n\n    nx::vms::client::desktop::GraphicsWebEngineView* webView() const;\n\n    void setMinimalTitleBarMode(bool value);\n\n    bool overlayIsVisible() const;\n    void setOverlayVisibility(bool visible);\n\n    void setPreventDefaultContextMenu(bool value);\n\nprotected:\n    virtual int helpTopicAt(const QPointF&amp; pos) const override;\n\n    virtual QString calculateDetailsText() const override;\n    virtual QPixmap calculateDetailsIcon() const override;\n    virtual Qn::ResourceStatusOverlay calculateStatusOverlay() const override;\n    virtual int calculateButtonsVisibility() const override;\n    virtual QString calculateTitleText() const override;\n\n    virtual Qn::RenderStatus paintChannelBackground(\n        QPainter *painter, int channel, const QRectF &amp;channelRect, const QRectF &amp;paintRect) override;\n\nprivate:\n    void setupOverlays();\n    void disableHotkeyHints();\n    void setupWidget();\n    bool verifyCertificate(const QString&amp; pemString, const QUrl&amp; url);\n    bool askUserToAcceptCertificate(\n        const nx::network::ssl::CertificateChain&amp; chain, const nx::Url&amp; url);\n\nprivate:\n    std::unique_ptr&lt;nx::vms::client::desktop::GraphicsWebEngineView&gt; m_webEngineView;\n    std::unique_ptr&lt;QTimer&gt; m_refreshTimer;\n    bool m_validCertificate = true;\n    bool m_pageLoaded = false;\n    bool m_isMinimalTitleBar = false;\n    bool m_overlayIsVisible = true;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_qml_view.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_qml_view.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_qml_view.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtQuickWidgets/QQuickWidget&gt;\n#include &lt;QtWidgets/QGraphicsWidget&gt;\n\nclass QQmlEngine;\nclass QQuickWindow;\nclass QQuickItem;\nclass QQmlError;\nclass QOpenGLWidget;\n\nnamespace nx::vms::client::desktop {\n\n/**\n * Shows QML on scene using interface similar to QQuickWidget.\n */\nclass GraphicsQmlView: public QGraphicsWidget\n{\n    Q_OBJECT\n\n    using base_type = QGraphicsWidget;\n\npublic:\n    GraphicsQmlView(QGraphicsItem* parent = nullptr, Qt::WindowFlags wFlags = {});\n    ~GraphicsQmlView();\n\n    QQmlEngine* engine() const;\n    void setData(const QByteArray&amp; data, const QUrl&amp; url);\n\n    QQuickWindow* quickWindow() const;\n    QQuickItem* rootObject() const;\n    QList&lt;QQmlError&gt; errors() const;\n\n    /** Detach root object from this view. */\n    QQuickItem* takeRootObject();\n\n    /** Set new root object for this view. */\n    void setRootObject(QQuickItem* root);\n\npublic slots:\n    void setSource(const QUrl&amp; url);\n    void updateWindowGeometry();\n\nsignals:\n    void statusChanged(QQuickWidget::Status status);\n\nprotected:\n    virtual void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget = 0) override;\n    virtual void hoverMoveEvent(QGraphicsSceneHoverEvent* event) override;\n\n    virtual bool event(QEvent* event) override;\n    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent* event) override;\n    virtual void mousePressEvent(QGraphicsSceneMouseEvent* event) override;\n    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;\n    virtual void wheelEvent(QGraphicsSceneWheelEvent* event) override;\n    virtual void dragMoveEvent(QGraphicsSceneDragDropEvent* event) override;\n    virtual void dropEvent(QGraphicsSceneDragDropEvent* event) override;\n    virtual void keyPressEvent(QKeyEvent* event) override;\n    virtual void keyReleaseEvent(QKeyEvent* event) override;\n    virtual void focusInEvent(QFocusEvent* event) override;\n    virtual void focusOutEvent(QFocusEvent* event) override;\n    virtual bool focusNextPrevChild(bool next) override;\n    virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const override;\n\nprivate:\n    struct Private;\n    QScopedPointer&lt;Private&gt; d;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_web_view.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_web_view.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_web_view.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n\n#include &lt;core/resource/resource.h&gt;\n#include &lt;ui/graphics/items/standard/graphics_qml_view.h&gt;\n\nnamespace nx::vms::client::desktop { class WebViewController; }\n\nenum WebViewPageStatus\n{\n    kPageInitialLoadInProgress\n    , kPageLoading\n    , kPageLoaded\n    , kPageLoadFailed\n};\n\nnamespace nx::vms::client::desktop {\n\nclass GraphicsWebEngineView: public GraphicsQmlView\n{\n    Q_OBJECT\n\n    Q_PROPERTY(WebViewPageStatus status READ status WRITE setStatus NOTIFY statusChanged)\n    Q_PROPERTY(bool canGoBack READ canGoBack WRITE setCanGoBack NOTIFY canGoBackChanged)\n\npublic:\n    static const QUrl kQmlSourceUrl;\n\n    typedef std::function&lt;void(void)&gt; RootReadyCallback;\n\n    GraphicsWebEngineView(const QnResourcePtr &amp;resource, QGraphicsItem* parent = nullptr);\n\n    virtual ~GraphicsWebEngineView();\n\n    WebViewPageStatus status() const;\n\n    void setStatus(WebViewPageStatus value);\n\n    bool canGoBack() const;\n\n    void setCanGoBack(bool value);\n\n    QUrl url() const;\n\n    WebViewController* controller() const { return m_controller.data(); }\n\npublic slots:\n    void back();\n\n    void reload();\n\nsignals:\n    void loadStarted();\n    void statusChanged();\n    void canGoBackChanged();\n    void loadProgress(int progress);\n    void loadFinished(bool ok);\n    void urlChanged();\n\nprotected:\n    virtual void dragEnterEvent(QGraphicsSceneDragDropEvent* event) override;\n\nprivate slots:\n    void updateCanGoBack();\n\n    void setViewStatus(int status);\n\n    void onLoadProgressChanged();\n\nprivate:\n    WebViewPageStatus m_status = kPageInitialLoadInProgress;\n    bool m_canGoBack = false;\n    QScopedPointer&lt;WebViewController&gt; m_controller;\n};\n\n} // namespace nx::vms::client::desktop\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_process_handler.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_process_handler.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_process_handler.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_KINETIC_PROCESS_HANDLER_H\n#define QN_KINETIC_PROCESS_HANDLER_H\n\n#include &lt;QtCore/QtGlobal&gt; /* For Q_UNUSED. */\n\nclass QVariant;\n\nclass KineticProcessor;\n\n/**\n * This interface is to be implemented by the receiver of kinetic events.\n *\n * It is to be used in conjunction with &lt;tt&gt;KineticProcessor&lt;/tt&gt;.\n */\nclass KineticProcessHandler {\npublic:\n    /**\n     * Default constructor.\n     */\n    KineticProcessHandler(): mProcessor(nullptr) {}\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~KineticProcessHandler();\n\n    /**\n     * This function is called whenever kinetic motion starts.\n     *\n     * It is guaranteed that &lt;tt&gt;finishKinetic()&lt;/tt&gt; will also be called.\n     */\n    virtual void startKinetic() {}\n\n    /**\n     * This function is called at regular time intervals throughout the kinetic\n     * motion process.\n     *\n     * \\param distance                  Distance that was covered by kinetic\n     *                                  motion since the last call to this function.\n     */\n    virtual void kineticMove(const QVariant &amp;distance) { Q_UNUSED(distance); };\n\n    /**\n     * This function is called whenever kinetic motion stops.\n     *\n     * If &lt;tt&gt;startKinetic()&lt;/tt&gt; was called, then it is guaranteed that\n     * this function will also be called.\n     */\n    virtual void finishKinetic() {};\n\n    /**\n     * \\returns                         Kinetic processor associated with this handler.\n     */\n    KineticProcessor *kineticProcessor() const {\n        return mProcessor;\n    }\n\nprivate:\n    friend class KineticProcessor;\n\n    KineticProcessor *mProcessor;\n};\n\n\n#endif // QN_KINETIC_PROCESS_HANDLER_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_processor.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_processor.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_processor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_KINETIC_PROCESSOR_H\n#define QN_KINETIC_PROCESSOR_H\n\n#include &lt;limits&gt;\n\n#include &lt;QtCore/QDateTime&gt;\n#include &lt;QtCore/QList&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;ui/animation/animation_timer_listener.h&gt;\n#include &lt;utils/math/linear_combination.h&gt;\n#include &lt;utils/math/magnitude.h&gt;\n\n#include &quot;kinetic_process_handler.h&quot;\n\n/**\n * Kinetic processor implements logic that is common to components that make\n * use of kinetic motion.\n *\n * Kinetic processor presents several functions that are to be used from user\n * code. The most important functions are:\n * &lt;ul&gt;\n * &lt;li&gt;&lt;tt&gt;reset()&lt;/tt&gt;, which is to be used when a user-controlled motion starts,\n *    or when there is a need to stop kinetic process prematurely. &lt;/li&gt;\n * &lt;li&gt;&lt;tt&gt;shift()&lt;/tt&gt;, which is be to used to feed position delta\n *    values to kinetic processor while user-controller motion is in progress.&lt;/tt&gt;\n * &lt;li&gt;&lt;tt&gt;start()&lt;/tt&gt;, which starts kinetic motion.&lt;/tt&gt;\n * &lt;/ul&gt;\n *\n * User code is notified about state changes and kinetic motion through the\n * &lt;tt&gt;KineticProcessHandler&lt;/tt&gt; interface. It is guaranteed that no matter\n * what happens, functions of this interface will be called in proper order.\n * For example, if &lt;tt&gt;startKinetic()&lt;/tt&gt; function was called,\n * then &lt;tt&gt;finishKinetic()&lt;/tt&gt; will also be called even if this kinetic\n * processor is destroyed.\n */\nclass KineticProcessor : public QObject\n{\n    Q_OBJECT;\n    Q_FLAGS(Flags Flag);\n    Q_ENUMS(State);\n\npublic:\n    enum Flag {\n        /** When this flag is set, delta time between events is ignored and\n         * all events are treated as being separated by a constant amount of\n         * time determined by &lt;tt&gt;maxShiftInterval&lt;/tt&gt;. */\n        IgnoreDeltaTime = 0x1\n    };\n\n    Q_DECLARE_FLAGS(Flags, Flag);\n\n    /**\n     * Kinetic state.\n     */\n    enum State {\n        Measuring, /**&lt; Recording shifts. */\n        Running    /**&lt; Performing kinetic motion. */\n    };\n\n    /**\n     * Constructor.\n     *\n     * \\param type                      &lt;tt&gt;QMetaType::Type&lt;/tt&gt; for spatial type of this processor.\n     * \\param parent                    Parent for this object.\n     */\n    KineticProcessor(QMetaType type, QObject *parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~KineticProcessor();\n\n    /**\n     * Resets this kinetic processor into its initial state.\n     */\n    void reset();\n\n    /**\n     * \\param dv                        Spatial displacement since the last call to this function.\n     */\n    void shift(const QVariant &amp;dv);\n\n    /**\n     * Starts kinetic process.\n     */\n    void start() {\n        transition(Running);\n    }\n\n    /**\n     * \\returns                         &lt;tt&gt;QMetaType::Type&lt;/tt&gt; for spatial type of this processor.\n     */\n    QMetaType type() const {\n        return mType;\n    }\n\n    /**\n     * \\returns                         Flags of this kinetic processor.\n     */\n    Flags flags() const {\n        return mFlags;\n    }\n\n    /**\n     * \\param flags                     New flags for this kinetic processor.\n     */\n    void setFlags(Flags flags) {\n        mFlags = flags;\n    }\n\n    /**\n     * \\returns                         Current state of this kinetic processor.\n     */\n    State state() const {\n        return mState;\n    }\n\n    /**\n     * \\returns                         Whether this processor is currently measuring offsets to\n     *                                  start a kinetic motion.\n     */\n    bool isMeasuring() const {\n        return mState == Measuring;\n    }\n\n    /**\n     * \\returns                         Whether this processor is currently performing a kinetic motion.\n     */\n    bool isRunning() const {\n        return mState == Running;\n    }\n\n    /**\n     * \\returns                         Handler for this kinetic processor.\n     */\n    KineticProcessHandler *handler() const {\n        return mHandler;\n    }\n\n    /**\n     * \\param handler                   New handler for this kinetic processor.\n     */\n    void setHandler(KineticProcessHandler *handler);\n\n    /**\n     * \\param count                     Maximal number of latest shifts that will\n     *                                  be considered when computing initial\n     *                                  kinetic speed. Good values are in range [5, 15].\n     */\n    void setMaxShiftCount(int count);\n\n    int maxShiftCount() const {\n        return mMaxShiftCount;\n    }\n\n    /**\n     * \\param minSpeedMagnitude         Minimal speed magnitude. When current speed\n     *                                  magnitude becomes less or equal to this value,\n     *                                  kinetic motion stops.\n     */\n    void setMinSpeedMagnitude(qreal minSpeedMagnitude);\n\n    qreal minSpeedMagnitude() const {\n        return mMinSpeedMagnitude;\n    }\n\n    /**\n     * \\param maxSpeedMagnitude         Maximal speed magnitude. Current speed\n     *                                  magnitude cannot become greater than this value.\n     */\n    void setMaxSpeedMagnitude(qreal maxSpeedMagnitude) {\n        mMaxSpeedMagnitude = maxSpeedMagnitude;\n    }\n\n    qreal maxSpeedMagnitude() const {\n        return mMaxSpeedMagnitude;\n    }\n\n    /**\n     * \\param interval                  Maximal interval between consequent calls\n     *                                  to &lt;tt&gt;shift()&lt;/tt&gt; for them to be considered\n     *                                  a part of a single motion, in seconds.\n     */\n    void setMaxShiftInterval(qreal interval) {\n        mMaxShiftInterval = interval;\n    }\n\n    qreal maxShiftInterval() const {\n        return mMaxShiftInterval;\n    }\n\n    /**\n     * \\param friction                  Friction coefficient. Set to +inf to disable kinetic motion, set to 0.0 to make it never stop.\n     */\n    void setFriction(qreal friction);\n\n    qreal friction() const {\n        return mFriction;\n    }\n\n    QVariant currentSpeed() const {\n        return mCurrentSpeed;\n    }\n\n    AnimationTimerListenerPtr animationTimerListener() const { return m_animationTimerListener; }\n\nprotected:\n    struct Shift {\n        QVariant dv; /**&lt; Spatial displacement. */\n        qreal dt;    /**&lt; Time delta, in seconds. */\n    };\n\n    typedef QList&lt;Shift&gt; ShiftList;\n\n    MagnitudeCalculator *magnitudeCalculator() const {\n        return mMagnitudeCalculator;\n    }\n\n    LinearCombinator *linearCombinator() const {\n        return mLinearCombinator;\n    }\n\n    /**\n     * Given a valid list of shifts, this function calculates speed.\n     *\n     * Default implementation just takes the mean. If some other behavior is\n     * desired, this function can be reimplemented in derived class.\n     *\n     * \\param shifts                    List of shifts.\n     * \\returns                         Estimated speed, in T per second.\n     */\n    virtual QVariant calculateSpeed(const ShiftList &amp;shifts) const;\n\n    /**\n     * Calculates speed based on currently recorded shifts and clears them.\n     */\n    QVariant calculateSpeed();\n\n    /**\n     * This functions implements deceleration of the kinetic movement over time.\n     *\n     * Default implementation uses friction value as deceleration.\n     *\n     * \\param initialSpeed              Speed at the beginning of kinetic process.\n     * \\param currentSpeed              Current speed.\n     * \\param speedGain                 Speed gain due to new shifts added since the\n     *                                  last call to this function.\n     * \\param dt                        Time since the last call to this function, in seconds.\n     * \\returns                         New speed.\n     */\n    virtual QVariant updateSpeed(const QVariant &amp;initialSpeed, const QVariant &amp;currentSpeed, const QVariant &amp;speedGain, qreal dt) const;\n\n\n  private:\n    void tick(int deltaTimeMSec);\n    void transition(State state);\n\n  private:\n    AnimationTimerListenerPtr m_animationTimerListener = AnimationTimerListener::create();\n\n    /* &#x27;Working&#x27; state. */\n\n    /** Current state. */\n    State mState;\n\n    /** Queue of recorded shifts. */\n    ShiftList mShifts;\n\n    /** Last time a shift was recorded. */\n    qint64 mLastShiftTimeMSec;\n\n    /** Speed at the beginning of kinetic motion. */\n    QVariant mInitialSpeed;\n\n    /** Current kinetic speed. */\n    QVariant mCurrentSpeed;\n\n\n    /* &#x27;Stable&#x27; state. */\n\n    /** &lt;tt&gt;QMetaType::Type&lt;/tt&gt; for the spatial type of this processor. */\n    QMetaType mType;\n\n    /** Magnitude calculator. */\n    MagnitudeCalculator *mMagnitudeCalculator;\n\n    /** Linear combinator. */\n    LinearCombinator *mLinearCombinator;\n\n    /** Flags */\n    Flags mFlags;\n\n    /** Kinetic handler. */\n    KineticProcessHandler *mHandler;\n\n    /** Maximal size of the shift queue. */\n    int mMaxShiftCount;\n\n    /** Maximal time interval between consequent shifts, in seconds. */\n    qreal mMaxShiftInterval;\n\n    /** Minimal speed magnitude. */\n    qreal mMinSpeedMagnitude;\n\n    /** Maximal speed magnitude. */\n    qreal mMaxSpeedMagnitude;\n\n    /** Friction coefficient. */\n    qreal mFriction;\n};\n\n#endif // QN_KINETIC_PROCESSOR_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/utils/viewport_scale_watcher.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/utils/viewport_scale_watcher.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/utils/viewport_scale_watcher.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtGui/QTransform&gt;\n\nclass QGraphicsScene;\nclass QGraphicsView;\n\nclass QnViewportScaleWatcher : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(qreal scale READ scale NOTIFY scaleChanged)\n\n    using base_type = QObject;\npublic:\n    QnViewportScaleWatcher(QObject* parent = nullptr);\n\n    ~QnViewportScaleWatcher();\n\n    bool initialized() const;\n\n    void initialize(QGraphicsScene* scene);\n\n    qreal scale() const;\n\npublic:\n    virtual bool eventFilter(QObject* watched, QEvent* event) override;\n\nsignals:\n    void scaleChanged(qreal value);\n\nprivate:\n    void updateScale();\n\nprivate:\n    using ViewportPointer = QPointer&lt;QGraphicsView&gt;;\n\n    ViewportPointer m_viewport;\n    QTransform m_transform;\n    qreal m_scale;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/toggle.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/toggle.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/toggle.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_TOGGLE_H\n#define QN_TOGGLE_H\n\n#include &lt;QtCore/QObject&gt;\n\nclass QnToggle: public QObject {\n    Q_OBJECT;\npublic:\n    QnToggle(QObject *parent = nullptr): QObject(parent), m_active(false) {}\n    QnToggle(bool active, QObject *parent = nullptr): QObject(parent), m_active(active) {}\n\n    virtual ~QnToggle() {\n        setActive(false);\n    }\n\npublic slots:\n    void setActive(bool active) {\n        if(m_active == active)\n            return;\n\n        m_active = active;\n\n        emit toggled(m_active);\n        if(m_active) {\n            emit activated();\n        } else {\n            emit deactivated();\n        }\n    }\n\n    void setInactive(bool inactive) { setActive(!inactive); }\n    void activate() { setActive(true); }\n    void deactivate() { setActive(false); }\n\nsignals:\n    void toggled(bool active);\n    void activated();\n    void deactivated();\n\nprivate:\n    bool m_active;\n};\n\n\n#endif // QN_TOGGLE_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_display.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_display.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_display.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;array&gt;\n\n#include &lt;QtCore/QHash&gt;\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;client/client_globals.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/client/desktop/camera/camera_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/workbench/timeline/thumbnail.h&gt;\n#include &lt;nx/vms/event/event_fwd.h&gt;\n#include &lt;ui/animation/animation_timer_listener.h&gt;\n#include &lt;ui/common/notification_levels.h&gt;\n#include &lt;ui/common/scene_transformations.h&gt;\n#include &lt;ui/workbench/workbench_context_aware.h&gt;\n\nclass QGraphicsScene;\nclass QGraphicsView;\n\nclass InstrumentManager;\nclass BoundingInstrument;\nclass TransformListenerInstrument;\nclass ForwardingInstrument;\nclass SignalingInstrument;\nclass SelectionOverlayTuneInstrument;\nclass FocusListenerInstrument;\nclass ViewportAnimator;\nclass WidgetAnimator;\n\nclass QnWorkbenchItem;\nclass QnWorkbenchLayout;\nclass QnResourceWidget;\nclass QnCurtainAnimator;\nclass QnCurtainItem;\nclass QnGridItem;\nclass QnGridBackgroundItem;\nclass QnCamDisplay;\n\nnamespace nx::vms::client::desktop { class FrameTimePointsProviderInstrument; }\nnamespace nx::vms::rules { class NotificationActionBase; }\n\n/**\n * This class ties a workbench, a scene and a view together.\n *\n * It presents some low-level functions for viewport and item manipulation.\n */\nclass QnWorkbenchDisplay:\n    public QObject,\n    public QnWorkbenchContextAware,\n    protected QnSceneTransformations\n{\n    Q_OBJECT\n\n    using base_type = QObject;\n    using ThumbnailPtr = nx::vms::client::desktop::workbench::timeline::ThumbnailPtr;\n\npublic:\n\n    /**\n    * Layer of a graphics item on the scene.\n    *\n    * Workbench display presents convenience functions for moving items between layers\n    * and guarantees that items from the layers with higher numbers are always\n    * displayed on top of those from the layers with lower numbers.\n    */\n    enum ItemLayer\n    {\n        InvisibleLayer = -1,        //&lt; Layer for invisible items.\n        EMappingLayer = 0,          /**&lt; Layer for E-Mapping background. */\n        BackLayer,                  /**&lt; Back layer. */\n        PinnedLayer,                /**&lt; Layer for pinned items. */\n        PinnedRaisedLayer,          /**&lt; Layer for pinned items that are raised. */\n        UnpinnedLayer,              /**&lt; Layer for unpinned items. */\n        UnpinnedRaisedLayer,        /**&lt; Layer for unpinned items that are raised. */\n        ZoomedLayer,                /**&lt; Layer for zoomed items. */\n        FrontLayer,                 /**&lt; Topmost layer for items. Items that are being dragged, resized or manipulated in any other way are to be placed here. */\n        EffectsLayer,               /**&lt; Layer for top-level effects. */\n        UiLayer,                    /**&lt; Layer for ui elements, i.e. navigation bar, resource tree, etc... */\n        MessageBoxLayer,            /**&lt; Layer for graphics text messages. */\n        LayerCount\n    };\n\n    /**\n     * Constructor.\n     *\n     * \\param parent                    Parent object for this workbench display.\n     */\n    QnWorkbenchDisplay(QObject *parent = nullptr);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~QnWorkbenchDisplay();\n\n    void initialize(QGraphicsScene* scene, QGraphicsView* view);\n\n    void deinitialize();\n\n    /**\n     * \\returns                         Instrument manager owned by this workbench display.\n     */\n    InstrumentManager* instrumentManager() const;\n\n    /**\n     * \\returns                         Bounding instrument used by this workbench display.\n     */\n    BoundingInstrument* boundingInstrument() const;\n\n    /**\n     * \\returns                         Transformation listener instrument used by this workbench display.\n     */\n    TransformListenerInstrument* transformationListenerInstrument() const;\n\n    FocusListenerInstrument* focusListenerInstrument() const;\n\n    /**\n     * \\returns                         Paint forwarding instrument used by this workbench display.\n     */\n    ForwardingInstrument* paintForwardingInstrument() const;\n\n    SelectionOverlayTuneInstrument* selectionOverlayTuneInstrument() const;\n\n    SignalingInstrument* beforePaintInstrument() const;\n\n    SignalingInstrument* afterPaintInstrument() const;\n\n    nx::vms::client::desktop::FrameTimePointsProviderInstrument* frameTimePointsInstrument() const;\n\n    /**\n     * \\returns                         Grid item.\n     */\n    QnGridItem *gridItem() const;\n\n    /**\n     * \\returns                         Curtain item (that is painted in black when a single widget is zoomed).\n     */\n    QnCurtainItem* curtainItem() const;\n\n    /**\n     * \\returns                         Curtain item animator.\n     */\n    QnCurtainAnimator* curtainAnimator() const;\n\n    /**\n     * \\returns                         Grid background item (E-Mapping).\n     */\n    QnGridBackgroundItem *gridBackgroundItem() const;\n\n    /**\n     * \\param item                      Item to get widget for.\n     * \\returns                         Widget for the given item.\n     */\n    QnResourceWidget *widget(QnWorkbenchItem *item) const;\n\n    QnResourceWidget *widget(Qn::ItemRole role) const;\n\n    QnResourceWidget *widget(const nx::Uuid &amp;uuid) const;\n\n    QList&lt;QnResourceWidget *&gt; widgets(const QnResourcePtr &amp;resource) const;\n\n    QList&lt;QnResourceWidget *&gt; widgets() const;\n\n    QnResourceWidget* activeWidget() const;\n\n    QnResourceDisplayPtr display(QnWorkbenchItem *item) const;\n\n    QnCamDisplay *camDisplay(QnWorkbenchItem *item) const;\n\n    /**\n     * \\param item                      Item to get enclosing geometry for.\n     * \\returns                         Given item&#x27;s enclosing geometry in scene\n     *                                  coordinates as defined by the model.\n     *                                  Note that actual geometry may differ because of\n     *                                  aspect ration constraints.\n     */\n    QRectF itemEnclosingGeometry(QnWorkbenchItem *item) const;\n\n    /**\n     * \\param item                      Item to get geometry for.\n     * \\param[out] enclosingGeometry    Item&#x27;s enclosing geometry.\n     * \\returns                         Item&#x27;s geometry in scene coordinates,\n     *                                  taking aspect ratio constraints into account.\n     *                                  Note that actual geometry of the item&#x27;s widget\n     *                                  may differ because of manual dragging / resizing / etc...\n     */\n    QRectF itemGeometry(QnWorkbenchItem *item, QRectF *enclosingGeometry = nullptr) const;\n\n    QRectF fitInViewGeometry() const;\n\n    /**\n     * \\returns                         Current viewport geometry, in scene coordinates.\n     */\n    QRectF viewportGeometry() const;\n\n    /**\n     * \\returns                         Current viewport geometry, in scene coordinates, calculated taking viewport margins into account.\n     */\n    QRectF boundedViewportGeometry(Qn::MarginTypes marginTypes= Qn::CombinedMargins) const;\n\n    /**\n     * This function can be used in case the &quot;actual&quot; viewport differs from the\n     * &quot;real&quot; one. This can be the case if control panels are drawn on the scene.\n     * Some layouts can have additional viewport margins, that are changed independently of panels.\n     * For example, these are tour review layouts. Different fields are required to correctly\n     * calculate background rect.\n     *\n     * \\param margins                   New viewport margins.\n     * \\param marginType                Type of margins to be set.\n     */\n    void setViewportMargins(const QMargins&amp; margins, Qn::MarginType marginType);\n\n    QMargins viewportMargins(Qn::MarginTypes marginTypes = Qn::CombinedMargins) const;\n\n    Qn::MarginFlags currentMarginFlags() const;\n\n    Qn::MarginFlags zoomedMarginFlags() const;\n\n    Qn::MarginFlags normalMarginFlags() const;\n\n    void setZoomedMarginFlags(Qn::MarginFlags flags);\n\n    void setNormalMarginFlags(Qn::MarginFlags flags);\n\n\n    void bringToFront(const QList&lt;QGraphicsItem *&gt; &amp;items);\n\n    void bringToFront(QGraphicsItem *item);\n\n    void bringToFront(QnWorkbenchItem *item);\n\n    ItemLayer layer(QGraphicsItem *item) const;\n    void setLayer(QGraphicsItem *item, ItemLayer layer);\n    void setLayer(const QList&lt;QGraphicsItem *&gt; &amp;items, ItemLayer layer);\n    qreal layerZValue(ItemLayer layer) const;\n\n    void synchronize(QnWorkbenchItem *item, bool animate);\n\n    void synchronize(QnResourceWidget *widget, bool animate);\n\n\n    QPoint mapViewportToGrid(const QPoint &amp;viewportPoint) const;\n\n    QPoint mapGlobalToGrid(const QPoint &amp;globalPoint) const;\n\n    QPointF mapViewportToGridF(const QPoint &amp;viewportPoint) const;\n\n    QPointF mapGlobalToGridF(const QPoint &amp;globalPoint) const;\n\n    /**\n     * Status function to know if we are changing layout now.\n     * \\returns true if we are changing layout\n     */\n    bool isChangingLayout() const { return m_inChangeLayout; } //&lt; TODO: #sivanov Remove this.\n\n    QnResourceWidget *zoomTargetWidget(QnResourceWidget *widget) const;\n\n    QRectF raisedGeometry(const QRectF &amp;widgetGeometry, qreal rotation) const;\n\n    QSet&lt;QnWorkbenchItem*&gt; draggedItems() const;\n    void setDraggedItems(const QSet&lt;QnWorkbenchItem*&gt;&amp; value, bool updateGeometry = true);\n\n    bool animationAllowed() const;\n\n    bool forceNoAnimation() const;\n    void setForceNoAnimation(bool noAnimation);\n\n    QTimer* playbackPositionBlinkTimer() const;\n\n    void showNotificationSplash(const QnResourceList&amp; resources, QnNotificationLevel::Value level);\n\npublic slots:\n    void fitInView(bool animate);\n\nsignals:\n    void viewportGrabbed();\n    void viewportUngrabbed();\n\n    void widgetAdded(QnResourceWidget *widget);\n    void widgetAboutToBeRemoved(QnResourceWidget *widget);\n    void widgetChanged(Qn::ItemRole role);\n    void widgetAboutToBeChanged(Qn::ItemRole role);\n\n    void zoomLinkAdded(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n    void zoomLinkAboutToBeRemoved(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n\n    void layoutAccessChanged();\n\nprotected:\n    WidgetAnimator *animator(QnResourceWidget *widget);\n\n    void synchronizeGeometry(QnWorkbenchItem *item, bool animate);\n    void synchronizeGeometry(QnResourceWidget *widget, bool animate);\n    void synchronizeZoomRect(QnWorkbenchItem *item);\n    void synchronizeZoomRect(QnResourceWidget *widget);\n    void synchronizeAllGeometries(bool animate);\n    void synchronizeLayer(QnWorkbenchItem *item);\n    void synchronizeLayer(QnResourceWidget *widget);\n    void synchronizePlaceholder(QnResourceWidget *widget);\n    void synchronizeSceneBounds();\n\n    void updateCurrentMarginFlags();\n\n    void adjustGeometryLater(QnWorkbenchItem *item, bool animate);\n    void adjustGeometry(QnWorkbenchItem *item, bool animate);\n\n    qreal layerFrontZValue(ItemLayer layer) const;\n    ItemLayer synchronizedLayer(QnResourceWidget *widget) const;\n    ItemLayer shadowLayer(ItemLayer itemLayer) const;\n\n    bool addItemInternal(QnWorkbenchItem *item, bool animate, bool startDisplay);\n    bool removeItemInternal(QnWorkbenchItem *item);\n\n    bool addZoomLinkInternal(QnWorkbenchItem *item, QnWorkbenchItem *zoomTargetItem);\n    bool removeZoomLinkInternal(QnWorkbenchItem *item, QnWorkbenchItem *zoomTargetItem);\n    bool addZoomLinkInternal(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n    bool removeZoomLinkInternal(QnResourceWidget *widget, QnResourceWidget *zoomTargetWidget);\n    bool removeZoomLinksInternal(QnWorkbenchItem *item);\n\n    void initBoundingInstrument();\n\n    void setWidget(Qn::ItemRole role, QnResourceWidget *widget);\n\n    /** Clear role before widget is destroyed. */\n    void clearWidget(Qn::ItemRole role);\n\nprotected slots:\n    void synchronizeSceneBoundsExtension();\n    void synchronizeRaisedGeometry();\n\n    void updateBackground(const nx::vms::client::core::LayoutResourcePtr&amp; layout);\n\n    /** Mark item on the scene selected as it was selected in the tree. */\n    void updateSelectionFromTree();\n\n    void at_scene_selectionChanged();\n\n    void at_viewportAnimator_finished();\n\n    void at_workbench_itemChanged(Qn::ItemRole role);\n    void at_workbench_currentLayoutAboutToBeChanged();\n    void at_workbench_currentLayoutChanged();\n\n    void at_layout_itemAdded(QnWorkbenchItem *item);\n    void at_layout_itemRemoved(QnWorkbenchItem *item);\n    void at_layout_zoomLinkAdded(QnWorkbenchItem *item, QnWorkbenchItem *zoomTargetItem);\n    void at_layout_zoomLinkRemoved(QnWorkbenchItem *item, QnWorkbenchItem *zoomTargetItem);\n    void at_layout_boundingRectChanged(const QRect &amp;oldRect, const QRect &amp;newRect);\n\n    void at_item_geometryChanged();\n    void at_item_geometryDeltaChanged();\n    void at_item_zoomRectChanged();\n    void at_item_rotationChanged();\n    void at_item_dataChanged(int role);\n    void at_item_flagChanged(Qn::ItemFlag flag, bool value);\n\n    void at_widget_aspectRatioChanged();\n\n    void at_mapper_originChanged();\n    void at_mapper_cellSizeChanged();\n    void at_mapper_spacingChanged();\n\n    void showSplashOnResource(const QnResourcePtr&amp; resource, QnNotificationLevel::Value level);\n\n    bool canShowLayoutBackground() const;\n\nprivate:\n    /* Directly visible state */\n\n    /** Current scene. */\n    QGraphicsScene* m_scene = nullptr;\n\n    /** Current view. */\n    QGraphicsView* m_view = nullptr;\n\n    /* Internal state. */\n    QList&lt;QnResourceWidget *&gt; m_widgets;\n\n    /** Item to widget mapping. */\n    QHash&lt;QnWorkbenchItem *, QnResourceWidget *&gt; m_widgetByItem;\n\n    /** Resource to widget mapping. */\n    QHash&lt;QnResourcePtr, QList&lt;QnResourceWidget *&gt; &gt; m_widgetsByResource;\n\n    /** Widget to zoom target widget mapping. */\n    QHash&lt;QnResourceWidget *, QnResourceWidget *&gt; m_zoomTargetWidgetByWidget;\n\n    /** Current front z displacement value. */\n    qreal m_frontZ;\n\n    /** Current items by role. */\n    std::array&lt;QnResourceWidget*, Qn::ItemRoleCount&gt; m_widgetByRole;\n\n    /** Grid item. */\n    QPointer&lt;QnGridItem&gt; m_gridItem;\n\n    /** Grid background item. */\n    QPointer&lt;QnGridBackgroundItem&gt; m_gridBackgroundItem;\n\n    Qn::MarginFlags m_zoomedMarginFlags, m_normalMarginFlags;\n\n    /** Whether we are changing layout now. */\n    bool m_inChangeLayout;\n\n    bool m_inChangeSelection = false;\n\n    QSet&lt;QnWorkbenchItem*&gt; m_draggedItems;\n\n\n    /* Instruments. */\n\n    /** Instrument manager owned by this workbench manager. */\n    InstrumentManager *m_instrumentManager;\n\n    /** Transformation listener instrument. */\n    TransformListenerInstrument *m_transformListenerInstrument;\n\n    /** Focus listener instrument. */\n    FocusListenerInstrument *m_focusListenerInstrument;\n\n    /** Bounding instrument. */\n    BoundingInstrument *m_boundingInstrument;\n\n    /** Paint forwarding instrument. */\n    ForwardingInstrument *m_paintForwardingInstrument;\n\n    /** Selection overlay tune instrument. */\n    SelectionOverlayTuneInstrument *m_selectionOverlayTuneInstrument;\n\n    SignalingInstrument *m_beforePaintInstrument;\n\n    SignalingInstrument *m_afterPaintInstrument;\n\n    /* Frame time points instrument. */\n    nx::vms::client::desktop::FrameTimePointsProviderInstrument* m_frameTimePointsInstrument;\n\n    /* Animation-related stuff. */\n\n    /** Viewport animator. */\n    ViewportAnimator *m_viewportAnimator;\n\n    /** Curtain item. */\n    QPointer&lt;QnCurtainItem&gt; m_curtainItem;\n\n    /** Curtain animator. */\n    QnCurtainAnimator *m_curtainAnimator;\n\n    QTimer* m_playbackPositionBlinkTimer = nullptr;\n\n    bool m_forceNoAnimation = false;\n};\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_grid_mapper.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_grid_mapper.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_grid_mapper.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_WORKBENCH_GRID_MAPPER_H\n#define QN_WORKBENCH_GRID_MAPPER_H\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QPoint&gt;\n#include &lt;QtCore/QRect&gt;\n#include &lt;QtCore/QSize&gt;\n\n/**\n * Convenience class that stores grid parameters.\n */\nclass QnWorkbenchGridMapper: public QObject\n{\n    Q_OBJECT\n\npublic:\n    QnWorkbenchGridMapper(QSizeF cellSize, QObject* parent = nullptr);\n\n    virtual ~QnWorkbenchGridMapper();\n\n    /**\n     * \\returns                         Origin of the grid coordinate system.\n     */\n    const QPointF &amp;origin() const {\n        return m_origin;\n    }\n\n    /**\n     * \\param origin                    New origin of the grid coordinate system.\n     */\n    void setOrigin(const QPointF &amp;origin);\n\n    /**\n     * \\returns                         Size of a single cell.\n     */\n    const QSizeF &amp;cellSize() const {\n        return m_cellSize;\n    }\n\n    /**\n     * \\param cellSize                  New size of a single cell.\n     */\n    void setCellSize(const QSizeF &amp;cellSize);\n\n    /**\n     * \\param width                     New height of a single cell.\n     * \\param height                    New width of a single cell.\n     */\n    void setCellSize(qreal width, qreal height) {\n        setCellSize(QSizeF(width, height));\n    }\n\n    /**\n     * Sets the layout&#x27;s spacing.\n     *\n     * \\param spacing                   Spacing value.\n     */\n    void setSpacing(qreal spacing);\n\n    /**\n     * Sets the default vertical spacing.\n     *\n     * \\param spacing                   Vertical spacing value.\n     */\n    void setVerticalSpacing(qreal spacing);\n\n    /**\n     * Sets the default horizontal spacing.\n     *\n     * \\param spacing                   Horizontal spacing value.\n     */\n    void setHorizontalSpacing(qreal spacing);\n\n    /**\n     * \\returns                         Spacing.\n     */\n    qreal spacing() const;\n\n    /**\n     * \\returns                         Grid step, sum of cell size and spacing.\n     */\n    QSizeF step() const;\n\n    /**\n     * \\param pos                       Position in scene coordinates to map to grid coordinates.\n     * \\returns                         Coordinate of the grid cell that the given\n     *                                  position belongs to. If the position at spacing region is\n     *                                  given, returns coordinate of the closest grid cell.\n     */\n    QPoint mapToGrid(const QPointF &amp;pos) const;\n\n    /**\n     * \\param pos                       Position in scene coordinates to map to grid coordinates.\n     * \\returns                         Corresponding position in grid coordinates.\n     */\n    QPointF mapToGridF(const QPointF &amp;pos) const;\n\n    /**\n     * \\param size                      Size in scene coordinates.\n     * \\returns                         Smallest size in grid cells that fits the given size.\n     */\n    QSize mapToGrid(const QSizeF &amp;size) const;\n\n    /**\n     * \\param size                      Size in scene coordinates.\n     * \\returns                         Corresponding size in grid cells.\n     */\n    QSizeF mapToGridF(const QSizeF &amp;size) const;\n\n    /**\n     * \\param gridPos                   Coordinate of the grid cell.\n     * \\returns                         Position in scene coordinates of the top left corner of the grid cell.\n     */\n    QPointF mapFromGrid(const QPoint &amp;gridPos) const;\n\n    /**\n     * \\param gridPos                   Coordinate of a point on a grid.\n     * \\return                          Position in scene coordinates of the given point.\n     */\n    QPointF mapFromGridF(const QPointF &amp;gridPos) const;\n\n    /**\n     * \\param gridSize                  Size in grid cells.\n     * \\returns                         Corresponding size in scene coordinates.\n     */\n    QSizeF mapFromGrid(const QSize &amp;gridSize) const;\n\n    /**\n     * \\param gridSize                  Size in grid cells.\n     * \\returns                         Corresponding size in scene coordinates.\n     */\n    QSizeF mapFromGridF(const QSizeF &amp;gridSize) const;\n\n    /**\n     * \\param rect                      Rectangle in scene coordinates to map to grid coordinates.\n     * \\returns                         Smallest grid rectangle that fits the given rectangle.\n     */\n    QRect mapToGrid(const QRectF &amp;rect) const;\n\n    /**\n     * \\param rect                      Rectangle in scene coordinates to map to grid coordinates.\n     * \\returns                         Corresponding grid rectangle in grid coordinates.\n     */\n    QRectF mapToGridF(const QRectF &amp;rect) const;\n\n    /**\n     * \\param gridRect                  Rectangle in grid cells.\n     * \\returns                         Corresponding rectangle in scene coordinates.\n     */\n    QRectF mapFromGrid(const QRect &amp;gridRect) const;\n\n    /**\n     * \\param gridRect                  Rectangle in grid cells.\n     * \\returns                         Corresponding rectangle in scene coordinates.\n     */\n    QRectF mapFromGridF(const QRectF &amp;gridRect) const;\n\n    /**\n     * \\param delta                     Directed vector, in scene coordinates.\n     * \\returns                         Corresponding directed vector in grid coordinates.\n     */\n    QPointF mapDeltaToGridF(const QPointF &amp;delta) const;\n\nsignals:\n    void originChanged();\n    void cellSizeChanged();\n    void spacingChanged();\n\nprivate:\n    QPointF m_origin;\n    QSizeF m_cellSize;\n    QSizeF m_spacing;\n};\n\n\n#endif // QN_WORKBENCH_GRID_MAPPER_H\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_layout.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_layout.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_layout.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QHash&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QSet&gt;\n#include &lt;QtGui/QIcon&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/utils/impl_ptr.h&gt;\n#include &lt;nx/utils/uuid.h&gt;\n#include &lt;nx/vms/client/core/client_core_globals.h&gt;\n#include &lt;nx/vms/client/desktop/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/client/desktop/system_context_aware.h&gt;\n#include &lt;nx/vms/client/desktop/window_context_aware.h&gt;\n#include &lt;nx/vms/client/desktop/workbench/layouts/workbench_layout_state.h&gt;\n#include &lt;utils/math/magnitude.h&gt;\n#include &lt;utils/rect_set.h&gt;\n\n#include &quot;matrix_map.h&quot;\n\nQ_MOC_INCLUDE(&quot;core/resource/layout_resource.h&quot;)\nQ_MOC_INCLUDE(&quot;ui/workbench/workbench_item.h&quot;)\nQ_MOC_INCLUDE(&quot;ui/workbench/workbench_layout_synchronizer.h&quot;)\n\nclass QnWorkbenchItem;\nclass QnWorkbenchLayoutSynchronizer;\n\nenum class QnLayoutFlag\n{\n    Empty = 0,\n    FixedViewport = 1 &lt;&lt; 0, //&lt; Disallow to zoom and hand scroll\n    NoMove = 1 &lt;&lt; 1,\n    NoResize = 1 &lt;&lt; 2, //&lt; Disallow to resize (including raise) items\n    NoTimeline = 1 &lt;&lt; 3,\n    SpecialBackground = 1 &lt;&lt; 4,\n    FillViewport = 1 &lt;&lt; 5, //&lt; Layout must fill viewport as much as possible\n};\nQ_DECLARE_FLAGS(QnLayoutFlags, QnLayoutFlag)\nQ_DECLARE_OPERATORS_FOR_FLAGS(QnLayoutFlags)\n\n/**\n * Layout of a workbench.\n * Contains workbench items and information on their positions. Provides the\n * necessary functions for moving items around.\n */\nclass QnWorkbenchLayout: public QObject,\n    public nx::vms::client::desktop::WindowContextAware\n{\n    Q_OBJECT\n    Q_PROPERTY(QnLayoutResource* resource READ resourcePtr CONSTANT)\n\npublic:\n    using LayoutResourcePtr = nx::vms::client::core::LayoutResourcePtr;\n    using StreamSynchronizationState = nx::vms::client::desktop::StreamSynchronizationState;\n    static constexpr auto kDefaultCellSpacing = nx::vms::client::core::CellSpacing::Small;\n\n    /**\n     * @return Layout associated with the given resource, if any.\n     */\n    static QnWorkbenchLayout* instance(const LayoutResourcePtr&amp; resource);\n\n    // TODO: #sivanov Reimplement the same way as Showreel reviews are implemented.\n    /**\n     * @return Layout associated with the given resource, if any.\n     */\n    static QnWorkbenchLayout* instance(const QnVideoWallResourcePtr&amp; videowall);\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~QnWorkbenchLayout();\n\n    QnWorkbenchLayoutSynchronizer* layoutSynchronizer() const;\n\n    /**\n     * @return Resource associated with this layout. Always exists.\n     */\n    LayoutResourcePtr resource() const;\n\n    /**\n     * @return Plain pointer to the associated resource. Needed by QML.\n     */\n    QnLayoutResource* resourcePtr() const;\n\n    QIcon icon() const;\n\n    QnLayoutFlags flags() const;\n    void setFlags(QnLayoutFlags value);\n\n    nx::Uuid resourceId() const;\n\n    /**\n     * @return Name of this layout.\n     */\n    QString name() const;\n\n    /**\n     * State of cameras synchronization on this layout.\n     */\n    StreamSynchronizationState streamSynchronizationState() const;\n\n    /**\n     * Set cameras synchronization state. It will be used when this layout become current. If it\n     * already is, no changes would be applied.\n     */\n    void setStreamSynchronizationState(StreamSynchronizationState value);\n\n    /**\n     * @param resource Resource to update layout from.\n     * @return Whether there were no errors during loading.\n     */\n    bool update(const LayoutResourcePtr&amp; resource);\n\n    /**\n     * @param[out] resource Resource to submit layout to.\n     */\n    void submit(const LayoutResourcePtr&amp; resource) const;\n\n    /**\n     * Notify all subscribers that layout title should be updated.\n     */\n    void notifyTitleChanged();\n\n    /**\n     * @returns true if the layout has no specific Cell Aspect Ratio and it can be adjusted.\n     */\n    bool canAutoAdjustAspectRatio();\n\n    /**\n     * Helper struct for obtaining detailed information on move operations.\n     */\n    struct Disposition\n    {\n        /** Set of free slots that the moved items will occupy. */\n        QSet&lt;QPoint&gt; free;\n\n        /** Set of slots that are already occupied, thus blocking the items from being moved. */\n        QSet&lt;QPoint&gt; occupied;\n    };\n\n    /**\n     * @param item Item to check.\n     * @param geometry New position.\n     * @param[out] disposition Disposition of free and occupied cells in the target region.\n     * @return Whether the item can be moved.\n     */\n    bool canMoveItem(QnWorkbenchItem* item, const QRect&amp; geometry,\n        Disposition* disposition = nullptr);\n\n    /**\n     * @param item Item to move to a new position.\n     * @param geometry New position.\n     * @param[out] disposition Disposition of free and occupied cells in the target region.\n     * @return Whether the item was moved.\n     */\n    bool moveItem(QnWorkbenchItem* item, const QRect&amp; geometry);\n\n    /**\n     * @param items Items to check.\n     * @param geometries New positions.\n     * @param[out] disposition Disposition of free and occupied cells in the target region.\n     * @return Whether the items can be moved.\n     */\n    bool canMoveItems(const QList&lt;QnWorkbenchItem*&gt;&amp; items, const QList&lt;QRect&gt;&amp; geometries,\n        Disposition* disposition = nullptr) const;\n\n    /**\n     * @param items Items to move to new positions.\n     * @param geometries New positions.\n     * @return Whether the items were moved.\n     */\n    bool moveItems(const QList&lt;QnWorkbenchItem*&gt;&amp; items, const QList&lt;QRect&gt;&amp; geometries);\n\n    /**\n     * @param item Item to pin.\n     * @param geometry Position to pin to.\n     * @return Whether the item was pinned.\n     */\n    bool pinItem(QnWorkbenchItem* item, const QRect&amp; geometry);\n\n    /**\n     * @param item Item to unpin.\n     * @return Whether the item was unpinned.\n     */\n    bool unpinItem(QnWorkbenchItem* item);\n\n    /**\n     * Adds the given item to this layout. This layout takes ownership of the given item. If the\n     * given item already belongs to some other layout, it will first be removed from that layout.\n     * If the position where the item is to be placed is occupied, the item will be placed unpinned.\n     * @param item Item to add.\n     */\n    Q_SLOT void addItem(QnWorkbenchItem* item);\n\n    /**\n     * Removes the given item from this layout. Item&#x27;s ownership is passed to the caller.\n     * @param item Item to remove\n     */\n    Q_SLOT void removeItem(QnWorkbenchItem* item);\n\n    /**\n     * Remove all items by the given resource.\n     */\n    void removeItems(const QnResourcePtr&amp; resource);\n\n    /**\n     * @param position Position to get item at.\n     * @return Pinned item at the given position, or nullptr if the given position is empty.\n     */\n    QnWorkbenchItem* item(const QPoint&amp; position) const;\n\n    /**\n     * @param uuid Universally unique identifier to get item for.\n     * @return Item for the given universally unique identifier, or nullptr if no such item exists in\n     *     this layout.\n     */\n    QnWorkbenchItem* item(const nx::Uuid&amp; uuid) const;\n\n    /**\n     * @param region Region to get pinned items at.\n     * @return Set of pinned items at the given region.\n     */\n    QSet&lt;QnWorkbenchItem*&gt; items(const QRect&amp; region) const;\n\n    /**\n     * @param regions Regions to get pinned items at.\n     * @return Set of pinned items at the given regions.\n     */\n    QSet&lt;QnWorkbenchItem*&gt; items(const QList&lt;QRect&gt;&amp; regions) const;\n\n    /**\n     * @param resource Resource.\n     * @return Set of items that have the given resource.\n     */\n    const QSet&lt;QnWorkbenchItem*&gt;&amp; items(const QnResourcePtr&amp; resource) const;\n\n    /**\n     * @return All items of this model.\n     */\n    const QSet&lt;QnWorkbenchItem*&gt;&amp; items() const;\n\n    /**\n     * @return All resources of layout items, without duplicates.\n     */\n    QnResourceList itemResources() const;\n\n    void addZoomLink(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem);\n\n    void removeZoomLink(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem);\n\n    QnWorkbenchItem* zoomTargetItem(QnWorkbenchItem* item) const;\n\n    QList&lt;QnWorkbenchItem*&gt; zoomItems(QnWorkbenchItem* zoomTargetItem) const;\n\n    /**\n     * @return Whether there are no items on this layout.\n     */\n    bool isEmpty() const;\n\n    /**\n     * @return Cell aspect ratio of this layout.\n     */\n    float cellAspectRatio() const;\n\n    /**\n     * @return True if the correct cell aspect ratio (&gt; 0.0) has been set\n     */\n    bool hasCellAspectRatio() const;\n\n    /**\n     * @return Spacing between cells of this layout,\n     * relative to cell size.\n     */\n    qreal cellSpacing() const;\n\n    /**\n     * @return Lock state of this layout.\n     */\n    bool locked() const;\n\n    /**\n     * @return Bounding rectangle of all pinned items in this layout.\n     */\n    const QRect&amp; boundingRect() const;\n\n    /**\n     * @param gridPos Desired position, in grid coordinates.\n     * @return True if requested rect is not covered by pinned items.\n     */\n    bool isFreeSlot(const QPoint&amp; gridPos) const;\n\n    /**\n     * @param gridPos Desired position, in grid coordinates.\n     * @param size Desired slot size.\n     * @param metric Metric of the gridspace to use for determining the closest slot. Positions of\n     *     the top-left corner of the slot at hand will be passed to it.\n     * @return Geometry of the free slot of desired size whose upper-left corner is closest (as\n     *     defined by the metric) to the given position.\n     */\n    QRect closestFreeSlot(const QPointF&amp; gridPos, const QSize&amp; size,\n        const TypedMagnitudeCalculator&lt;QPoint&gt;* const metric = nullptr) const;\n\n    /**\n     * @param role Role to get data for.\n     * @return Data for the given role.\n     */\n    QVariant data(int role) const;\n\n    /**\n     * @param role Role to set data for.\n     * @param value New value for the given data role.\n     */\n    void setData(int role, const QVariant&amp; value);\n\n    /**\n     * Move all items to the center of the grid coordinates (relative position is not changed).\n     */\n    void centralizeItems();\n\n    /**\n     * Whether this layout is a preview search layout.\n     */\n    bool isPreviewSearchLayout() const;\n\n    /**\n     * Whether this layout is a showreel review layout.\n     */\n    bool isShowreelReviewLayout() const;\n\n    /** Whether this layout is a Video Wall review layout. */\n    bool isVideoWallReviewLayout() const;\n\n    /** Debug string representation. */\n    QString toString() const;\n\nsignals:\n    void flagsChanged();\n\n    void iconChanged();\n\n    /**\n     * Emitted whenever an item is added to this layout. At the time of emit all internal data\n     * structures are already updated to include the added item.\n     * @param item Item that was added.\n     */\n    void itemAdded(QnWorkbenchItem* item);\n\n    void itemsMoved(QList&lt;QnWorkbenchItem*&gt; items);\n\n    void zoomLinkAdded(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem);\n    void zoomLinkRemoved(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem);\n\n    /**\n     * Emitted whenever an item is about to be removed from this layout. At the time of emit the\n     * item is still valid, but all internal data structures are already updated not to include the\n     * removed item.\n     * @param item Item that was removed.\n     */\n    void itemRemoved(QnWorkbenchItem* item);\n\n    /**\n     * Emitted whenever bounding rectangle of this layout changes.\n     */\n    void boundingRectChanged(const QRect&amp; oldRect, const QRect&amp; newRect);\n\n    /**\n     * Emitted whenever or icon of this layout changes.\n     */\n    void titleChanged();\n\n    /**\n     * Emitted whenever cell aspect ratio of this layout changes.\n     */\n    void cellAspectRatioChanged();\n\n    /**\n     * Emitted whenever cell spacing of this layout changes.\n     */\n    void cellSpacingChanged();\n\n    /**\n     * Emitted whenever data associated with the provided role is changed.\n     *\n     * @param role Role of the changed data.\n     */\n    void dataChanged(int role);\n\nprotected:\n    /**\n     * Constructor.\n     * @param resource Layout resource that this layout will be in sync with.\n     */\n    QnWorkbenchLayout(\n        nx::vms::client::desktop::WindowContext* windowContext,\n        const LayoutResourcePtr&amp; resource);\n\nprivate:\n    void moveItemInternal(QnWorkbenchItem* item, const QRect&amp; geometry);\n    void updateBoundingRectInternal();\n\n    void addZoomLinkInternal(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem,\n        bool notifyItem);\n\n    void removeZoomLinkInternal(QnWorkbenchItem* item, QnWorkbenchItem* zoomTargetItem,\n        bool notifyItem);\n\n    nx::Uuid zoomTargetUuidInternal(QnWorkbenchItem* item) const;\n\n    /** Check that item belongs to the current layout. */\n    bool own(QnWorkbenchItem* item) const;\n\n    /** Calculate what icon should be used for the layout. */\n    QIcon calculateIcon() const;\n\nprivate:\n    struct Private;\n    nx::utils::ImplPtr&lt;Private&gt; d;\n};\n\nusing QnWorkbenchLayoutList = QList&lt;QnWorkbenchLayout*&gt;;\n"}, "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h": {"id": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "filePath": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n\n/* Abstract access interfaces */\n/* -------------------------- */\n\ntemplate&lt;class T&gt;\nstruct QnAbstractGetter\n{\n    virtual ~QnAbstractGetter() {}\n    virtual T operator () () const = 0;\n};\n\ntemplate&lt;class T&gt;\nstruct QnAbstractSetter\n{\n    virtual ~QnAbstractSetter() {}\n    virtual void operator () (const T&amp;) const = 0;\n};\n\ntemplate&lt;class T, class Object&gt;\nstruct QnAbstractExternalGetter\n{\n    virtual ~QnAbstractExternalGetter() {}\n    virtual T operator () (const Object*) const = 0;\n};\n\ntemplate&lt;class T, class Object&gt;\nstruct QnAbstractExternalSetter\n{\n    virtual ~QnAbstractExternalSetter() {}\n    virtual void operator () (Object*, const T&amp;) const = 0;\n};\n\n/* Abstract member access bases */\n/* ---------------------------- */\n\ntemplate&lt;class T, class Object&gt;\nclass QnAbstractMemberGetter : public QnAbstractGetter&lt;T&gt;\n{\nprotected:\n    QnAbstractMemberGetter(const Object* object) : m_object(object) {}\n    const Object* object() const { return m_object; }\n\nprivate:\n    const Object* m_object;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnAbstractMemberSetter : public QnAbstractSetter&lt;T&gt;\n{\nprotected:\n    QnAbstractMemberSetter(Object* object) : m_object(object) {}\n    Object* object() const { return m_object; }\n\nprivate:\n    Object* m_object;\n};\n\n/* Field access */\n/* ------------ */\n\ntemplate&lt;class T, class Object&gt;\nclass QnFieldExternalGetter : public QnAbstractExternalGetter&lt;T, Object&gt;\n{\n    typedef T Object::* FieldPointer;\n\npublic:\n    QnFieldExternalGetter(const FieldPointer field) : m_field(field) {}\n\n    virtual T operator () (const Object* object) const override { return object-&gt;*m_field; }\n\nprivate:\n    FieldPointer m_field;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnFieldExternalSetter : public QnAbstractExternalSetter&lt;T, Object&gt;\n{\n    typedef T Object::* FieldPointer;\n\npublic:\n    QnFieldExternalSetter(FieldPointer field) : m_field(field) {}\n\n    virtual void operator () (Object* object, const T&amp; value) const override { object-&gt;*m_field = value; }\n\nprivate:\n    FieldPointer m_field;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnFieldGetter : public QnAbstractMemberGetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberGetter&lt;T, Object&gt; base_type;\n    typedef QnFieldExternalGetter&lt;T, Object&gt; ExternalGetter;\n\npublic:\n    QnFieldGetter(const Object* object, ExternalGetter field) : base_type(object), m_fieldGetter(field) {}\n    virtual T operator () () const override { return m_fieldGetter(this-&gt;object()); }\n\nprivate:\n    ExternalGetter m_fieldGetter;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnFieldSetter : public QnAbstractMemberSetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberSetter&lt;T, Object&gt; base_type;\n    typedef QnFieldExternalSetter&lt;T, Object&gt; ExternalSetter;\n\npublic:\n    QnFieldSetter(Object* object, ExternalSetter field) : base_type(object), m_fieldSetter(field) {}\n    virtual void operator () (const T&amp; value) const override { m_fieldSetter(this-&gt;object(), value); }\n\nprivate:\n    ExternalSetter m_fieldSetter;\n};\n\n/* Member function access */\n/* ---------------------- */\n\ntemplate&lt;class T, class Object, class MemberFunction&gt;\nclass QnMethodExternalGetter : public QnAbstractExternalGetter&lt;T, Object&gt;\n{\npublic:\n    QnMethodExternalGetter(MemberFunction method) : m_method(method) {}\n\n    virtual T operator () (const Object* object) const override { return (object-&gt;*m_method)(); }\n\nprivate:\n    MemberFunction m_method;\n};\n\ntemplate&lt;class T, class Object, class MemberFunction&gt;\nclass QnMethodExternalSetter : public QnAbstractExternalSetter&lt;T, Object&gt;\n{\npublic:\n    QnMethodExternalSetter(MemberFunction method) : m_method(method) {}\n\n    virtual void operator () (Object* object, const T&amp; value) const override { (object-&gt;*m_method)(value); }\n\nprivate:\n    MemberFunction m_method;\n};\n\ntemplate&lt;class T, class Object, class MemberFunction&gt;\nclass QnMethodGetter : public QnAbstractMemberGetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberGetter&lt;T, Object&gt; base_type;\n    typedef QnMethodExternalGetter&lt;T, Object, MemberFunction&gt; ExternalGetter;\n\npublic:\n    QnMethodGetter(const Object* object, ExternalGetter method) : base_type(object), m_methodGetter(method) {}\n    virtual T operator () () const override { return m_methodGetter(this-&gt;object()); }\n\nprivate:\n    ExternalGetter m_methodGetter;\n};\n\ntemplate&lt;class T, class Object, class MemberFunction&gt;\nclass QnMethodSetter : public QnAbstractMemberSetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberSetter&lt;T, Object&gt; base_type;\n    typedef QnMethodExternalSetter&lt;T, Object, MemberFunction&gt; ExternalSetter;\n\npublic:\n    QnMethodSetter(Object* object, ExternalSetter method) : base_type(object), m_methodSetter(method) {}\n    virtual void operator () (const T&amp; value) const override { m_methodSetter(this-&gt;object(), value); }\n\nprivate:\n    ExternalSetter m_methodSetter;\n};\n\n/* Automatically selected member access */\n/* ------------------------------------ */\n\nnamespace detail\n{\n    template&lt;class T, class Object, class GetMember&gt;\n    struct QnMemberGetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_object_pointer&lt;GetMember&gt;::value,   /* ? */\n                    QnFieldGetter&lt;T, Object&gt;,  /* : */\n                typename std::conditional&lt;std::is_member_function_pointer&lt;GetMember&gt;::value, /* ? */\n                    QnMethodGetter&lt;T, Object, GetMember&gt;, /* : */\n             /* default (error): */\n                    void&gt;::type&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class SetMember&gt;\n    struct QnMemberSetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_object_pointer&lt;SetMember&gt;::value,   /* ? */\n                    QnFieldSetter&lt;T, Object&gt;,  /* : */\n                typename std::conditional&lt;std::is_member_function_pointer&lt;SetMember&gt;::value, /* ? */\n                    QnMethodSetter&lt;T, Object, SetMember&gt;, /* : */\n             /* default (error): */\n                    void&gt;::type&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class GetMember&gt;\n    struct QnMemberExternalGetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_object_pointer&lt;GetMember&gt;::value,   /* ? */\n                    QnFieldExternalGetter&lt;T, Object&gt;,  /* : */\n                typename std::conditional&lt;std::is_member_function_pointer&lt;GetMember&gt;::value, /* ? */\n                    QnMethodExternalGetter&lt;T, Object, GetMember&gt;, /* : */\n             /* default (error): */\n                    void&gt;::type&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class SetMember&gt;\n    struct QnMemberExternalSetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_object_pointer&lt;SetMember&gt;::value,   /* ? */\n                    QnFieldExternalSetter&lt;T, Object&gt;,  /* : */\n                typename std::conditional&lt;std::is_member_function_pointer&lt;SetMember&gt;::value, /* ? */\n                    QnMethodExternalSetter&lt;T, Object, SetMember&gt;, /* : */\n             /* default (error): */\n                    void&gt;::type&gt;::type\n            type;\n    };\n\n} // namespace detail\n\ntemplate&lt;class T, class Object, class GetMember&gt;\nusing QnMemberGetter = typename detail::QnMemberGetterTypeSelector&lt;T, Object, GetMember&gt;::type;\n\ntemplate&lt;class T, class Object, class SetMember&gt;\nusing QnMemberSetter = typename detail::QnMemberSetterTypeSelector&lt;T, Object, SetMember&gt;::type;\n\ntemplate&lt;class T, class Object, class GetMember&gt;\nusing QnMemberExternalGetter = typename detail::QnMemberExternalGetterTypeSelector&lt;T, Object, GetMember&gt;::type;\n\ntemplate&lt;class T, class Object, class SetMember&gt;\nusing QnMemberExternalSetter = typename detail::QnMemberExternalSetterTypeSelector&lt;T, Object, SetMember&gt;::type;\n\n/* Access via functor */\n/* ------------------ */\n\ntemplate&lt;class T, class Functor&gt;\nclass QnFunctorGetter : public QnAbstractGetter&lt;T&gt;\n{\npublic:\n    QnFunctorGetter(Functor functor) : m_functor(functor) {}\n    virtual T operator () () const override { return m_functor(); }\n\nprivate:\n    Functor m_functor;\n};\n\ntemplate&lt;class T, class Functor&gt;\nclass QnFunctorSetter : public QnAbstractSetter&lt;T&gt;\n{\npublic:\n    QnFunctorSetter(Functor functor) : m_functor(functor) {}\n    virtual void operator () (const T&amp; value) const override { m_functor(value); }\n\nprivate:\n    Functor m_functor;\n};\n\ntemplate&lt;class T, class Object, class Functor&gt;\nclass QnFunctorExternalGetter : public QnAbstractExternalGetter&lt;T, Object&gt;\n{\npublic:\n    QnFunctorExternalGetter(Functor functor) : m_functor(functor) {}\n    virtual T operator () (const Object* object) const override { return m_functor(object); }\n\nprivate:\n    Functor m_functor;\n};\n\ntemplate&lt;class T, class Object, class Functor&gt;\nclass QnFunctorExternalSetter : public QnAbstractExternalSetter&lt;T, Object&gt;\n{\npublic:\n    QnFunctorExternalSetter(Functor functor) : m_functor(functor) {}\n    virtual void operator () (Object* object, const T&amp; value) const override { m_functor(object, value); }\n\nprivate:\n    Functor m_functor;\n};\n\n/* Direct variable access */\n/* ---------------------- */\n\ntemplate&lt;class T&gt;\nclass QnVariableGetter : public QnAbstractGetter&lt;T&gt;\n{\npublic:\n    QnVariableGetter(const T&amp; reference) : m_reference(reference) {}\n    QnVariableGetter(const T* pointer) : m_reference(*pointer) {}\n\n    virtual T operator () () const override { return m_reference; }\n\nprivate:\n    const T&amp; m_reference;\n};\n\ntemplate&lt;class T&gt;\nclass QnVariableSetter : public QnAbstractSetter&lt;T&gt;\n{\npublic:\n    QnVariableSetter(T&amp; reference) : m_reference(reference) {}\n    QnVariableSetter(T* pointer) : m_reference(*pointer) {}\n\n    virtual void operator () (const T&amp; value) const override { m_reference = value; }\n\nprivate:\n    T&amp; m_reference;\n};\n\n/* Automatically selected non-object access */\n/* ---------------------------------------- */\n\nnamespace detail\n{\n    template&lt;class T, class Get&gt;\n    struct QnGlobalScopeGetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_same&lt;T, typename std::remove_reference&lt;Get&gt;::type&gt;::value, /* ? */\n                    QnVariableGetter&lt;T&gt;, /* : */\n                    QnFunctorGetter&lt;T, Get&gt;&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Set&gt;\n    struct QnGlobalScopeSetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_same&lt;T, typename std::remove_reference&lt;Set&gt;::type&gt;::value, /* ? */\n                    QnVariableSetter&lt;T&gt;, /* : */\n                    QnFunctorSetter&lt;T, Set&gt;&gt;::type\n            type;\n    };\n\n} // namespace detail\n\ntemplate&lt;class T, class Get&gt;\nusing QnGlobalScopeGetter = typename detail::QnGlobalScopeGetterTypeSelector&lt;T, Get&gt;::type;\n\ntemplate&lt;class T, class Set&gt;\nusing QnGlobalScopeSetter = typename detail::QnGlobalScopeSetterTypeSelector&lt;T, Set&gt;::type;\n\n/* Automatically selected access */\n/* ----------------------------- */\n\nnamespace detail\n{\n    template&lt;class T, class Object, class Get&gt;\n    struct QnGetterTypeSelector\n    {\n        struct GlobalScopeAdaptor : public QnGlobalScopeGetter&lt;T, Get&gt;\n        {\n            GlobalScopeAdaptor(const Object*, Get get) : QnGlobalScopeGetter&lt;T, Get&gt;(get) {}\n        };\n\n        typedef typename std::conditional&lt;std::is_member_pointer&lt;Get&gt;::value, /* ? */\n                    QnMemberGetter&lt;T, Object, Get&gt;, /* : */\n                    GlobalScopeAdaptor&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class Set&gt;\n    struct QnSetterTypeSelector\n    {\n        struct GlobalScopeAdaptor : public QnGlobalScopeSetter&lt;T, Set&gt;\n        {\n            GlobalScopeAdaptor(Object*, Set set) : QnGlobalScopeSetter&lt;T, Set&gt;(set) {}\n        };\n\n        typedef typename std::conditional&lt;std::is_member_pointer&lt;Set&gt;::value, /* ? */\n                    QnMemberSetter&lt;T, Object, Set&gt;, /* : */\n                    GlobalScopeAdaptor&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class Get&gt;\n    struct QnExternalGetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_pointer&lt;Get&gt;::value, /* ? */\n                    QnMemberExternalGetter&lt;T, Object, Get&gt;, /* : */\n                    QnFunctorExternalGetter&lt;T, Object, Get&gt;&gt;::type\n            type;\n    };\n\n    template&lt;class T, class Object, class Set&gt;\n    struct QnExternalSetterTypeSelector\n    {\n        typedef typename std::conditional&lt;std::is_member_pointer&lt;Set&gt;::value, /* ? */\n                    QnMemberExternalSetter&lt;T, Object, Set&gt;, /* : */\n                    QnFunctorExternalSetter&lt;T, Object, Set&gt;&gt;::type\n            type;\n    };\n\n} // namespace detail\n\ntemplate&lt;class T, class Object, class Get&gt;\nusing QnGetter = typename detail::QnGetterTypeSelector&lt;T, Object, Get&gt;::type;\n\ntemplate&lt;class T, class Object, class Set&gt;\nusing QnSetter = typename detail::QnSetterTypeSelector&lt;T, Object, Set&gt;::type;\n\ntemplate&lt;class T, class Object, class Get&gt;\nusing QnExternalGetter = typename detail::QnExternalGetterTypeSelector&lt;T, Object, Get&gt;::type;\n\ntemplate&lt;class T, class Object, class Set&gt;\nusing QnExternalSetter = typename detail::QnExternalSetterTypeSelector&lt;T, Object, Set&gt;::type;\n\n/* Getter/setter utility aggregators with move semantics: */\n/* ------------------------------------------------------ */\n\ntemplate&lt;class T&gt;\nclass QnGetterAggregator : public QnAbstractGetter&lt;T&gt;\n{\npublic:\n    QnGetterAggregator(const QnAbstractGetter&lt;T&gt;* getter) : m_getter(getter) {}\n    virtual T operator () () const override { return (*m_getter)(); }\n\nprivate:\n    std::unique_ptr&lt;const QnAbstractGetter&lt;T&gt;&gt; m_getter;\n};\n\ntemplate&lt;class T&gt;\nclass QnSetterAggregator\n{\npublic:\n    QnSetterAggregator(const QnAbstractSetter&lt;T&gt;* setter) : m_setter(setter) {}\n    virtual void operator () (const T&amp; value) const { (*m_setter)(value); }\n\nprivate:\n    std::unique_ptr&lt;const QnAbstractSetter&lt;T&gt;&gt; m_setter;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnExternalGetterAggregator\n{\npublic:\n    QnExternalGetterAggregator(const QnAbstractExternalGetter&lt;T, Object&gt;* getter) : m_getter(getter) {}\n    virtual T operator () (const Object* object) const { return (*m_getter)(object); }\n\nprivate:\n    std::unique_ptr&lt;const QnAbstractExternalGetter&lt;T, Object&gt;&gt; m_getter;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnExternalSetterAggregator\n{\npublic:\n    QnExternalSetterAggregator(const QnAbstractExternalSetter&lt;T, Object&gt;* setter) : m_setter(setter) {}\n    virtual void operator () (Object* object, const T&amp; value) const { (*m_setter)(object, value); }\n\nprivate:\n    std::unique_ptr&lt;const QnAbstractExternalSetter&lt;T, Object&gt;&gt; m_setter;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnCascadeGetterAggregator : public QnAbstractMemberGetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberGetter&lt;T, Object&gt; base_type;\n    typedef QnAbstractExternalGetter&lt;T, Object&gt; ExternalGetter;\n\npublic:\n    QnCascadeGetterAggregator(const Object* object, const ExternalGetter* getter) : base_type(object), m_getter(getter) {}\n    virtual T operator () () const override { return (*m_getter)(this-&gt;object()); }\n\nprivate:\n    std::unique_ptr&lt;const ExternalGetter&gt; m_getter;\n};\n\ntemplate&lt;class T, class Object&gt;\nclass QnCascadeSetterAggregator : public QnAbstractMemberSetter&lt;T, Object&gt;\n{\n    typedef QnAbstractMemberSetter&lt;T, Object&gt; base_type;\n    typedef QnAbstractExternalSetter&lt;T, Object&gt; ExternalSetter;\n\npublic:\n    QnCascadeSetterAggregator(Object* object, const ExternalSetter* setter) : base_type(object), m_setter(setter) {}\n    virtual void operator () (const T&amp; value) const override { return (*m_setter)(this-&gt;object(), value); }\n\nprivate:\n    std::unique_ptr&lt;const ExternalSetter&gt; m_setter;\n};\n\n/* Typed accessor template */\n/* ----------------------- */\n\ntemplate&lt;class T, class Object&gt;\nclass QnTypedAccessor\n{\npublic:\n    QnTypedAccessor() = delete;\n    QnTypedAccessor(const QnTypedAccessor&amp;) = delete;\n\n    template&lt;class Get, class Set&gt;\n    QnTypedAccessor(Object* object, Get get, Set set) :\n        m_getter(new QnGetter&lt;T, Object, Get&gt;(object, get)),\n        m_setter(new QnSetter&lt;T, Object, Set&gt;(object, set))\n    {\n    }\n\n    template&lt;class Get, class Set&gt;\n    QnTypedAccessor(Get get, Set set) :\n        m_getter(new QnGlobalScopeGetter&lt;T, Get&gt;(get)),\n        m_setter(new QnGlobalScopeSetter&lt;T, Set&gt;(set))\n    {\n    }\n\n    const T&amp; get() const { return m_getter(); }\n    void set(const T&amp; value) const { m_setter(value); }\n\n    QnGetterAggregator&lt;T&gt; m_getter;\n    QnSetterAggregator&lt;T&gt; m_setter;\n};\n\nnamespace Qn {\n\n/* Helper functions to choose accessor overloads */\n/* --------------------------------------------- */\n\ntemplate &lt;class Get&gt;\nGet getter_helper(Get get)\n{\n    return get;\n}\n\ntemplate &lt;class Set&gt;\nSet setter_helper(Set set)\n{\n    return set;\n}\n\ntemplate&lt;class T&gt;\nauto getter_helper(T (*get)())\n{\n    return get;\n}\n\ntemplate&lt;class T&gt;\nauto getter_helper(const T&amp; (*get)())\n{\n    return get;\n}\n\ntemplate&lt;class T, class Object&gt;\nauto getter_helper(T (Object::*get)() const)\n{\n    return get;\n}\n\ntemplate&lt;class T, class Object&gt;\nauto getter_helper(const T&amp; (Object::*get)() const)\n{\n    return get;\n}\n\ntemplate&lt;class T&gt;\nauto setter_helper(void (*set)(T))\n{\n    return set;\n}\n\ntemplate&lt;class T&gt;\nauto setter_helper(void (*set)(const T&amp;))\n{\n    return set;\n}\n\ntemplate&lt;class T, class Object&gt;\nauto setter_helper(void (Object::*set)(T))\n{\n    return set;\n}\n\ntemplate&lt;class T, class Object&gt;\nauto setter_helper(void (Object::*set)(const T&amp;))\n{\n    return set;\n}\n\n#define QN_GETTER(x) Qn::getter_helper(&amp;x)\n#define QN_SETTER(x) Qn::setter_helper(&amp;x)\n\n/* Sample: cutting off wrong overload of QWidget::setContentsMargins\n *    QnTypedAccessor&lt;QMargins, QWidget&gt; accessor(widget, &amp;QWidget::contentsMargins, QN_SETTER(QWidget::setContentsMargins));\n */\n\n} // namespace Qn\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QSettings&gt;\n\n#include &lt;QtCore/QAtomicInt&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/fusion/serialization/json_functions.h&gt;\n#include &lt;nx/fusion/serialization/lexical_functions.h&gt;\n#include &lt;nx/reflect/string_conversion.h&gt;\n#include &lt;nx/utils/safe_direct_connection.h&gt;\n\n// TODO: #sivanov Create meta_functions and move json_serializer, lexical_serializer,\n// linear_combinator &amp; magnitude_calculator there.\n// TODO: #sivanov Use equals from Qt5.2 variant.\n\nclass QnAbstractResourcePropertyHandler {\npublic:\n    QnAbstractResourcePropertyHandler() {}\n    virtual ~QnAbstractResourcePropertyHandler() {}\n\n    virtual bool serialize(const QVariant &amp;value, QString *target) const = 0;\n    virtual bool deserialize(const QString &amp;value, QVariant *target) const = 0;\n    virtual bool equals(const QVariant &amp;l, const QVariant &amp;r) const = 0;\n};\n\ntemplate&lt;class T&gt;\nclass QnResourcePropertyHandler: public QnAbstractResourcePropertyHandler {\npublic:\n    QnResourcePropertyHandler(): m_type(QMetaType::fromType&lt;T&gt;()) {}\n\n    virtual bool equals(const QVariant &amp;l, const QVariant &amp;r) const override {\n        if (l.userType() != m_type.id() || r.userType() != m_type.id())\n            return false;\n\n        const T &amp;ll = *static_cast&lt;const T *&gt;(l.constData());\n        const T &amp;rr = *static_cast&lt;const T *&gt;(r.constData());\n        return ll == rr;\n    }\n\n    virtual bool serialize(const QVariant &amp;value, QString *target) const override {\n        if (value.userType() == m_type.id()) {\n            return serialize(*static_cast&lt;const T *&gt;(value.constData()), target);\n        } else {\n            return false;\n        }\n    }\n\n    virtual bool deserialize(const QString &amp;value, QVariant *target) const override {\n        if (target-&gt;userType() != m_type.id())\n            *target = QVariant(m_type);\n\n        return deserialize(value, static_cast&lt;T *&gt;(target-&gt;data()));\n    }\n\n    virtual bool serialize(const T &amp;value, QString *target) const = 0;\n    virtual bool deserialize(const QString &amp;value, T *target) const = 0;\n\nprivate:\n    QMetaType m_type;\n};\n\ntemplate&lt;class T&gt;\nclass QnJsonResourcePropertyHandler: public QnResourcePropertyHandler&lt;T&gt; {\npublic:\n    virtual bool serialize(const T &amp;value, QString *target) const override {\n        *target = QString::fromUtf8(QJson::serialized(value));\n        return true;\n    }\n\n    virtual bool deserialize(const QString &amp;value, T *target) const override {\n        QnJsonContext ctx;\n        ctx.setAllowStringConversions(true);\n        ctx.setStrictMode(true);\n        return QJson::deserialize(&amp;ctx, value.toUtf8(), target);\n    }\n};\n\ntemplate&lt;class T&gt;\nclass QnLexicalResourcePropertyHandler: public QnResourcePropertyHandler&lt;T&gt; {\npublic:\n    virtual bool serialize(const T &amp;value, QString *target) const override {\n        *target = QnLexical::serialized(value);\n        return true;\n    }\n\n    virtual bool deserialize(const QString &amp;value, T *target) const override {\n        return QnLexical::deserialize(value, target);\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass QnReflectLexicalResourcePropertyHandler: public QnResourcePropertyHandler&lt;T&gt;\n{\npublic:\n    virtual bool serialize(const T&amp; value, QString* target) const override\n    {\n        *target = QString::fromStdString(nx::reflect::toString(value));\n        return true;\n    }\n\n    virtual bool deserialize(const QString&amp; value, T* target) const override\n    {\n        return nx::reflect::fromString(value.toStdString(), target);\n    }\n};\n\n/**\n * Base class for accessing resource properties.\n *\n * This class is thread-safe.\n */\nclass NX_VMS_COMMON_API QnAbstractResourcePropertyAdaptor:\n    public QObject,\n    public /*mixin*/ Qn::EnableSafeDirectConnection\n{\n    Q_OBJECT\n    typedef QObject base_type;\n\npublic:\n    QnAbstractResourcePropertyAdaptor(\n        const QString&amp; key,\n        const QVariant&amp; defaultValue,\n        QnAbstractResourcePropertyHandler* handler,\n        QObject* parent = NULL,\n        std::function&lt;QString()&gt; label = nullptr);\n    virtual ~QnAbstractResourcePropertyAdaptor();\n\n    const QString&amp; key() const;\n    QString label() const;\n\n    QnResourcePtr resource() const;\n    void setResource(const QnResourcePtr &amp;resource);\n\n    QVariant value() const;\n    bool isDefault() const; //&lt; True if no explicit (not default) value has been set.\n    QString serializedValue() const;\n    bool deserializeValue(const QString&amp; serializedValue, QVariant* outValue) const;\n    virtual QJsonValue jsonValue(QnJsonContext* context = nullptr) const = 0;\n\n    bool testAndSetValue(const QVariant &amp;expectedValue, const QVariant &amp;newValue);\n    virtual void setValue(const QVariant&amp; value) = 0;\n    virtual void setJsonValue(const QJsonValue&amp; value) = 0;\n    virtual void setSerializedValue(const QVariant&amp; value);\n\n    virtual bool isSerializedValueValid(const QString&amp; value) const = 0;\n    virtual bool isJsonValueValid(const QJsonValue&amp; value) const = 0;\n\n    void saveToResource();\n    bool takeFromSettings(QSettings* settings, const QString&amp; preffix);\n\n    bool isReadOnly() const { return m_isReadOnly; }\n    bool isWriteOnly() const { return m_isWriteOnly; }\n    bool isHidden() const { return isReadOnly() &amp;&amp; isWriteOnly(); }\n    bool isSecurity() const { return m_isSecurity; }\n\n    void markReadOnly() { m_isReadOnly = true; }\n    void markWriteOnly() { m_isWriteOnly = true; }\n    void markSecurity() { m_isSecurity = true; }\n\nsignals:\n    void valueChanged();\n    void synchronizationNeeded(const QnResourcePtr&amp; resource);\n\nprotected:\n    QString defaultSerializedValue() const;\n    virtual QString defaultSerializedValueLocked() const;\n    void setValueInternal(const QVariant&amp; value);\n\nprivate:\n    void loadValue(const QString &amp;serializedValue);\n    bool loadValueLocked(const QString &amp;serializedValue);\n\n    void processSaveRequests();\n    void processSaveRequestsNoLock(const QnResourcePtr &amp;resource, const QString &amp;serializedValue);\n    void enqueueSaveRequest();\n    Q_SIGNAL void saveRequestQueued();\n\n    void setResourceInternal(const QnResourcePtr &amp;resource, bool notify);\n\n    Q_SLOT void at_resource_propertyChanged(const QnResourcePtr &amp;resource, const QString &amp;key, const QString&amp; prevValue, const QString&amp; newValue);\n\nprivate:\n    const QString m_key;\n    const std::function&lt;QString()&gt; m_label;\n    const QVariant m_defaultValue;\n    const QScopedPointer&lt;QnAbstractResourcePropertyHandler&gt; m_handler;\n    QAtomicInt m_pendingSave;\n\n    mutable nx::Mutex m_mutex;\n    QnResourcePtr m_resource;\n    QString m_serializedValue;\n    QVariant m_value;\n\n    bool m_isReadOnly = false;\n    bool m_isWriteOnly = false;\n    bool m_isSecurity = false;\n};\n\ntemplate&lt;class T&gt;\nclass QnResourcePropertyAdaptor: public QnAbstractResourcePropertyAdaptor {\n    typedef QnAbstractResourcePropertyAdaptor base_type;\npublic:\n    QnResourcePropertyAdaptor(\n        const QString&amp; key,\n        QnResourcePropertyHandler&lt;T&gt;* handler,\n        const T&amp; defaultValue,\n        std::function&lt;bool(const T&amp;)&gt; isValueValid = nullptr,\n        QObject* parent = NULL,\n        std::function&lt;QString()&gt; label = nullptr)\n        :\n        QnAbstractResourcePropertyAdaptor(\n            key, QVariant::fromValue(defaultValue), handler, parent, std::move(label)),\n        m_type(QMetaType::fromType&lt;T&gt;()),\n        m_defaultValue(defaultValue),\n        m_isValueValid(std::move(isValueValid))\n    {\n        NX_CRITICAL(this-&gt;isValueValid(m_defaultValue), QJson::serialized(m_defaultValue));\n        if (handler)\n            handler-&gt;serialize(QVariant::fromValue(defaultValue), &amp;m_defaultSerializedValue);\n    }\n\n    QnResourcePropertyAdaptor(\n        const QString&amp; key,\n        QnResourcePropertyHandler&lt;T&gt;* handler,\n        const T&amp; defaultValue,\n        QObject* parent,\n        std::function&lt;QString()&gt; label = nullptr)\n        :\n        QnResourcePropertyAdaptor(key, handler, defaultValue, nullptr, parent, std::move(label))\n    {\n    }\n\n    T value() const\n    {\n        QVariant baseValue = base_type::value();\n        if (baseValue.userType() == m_type.id())\n        {\n            if (auto v = baseValue.value&lt;T&gt;(); isValueValid(v))\n                return v;\n        }\n\n        return m_defaultValue;\n    }\n\n    QVariant rawValue() const\n    {\n        return base_type::value();\n    }\n\n    static QJsonValue jsonValue(QnJsonContext* context, const T&amp; value)\n    {\n        QJsonValue result;\n\n        if (context)\n            QJson::serialize(context, value, &amp;result);\n        else\n            QJson::serialize(value, &amp;result);\n\n        return result;\n    }\n\n    virtual QJsonValue jsonValue(QnJsonContext* context = nullptr) const override\n    {\n        return jsonValue(context, value());\n    }\n\n    virtual void setValue(const QVariant&amp; value) override\n    {\n        //converting incoming value to expected type\n        base_type::setValueInternal(QVariant::fromValue(value.value&lt;T&gt;()));\n    }\n\n    virtual void setJsonValue(const QJsonValue&amp; value) override\n    {\n        if (const auto typedValue = QJson::deserializeOrThrow&lt;T&gt;(value); isValueValid(typedValue))\n            return setValue(typedValue);\n\n        throw nx::json::InvalidParameterException{{key(), QString{QJson::serialized(value)}}};\n    }\n\n    void setValue(const T&amp; value)\n    {\n        NX_ASSERT(isValueValid(value), &quot;%1 = %2&quot;, key(), QJson::serialized(m_defaultValue));\n        base_type::setValueInternal(QVariant::fromValue(value));\n    }\n\n    bool testAndSetValue(const T&amp; expectedValue, const T&amp; newValue)\n    {\n        return base_type::testAndSetValue(\n            QVariant::fromValue(expectedValue), QVariant::fromValue(newValue));\n    }\n\n    bool isValueValid(const T&amp; value) const\n    {\n        return m_isValueValid ? m_isValueValid(value) : true;\n    }\n\n    virtual bool isSerializedValueValid(const QString&amp; serializedValue) const override\n    {\n        QVariant value(m_type, nullptr);\n        return deserializeValue(serializedValue, &amp;value) &amp;&amp; isValueValid(value.value&lt;T&gt;());\n    }\n\n    virtual bool isJsonValueValid(const QJsonValue&amp; value) const override\n    {\n        T typedValue;\n        return QJson::deserialize&lt;T&gt;(value, &amp;typedValue) &amp;&amp; isValueValid(typedValue);\n    }\n\nprotected:\n    virtual QString defaultSerializedValueLocked() const override\n    {\n        return m_defaultSerializedValue;\n    }\n\nprivate:\n    const QMetaType m_type;\n    const T m_defaultValue;\n    const std::function&lt;bool(const T&amp;)&gt; m_isValueValid;\n    QString m_defaultSerializedValue;\n};\n\ntemplate&lt;class T&gt;\nclass QnJsonResourcePropertyAdaptor: public QnResourcePropertyAdaptor&lt;T&gt;\n{\npublic:\n    template&lt;typename... Args&gt;\n    QnJsonResourcePropertyAdaptor(const QString &amp;key, Args... args):\n        QnResourcePropertyAdaptor&lt;T&gt;(\n            key, new QnJsonResourcePropertyHandler&lt;T&gt;(), std::forward&lt;Args&gt;(args)...)\n    {\n    }\n};\n\ntemplate&lt;class T&gt;\nclass QnLexicalResourcePropertyAdaptor: public QnResourcePropertyAdaptor&lt;T&gt;\n{\npublic:\n    template&lt;typename... Args&gt;\n    QnLexicalResourcePropertyAdaptor(const QString &amp;key, Args... args):\n        QnResourcePropertyAdaptor&lt;T&gt;(\n            key, new QnLexicalResourcePropertyHandler&lt;T&gt;(), std::forward&lt;Args&gt;(args)...)\n    {\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass QnReflectLexicalResourcePropertyAdaptor: public QnResourcePropertyAdaptor&lt;T&gt;\n{\npublic:\n    template&lt;typename... Args&gt;\n    QnReflectLexicalResourcePropertyAdaptor(const QString&amp; key, Args... args):\n        QnResourcePropertyAdaptor&lt;T&gt;(\n            key, new QnReflectLexicalResourcePropertyHandler&lt;T&gt;(), std::forward&lt;Args&gt;(args)...)\n    {\n    }\n};\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/dataconsumer/abstract_data_receptor.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/dataconsumer/abstract_data_receptor.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/dataconsumer/abstract_data_receptor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QSharedPointer&gt;\n\n#include &lt;nx/media/media_data_packet.h&gt;\n\n/**\n * Abstract interface of class, accepting media data.\n * NOTE: In a correct way we should make QnAbstractDataConsumer not thread\n *   and add another class derived from QnAbstractDataConsumer.\n */\nclass NX_VMS_COMMON_API QnAbstractDataReceptor\n{\npublic:\n    virtual ~QnAbstractDataReceptor();\n\n    /**\n     * @return true, if subsequent QnAbstractDataReceptor::putData\n     *   call is guaranteed to accept input data.\n     */\n    virtual bool canAcceptData() const = 0;\n\n    /**\n     * NOTE: Can ignore data for some reasons (e.g., some internal buffer size is exceeded).\n     * Data provider should use canAcceptData method to find out whether it is possible.\n     */\n    virtual void putData(const QnAbstractDataPacketPtr&amp; data) = 0;\n\n    virtual void clearUnprocessedData() = 0;\n\n    /** Sanity check. */\n    std::atomic&lt;size_t&gt; consumers{0};\n};\n\nusing QnAbstractDataReceptorPtr = QSharedPointer&lt;QnAbstractDataReceptor&gt;;\n\nclass QnAbstractMediaDataReceptor:\n    public QnAbstractDataReceptor\n{\npublic:\n    /**\n     * DataReceptor is required that provider should be fully configured.\n     */\n    virtual bool needConfigureProvider() const { return true; }\n\n    /**\n     * Allow to replace video data if Tier limit overused.\n     */\n    virtual bool canReplaceData() const { return true; }\n};\n\nusing QnAbstractMediaDataReceptorPtr = QSharedPointer&lt;QnAbstractMediaDataReceptor&gt;;\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/ptz/abstract_ptz_controller.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/ptz/abstract_ptz_controller.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/ptz/abstract_ptz_controller.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &lt;core/ptz/ptz_auxiliary_trait.h&gt;\n#include &lt;core/ptz/ptz_data.h&gt;\n#include &lt;core/ptz/ptz_fwd.h&gt;\n#include &lt;core/ptz/ptz_limits.h&gt;\n#include &lt;core/ptz/ptz_math.h&gt;\n#include &lt;core/ptz/ptz_object.h&gt;\n#include &lt;core/ptz/ptz_preset.h&gt;\n#include &lt;core/ptz/ptz_tour.h&gt;\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/vms/common/ptz/command.h&gt;\n#include &lt;nx/vms/common/ptz/coordinate_space.h&gt;\n#include &lt;nx/vms/common/ptz/datafield.h&gt;\n#include &lt;nx/vms/common/ptz/options.h&gt;\n\n/**\n * A thread-safe blocking interface for accessing camera&#x27;s PTZ functions.\n */\nclass NX_VMS_COMMON_API QnAbstractPtzController: public QObject\n{\n    Q_OBJECT\n    using base_type = QObject;\n\nprotected:\n    using Command = nx::vms::common::ptz::Command;\n    using CoordinateSpace = nx::vms::common::ptz::CoordinateSpace;\n    using DataField = nx::vms::common::ptz::DataField;\n    using DataFields = nx::vms::common::ptz::DataFields;\n    using Options = nx::vms::common::ptz::Options;\n    using Override = nx::vms::common::ptz::Override;\n    using Type = nx::vms::common::ptz::Type;\n    using Vector = nx::vms::common::ptz::Vector;\n\npublic:\n    static const qreal MaxPtzSpeed;\n\n    /**\n     * @param resource Resource that this PTZ controller belongs to.\n     */\n    QnAbstractPtzController(const QnResourcePtr&amp; resource);\n    virtual ~QnAbstractPtzController();\n\n    /**\n     * @returns Resource that this PTZ controller belongs to.\n     */\n    virtual QnResourcePtr resource() const;\n\n    /**\n     * This method will be invoked after the controller is moved to the executor thread.\n     * Note: invocation is done through the event loop in the executor thread.\n     */\n    virtual void initialize();\n\n    /** Mark meaningful data invalid and forces to re-request it at some time. */\n    virtual void invalidate();\n\npublic slots: //&lt; Class is exposed to QML. All functions in section below are invokable\n    /**\n     * @param capabilities Capabilities to check.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether this controller implements the given capabilities.\n     */\n    bool hasCapabilities(\n        Ptz::Capabilities capabilities,\n        const Options&amp; options = {Type::operational}) const;\n\n    /**\n     * @returns PTZ capabilities that this controller implements.\n     * @param options Additional options (e.g. ptz type)\n     */\n    virtual Ptz::Capabilities getCapabilities(\n        const Options&amp; options = {Type::operational}) const = 0;\n\n    /**\n     * @param command Ptz command to check.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether this controller supports the given command.\n     */\n    bool supports(\n        Command command,\n        const Options&amp; options = {Type::operational}) const;\n\n    /**\n     * Starts or stops continuous PTZ movement.\n     *\n     * Speed is specified in image-based coordinate space and all of its\n     * components are expected to be in range &lt;tt&gt;[-1, 1]&lt;/tt&gt;. This means that\n     * implementation must handle flipped / mirrored state of the video stream.\n     *\n     * Passing zero in speed should stop PTZ movement.\n     *\n     * This function is expected to be implemented if this controller has\n     * at least one of the &lt;tt&gt;Ptz::Capability::continuousPanTiltZoomRotation&lt;/tt&gt;.\n     *\n     * @param speed Movement speed.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool continuousMove(\n        const Vector&amp; speed,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Starts or stops continuous focus movement.\n     *\n     * Speed is specified in device-specific coordinate space and is expected\n     * to be in range &lt;tt&gt;[-1, 1]&lt;/tt&gt;. Positive speed is for far focus.\n     *\n     * Passing zero should stop focus movement.\n     *\n     * This function is expected to be implemented if this controller has\n     * &lt;tt&gt;Ptz::Capability::continuousFocus&lt;/tt&gt;.\n     *\n     * @param speed Focus speed.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool continuousFocus(\n        qreal speed,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Sets camera PTZ position in the given coordinate space.\n     *\n     * Note that for the function to succeed, this controller must have a\n     * capability corresponding to the provided coordinate space,\n     * that is &lt;tt&gt;Ptz::Capability::devicePositioning&lt;/tt&gt; or\n     * &lt;tt&gt;Ptz::Capability::logicalPositioning&lt;/tt&gt;.\n     *\n     * This function is expected to be implemented if this controller has\n     * at least one of the &lt;tt&gt;Ptz::Capability::absolutePanTiltZoomRotation&lt;/tt&gt;.\n     *\n     * @param space Coordinate space of the provided position.\n     * @param position Position to move to.\n     * @param speed Movement speed, in range [0, 1].\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool absoluteMove(\n        CoordinateSpace space,\n        const Vector&amp; position,\n        qreal speed,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Moves camera&#x27;s viewport relative to current viewport. New viewport\n     * coordinates are provided in a coordinate space where current viewport\n     * is a square with side 1 with top-left at &lt;tt&gt;(0, 0)&lt;/tt&gt;.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::viewport&lt;/tt&gt;.\n     *\n     * @param aspectRatio Actual aspect ratio of the current viewport.\n     * @param viewport New viewport position.\n     * @param speed Movement speed, in range [0, 1].\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool viewportMove(\n        qreal aspectRatio,\n        const QRectF&amp; viewport,\n        qreal speed,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Moves the camera relative to its current position.\n     *\n     * This function is expected to be implemented if this controller has\n     * at least one of the &lt;tt&gt;Ptz::Capability::relativePanTiltZoomRotation&lt;/tt&gt;.\n     *\n     * @param direction Direction to move. Each component must be in range [-1, 1].\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool relativeMove(\n        const Vector&amp; direction,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Changes the camera focus relatively to its current position.\n     *\n     * This function is expected to be implemented if this controller has\n     * &lt;tt&gt;Ptz::Capability::relativeFocus&lt;/tt&gt;.\n     *\n     * @param direction. Direction to move, must be in range [-1, 1].\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool relativeFocus(\n        qreal direction,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Gets PTZ position from camera in the given coordinate space.\n     *\n     * This function is expected to be implemented if this controller has\n     * at least one of the &lt;tt&gt;Ptz::Capability::absolutePanTiltZoom&lt;/tt&gt;.\n     *\n     * @param space Coordinate space to get position in.\n     * @param[out] position Current ptz position.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     * @see absoluteMove\n     */\n    virtual bool getPosition(\n        Vector* outPosition,\n        CoordinateSpace space,\n        const Options&amp; options = {Type::operational}) const = 0;\n\n    /**\n     * Gets PTZ limits of the camera.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::limits&lt;tt&gt;.\n     *\n     * @param space Coordinate space to get limits in.\n     * @param[out] limits Ptz limits.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getLimits(\n        QnPtzLimits* limits,\n        CoordinateSpace space,\n        const Options&amp; options = {Type::operational}) const = 0;\n\n    /**\n     * Returns the camera streams&#x27;s flipped state. This function can be used for\n     * implementing emulated viewport movement.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::flip&lt;/tt&gt;.\n     *\n     * @param[out] flip Flipped state of the camera&#x27;s video stream.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getFlip(\n        Qt::Orientations* flip,\n        const Options&amp; options = {Type::operational}) const = 0;\n\n    /**\n     * Saves current PTZ position as a preset, either as a new one or\n     * replacing an existing one. Note that id of the provided preset\n     * must be set.\n     *\n     * If you want to create a new preset, a good idea would be to set its id to\n     * &lt;tt&gt;nx::Uuid::createUuid().toString()&lt;/tt&gt;.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::presets&lt;tt&gt;.\n     *\n     * @param preset Preset to create.\n     * @returns Whether the operation was successful.\n     */\n    virtual bool createPreset(const QnPtzPreset&amp; preset) = 0;\n\n    /**\n     * Updates the given preset without changing its associated position.\n     * Currently this function can only be used to change preset name.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::presets&lt;tt&gt;.\n     *\n     * @param preset Preset to update.\n     * @returns Whether the operation was successful.\n     */\n    virtual bool updatePreset(const QnPtzPreset&amp; preset) = 0;\n\n    /**\n     * Removes the given preset.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::presets&lt;tt&gt;.\n     *\n     * @param presetId Id of the preset to remove.\n     * @returns Whether the operation was successful.\n     */\n    virtual bool removePreset(const QString&amp; presetId) = 0;\n\n    /**\n     * Activates the given preset.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::presets&lt;tt&gt;.\n     *\n     * @param presetId Id of the preset to activate.\n     * @param speed Movement speed, in range [0, 1].\n     * @returns Whether the operation was successful.\n     */\n    virtual bool activatePreset(const QString&amp; presetId, qreal speed) = 0;\n\n    /**\n     * Gets a list of all PTZ presets for the camera.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::presets&lt;tt&gt;.\n     *\n     * @param[out] presets PTZ presets.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getPresets(QnPtzPresetList* presets) const = 0;\n\n    /**\n     * Saves the given tour either as a new one, or replacing an existing one.\n     * Note that id of the provided preset must be set.\n     *\n     * If you want to create a new preset, a good idea would be to set its id to\n     * &lt;tt&gt;nx::Uuid::createUuid().toString()&lt;/tt&gt;.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::tours&lt;tt&gt;.\n     *\n     * @param tour Tour to create.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool createTour(const QnPtzTour&amp; tour) = 0;\n\n    /**\n     * Removes the given tour.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::tours&lt;tt&gt;.\n     *\n     * @param tourId Id of the tour to remove.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool removeTour(const QString&amp; tourId) = 0;\n\n    /**\n     * Activates the given tour.\n     *\n     * Note that after the tour has been started, any movement command issued\n     * to the controller will stop that tour.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::tours&lt;tt&gt;.\n     *\n     * @param tourId Id of the tour to activate.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool activateTour(const QString&amp; tourId) = 0;\n\n    virtual std::optional&lt;QnPtzTour&gt; getActiveTour();\n\n    /**\n     * Gets a list of all PTZ tours for the camera.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::tours&lt;tt&gt;.\n     *\n     * @param[out] tours PTZ tours.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getTours(QnPtzTourList* tours) const = 0;\n\n    virtual bool getActiveObject(QnPtzObject* activeObject) const = 0;\n\n    /**\n     * Updates PTZ home position for the camera.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::home&lt;tt&gt;.\n     *\n     * @param homeObject PTZ home object.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool updateHomeObject(const QnPtzObject&amp; homeObject) = 0;\n\n    /**\n     * Gets PTZ home position that is currently assigned for the camera.\n     *\n     * This function is expected to be implemented only if this controller has\n     * &lt;tt&gt;Ptz::Capability::home&lt;tt&gt;.\n     *\n     * @param[out] homePosition PTZ home object.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getHomeObject(QnPtzObject* homeObject) const = 0;\n\n    virtual bool getAuxiliaryTraits(\n        QnPtzAuxiliaryTraitList* auxiliaryTraits,\n        const Options&amp; options = {Type::operational}) const = 0;\n\n    virtual bool runAuxiliaryCommand(\n        const QnPtzAuxiliaryTrait&amp; trait,\n        const QString&amp; data,\n        const Options&amp; options = {Type::operational}) = 0;\n\n    /**\n     * Gets all PTZ data associated with this controller in a single operation.\n     * Default implementation just calls all the accessor functions one by one.\n     *\n     * @param query Data fields to get.\n     * @param[out] data PTZ data.\n     * @param options Additional options (e.g. ptz type)\n     * @returns Whether the operation was successful.\n     */\n    virtual bool getData(\n        QnPtzData* data,\n        DataFields query,\n        const Options&amp; options = {Type::operational}) const;\n\nsignals:\n    void changed(nx::vms::common::ptz::DataFields fields);\n    void finished(nx::vms::common::ptz::Command command, const QVariant&amp; data);\n\nprotected:\n    static Command spaceCommand(Command command, CoordinateSpace space);\n\nprivate:\n    QnResourcePtr m_resource;\n};\n\nbool deserialize(const QString&amp; value, QnPtzObject* target);\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/filter_chain.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/filter_chain.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/filter_chain.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;core/resource/resource_media_layout.h&gt;\n#include &lt;nx/core/transcoding/filters/transcoding_settings.h&gt;\n#include &lt;nx/vms/api/data/dewarping_data.h&gt;\n#include &lt;transcoding/filters/abstract_image_filter.h&gt;\n\nclass CLVideoDecoderOutput;\nusing CLVideoDecoderOutputPtr = QSharedPointer&lt;CLVideoDecoderOutput&gt;;\n\nnamespace nx {\nnamespace core {\nnamespace transcoding {\n\nclass NX_VMS_COMMON_API FilterChain: public QnAbstractImageFilterList\n{\npublic:\n    const static QSize kDefaultResolutionLimit;\n\n    FilterChain() = default;\n\n    explicit FilterChain(const Settings&amp; settings,\n        nx::vms::api::dewarping::MediaData dewarpingParams, // TODO move it to settings?\n        QnConstResourceVideoLayoutPtr layout);\n\n    FilterChain(const FilterChain&amp;) = default;\n    FilterChain&amp; operator=(const FilterChain&amp;) = default;\n\n    /**\n     * Prepare set of filters to apply to video data.\n     */\n    void prepare(const QSize&amp; srcFrameResolution,\n        const QSize&amp; resolutionLimit = kDefaultResolutionLimit);\n\n    /**\n     * Prepare set of filters to apply to an image. Main difference is that panoramic cameras\n     * screenshots do not require tiling (already transcoded), but aspect ratio must be calculated\n     * concerning video layout size.\n     */\n    void prepareForImage(const QSize&amp; fullImageResolution,\n        const QSize&amp; resolutionLimit = kDefaultResolutionLimit);\n\n    /**\n     * Check if chain contains any options that require transcoding.\n     * @param concernTiling If video layout transcoding (tiling) matters - it is not applied while\n     *     transcoding images.\n     */\n    bool isTranscodingRequired(bool concernTiling = true) const;\n\n    bool isImageTranscodingRequired(const QSize&amp; fullImageResolution,\n        const QSize&amp; resolutionLimit = kDefaultResolutionLimit) const;\n\n    bool isDownscaleRequired(const QSize&amp; srcResolution) const;\n\n    bool isReady() const;\n    void reset();\n\n    QSize apply(const QSize&amp; resolution) const;\n    CLVideoDecoderOutputPtr apply(\n        const CLVideoDecoderOutputPtr&amp; source,\n        const QnAbstractCompressedMetadataPtr&amp; metadata) const;\n\n    void addLegacyFilter(QnAbstractImageFilterPtr filter);\n\nprivate:\n    void prepareVideoArFilter(const QSize&amp; srcFrameResolution);\n    void prepareImageArFilter(const QSize&amp; fullImageResolution);\n    void prepareDewarpingFilter();\n    void prepareZoomWindowFilter();\n    void prepareImageEnhancementFilter();\n    void prepareRotationFilter();\n    void prepareOverlaysFilters();\n    void prepareWatermarkFilter();\n    void prepareDownscaleFilter(const QSize&amp; srcFrameResolution, const QSize&amp; resolutionLimit);\n    void createScaleImageFilter(const QSize&amp; dstSize);\n    void createPixelationImageFilter();\n\nprivate:\n    bool m_ready = false;\n    Settings m_settings;\n    nx::vms::api::dewarping::MediaData m_dewarpingParams;\n    QnConstResourceVideoLayoutPtr m_layout;\n    QnAbstractImageFilterList m_legacyFilters;\n};\n\n} // namespace transcoding\n} // namespace core\n} // namespace nx\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/legacy_transcoding_settings.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/legacy_transcoding_settings.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/legacy_transcoding_settings.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QRect&gt;\n\n#include &lt;core/resource/resource_fwd.h&gt;\n#include &lt;nx/core/transcoding/filters/timestamp_params.h&gt;\n#include &lt;nx/core/watermark/watermark.h&gt;\n#include &lt;nx/vms/api/data/dewarping_data.h&gt;\n#include &lt;nx/vms/api/data/image_correction_data.h&gt;\n#include &lt;nx/vms/api/data/media_settings.h&gt;\n#include &lt;utils/common/aspect_ratio.h&gt;\n\nnamespace nx {\nnamespace core {\nnamespace transcoding {\n\nstruct NX_VMS_COMMON_API LegacyTranscodingSettings\n{\n    LegacyTranscodingSettings() = default;\n    LegacyTranscodingSettings(\n        const QnMediaResourcePtr&amp; resource,\n        const nx::vms::api::MediaSettings* settings = nullptr);\n    LegacyTranscodingSettings(const LegacyTranscodingSettings&amp;) = default;\n    LegacyTranscodingSettings&amp; operator=(const LegacyTranscodingSettings&amp;) = default;\n\n    QnMediaResourcePtr resource;\n\n    QnAspectRatio forcedAspectRatio;\n    int rotation = 0;\n    QRectF zoomWindow;\n    nx::vms::api::ImageCorrectionData contrastParams;\n    bool forceDewarping = false;\n    nx::vms::api::dewarping::ViewData itemDewarpingParams;\n    nx::core::transcoding::TimestampParams timestampParams;\n    nx::core::transcoding::FilterParams cameraNameParams;\n    Watermark watermark;\n    bool panoramic = false;\n\n    bool isEmpty() const;\n};\n\n} // namespace transcoding\n} // namespace core\n} // namespace nx\n\nusing QnLegacyTranscodingSettings = nx::core::transcoding::LegacyTranscodingSettings;\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_archive_resource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_archive_resource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_archive_resource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef ABSTRACT_ARCHIVE_RESOURCE_H\n#define ABSTRACT_ARCHIVE_RESOURCE_H\n\n#include &lt;core/resource/media_resource.h&gt;\n#include &lt;core/resource/resource.h&gt;\n\nclass NX_VMS_COMMON_API QnAbstractArchiveResource: public QnMediaResource\n{\n    Q_OBJECT;\n\npublic:\n    QnAbstractArchiveResource();\n    ~QnAbstractArchiveResource();\n\n    //!Implementation of QnResource::setStatus\n    virtual nx::vms::api::ResourceStatus getStatus() const override;\n    virtual void setStatus(nx::vms::api::ResourceStatus newStatus, Qn::StatusChangeReason reason = Qn::StatusChangeReason::Local) override;\n\nprivate:\n    nx::vms::api::ResourceStatus m_localStatus;\n};\n\n#endif // ABSTRACT_ARCHIVE_RESOURCE_H\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_data_consumer.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_data_consumer.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_data_consumer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef abstract_data_consumer_h_2111\n#define abstract_data_consumer_h_2111\n\n#include &lt;core/dataconsumer/abstract_data_receptor.h&gt;\n#include &lt;nx/streaming/data_packet_queue.h&gt;\n#include &lt;nx/utils/thread/long_runnable.h&gt;\n\nclass NX_VMS_COMMON_API QnAbstractDataConsumer\n:\n    public QnLongRunnable,\n    public QnAbstractMediaDataReceptor\n{\npublic:\n    QnAbstractDataConsumer(int maxQueueSize);\n    virtual ~QnAbstractDataConsumer(){ stop(); }\n\n    /**\n      * @return true is there is any space in the queue, false otherwise\n      */\n    virtual bool canAcceptData() const override;\n    virtual void putData( const QnAbstractDataPacketPtr&amp; data ) override;\n    virtual void clearUnprocessedData() override;\n    int queueSize() const;\n    int maxQueueSize() const;\n    virtual void setSingleShotMode(bool /*single*/) {}\n\n    //virtual qint64 getDisplayedTime() const { return 0; }\n    virtual bool isRealTimeSource() const { return false; }\n    virtual void pleaseStop() override;\n    virtual bool isRunning() const { return QnLongRunnable::isRunning(); }\nprotected:\n    static const int kNoDataDelayIntervalMs = 10;\n\n    friend class QnArchiveStreamReader;\n\n    virtual void run() override;\n    virtual void runCycle();\n    virtual void setSpeed(float /*value*/) {}\n    virtual bool processData(const QnAbstractDataPacketPtr&amp; data) = 0;\n    virtual void beforeRun();\n    virtual void endOfRun();\nprivate:\n    void resumeDataQueue();\nprotected:\n    QnDataPacketQueue m_dataQueue;\nprivate:\n    nx::Mutex m_pleaseStopMutex;\n};\n\n#endif // abstract_data_consumer_h_2111\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/transcoding/filters/abstract_image_filter.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/transcoding/filters/abstract_image_filter.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/transcoding/filters/abstract_image_filter.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QSharedPointer&gt;\n\n#include &lt;QtCore/QRectF&gt;\n\nclass CLVideoDecoderOutput;\nusing CLVideoDecoderOutputPtr = QSharedPointer&lt;CLVideoDecoderOutput&gt;;\n\nstruct QnAbstractCompressedMetadata;\nusing QnAbstractCompressedMetadataPtr = std::shared_ptr&lt;QnAbstractCompressedMetadata&gt;;\n\n// todo: simplify ffmpegVideoTranscoder and perform crop scale operations as filters\n\n/**\n * Base class for addition effects during video transcoding\n */\nclass QnAbstractImageFilter\n{\npublic:\n    enum class ColorSpace\n    {\n        noImage,\n        rgb,\n        yuv\n    };\n\n    virtual ~QnAbstractImageFilter() {}\n\n    // TODO: #sivanov Apply to filters.\n    virtual ColorSpace colorSpace() const { return ColorSpace::yuv; }\n\n    /**\n     * Update video image.\n     *\n     * @param frame Frame image to update.\n     * @param metadata Frame metadata.\n     */\n    virtual CLVideoDecoderOutputPtr updateImage(\n        const CLVideoDecoderOutputPtr&amp; frame,\n        const QnAbstractCompressedMetadataPtr&amp; metadata) = 0;\n\n    /**\n     * Update video size.\n     *\n     * @param srcSize input image size. Function should return output image size\n     */\n    virtual QSize updatedResolution(const QSize&amp; srcSize) = 0;\n};\n\nusing QnAbstractImageFilterPtr = QSharedPointer&lt;QnAbstractImageFilter&gt;;\nusing QnAbstractImageFilterList = QList&lt;QnAbstractImageFilterPtr&gt;;\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/color_space/image_correction.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/color_space/image_correction.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/color_space/image_correction.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QRectF&gt;\n#include &lt;QtCore/QtGlobal&gt;\n\nnamespace nx::vms::api { struct ImageCorrectionData; }\n\nstruct NX_VMS_COMMON_API ImageCorrectionResult\n{\n    float aCoeff = 1.0f;\n    float bCoeff = 0.0f;\n    float gamma = 1.0f;\n    int hystogram[256];\n    bool filled = false;\n\n    void analyseImage(\n        const quint8* yPlane,\n        int width,\n        int height,\n        int stride,\n        const nx::vms::api::ImageCorrectionData&amp; data,\n        const QRectF&amp; srcRect = QRectF(0.0, 0.0, 1.0, 1.0));\nprivate:\n    float calcGamma(int leftPos, int rightPos, int pixels) const;\n};\n\nclass QnHistogramConsumer\n{\npublic:\n    virtual ~QnHistogramConsumer() {}\n    virtual void setHistogramData(const ImageCorrectionResult&amp; data) = 0;\n};\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/property_storage.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/property_storage.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/property_storage.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_PROPERTY_STORAGE_H\n#define QN_PROPERTY_STORAGE_H\n\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QScopedPointer&gt;\n#include &lt;QtCore/QSet&gt;\n#include &lt;QtCore/QStringList&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nclass QSettings;\nclass QTextStream;\n\nclass QnPropertyStorageLocker;\n\nclass NX_VMS_COMMON_API QnPropertyNotifier: public QObject\n{\n    Q_OBJECT;\npublic:\n    QnPropertyNotifier(QObject *parent = NULL): QObject(parent) {}\n\nsignals:\n    void valueChanged(int id);\n\nprivate:\n    friend class QnPropertyStorage;\n};\n\n\n/**\n * Storage of typed key-value pairs that supports value change notifications,\n * writing and reading to/from &lt;tt&gt;QSettings&lt;/tt&gt; and updating from command line.\n *\n * The typical usage is to derive from this class, create an enumeration\n * for ids of all properties, and then declare them using\n * &lt;tt&gt;QN_DECLARE_R_PROPERTY&lt;/tt&gt; and &lt;tt&gt;QN_DECLARE_RW_PROPERTY&lt;/tt&gt; macros,\n * wrapped in a pair of &lt;tt&gt;QN_BEGIN_PROPERTY_STORAGE&lt;/tt&gt; and\n * &lt;tt&gt;QN_END_PROPERTY_STORAGE&lt;/tt&gt; invocations. These macros will generate\n * an &lt;tt&gt;init()&lt;/tt&gt; function, that is then to be called from derived class&#x27;s\n * constructor.\n */\nclass NX_VMS_COMMON_API QnPropertyStorage: public QObject\n{\n    Q_OBJECT;\npublic:\n    QnPropertyStorage(QObject *parent = NULL);\n    virtual ~QnPropertyStorage();\n\n    QList&lt;int&gt; variables() const;\n\n    Q_INVOKABLE QVariant value(int id) const;\n    Q_INVOKABLE bool setValue(int id, const QVariant &amp;value);\n\n    Q_INVOKABLE QVariant value(const QString &amp;name) const;\n    Q_INVOKABLE bool setValue(const QString &amp;name, const QVariant &amp;value);\n\n    QnPropertyNotifier *notifier(int id) const;\n\n    QString name(int id) const;\n    void setName(int id, const QString &amp;name);\n\n    void addArgumentName(int id, const char *argumentName);\n    void addArgumentName(int id, const QString &amp;argumentName);\n    void setArgumentNames(int id, const QStringList &amp;argumentNames);\n    QStringList argumentNames(int id) const;\n\n    QMetaType type(int id) const;\n    void setType(int id, QMetaType type);\n\n    bool isWritable(int id) const;\n    void setWritable(int id, bool writable);\n\n    bool isThreadSafe() const;\n    void setThreadSafe(bool threadSafe);\n\n    // TODO: #sivanov We need a &#x27;dirty&#x27; flag and several submit modes. Default mode is to write out\n    // only those settings that were actually changed.\n\n    void updateFromSettings(QSettings *settings);\n    void submitToSettings(QSettings *settings) const;\n\n    void updateFromJson(const QJsonObject &amp;json);\n\n    // TODO: #sivanov We need a way to make command line parameters not to be saved to settings if\n    // they are not changed.\n\n    bool updateFromCommandLine(int &amp;argc, const char **argv, FILE *errorFile);\n    bool updateFromCommandLine(int &amp;argc, const char **argv, QTextStream *errorStream);\n\nsignals:\n    void valueChanged(int id);\n\nprotected:\n    enum UpdateStatus {\n        Changed,    /**&lt; Value was changed. */\n        Skipped,    /**&lt; Value didn&#x27;t change. */\n        Failed,     /**&lt; An error has occurred. */\n    };\n\n    virtual void updateValuesFromSettings(QSettings *settings, const QList&lt;int&gt; &amp;ids);\n    virtual void submitValuesToSettings(QSettings *settings, const QList&lt;int&gt; &amp;ids) const;\n    virtual QVariant readValueFromSettings(QSettings *settings, int id, const QVariant &amp;defaultValue) const;\n    virtual void writeValueToSettings(QSettings *settings, int id, const QVariant &amp;value) const;\n\n    virtual void updateValuesFromJson(const QJsonObject &amp;json, const QList&lt;int&gt; &amp;ids);\n    virtual QVariant readValueFromJson(const QJsonObject &amp;json, int id, const QVariant &amp;defaultValue);\n\n    virtual UpdateStatus updateValue(int id, const QVariant &amp;value);\n\n#define QN_BEGIN_PROPERTY_STORAGE(LAST_ID)                                      \\\nprivate:                                                                        \\\n    template&lt;int&gt; struct Dummy {};                                              \\\n                                                                                \\\n    template&lt;int id&gt;                                                            \\\n    void init(const Dummy&lt;id&gt; &amp;) { init(Dummy&lt;id - 1&gt;()); }                     \\\n    void init(const Dummy&lt;-1&gt; &amp;) {}                                             \\\n                                                                                \\\n    void init() { init(Dummy&lt;LAST_ID&gt;()); };                                    \\\n\n#define QN_DECLARE_PROPERTY(TYPE, ID, NAME, WRITABLE, DEFAULT_VALUE)            \\\nprivate:                                                                        \\\n    void init(const Dummy&lt;ID&gt; &amp;) {                                              \\\n        init(Dummy&lt;ID - 1&gt;());                                                  \\\n        setType(ID, QMetaType::fromType&lt;TYPE&gt;());                                       \\\n        setName(ID, QLatin1String(NAME));                                       \\\n        setValue(ID, QVariant::fromValue&lt;TYPE&gt;(DEFAULT_VALUE));                 \\\n        setWritable(ID, WRITABLE);                                              \\\n    }                                                                           \\\n\n#define QN_DECLARE_R_PROPERTY(TYPE, GETTER, ID, DEFAULT_VALUE)                  \\\n    QN_DECLARE_PROPERTY(TYPE, ID, #GETTER, false, DEFAULT_VALUE)                \\\npublic:                                                                         \\\n    TYPE GETTER() const { return value(ID).value&lt;TYPE&gt;(); }                     \\\nprivate:                                                                        \\\n\n#define QN_DECLARE_RW_PROPERTY(TYPE, GETTER, SETTER, ID, DEFAULT_VALUE)         \\\n    QN_DECLARE_PROPERTY(TYPE, ID, #GETTER, true, DEFAULT_VALUE)                 \\\npublic:                                                                         \\\n    TYPE GETTER() const { return value(ID).value&lt;TYPE&gt;(); }                     \\\n    void SETTER(const TYPE &amp;value) { setValue(ID, QVariant::fromValue&lt;TYPE&gt;(value)); } \\\nprivate:                                                                        \\\n\n#define QN_END_PROPERTY_STORAGE()                                               \\\n\nprivate:\n    friend class QnPropertyStorageLocker;\n\n    void lock() const;\n    void unlock() const;\n    void notify(int id) const;\n\n    bool isWritableLocked(int id) const;\n    QVariant valueLocked(int id) const;\n    bool setValueLocked(int id, const QVariant &amp;value);\n\nprivate:\n    bool m_threadSafe;\n    QScopedPointer&lt;nx::Mutex&gt; m_mutex;\n    mutable int m_lockDepth;\n    mutable QSet&lt;int&gt; m_pendingNotifications;\n\n    QHash&lt;int, QVariant&gt; m_valueById;\n    QHash&lt;int, QString&gt; m_nameById;\n    QHash&lt;QString, int&gt; m_idByName;\n    QHash&lt;int, QStringList&gt; m_argumentNamesById;\n    QHash&lt;int, QMetaType&gt; m_typeById;\n    QHash&lt;int, bool&gt; m_writableById;\n    mutable QHash&lt;int, QnPropertyNotifier *&gt; m_notifiers;\n};\n\n#endif // QN_PROPERTY_STORAGE_H\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/threadqueue.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/threadqueue.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/threadqueue.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QQueue&gt;\n#include &lt;QtCore/QVariant&gt;\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/thread/semaphore.h&gt;\n#include &lt;nx/utils/thread/wait_condition.h&gt;\n\nstatic constexpr qint32 kDefaultMaxThreadQueueSize = 256;\n\ntemplate &lt;typename T&gt;\nclass QnSafeQueue\n{\npublic:\n    template &lt;class Q = QnSafeQueue&gt;\n    class RandomAccess\n    {\n    public:\n        RandomAccess(const RandomAccess&lt;Q&gt;&amp;) = delete;\n        RandomAccess&lt;Q&gt;&amp; operator=(const RandomAccess&lt;Q&gt;&amp;) = delete;\n\n        RandomAccess(RandomAccess&lt;Q&gt;&amp;&amp; other) noexcept\n        {\n            m_q = std::exchange(other.m_q, nullptr);\n        }\n        RandomAccess&lt;Q&gt;&amp; operator=(RandomAccess&lt;Q&gt;&amp;&amp; other) noexcept\n        {\n            m_q = std::exchange(other.m_q, nullptr);\n            return *this;\n        }\n\n        ~RandomAccess()\n        {\n            if (m_q)\n                m_q-&gt;unlockInternal();\n        }\n\n        // Returns T() in case of invalid index.\n        const T&amp; at(int index) const\n        {\n            return m_q-&gt;atUnsafe(index);\n        }\n\n        bool setAt(const T&amp; value, int i)\n        {\n            return m_q-&gt;setAtUnsafe(value, i);\n        }\n\n        bool removeAt(int index)\n        {\n            return m_q-&gt;removeAtUnsafe(index);\n        }\n\n        void pack()\n        {\n            m_q-&gt;packUnsafe();\n        }\n\n        bool popFront()\n        {\n            if (m_q-&gt;isEmpty())\n                return false;\n\n            m_q-&gt;m_buffer[m_q-&gt;m_headIndex++] = T();\n            if (m_q-&gt;m_headIndex &gt;= (int) m_q-&gt;m_buffer.size())\n                m_q-&gt;m_headIndex = 0;\n            --m_q-&gt;m_bufferLen;\n            return true;\n        }\n\n        const T&amp; front() const\n        {\n            return at(0);\n        }\n\n        const T&amp; last() const\n        {\n            return at(size() - 1);\n        }\n\n        int size() const\n        {\n            return m_q-&gt;size();\n        }\n\n        void clear()\n        {\n            m_q-&gt;clearUnsafe();\n        }\n\n    private:\n        explicit RandomAccess(Q* queue): m_q(queue)\n        {\n            m_q-&gt;lockInternal();\n        }\n\n    private:\n        Q* m_q = nullptr;\n\n        friend class QnSafeQueue&lt;T&gt;;\n    };\n\n    /**\n     * @param maxSize Is not used by the implementation of this class, but rather intended to be\n     *     checked by pushers via maxSize().\n     */\n    explicit QnSafeQueue(quint32 maxSize = kDefaultMaxThreadQueueSize) : m_maxSize(maxSize)\n    {\n        reallocateBufferUnsafe(maxSize);\n    }\n\n    RandomAccess&lt;const QnSafeQueue&gt; lock() const\n    {\n        return RandomAccess&lt;const QnSafeQueue&gt;(const_cast&lt;QnSafeQueue*&gt;(this));\n    }\n\n    RandomAccess&lt;QnSafeQueue&gt; lock()\n    {\n        return RandomAccess&lt;QnSafeQueue&gt;(this);\n    }\n\n    bool isEmpty() const\n    {\n        return size() == 0;\n    }\n\n    template&lt;typename ValueRef&gt;\n    bool push(ValueRef&amp;&amp; val)\n    {\n        NX_MUTEX_LOCKER mutex(&amp;m_mutex);\n        if (m_terminated)\n            return false;\n\n        if ((uint)m_bufferLen == m_buffer.size())\n            reallocateBufferUnsafe(qMax(m_bufferLen + 1, m_bufferLen + m_bufferLen/4));\n\n        const int index = (m_headIndex + m_bufferLen) % m_buffer.size();\n        m_buffer[index] = std::forward&lt;ValueRef&gt;(val);\n        m_bufferLen++;\n\n        m_waitCond.wakeOne();\n\n        return true;\n    }\n\n    bool pop(T&amp; val, std::chrono::milliseconds timeout = std::chrono::milliseconds::max())\n    {\n        NX_MUTEX_LOCKER mutex(&amp;m_mutex);\n        if (!m_terminated &amp;&amp; isEmpty())\n            m_waitCond.wait(&amp;m_mutex, timeout);\n\n        if (m_terminated || isEmpty())\n            return false;\n\n        val = std::exchange(m_buffer[m_headIndex], T());\n        m_headIndex++;\n        if ((uint)m_headIndex &gt;= m_buffer.size())\n            m_headIndex = 0;\n        m_bufferLen--;\n        return true;\n    }\n\n    template &lt;class ConditionFunc&gt;\n    void detachDataByCondition(const ConditionFunc&amp; cond, const QVariant&amp; opaque = QVariant())\n    {\n        NX_MUTEX_LOCKER mutex(&amp;m_mutex);\n        int index = m_headIndex;\n        for (int i = 0; i &lt; m_bufferLen; ++i)\n        {\n            if (cond(m_buffer[index], opaque))\n                m_buffer[index] = T();\n            index = (index + 1) % m_buffer.size();\n        }\n    }\n\n    int size() const\n    {\n        return m_bufferLen;\n    }\n\n    int maxSize() const\n    {\n        return m_maxSize;\n    }\n\n    void setMaxSize(int value)\n    {\n        NX_MUTEX_LOCKER mutex(&amp;m_mutex);\n        m_maxSize = value;\n        reallocateBufferUnsafe(std::max((int) m_maxSize, (int) m_buffer.size()));\n    }\n\n    void clear()\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        clearUnsafe();\n        m_waitCond.wakeOne();\n    }\n\n    /**\n     * Queue in terminated mode will not wait for new data if empty.\n     * But pop call returns already queued data anyway.\n     */\n    void setTerminated(bool value)\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        m_terminated = value;\n        m_waitCond.wakeAll();\n    }\n\nprivate:\n    void lockInternal() const\n    {\n        m_mutex.lock();\n    }\n\n    void unlockInternal() const\n    {\n        m_mutex.unlock();\n    }\n\n    bool isValidIndex(int index) const\n    {\n        return index &gt;= 0 &amp;&amp; index &lt; size();\n    }\n\n    const T&amp; atUnsafe(int i) const\n    {\n        static const T empty{};\n        if (!isValidIndex(i))\n            return empty;\n\n        const int index = m_headIndex + i;\n        return m_buffer[index % m_buffer.size()];\n    }\n\n    bool setAtUnsafe(const T&amp; value, int i)\n    {\n        if (!isValidIndex(i))\n            return false;\n\n        const int index = m_headIndex + i;\n        m_buffer[index % m_buffer.size()] = value;\n        return true;\n    }\n\n    bool removeAtUnsafe(int index)\n    {\n        if (!isValidIndex(index))\n            return false;\n\n        int bufferIndex = (m_headIndex + index) % m_buffer.size();\n        int toMove = m_bufferLen - index - 1;\n        for (int i = 0; i &lt; toMove; ++i)\n        {\n            int nextIndex = (bufferIndex + 1) % m_buffer.size();\n            m_buffer[bufferIndex] = std::move(m_buffer[nextIndex]);\n            bufferIndex = nextIndex;\n        }\n        m_buffer[bufferIndex] = T();\n        --m_bufferLen;\n        return true;\n    }\n\n    void packUnsafe()\n    {\n        int emptyElementIndex = -1;\n        int emptyElements = 0;\n        for (int index = 0; index &lt; m_bufferLen; ++index)\n        {\n            const int bufferIndex = (m_headIndex + index) % m_buffer.size();\n            if (m_buffer[bufferIndex] == T())\n            {\n                if (emptyElementIndex == -1)\n                    emptyElementIndex = bufferIndex;\n                ++emptyElements;\n            }\n            else if (emptyElementIndex != -1)\n            {\n                std::swap(m_buffer[emptyElementIndex], (m_buffer[bufferIndex]));\n                emptyElementIndex = (emptyElementIndex + 1) % m_buffer.size();\n            }\n        }\n        m_bufferLen -= emptyElements;\n    }\n\n    // For grow only.\n    void reallocateBufferUnsafe(int newSize)\n    {\n        const int oldSize = (int) m_buffer.size();\n        m_buffer.resize(newSize);\n\n        if (m_headIndex &gt; 0 &amp;&amp; m_bufferLen &gt; 0 &amp;&amp; newSize &gt; oldSize)\n        {\n            int tailIndex = m_headIndex + m_bufferLen;\n            if (tailIndex &lt;= oldSize)\n                return; //&lt; No correction is needed.\n\n            tailIndex -= oldSize;\n            const int delta = newSize - oldSize;\n\n            for (int i = 0; i &lt; delta &amp;&amp; i &lt; tailIndex; ++i)\n                m_buffer[oldSize + i] = std::move(m_buffer[i]);\n            int i = 0;\n            for (;i &lt; tailIndex - delta; ++i)\n                m_buffer[i] = std::move(m_buffer[i + delta]);\n            for (;i &lt; tailIndex; ++i)\n                m_buffer[i] = T();\n        }\n    }\n\n    void clearUnsafe()\n    {\n        int index = m_headIndex;\n        for (int i = 0; i &lt; m_bufferLen; ++i)\n        {\n            m_buffer[index] = T();\n            index = (index + 1) % m_buffer.size();\n        }\n        m_bufferLen = 0;\n        m_headIndex = 0;\n    }\n\nprotected:\n    std::vector&lt;T&gt; m_buffer;\n    int m_headIndex = 0;\n    std::atomic&lt;int&gt; m_bufferLen = 0;\n    std::atomic&lt;int&gt; m_maxSize = 0;\n\n    mutable nx::Mutex m_mutex;\n    mutable nx::WaitCondition m_waitCond;\n    bool m_terminated = false;\n};\n\ntemplate &lt;typename T&gt;\nclass QnUnsafeQueue\n{\npublic:\n    QnUnsafeQueue( quint32 maxSize = kDefaultMaxThreadQueueSize)\n        : m_headIndex(0),\n        m_bufferLen(0),\n        m_maxSize( maxSize )\n    {\n        reallocateBuffer(maxSize);\n    }\n\n    ~QnUnsafeQueue() {\n        clear();\n    }\n\n    bool isEmpty() const\n    {\n        return m_bufferLen == 0;\n    }\n\n    bool push(const T&amp; val)\n    {\n        if ((uint)m_bufferLen == m_buffer.size())\n            reallocateBuffer(qMax(m_bufferLen + 1, m_bufferLen + m_bufferLen/4));\n\n        // we can have 2 threads independently put data at the same queue; so we need to put data any way. client is responsible for max size of the queue\n        //if ( m_queue.size()&gt;=m_maxSize )    return false; &lt;- wrong approach\n\n        //m_queue.enqueue(val);\n        int index = (m_headIndex + m_bufferLen) % m_buffer.size();\n        m_buffer[index] = val;\n        m_bufferLen++;\n\n        return true;\n    }\n\n    T front() const\n    {\n        return m_buffer[m_headIndex];\n    }\n\n    const T&amp; at(int i) const\n    {\n        int index = m_headIndex + i;\n        return m_buffer[index % m_buffer.size()];\n    }\n\n    T last() const\n    {\n        int index = m_headIndex + m_bufferLen - 1;\n        return m_buffer[index % m_buffer.size()];\n    }\n\n    bool pop(T&amp; val)\n    {\n        if (m_bufferLen &gt; 0)\n        {\n            val = std::move(m_buffer[m_headIndex]);\n            m_headIndex++;\n            if ((uint)m_headIndex &gt;= m_buffer.size())\n                m_headIndex = 0;\n            m_bufferLen--;\n            return true;\n        }\n        return false;\n    }\n\n    template &lt;class ConditionFunc&gt;\n    void detachDataByCondition(const ConditionFunc&amp; cond, QVariant opaque)\n    {\n        int index = m_headIndex;\n        for (int i = 0; i &lt; m_bufferLen; ++i)\n        {\n            if (cond(m_buffer[index], opaque))\n                m_buffer[index] = T();\n            index = (index + 1) % m_buffer.size();\n        }\n    }\n\n    int size() const\n    {\n        return m_bufferLen;\n    }\n\n    int maxSize() const\n    {\n        return m_maxSize;\n    }\n\n    void setMaxSize(int value)\n    {\n        m_maxSize = value;\n        reallocateBuffer(qMax(m_maxSize, (int) m_buffer.size()));\n    }\n\n    void clear()\n    {\n        int index = m_headIndex;\n        for (int i = 0; i &lt; m_bufferLen; ++i)\n        {\n            m_buffer[index] = T();\n            index = (index + 1) % m_buffer.size();\n        }\n        m_bufferLen = 0;\n        m_headIndex = 0;\n    }\n\nprivate:\n    // for grow only\n    void reallocateBuffer(int newSize)\n    {\n        int oldSize = (int) m_buffer.size();\n        m_buffer.resize(newSize);\n\n        if (m_headIndex &gt; 0 &amp;&amp; m_bufferLen &gt; 0 &amp;&amp; newSize &gt; oldSize)\n        {\n            int tailIndex = m_headIndex + m_bufferLen;\n            if (tailIndex &gt; oldSize)\n                tailIndex -= oldSize;\n            else\n                return; // no correction is needed\n\n            int delta = newSize-oldSize;\n\n            for (int i = 0; i &lt; delta &amp;&amp; i &lt; tailIndex; ++i)\n                m_buffer[oldSize + i] = m_buffer[i];\n            int i = 0;\n            for (;i &lt; tailIndex - delta; ++i)\n                m_buffer[i] = m_buffer[i+delta];\n            for (;i &lt; tailIndex; ++i)\n                m_buffer[i] = T();\n        }\n    }\n\nprotected:\n    std::vector&lt;T&gt; m_buffer;\n    int m_headIndex;\n    int m_bufferLen;\n\n    int m_maxSize;\n};\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/math/magnitude.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/math/magnitude.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/math/magnitude.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#ifndef QN_MAGNITUDE_H\n#define QN_MAGNITUDE_H\n\n#include &lt;typeinfo&gt;\n\n#include &lt;QtCore/QMargins&gt;\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nclass QPoint;\nclass QPointF;\nclass QSize;\nclass QSizeF;\nclass QRectF;\nclass QVector2D;\nclass QVector3D;\nclass QVector4D;\nclass QColor;\nclass QVariant;\n\nqreal calculateMagnitude(int value);\nqreal calculateMagnitude(long value);\nqreal calculateMagnitude(long long value);\nqreal calculateMagnitude(float value);\nqreal calculateMagnitude(double value);\nqreal calculateMagnitude(const QPoint &amp;value);\nqreal calculateMagnitude(const QPointF &amp;value);\nqreal calculateMagnitude(const QSize &amp;value);\nqreal calculateMagnitude(const QSizeF &amp;value);\nqreal calculateMagnitude(const QVector2D &amp;value);\nqreal calculateMagnitude(const QVector3D &amp;value);\nqreal calculateMagnitude(const QVector4D &amp;value);\nqreal calculateMagnitude(const QColor &amp;value);\nqreal calculateMagnitude(const QMargins &amp;value);\nqreal calculateMagnitude(const QRectF &amp;value); /* QRectF is treated as a 4D vector here. */\n\ntemplate&lt;class T&gt;\nqreal calculateMagnitude(const T&amp;, ...) {\n    NX_ASSERT(false, &quot;calculateMagnitude function is not implemented for type &#x27;%1&#x27;.&quot;, typeid(T).name());\n    return 0.0;\n}\n\ntemplate&lt;class T&gt;\nclass TypedMagnitudeCalculator;\n\nclass NX_VMS_COMMON_API MagnitudeCalculator\n{\npublic:\n    /**\n     * \\param type                      &lt;tt&gt;QMetaType::Type&lt;/tt&gt; to get magnitude calculator for.\n     *                                  Pass zero to get no-op calculator.\n     * \\returns                         Magnitude calculator for the given type, or NULL if none.\n     *\n     * \\note                            This function is thread-safe.\n     */\n    static MagnitudeCalculator *forType(QMetaType type);\n\n    /**\n     * \\tparam T                        Type to get magnitude calculator for.\n     * \\returns                         Magnitude calculator for the given type, or NULL if none.\n     *\n     * \\note                            This function is thread-safe.\n     */\n    template&lt;class T&gt;\n    static TypedMagnitudeCalculator&lt;T&gt; *forType() {\n        return forType(QMetaType::fromType&lt;T&gt;())-&gt;template typed&lt;T&gt;();\n    }\n\n    /**\n     * \\param calculator                New magnitude calculator to register.\n     *\n     * \\note                            This function is thread-safe.\n     */\n    static void registerCalculator(MagnitudeCalculator *calculator);\n\n    /**\n     * Constructor.\n     *\n     * \\param type                      &lt;tt&gt;QMetaType::Type&lt;/tt&gt; for this magnitude calculator.\n     */\n    MagnitudeCalculator(QMetaType type): m_type(type) {}\n\n    /**\n     * Virtual destructor.\n     */\n    virtual ~MagnitudeCalculator() {}\n\n    /**\n     * \\returns                         &lt;tt&gt;QMetaType::Type&lt;/tt&gt; of this magnitude calculator.\n     */\n    QMetaType type() const { return m_type; }\n\n    /**\n     * Note that this function will NX_ASSERT if the type of the supplied variant\n     * does not match the type of this magnitude calculator.\n     *\n     * \\param value                     Value to calculate magnitude for.\n     * \\returns                         Magnitude of the given value.\n     */\n    qreal calculate(const QVariant &amp;value) const;\n\n    qreal calculate(const void *value) const;\n\n    template&lt;class T&gt;\n    inline const TypedMagnitudeCalculator&lt;T&gt; *typed() const;\n\n    template&lt;class T&gt;\n    TypedMagnitudeCalculator&lt;T&gt; *typed() {\n        return const_cast&lt;TypedMagnitudeCalculator&lt;T&gt; *&gt;(static_cast&lt;const MagnitudeCalculator *&gt;(this)-&gt;typed&lt;T&gt;());\n    }\n\nprotected:\n    /**\n     * \\param value                     Value to calculate magnitude for.\n     * \\returns                         Magnitude of the given value.\n     */\n    virtual qreal calculateInternal(const void *value) const = 0;\n\nprivate:\n    QMetaType m_type;\n};\n\n\ntemplate&lt;class T&gt;\nclass TypedMagnitudeCalculator: public MagnitudeCalculator {\n    typedef MagnitudeCalculator base_type;\npublic:\n    TypedMagnitudeCalculator(): base_type(QMetaType::fromType&lt;T&gt;()) {}\n\n    using base_type::calculate;\n\n    qreal calculate(const T &amp;value) const {\n        return base_type::calculate(static_cast&lt;const void *&gt;(&amp;value));\n    }\n};\n\n\ntemplate&lt;class T&gt;\nconst TypedMagnitudeCalculator&lt;T&gt; *MagnitudeCalculator::typed() const {\n    if(QMetaType::fromType&lt;T&gt;() == m_type) {\n        return static_cast&lt;const TypedMagnitudeCalculator&lt;T&gt; *&gt;(this);\n    } else {\n        return NULL;\n    }\n}\n\n\n#endif // QN_MAGNITUDE_H\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QtGlobal&gt;\n\nclass NX_VMS_COMMON_API QnlTimeSource\n{\npublic:\n    /*\n    * @return current time. May be different from displayed time. After seek for example, while no any frames are really displayed\n    */\n    virtual qint64 getCurrentTime() const = 0;\n\n    /*\n    * @return Return last displayed time\n    */\n    virtual qint64 getDisplayedTime() const = 0;\n\n    /*\n    * @return Return time of the next frame\n    */\n    virtual qint64 getNextTime() const = 0;\n\n    /*\n    * @return time of the external time source. Syncplay time of camDisplay for example\n    */\n    virtual qint64 getExternalTime() const = 0;\n\n    /*\n    * @return expected time. For example, time based on local timer\n    */\n    virtual qint64 expectedTime() const { return getCurrentTime(); }\n\n    virtual void onBufferingStarted(QnlTimeSource* /*src*/, qint64 /*firstTime*/) {}\n    virtual void onBufferingFinished(QnlTimeSource* /*src*/) {}\n    virtual void onEofReached(QnlTimeSource* /*src*/, bool /*value*/) {}\n    virtual bool isEnabled() const { return true; }\n\n    virtual void reinitTime(qint64 /*newTime*/) {}\n\n    virtual bool isBuffering() const { return false; }\n};\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/artifacts/qt_graphics_items/src/qt_graphics_items/graphics_widget.h", "reportHash": "7e8e057e24d8c9c28d5ceef0f07de4e5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 35, "column": 7, "message": "class 'GraphicsWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'GraphicsWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/qt_graphics_items/src/qt_graphics_items/graphics_widget.h", "line": 35, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/abstract_video_decoder.h", "reportHash": "8b8041c46f0eca32f4c3c29222c10716", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 7, "message": "class 'QnAbstractVideoDecoder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractVideoDecoder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/abstract_video_decoder.h", "line": 32, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "reportHash": "c1c078e59f302495d3672868137cfda7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 35, "column": 7, "message": "class 'AbstractVideoSurface' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractVideoSurface' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "line": 35, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "reportHash": "e3cb12f2245bcae99a8bfa47338b7a33", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 55, "column": 25, "message": "class 'CLVideoDecoderOutput' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'CLVideoDecoderOutput' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "line": 55, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "reportHash": "339f6cb6728dfc20e3794761def45376", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 144, "column": 7, "message": "destructor of 'ScreenshotInterface' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "line": 144, "column": 7}, {"message": "destructor of 'ScreenshotInterface' is public and non-virtual", "fileId": "/home/misha/nika/nx_open/libs/nx_media_core/src/nx/media/ffmpeg/frame_info.h", "line": 144, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/access/access_controller.h", "reportHash": "93257c7b32f7d2e8e9fe5c5f2b36283f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 30, "message": "class 'AccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/access/access_controller.h", "line": 23, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/camera/iomodule/io_module_monitor.h", "reportHash": "c2af8f749a4ffcf7caab4052401a439e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 30, "message": "class 'IOModuleMonitor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'IOModuleMonitor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/camera/iomodule/io_module_monitor.h", "line": 13, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/media/abstract_analytics_metadata_provider.h", "reportHash": "ceff025fd254d0729c0233583d937c81", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 30, "message": "class 'AbstractAnalyticsMetadataProvider' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAnalyticsMetadataProvider' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/media/abstract_analytics_metadata_provider.h", "line": 14, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/resource/screen_recording/desktop_resource.h", "reportHash": "bbfa035c1692f824c130252163aaca24", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 30, "message": "class 'DesktopResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DesktopResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_core/src/nx/vms/client/core/resource/screen_recording/desktop_resource.h", "line": 15, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/cam_display.h", "reportHash": "6744c1f404d62b48a9758b27bfb9ede2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 40, "column": 7, "message": "class 'QnCamDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnCamDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/cam_display.h", "line": 40, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/video_stream_display.h", "reportHash": "e1bb427f4fcebea56bbd226aee8f6746", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 7, "message": "class 'QnVideoStreamDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnVideoStreamDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/camera/video_stream_display.h", "line": 32, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/client/client_runtime_settings.h", "reportHash": "cb15f14f908fc0fb8f8fd9cc27f6f8a6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 33, "message": "class 'QnClientRuntimeSettings' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnClientRuntimeSettings' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/client/client_runtime_settings.h", "line": 13, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/local_resources_directory_model.h", "reportHash": "d5d266b375ba5b45b26e98e1e7662d03", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 7, "message": "class 'LocalResourcesDirectoryModel' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'LocalResourcesDirectoryModel' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/local_resources_directory_model.h", "line": 12, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/resource_directory_browser.h", "reportHash": "4c5254ede417ed0dc2c2c77046e87bb3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 47, "column": 7, "message": "class 'ResourceDirectoryBrowser' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ResourceDirectoryBrowser' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/core/resource/resource_directory_browser.h", "line": 47, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/access_controller.h", "reportHash": "10359792cdbb1c1ccb7b6a2de9ea9f7c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 33, "message": "class 'AccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/access_controller.h", "line": 14, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/caching_access_controller.h", "reportHash": "64eb29a171f128008334e45e2ebebbf2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 9, "column": 33, "message": "class 'CachingAccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CachingAccessController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/access/caching_access_controller.h", "line": 9, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/camera/abstract_video_display.h", "reportHash": "3d1bb0ca7580076ef4053c9c0387a281", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 7, "message": "class 'AbstractVideoDisplay' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractVideoDisplay' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/camera/abstract_video_display.h", "line": 13, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/common/utils/accessor.h", "reportHash": "1897b19bd0bfdc0ff3e23dcbf8861dec", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'AbstractAccessor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAccessor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/common/utils/accessor.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/help/help_handler.h", "reportHash": "d466e29cc8d92da22cdb205ec879a064", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 7, "message": "class 'HelpHandler' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'HelpHandler' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/help/help_handler.h", "line": 18, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "reportHash": "3c19ef227edf51e1e32db1ecd5a6f8ae", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 21, "column": 7, "message": "class 'Action' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Action' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "line": 21, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "reportHash": "5fc76f23e1b88fb72c427ff6f9aaeeb9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 193, "column": 12, "message": "class 'ConditionalText' defines a destructor and a move constructor but does not define a copy constructor, a copy assignment operator or a move assignment operator", "events": [{"message": "class 'ConditionalText' defines a destructor and a move constructor but does not define a copy constructor, a copy assignment operator or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "line": 193, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "reportHash": "9d8a99f70192105f06c483b249f2f8ef", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 198, "column": 9, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                                            noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "line": 198, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action.h", "line": 198, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action_conditions.h", "reportHash": "3bc7afbb6b874fb0e25f017a32c29077", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 38, "column": 7, "message": "class 'Condition' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Condition' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/menu/action_conditions.h", "line": 38, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/scene/resource_widget/overlays/rewind_widget.h", "reportHash": "679d0d33c313dd2562ecd682fcc07ee3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'RewindWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'RewindWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/scene/resource_widget/overlays/rewind_widget.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "reportHash": "682d0ac000237d1d184ce921a7ee912b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'SceneBanners' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SceneBanners' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "reportHash": "82b65e7be27f1124815cad5191801914", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 7, "message": "class 'SceneBanner' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SceneBanner' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/ui/scene/widgets/scene_banners.h", "line": 45, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/workbench/workbench.h", "reportHash": "da7f0ffcde35503a0b0b7bc1b88cd59b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 47, "column": 7, "message": "class 'Workbench' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Workbench' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/nx/vms/client/desktop/workbench/workbench.h", "line": 47, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/abstract_animator.h", "reportHash": "4c081ebbf8594a347472dbe41b9ce31c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 7, "message": "class 'AbstractAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/abstract_animator.h", "line": 15, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/animator_group.h", "reportHash": "e48ff8974ddd449b14289d09529e6fd1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 8, "column": 7, "message": "class 'AnimatorGroup' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AnimatorGroup' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/animator_group.h", "line": 8, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/rect_animator.h", "reportHash": "6488ded7b5e663aca85105abb43360f3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 7, "message": "class 'RectAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'RectAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/rect_animator.h", "line": 13, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/variant_animator.h", "reportHash": "f1943ceedc4f2b8db98978ac708b7976", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 25, "column": 7, "message": "class 'VariantAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'VariantAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/variant_animator.h", "line": 25, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/viewport_animator.h", "reportHash": "57b869cc500e57e130eb2e67d5c77ad7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'ViewportAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ViewportAnimator' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/animation/viewport_animator.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_geometrically.h", "reportHash": "df5f5a09e403b7a21b9d4d050002e744", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'ConstrainedGeometrically' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ConstrainedGeometrically' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_geometrically.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_resizable.h", "reportHash": "9e4d257ed721748d453226ccd2a34fa8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 7, "message": "class 'ConstrainedResizable' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ConstrainedResizable' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/constrained_resizable.h", "line": 24, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/converter.h", "reportHash": "bb954d9367b088d229845600d9cbce12", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 7, "message": "class 'AbstractConverter' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractConverter' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/converter.h", "line": 33, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/frame_section_queryable.h", "reportHash": "c3d253a84543d9c946a57b420529e999", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 7, "message": "class 'FrameSectionQueryable' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'FrameSectionQueryable' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/frame_section_queryable.h", "line": 22, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/help_topic_queryable.h", "reportHash": "8e6f21f8dab5848acbf9103226fd6cb8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 8, "column": 7, "message": "class 'HelpTopicQueryable' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'HelpTopicQueryable' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/help_topic_queryable.h", "line": 8, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/weak_graphics_item_pointer.h", "reportHash": "660cce0eda63ba997b6a0148a05dfc22", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'WeakGraphicsItemPointer' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'WeakGraphicsItemPointer' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/common/weak_graphics_item_pointer.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/dialogs/sign_dialog.h", "reportHash": "39f2cebf61147bd265a98bc69b69dabd", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 30, "column": 7, "message": "class 'SignDialog' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'SignDialog' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/dialogs/sign_dialog.h", "line": 30, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/bounding_instrument.h", "reportHash": "cde324687c3ffe03a75d7385d84d2563", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'BoundingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'BoundingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/bounding_instrument.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/click_instrument.h", "reportHash": "c68b82ca0abf2e0fd6db840afcc188d1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 7, "message": "class 'ClickInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ClickInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/click_instrument.h", "line": 15, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drag_instrument.h", "reportHash": "6cc29062e73cf8906734a5a238d5b8b6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 7, "message": "class 'DragInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DragInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drag_instrument.h", "line": 10, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drop_instrument.h", "reportHash": "1b4e1aaeb22d9dec627e6634d2ae3caa", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 7, "message": "class 'DropInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DropInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/drop_instrument.h", "line": 23, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/hand_scroll_instrument.h", "reportHash": "d57a9a157c2fb876c423ebd917167eeb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 7, "message": "class 'HandScrollInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'HandScrollInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/hand_scroll_instrument.h", "line": 10, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrument_manager.h", "reportHash": "ddc56f7deebe151021373a6f517d7c19", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 7, "message": "class 'InstrumentManager' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'InstrumentManager' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrument_manager.h", "line": 24, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "reportHash": "f821e83eef4bf14abf409f9f25857ef9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 7, "message": "class 'InstrumentedBase' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'InstrumentedBase' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "line": 22, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "reportHash": "1e6304e308845ffd28698f9e604318a4", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 7, "message": "destructor of 'InstrumentedBase' is private and prevents using the type", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "line": 22, "column": 7}, {"message": "destructor of 'InstrumentedBase' is private and prevents using the type", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "line": 22, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "reportHash": "1f0da087964e3d2c00b8d9584c5fb2ed", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 42, "column": 7, "message": "class 'Instrumented' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Instrumented' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/instrumented.h", "line": 42, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/motion_selection_instrument.h", "reportHash": "3dc522eb2aa745e407dd1f6cf0df7bf8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 7, "message": "class 'MotionSelectionInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'MotionSelectionInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/motion_selection_instrument.h", "line": 10, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/move_instrument.h", "reportHash": "b5eeb54a7519179eccc168a347650c72", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'MoveInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'MoveInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/move_instrument.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/object_tracking_instrument.h", "reportHash": "cb499d812055607872c2d21435a73e6e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 11, "column": 7, "message": "class 'ObjectTrackingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ObjectTrackingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/object_tracking_instrument.h", "line": 11, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/ptz_instrument.h", "reportHash": "483b3fede8620212f4a1f31a987b8343", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 7, "message": "class 'PtzInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'PtzInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/ptz_instrument.h", "line": 32, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/resizing_instrument.h", "reportHash": "f3312c26a41ea1fb7a6720f26ba89061", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 59, "column": 7, "message": "class 'ResizingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ResizingInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/resizing_instrument.h", "line": 59, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rotation_instrument.h", "reportHash": "22bd6ab536362920b295f3befc3123ae", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 7, "message": "class 'RotationInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'RotationInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rotation_instrument.h", "line": 12, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rubber_band_instrument.h", "reportHash": "d9efff61e8270a4466a402502d037a42", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'RubberBandInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'RubberBandInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/rubber_band_instrument.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/selection_overlay_tune_instrument.h", "reportHash": "034286552a827e9bc98e9ecc3ea93ad3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 7, "message": "class 'SelectionOverlayTuneInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SelectionOverlayTuneInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/selection_overlay_tune_instrument.h", "line": 18, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/wheel_zoom_instrument.h", "reportHash": "ede1fb11126c16e0228fcb44bfac7b1b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'WheelZoomInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'WheelZoomInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/wheel_zoom_instrument.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/zoom_window_instrument.h", "reportHash": "4f759e28e9448f5a3eae2bc983724f0c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'ZoomWindowInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ZoomWindowInstrument' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/instruments/zoom_window_instrument.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/grid/grid_item.h", "reportHash": "599421938e98ad0b0ecc1d2483cc1ea7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'QnGridItem' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnGridItem' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/grid/grid_item.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/overlays/overlayed.h", "reportHash": "e5a350f5af3318c7bf359091761e87c7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 124, "column": 7, "message": "class 'Overlayed' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Overlayed' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/overlays/overlayed.h", "line": 124, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/media_resource_widget.h", "reportHash": "80125b4d56a18d3d909daef117d83a7a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 77, "column": 7, "message": "class 'QnMediaResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnMediaResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/media_resource_widget.h", "line": 77, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/resource_widget.h", "reportHash": "6b4ea8a3dc1a03495fd3b3c2fd556705", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 46, "column": 7, "message": "class 'QnResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/resource_widget.h", "line": 46, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/web_resource_widget.h", "reportHash": "b2276d23d865d321bbf476d13af382c8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 7, "message": "class 'QnWebResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnWebResourceWidget' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/resource/web_resource_widget.h", "line": 10, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_qml_view.h", "reportHash": "695856a01a4c9c0ed6db1f9a282a640b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'GraphicsQmlView' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'GraphicsQmlView' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_qml_view.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_web_view.h", "reportHash": "c2920d72de92967c5fa6e6d989848198", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 7, "message": "class 'GraphicsWebEngineView' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'GraphicsWebEngineView' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/graphics/items/standard/graphics_web_view.h", "line": 22, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_process_handler.h", "reportHash": "83a8b91ccdd94402c2871b170d2cf7ba", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 7, "message": "class 'KineticProcessHandler' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'KineticProcessHandler' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_process_handler.h", "line": 17, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_processor.h", "reportHash": "e0daf01e211aea04fa5145860ccbc2de", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 39, "column": 7, "message": "class 'KineticProcessor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'KineticProcessor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/processors/kinetic_processor.h", "line": 39, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/utils/viewport_scale_watcher.h", "reportHash": "760a75f97dc611a0cca3b6b7309ed262", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 12, "column": 7, "message": "class 'QnViewportScaleWatcher' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnViewportScaleWatcher' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/utils/viewport_scale_watcher.h", "line": 12, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/toggle.h", "reportHash": "4b7563e38520b4b6246b0924c74f11ec", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 8, "column": 7, "message": "class 'QnToggle' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnToggle' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/toggle.h", "line": 8, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_display.h", "reportHash": "8dc43ac2624c67996ebc8e5025d64f84", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 52, "column": 7, "message": "class 'QnWorkbenchDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnWorkbenchDisplay' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_display.h", "line": 52, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_grid_mapper.h", "reportHash": "5c0f1388c434c138b0de228bae7e73a3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 7, "message": "class 'QnWorkbenchGridMapper' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnWorkbenchGridMapper' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_grid_mapper.h", "line": 14, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_layout.h", "reportHash": "ff2c9c4bbd067f07045db79803098012", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 48, "column": 7, "message": "class 'QnWorkbenchLayout' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnWorkbenchLayout' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/ui/workbench/workbench_layout.h", "line": 48, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "reportHash": "d416321e9bd7c476a481602293c4ee6b", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 443, "column": 7, "message": "destructor of 'QnExternalGetterAggregator<bool, QAction>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "line": 443, "column": 7}, {"message": "destructor of 'QnExternalGetterAggregator<bool, QAction>' is public and non-virtual", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "line": 443, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "reportHash": "250dd64a876cd32239cfd26209477340", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 454, "column": 7, "message": "destructor of 'QnExternalSetterAggregator<bool, QAction>' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "line": 454, "column": 7}, {"message": "destructor of 'QnExternalSetterAggregator<bool, QAction>' is public and non-virtual", "fileId": "/home/misha/nika/nx_open/vms/client/nx_vms_client_desktop/src/utils/common/typed_accessors.h", "line": 454, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "reportHash": "3be62f6c03e8020f0cb61eb8d4393cf8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'QnAbstractResourcePropertyHandler' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractResourcePropertyHandler' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "reportHash": "158153ca3bbf9fcb5a1e285265766426", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 115, "column": 25, "message": "class 'QnAbstractResourcePropertyAdaptor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractResourcePropertyAdaptor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/resource_property_adaptor.h", "line": 115, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/dataconsumer/abstract_data_receptor.h", "reportHash": "2f852b097918620bbced20d393ff1918", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 14, "column": 25, "message": "class 'QnAbstractDataReceptor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractDataReceptor' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/dataconsumer/abstract_data_receptor.h", "line": 14, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/ptz/abstract_ptz_controller.h", "reportHash": "38d788773ac2d676247a8fc5bd89a38c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 25, "message": "class 'QnAbstractPtzController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractPtzController' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/core/ptz/abstract_ptz_controller.h", "line": 24, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/filter_chain.h", "reportHash": "e6856e18b7e6fee722cef6ed7d5245cb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 25, "message": "class 'FilterChain' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'FilterChain' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/filter_chain.h", "line": 18, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/legacy_transcoding_settings.h", "reportHash": "0b9e8e0c01592fb0e79fa3e6bf336a6f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 26, "message": "class 'LegacyTranscodingSettings' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'LegacyTranscodingSettings' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/core/transcoding/filters/legacy_transcoding_settings.h", "line": 19, "column": 26}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_archive_resource.h", "reportHash": "4742459cb1c3713880c74e7805a8ca64", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 9, "column": 25, "message": "class 'QnAbstractArchiveResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractArchiveResource' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_archive_resource.h", "line": 9, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_data_consumer.h", "reportHash": "c14e3a331f7825cd53bbcfd87b836fbc", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 10, "column": 25, "message": "class 'QnAbstractDataConsumer' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractDataConsumer' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/nx/streaming/abstract_data_consumer.h", "line": 10, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/transcoding/filters/abstract_image_filter.h", "reportHash": "f22e456b76cf7ae5f2b92192a813e734", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 20, "column": 7, "message": "class 'QnAbstractImageFilter' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnAbstractImageFilter' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/transcoding/filters/abstract_image_filter.h", "line": 20, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/color_space/image_correction.h", "reportHash": "e726089c5d99d8986163913c56d6fe71", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 29, "column": 7, "message": "class 'QnHistogramConsumer' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnHistogramConsumer' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/color_space/image_correction.h", "line": 29, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/property_storage.h", "reportHash": "ac19957a0a467a32a15bc0358aec0b0e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 25, "message": "class 'QnPropertyStorage' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnPropertyStorage' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/property_storage.h", "line": 45, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/threadqueue.h", "reportHash": "ff21c4d53391e7c33cc105fe2efe20c3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 342, "column": 7, "message": "class 'QnUnsafeQueue' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnUnsafeQueue' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/threadqueue.h", "line": 342, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/math/magnitude.h", "reportHash": "4634fb768991e3c916884d7dd57d847a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 48, "column": 25, "message": "class 'MagnitudeCalculator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'MagnitudeCalculator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/math/magnitude.h", "line": 48, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h", "reportHash": "88a119d2952e919f3c730ac5ef2c450a", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 7, "column": 25, "message": "destructor of 'QnlTimeSource' is public and non-virtual", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h", "line": 7, "column": 25}, {"message": "destructor of 'QnlTimeSource' is public and non-virtual", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/media/externaltimesource.h", "line": 7, "column": 25}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
