<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/libs/nx_network/src/nx/network/abstract_socket.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/abstract_socket.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/abstract_socket.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt; /* For std::uintptr_t. */\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include &lt;nx/network/async_stoppable.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n#include &lt;nx/utils/system_error.h&gt;\n\n#include &quot;aio/event_type.h&quot;\n#include &quot;socket_common.h&quot;\n\nnamespace nx::network {\n\nclass Pollable;\n\nnamespace aio { class AbstractAioThread; }\n\nnamespace deprecated {\n\nstatic constexpr std::chrono::milliseconds kDefaultConnectTimeout = std::chrono::seconds(10);\n\n} // namespace deprecated\n\nstatic constexpr std::chrono::milliseconds kNoTimeout =\n    std::chrono::milliseconds::zero();\n\n/**\n * Using IANA assigned numbers for protocol when possible.\n */\nnamespace Protocol {\n\nstatic constexpr int tcp = 6;\nstatic constexpr int udp = 17;\nstatic constexpr int udt = 256;\n\n/**\n * Custom protocol numbers should start with incrementing this number.\n */\nstatic constexpr int unassigned = 257;\n\n} // namespace ProtocolType\n\n/**\n * Base interface for sockets. Provides methods to set various socket configuration parameters.\n * Notes on deleting a socket with scheduled asynchronous I/O on it:\n * Socket can be safely removed while inside socket&#x27;s AIO thread (e.g., inside completion handler\n * of any asynchronous operation).\n * If removing socket in different thread, then caller MUST cancel all ongoing asynchronous\n * operations (including timers, posts, etc...) first using QnStoppableAsync::pleaseStop.\n *\n * NOTE: On any method failure use SystemError::getLastOSErrorCode() to get error code.\n */\nclass NX_NETWORK_API AbstractSocket:\n    public QnStoppableAsync\n{\npublic:\n#ifdef _WIN32\n    /** NOTE: this actually is the following define:\n     *\n     * typedef SOCKET SOCKET_HANDLE\n     *\n     * But we don&#x27;t want to include windows headers here.\n     * Equivalence of these typedefs is checked via static_assert in system_socket.cpp.\n     */\n    using SOCKET_HANDLE = std::uintptr_t;\n    static constexpr SOCKET_HANDLE kInvalidSocket = ~((SOCKET_HANDLE) 0);\n#else\n    using SOCKET_HANDLE = int;\n    static constexpr SOCKET_HANDLE kInvalidSocket = -1;\n#endif\n\n    /**\n     * Bind to local address/port.\n     * @return false on error. Use SystemError::getLastOSErrorCode() to get error code.\n     */\n    virtual bool bind(const SocketAddress&amp; localAddress) = 0;\n    bool bind(const std::string&amp; localAddress, unsigned short localPort);\n\n    /**\n     * If socket was not bound to some address explicitly, then the binding may be done on late as\n     * the first socket usage (this is OS-dependent).\n     * @return The local address the socket is bound to.\n     */\n    virtual SocketAddress getLocalAddress() const = 0;\n\n    /**\n     * Close socket.\n     * NOTE: Cannot be used to cancel I/O running concurrently in other threads. An UB may occur\n     * when doing so.\n     * @return false if an error occurred when closing the socket.\n     * NOTE: the socket is closed anyway, regardless of the return value.\n     */\n    virtual bool close() = 0;\n\n    /**\n     * @return true if the socket has been closed with a AbstractSocket::close call.\n     */\n    virtual bool isClosed() const = 0;\n\n    /**\n     * Shut down all socket&#x27;s I/O without closing the socket.\n     * It may be invoked concurrently with synchronous socket operations running concurrently in\n     * other threads. Whether these concurrent operations return immediately or not is OS-dependent\n     * and cannot be relied upon.\n     *\n     * WARNING: this method does not cancel asynchronous I/O.\n     */\n    virtual bool shutdown() = 0;\n\n    /**\n     * Allows multiple sockets to bind to same address and port EXCEPT\n     * multiple active listening sockets on the same.\n     * @return false on error.\n     * NOTE: Same as SO_REUSEADDR option on linux.\n     */\n    virtual bool setReuseAddrFlag(bool value) = 0;\n    virtual bool getReuseAddrFlag(bool* value) const = 0;\n\n    /**\n     * Allows multiple listening sockets on the same address and port.\n     * @return false on error.\n     * NOTE: Same as SO_REUSEPORT option on linux.\n     * NOTE: Due to lack of support in win32 API on mswin this option actually does nothing.\n     *   Only AbstractSocket::setReuseAddrFlag(true) is enough for reusing port.\n     */\n    virtual bool setReusePortFlag(bool value) = 0;\n    virtual bool getReusePortFlag(bool* value) const = 0;\n\n    /**\n     * if val is true turns non-blocking mode on, else turns it off.\n     * @return false on error.\n     */\n    virtual bool setNonBlockingMode(bool val) = 0;\n\n    /**\n     * Reads non-blocking mode flag.\n     * @param val Filled with non-blocking mode flag in case of success. In case of error undefined\n     * @return false on error.\n     */\n    virtual bool getNonBlockingMode(bool* val) const = 0;\n\n    /**\n     * Reads MTU (in bytes).\n     * @return false on error.\n     */\n    virtual bool getMtu(unsigned int* mtuValue) const = 0;\n\n    /**\n     * Set socket&#x27;s send buffer size (in bytes).\n     * @return false on error.\n     */\n    virtual bool setSendBufferSize(unsigned int buffSize) = 0;\n    /**\n     * Reads socket&#x27;s send buffer size (in bytes).\n     * @return false on error.\n     */\n    virtual bool getSendBufferSize(unsigned int* buffSize) const = 0;\n\n    /**\n     * Set socket&#x27;s receive buffer (in bytes).\n     * @return false on error.\n     */\n    virtual bool setRecvBufferSize(unsigned int buffSize) = 0;\n    /**\n     * Reads socket&#x27;s read buffer size (in bytes).\n     * @return false on error.\n     */\n    virtual bool getRecvBufferSize(unsigned int* buffSize) const = 0;\n\n    /**\n     * Change socket&#x27;s receive timeout (in millis).\n     * @param ms New timeout value. 0 - no timeout.\n     * @return true if timeout has been changed.\n     * By default, there is no timeout.\n     */\n    virtual bool setRecvTimeout(unsigned int millis) = 0;\n    bool setRecvTimeout(std::chrono::milliseconds m) { return setRecvTimeout((unsigned int) m.count()); }\n\n    /**\n     * Get socket&#x27;s receive timeout (in millis).\n     * @param millis In case of error value is undefined.\n     * @return false on error.\n     */\n    virtual bool getRecvTimeout(unsigned int* millis) const = 0;\n\n    /**\n     * Change socket&#x27;s send timeout (in millis).\n     * @param ms. New timeout value. 0 - no timeout.\n     * @return true if timeout has been changed.\n     * By default, there is no timeout.\n     */\n    virtual bool setSendTimeout(unsigned int ms) = 0;\n    bool setSendTimeout(std::chrono::milliseconds m) { return setSendTimeout((unsigned int) m.count()); }\n\n    /**\n     * Get socket&#x27;s send timeout (in millis).\n     * @param millis In case of error value is undefined.\n     * @return false on error.\n     */\n    virtual bool getSendTimeout(unsigned int* millis) const = 0;\n\n    /**\n     * Get socket&#x27;s last error code.\n     * Needed in case if poll returned socket with flag aio::etError.\n     * @return true if read error code successfully, false otherwise.\n     */\n    virtual bool getLastError(SystemError::ErrorCode* errorCode) const = 0;\n\n    /**\n     * Set IPV6_V6ONLY socket option. Default value is false on EVERY platform.\n     */\n    virtual bool setIpv6Only(bool val) = 0;\n\n    /**\n     * @param protocol One of values from Protocol namespace.\n     * Note that additional protocol support can be added.\n     * @return false if protocol is not defined yet.\n     * An implementation is allowed to choose actual protocol after socket creation.\n     */\n    virtual bool getProtocol(int* protocol) const = 0;\n\n    /**\n     * @return System specific socket handle.\n     * TODO: #akolesnikov Remove this method after complete move to the new socket.\n     */\n    virtual SOCKET_HANDLE handle() const = 0;\n\n    /**\n     * @return Handle for PollSet.\n     */\n    virtual nx::network::Pollable* pollable() = 0;\n\n    /**\n     * Invoke handler from within aio thread sock is bound to.\n     * NOTE: Call will always be queued. I.e., if called from handler running\n     * in aio thread, it will be called after handler has returned.\n     * NOTE: handler execution is cancelled if socket polling for every event is cancelled.\n     */\n    virtual void post(nx::MoveOnlyFunc&lt;void()&gt; handler) = 0;\n\n    /**\n     * Call handler from within AIO thread the socket is bound to.\n     * Differs from AbstractSocket::post in the following: if called in AIO thread, handler will be\n     * invoked immediately within this method. Otherwise,\n     * &lt;pre&gt;&lt;code&gt;\n     * post(std::move(handler))\n     * &lt;/code&gt;&lt;/pre&gt;\n     * is invoked.\n     * NOTE: handler execution is cancelled if socket polling for every event is cancelled.\n     */\n    virtual void dispatch(nx::MoveOnlyFunc&lt;void()&gt; handler) = 0;\n\n    /**\n     * @return Pointer to AIO thread this socket is bound to.\n     * NOTE: If the socket is not bound to any thread yet, it is bound by this method.\n     */\n    virtual nx::network::aio::AbstractAioThread* getAioThread() const = 0;\n\n    /**\n     * Binds current socket to specified AioThread.\n     * Cannot be used to re-bind socket to a different AIO thread if asynchronous I/O has already\n     * been scheduled on the socket.\n     * Cancel all asynchronous I/O first.\n     */\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) = 0;\n\n    /**\n     * @return true if the method is invoked within this socket&#x27;s AIO thread.\n     */\n    virtual bool isInSelfAioThread() const;\n};\n\nusing IoCompletionHandler = nx::MoveOnlyFunc&lt;\n    void(SystemError::ErrorCode /*errorCode*/, std::size_t /*bytesTransferred*/)&gt;;\n\n/**\n * Interface of a socket that supports receiving / sending data.\n */\nclass NX_NETWORK_API AbstractCommunicatingSocket:\n    public AbstractSocket\n{\npublic:\n    /**\n     * Establish connection to specified foreign address.\n     * @param remoteSocketAddress remote address (IP address or name) and port.\n     * @param timeout connection timeout, 0 - no timeout.\n     * @return false if unable to establish connection. Use SystemSocket::getLastOSErrorCode() to\n     * get the error code.\n     */\n    virtual bool connect(\n        const SocketAddress&amp; remoteSocketAddress,\n        std::chrono::milliseconds timeout) = 0;\n\n    bool connect(\n        const std::string&amp; foreignAddress,\n        unsigned short foreignPort,\n        std::chrono::milliseconds timeout);\n\n    /**\n     * @return true, if connection has been established, false otherwise.\n     */\n    virtual bool isConnected() const = 0;\n\n    /**\n     * Connect to a given address asynchronously.\n     * NOTE: the socket send timeout is used\n     * NOTE: the asynchronous connect is cancelled with `AbstractCommunicatingSocket::cancelWrite()`\n     */\n    virtual void connectAsync(\n        const SocketAddress&amp; address,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) = 0;\n\n    /**\n     * Read into the given buffer up to bufferLen bytes from connected socket.\n     * @param buffer buffer to receive the data\n     * @param bufferLen maximum number of bytes to read into buffer\n     * @return number of bytes read, 0 for EOF, and -1 for error.\n     * NOTE: If socket is in non-blocking mode and non-blocking read is not possible,\n     * method will return -1 and set error code to SystemError::wouldBlock.\n     */\n    virtual int recv(void* buffer, std::size_t bufferLen, int flags = 0) = 0;\n\n    /**\n     * Write the given buffer to connected socket.\n     * @param buffer buffer to be written.\n     * @param bufferLen number of bytes from buffer to be written.\n     * @return number of bytes sent. -1 if failed to send something.\n     * NOTE: If socket is in non-blocking mode and non-blocking send is not possible,\n     * method will return -1 and set error code to SystemError::wouldBlock.\n     */\n    virtual int send(const void* buffer, std::size_t bufferLen) = 0;\n    int send(const nx::Buffer&amp; data);\n\n    /**\n     * @returns Host address/port of remote host socket has been connected to.\n     * NOTE: If AbstractCommunicatingSocket::connect() has not been called yet,\n     *   empty address is returned.\n     */\n    virtual SocketAddress getForeignAddress() const = 0;\n\n    /**\n     * @return Text name of the remote host. By default, getForeignAddress().address.toString().\n     */\n    virtual std::string getForeignHostName() const;\n\n    /**\n     * Reads bytes from connected socket asynchronously.\n     * @param dst Buffer to read to. Maximum dst-&gt;capacity() bytes read to this buffer.\n     * If buffer already contains some data, newly read data will be appended to it.\n     * Buffer is resized after reading to its actual size.\n     *\n     * @param handler functor with following signature:\n     * @code{.cpp}\n     *     (SystemError::ErrorCode errorCode, size_t bytesRead)\n     * @endcode\n     * bytesRead is undefined, if errorCode is not SystemError::noError.\n     * bytesRead is 0, if connection has been closed.\n     * WARNING: Multiple concurrent asynchronous write operations are not queued and result in an\n     * undefined behavior.\n     */\n    virtual void readSomeAsync(nx::Buffer* const buffer, IoCompletionHandler handler) = 0;\n\n    /**\n     * Reads at least minimalSize bytes from socket asynchronously.\n     * Calls handler when least minimalSize bytes are read or an error or disconnect has happened.\n     * NOTE: Works similar to POSIX MSG_WAITALL flag but async.\n     */\n    void readAsyncAtLeast(\n        nx::Buffer* const buffer, std::size_t minimalSize,\n        IoCompletionHandler handler);\n\n    /**\n     * Asynchronously writes all bytes from input buffer.\n     * @param buf Calling party MUST guarantee that this object is alive until send completion\n     * @param handler functor with following parameters:\n     * @code{.cpp}\n     *   (SystemError::ErrorCode errorCode, size_t bytesWritten)\n     * @endcode\n     * bytesWritten differ from src size only if errorCode is not SystemError::noError.\n     */\n    virtual void sendAsync(\n        const nx::Buffer* buffer,\n        IoCompletionHandler handler) = 0;\n\n    /**\n     * Register timer on this socket.\n     * @param handler functor to be called\n     */\n    virtual void registerTimer(\n        std::chrono::milliseconds timeout,\n        nx::MoveOnlyFunc&lt;void()&gt; handler) = 0;\n\n    void registerTimer(\n        unsigned int timeoutMs,\n        nx::MoveOnlyFunc&lt;void()&gt; handler);\n\n    /**\n     * Cancel async socket operation. cancellationDoneHandler is invoked when cancelled.\n     * @param eventType event to cancel.\n     * @param handler Always invoked within socket&#x27;s AIO thread.\n     */\n    virtual void cancelIOAsync(\n        nx::network::aio::EventType eventType,\n        nx::MoveOnlyFunc&lt;void()&gt; handler) final;\n\n    /**\n     * Cancels scheduled async operations with a given eventType (e.g., aio::etRead) and blocks\n     * until the cancellation is completed.\n     * It is guaranteed that no handler with eventType is running or will be called after the\n     * return of this method.\n     *\n     * NOTE: If invoked within socket&#x27;s AIO thread, cancels immediately, without blocking.\n     *\n     * NOTE: If invoked within some other AIO thread, may lead to an assertion raised or a deadlock.\n     * So, to cancel async operation while in an AIO thread different this socket&#x27;s (getAioThread()),\n     * use AbstractCommunicatingSocket::cancelIOAsync.\n     */\n    virtual void cancelIOSync(nx::network::aio::EventType eventType) final;\n\n    /**\n     * See AbstractCommunicatingSocket::cancelIOSync() description.\n     */\n    void cancelRead() { cancelIOSync(aio::etRead); };\n\n    /**\n     * See AbstractCommunicatingSocket::cancelIOSync() description.\n     */\n    void cancelWrite() { cancelIOSync(aio::etWrite); };\n\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n\n    virtual void pleaseStopSync() override;\n\nprotected:\n    virtual void cancelIoInAioThread(nx::network::aio::EventType eventType) = 0;\n\nprivate:\n    void readAsyncAtLeastImpl(\n        nx::Buffer* const buffer, std::size_t minimalSize,\n        IoCompletionHandler handler,\n        std::size_t initBufSize);\n};\n\nstruct NX_NETWORK_API StreamSocketInfo\n{\n    /** Round-trip time smoothed variation, millis. */\n    unsigned int rttVar = 0;\n};\n\n/**\n * Interface for connection-oriented sockets.\n */\nclass NX_NETWORK_API AbstractStreamSocket:\n    public AbstractCommunicatingSocket\n{\npublic:\n    virtual ~AbstractStreamSocket() override;\n\n    /**\n     * Set TCP_NODELAY option (disable data aggregation).\n     * @return false on error.\n     */\n    virtual bool setNoDelay(bool value) = 0;\n\n    /**\n     * Read TCP_NODELAY option value.\n     * @return false on error.\n     */\n    virtual bool getNoDelay(bool* value) const = 0;\n\n    /**\n     * Enable collection of socket statistics.\n     * @param val true - enable, false - disable.\n     * NOTE: This method MUST be called only after establishing connection.\n     *   After reconnecting socket, it MUST be called again!\n     * NOTE: On win32 only process with admin rights can enable statistics collection,\n     *   on linux it is enabled by default for every socket.\n     */\n    virtual bool toggleStatisticsCollection(bool val) = 0;\n\n    /**\n     * Reads extended stream socket information.\n     * NOTE: AbstractStreamSocket::toggleStatisticsCollection\n     *   MUST be called prior to this method.\n     * NOTE: on win32 for tcp protocol this function is pretty slow,\n     *   so it is not recommended to call it too often.\n     */\n    virtual bool getConnectionStatistics(StreamSocketInfo* info) = 0;\n\n    /**\n     * Set keep alive options.\n     * @return false on error.\n     * NOTE: due to some OS limitations some values might not be actually set.\n     *   linux: full support\n     *   windows: only timeSec and intervalSec support\n     *   macosx: only timeSec support\n     *   other unix: only boolean enabled/disabled is supported\n     */\n    virtual bool setKeepAlive(std::optional&lt;KeepAliveOptions&gt; info) = 0;\n\n    /**\n     * Reads keep alive options.\n     * @return false on error.\n     * NOTE: due to some OS limitations some values might be = 0 (meaning system defaults).\n     */\n    virtual bool getKeepAlive(std::optional&lt;KeepAliveOptions&gt;* result) const = 0;\n\n    void setBeforeDestroyCallback(nx::MoveOnlyFunc&lt;void()&gt; callback);\n\nprivate:\n    nx::MoveOnlyFunc&lt;void()&gt; m_beforeDestroyCallback;\n};\n\n/**\n * Stream socket with encryption.\n * In most cases, AbstractStreamSocket interface is enough.\n * This one is needed for SMTP/TLS, for example.\n */\nclass NX_NETWORK_API AbstractEncryptedStreamSocket:\n    public AbstractStreamSocket\n{\npublic:\n    /**\n     * Has handshake has been initiated.\n     */\n    virtual bool isEncryptionEnabled() const = 0;\n\n    /**\n     * Similar to AbstractCommunicatingSocket::connectAsync uses socket&#x27;s send timeout.\n     */\n    virtual void handshakeAsync(\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) = 0;\n\n    /**\n     * @return &quot;servername&quot; TLS extension from ClientHello. Valid only for accepted socket.\n     */\n    virtual std::string serverName() const = 0;\n};\n\nusing AcceptCompletionHandler =\n    nx::MoveOnlyFunc&lt;void(\n        SystemError::ErrorCode, std::unique_ptr&lt;AbstractStreamSocket&gt;)&gt;;\n\n/**\n * Interface for a server socket that accepts stream connections.\n * NOTE: This socket has default recv timeout of 250ms for backward compatibility.\n */\nclass NX_NETWORK_API AbstractStreamServerSocket:\n    public AbstractSocket\n{\npublic:\n    static constexpr int kDefaultBacklogSize = 128;\n\n    /**\n     * Start listening for incoming connections.\n     * @param backlog Size of queue of fully established connections\n     *   waiting for AbstractStreamServerSocket::accept().\n     *   If queue is full and new connection arrives, it receives ECONNREFUSED error.\n     * @return false on error.\n     * NOTE: Method returns immediately.\n     */\n    virtual bool listen(int backlog = kDefaultBacklogSize) = 0;\n\n    /**\n     * Accepts new connection.\n     * @return NULL in case of error (use SystemError::getLastOSErrorCode() to get error description).\n     * NOTE: Uses read timeout.\n     */\n    virtual std::unique_ptr&lt;AbstractStreamSocket&gt; accept() = 0;\n\n    /**\n     * Starts async accept operation.\n     * @param handler functor with following signature:\n     * @code{.cpp}\n     *   (SystemError::ErrorCode errorCode, AbstractStreamSocket* newConnection)\n     *   //newConnection is nullptr in case of error\n     * @endcode\n     * newConnection is NULL, if errorCode is not SystemError::noError.\n     */\n    virtual void acceptAsync(AcceptCompletionHandler handler) = 0;\n\n    /**\n     * Cancel active AbstractStreamServerSocket::acceptAsync.\n     */\n    virtual void cancelIOAsync(nx::MoveOnlyFunc&lt;void()&gt; handler) final;\n\n    /**\n     * Cancel active AbstractStreamServerSocket::acceptAsync waiting for completion.\n     * NOTE: If called within socket&#x27;s aio thread, then does not block.\n     */\n    virtual void cancelIOSync() final;\n\nprotected:\n    virtual void cancelIoInAioThread() = 0;\n};\n\nstatic constexpr char BROADCAST_ADDRESS[] = &quot;255.255.255.255&quot;;\n\n/**\n * Interface for connectionless socket. In this case AbstractCommunicatingSocket::connect() just\n * remembers the remote address to use with AbstractCommunicatingSocket::send().\n */\nclass NX_NETWORK_API AbstractDatagramSocket:\n    public AbstractCommunicatingSocket\n{\npublic:\n    static constexpr int UDP_HEADER_SIZE = 8;\n    static constexpr int MAX_IP_HEADER_SIZE = 60;\n    static constexpr int MAX_DATAGRAM_SIZE = 64*1024 - 1 - UDP_HEADER_SIZE - MAX_IP_HEADER_SIZE;\n\n    /**\n     * Set destination address for use by AbstractCommunicatingSocket::send() method.\n     * Difference from AbstractCommunicatingSocket::connect() method is this method\n     *   does not enable filtering incoming datagrams by (foreignAddress, foreignPort),\n     *   and AbstractCommunicatingSocket::connect() does.\n     */\n    virtual bool setDestAddr(const SocketAddress&amp; foreignEndpoint) = 0;\n\n    // TODO: #akolesnikov Drop following overload.\n    bool setDestAddr(const std::string&amp; foreignAddress, unsigned short foreignPort);\n\n    /**\n     * Send the given buffer as a datagram to the specified address/port.\n     * @param buffer buffer to be written\n     * @param bufferLen number of bytes to write\n     * @param foreignAddress address (IP address or name) to send to\n     * @param foreignPort port number to send to\n     * @return true if whole data has been sent\n     * NOTE: Remembers new destination address\n     *   (as if AbstractDatagramSocket::setDestAddr(foreignAddress, foreignPort) has been called).\n     */\n    bool sendTo(\n        const void* buffer,\n        std::size_t bufferLen,\n        const std::string&amp; foreignAddress,\n        unsigned short foreignPort);\n\n    /**\n     * Send the given buffer as a datagram to the specified address/port.\n     * Same as previous method.\n     */\n    virtual bool sendTo(\n        const void* buffer,\n        std::size_t bufferLen,\n        const SocketAddress&amp; foreignAddress) = 0;\n\n    bool sendTo(\n        const nx::Buffer&amp; buf,\n        const SocketAddress&amp; foreignAddress);\n\n    /**\n     * @param completionHandler (errorCode, resolved target address, bytesSent).\n     */\n    virtual void sendToAsync(\n        const nx::Buffer* buf,\n        const SocketAddress&amp; targetAddress,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode, SocketAddress, size_t)&gt; completionHandler) = 0;\n\n    /**\n     * Read up to bufferLen bytes data from this socket.\n     *   The given buffer is where the data will be placed.\n     * @param buffer buffer to receive data\n     * @param bufferLen maximum number of bytes to receive\n     * @param sourceAddress If not nullptr datagram source endpoint is stored here.\n     * @return number of bytes received and -1 in case of error.\n     */\n    virtual int recvFrom(\n        void* buffer,\n        std::size_t bufferLen,\n        SocketAddress* const sourceAddress) = 0;\n\n    /**\n     * @param buf Data appended here.\n     * @param handler(errorCode, sourceAddress, bytesRead).\n     */\n    virtual void recvFromAsync(\n        nx::Buffer* const buf,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode, SocketAddress, size_t)&gt; completionHandler) = 0;\n\n    /**\n     * @return Address of previous datagram read with\n     * AbstractCommunicatingSocket::recv or AbstractDatagramSocket::recvFrom.\n     */\n    virtual SocketAddress lastDatagramSourceAddress() const = 0;\n\n    /**\n     * Checks, whether data is available for reading in non-blocking mode.\n     * Does not block for timeout, returns immediately.\n     * TODO: #akolesnikov Remove this method, since it requires use of select(),\n     *   which is heavy, use MSG_DONTWAIT instead.\n     */\n    virtual bool hasData() const = 0;\n\n    /**\n     * Set the multicast send interface.\n     * @param multicastIF multicast interface for sending packets.\n     */\n    virtual bool setMulticastIF(const std::string&amp; multicastIF) = 0;\n\n    /**\n     * Join the specified multicast group.\n     * @param multicastGroup multicast group address to join.\n     */\n    virtual bool joinGroup(const HostAddress&amp; multicastGroup) = 0;\n    virtual bool joinGroup(const HostAddress&amp; multicastGroup, const HostAddress&amp; multicastIF) = 0;\n\n    /**\n     * Leave the specified multicast group.\n     * @param multicastGroup multicast group address to leave.\n     */\n    virtual bool leaveGroup(const HostAddress&amp; multicastGroup) = 0;\n    virtual bool leaveGroup(const HostAddress&amp; multicastGroup, const HostAddress&amp; multicastIF) = 0;\n};\n\n} // namespace nx::network\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/address_resolver.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/address_resolver.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/address_resolver.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;deque&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n\n#include &lt;nx/network/async_stoppable.h&gt;\n#include &lt;nx/network/dns_resolver.h&gt;\n#include &lt;nx/utils/scope_guard.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx::network {\n\nclass AbstractResolver;\nclass CloudAddressResolver;\n\n/**\n * Resolves hostname to IP address or cloud host id which\n * is enough to establish connection to the host.\n */\nclass NX_NETWORK_API AddressResolver:\n    public QnStoppableAsync\n{\npublic:\n    static constexpr auto kDnsCacheTimeout = std::chrono::seconds(10);\n\n    using ResolveHandler = nx::MoveOnlyFunc&lt;void(\n        SystemError::ErrorCode, std::deque&lt;AddressEntry&gt;)&gt;;\n\n    AddressResolver();\n    virtual ~AddressResolver() = default;\n\n    // TODO: #akolesnikov Refactor &quot;const HostAddress&amp; hostName&quot; into std::string.\n\n    /**\n     * Tells the resolver to resolve hostName into the target.\n     */\n    void addFixedAddress(\n        const HostAddress&amp; hostName, const HostAddress&amp; target);\n\n    /**\n     * Tells the resolver to resolve hostName into the endpoint. This means the resulting\n     * AddressEntry will have endpoint.host resolve result and endpoint.port as an attribute.\n     * See AddressEntry structure for details on attributes.\n     */\n    void addFixedAddress(\n        const HostAddress&amp; hostName, const SocketAddress&amp; endpoint);\n\n    /**\n     * Removes address added with AddressResolver::addFixedAddress.\n     * If endpoint is std::nullopt then removes all addresses.\n     */\n    void removeFixedAddress(\n        const HostAddress&amp; hostName,\n        std::optional&lt;SocketAddress&gt; endpoint = std::nullopt);\n\n    /**\n     * Resolves hostName like DNS server does.\n     * Handler is called with complete address list including:\n     * - Addresses reported by AddressResolver::addFixedAddress.\n     * - Resolve result from DnsResolver.\n     * - Resolve result from MediatorAddressResolver.\n     *\n     * @param natTraversalSupport defines if mediator should be used for address resolution.\n     *\n     * NOTE: Handler might be called within this function in case if\n     *     values are available from cache.\n     */\n    void resolveAsync(\n        const HostAddress&amp; hostName,\n        ResolveHandler handler,\n        NatTraversalSupport natTraversalSupport,\n        int ipVersion,\n        void* requestId = nullptr);\n\n    std::deque&lt;AddressEntry&gt; resolveSync(\n        const HostAddress&amp; hostName,\n        NatTraversalSupport natTraversalSupport,\n        int ipVersion);\n\n    /**\n     * Cancels request.\n     * If handler not provided the method will block until actual cancellation is done.\n     * TODO: This method should not be blocking because it may commonly be used in AIO thread during\n     * stop operation.\n     */\n    void cancel(\n        void* requestId,\n        nx::MoveOnlyFunc&lt;void()&gt; handler = nullptr);\n\n    bool isRequestIdKnown(void* requestId) const;\n\n    bool isCloudHostname(const std::string_view&amp; hostname) const;\n    bool isCloudHostname(const QString&amp; hostname) const;\n    bool isCloudHostname(const char* hostname) const;\n\n    void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n\n    DnsResolver&amp; dnsResolver() { return m_dnsResolver; }\n\n    /**\n     * By default, kDnsCacheTimeout.\n     */\n    void setDnsCacheTimeout(std::chrono::milliseconds timeout);\n\nprotected:\n    struct NX_NETWORK_API HostAddressInfo\n    {\n        explicit HostAddressInfo(\n            std::chrono::milliseconds dnsCacheTimeout);\n\n        std::set&lt;void*&gt; pendingRequests;\n\n        enum class State { unresolved, resolved, inProgress };\n\n        State dnsState() const { return m_dnsState; }\n        void dnsProgress() { m_dnsState = State::inProgress; }\n        void setDnsEntries(std::deque&lt;AddressEntry&gt; entries = {});\n\n        void checkExpirations();\n        bool isResolved() const;\n        std::deque&lt;AddressEntry&gt; getAll() const;\n\n    private:\n        State m_dnsState = State::unresolved;\n        std::chrono::steady_clock::time_point m_dnsResolveTime;\n        std::optional&lt;std::deque&lt;AddressEntry&gt;&gt; m_dnsEntries;\n        const std::chrono::milliseconds m_dnsCacheTimeout;\n    };\n\n    struct ResolveTaskKey\n    {\n        int ipVersion = AF_INET;\n        std::string hostname;\n\n        std::string toString() const;\n\n        // TODO: #akolesnikov replace with operator&lt;=&gt; after upgrading compiler.\n        bool operator&lt;(const ResolveTaskKey&amp;) const;\n    };\n\n    using HostInfoMap = std::map&lt;ResolveTaskKey, HostAddressInfo&gt;;\n\n    using HaInfoIterator = HostInfoMap::iterator;\n\n    struct RequestInfo\n    {\n        const std::string hostname;\n        ResolveHandler handler;\n        bool handlerAboutToBeInvoked = false;\n        nx::utils::Guard guard;\n\n        RequestInfo(std::string hostname, ResolveHandler handler);\n    };\n\n    bool resolveNonBlocking(\n        const std::string&amp; hostName,\n        NatTraversalSupport natTraversalSupport,\n        int ipVersion,\n        ResolveResult* resolved);\n\n    void dnsResolve(\n        HaInfoIterator info, nx::Locker&lt;nx::Mutex&gt;* lk, int ipVersion);\n\n    void reportResult(\n        HaInfoIterator info,\n        SystemError::ErrorCode lastErrorCode,\n        std::deque&lt;AddressEntry&gt; entries);\n\n    std::vector&lt;std::multimap&lt;void*, RequestInfo&gt;::iterator&gt;\n        selectRequestsToComplete(const nx::Locker&lt;nx::Mutex&gt;&amp;, HaInfoIterator info);\n\nprotected:\n    mutable nx::Mutex m_mutex;\n    HostInfoMap m_dnsCache;\n    std::multimap&lt;void*, RequestInfo&gt; m_requests;\n    std::chrono::milliseconds m_dnsCacheTimeout = kDnsCacheTimeout;\n\n    DnsResolver m_dnsResolver;\n\n    std::vector&lt;std::unique_ptr&lt;AbstractResolver&gt;&gt; m_nonBlockingResolvers;\n    CloudAddressResolver* m_cloudAddressResolver = nullptr;\n    PredefinedHostResolver* m_predefinedHostResolver = nullptr;\n\nprivate:\n    static std::string_view toString(HostAddressInfo::State state);\n};\n\n} // namespace nx::network\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollable.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollable.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/network/async_stoppable.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n\nnamespace nx {\nnamespace network {\nnamespace aio {\n\nclass AbstractAioThread;\n\n/**\n * Abstract base for a class living in aio thread.\n * TODO: #akolesnikov concept is still a draft.\n */\nclass AbstractPollable:\n    public QnStoppableAsync\n{\npublic:\n    virtual ~AbstractPollable() = default;\n\n    virtual aio::AbstractAioThread* getAioThread() const = 0;\n    /**\n     * Generally, binding to aio thread can be done just after\n     *   object creation before any usage.\n     * Some implementation may allow more (e.g., binding if no async\n     *   operations are scheduled at the moment)\n     * NOTE: Re-binding is allowed.\n     */\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) = 0;\n    virtual void post(nx::MoveOnlyFunc&lt;void()&gt; func) = 0;\n    virtual void dispatch(nx::MoveOnlyFunc&lt;void()&gt; func) = 0;\n};\n\n} // namespace aio\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;memory&gt;\n\n#include &quot;event_type.h&quot;\n\nnamespace nx {\nnamespace network {\n\nclass Pollable;\n\nnamespace aio {\n\nstatic const int kInfiniteTimeout = -1;\n\nclass AbstractPollSetIterator\n{\npublic:\n    virtual ~AbstractPollSetIterator() = default;\n\n    /**\n     * @return true if iterator has been moved to a valid position. false otherwise.\n     */\n    virtual bool next() = 0;\n\n    virtual Pollable* socket() = 0;\n    virtual const Pollable* socket() const = 0;\n    virtual aio::EventType eventReceived() const = 0;\n};\n\n/**\n * Wrapper on top of OS provided epoll, select or kqueue.\n * Allows to wait for state change on multiple sockets.\n * If AbstractPollSet::poll() returns positive value, then AbstractPollSet::getSocketEventsIterator()\n *   returns iterator pointing just before the first socket which state has been changed.\n * NOTE: Every socket is always monitored for error and all errors are reported.\n * NOTE: This class is not thread-safe.\n * NOTE: If multiple event occurred on same socket each event will be presented separately.\n * NOTE: Polling same socket with two PollSet instances results in undefined behavior.\n */\nclass AbstractPollSet\n{\npublic:\n    virtual ~AbstractPollSet() = default;\n\n    /**\n     * Returns true, if all internal data has been initialized successfully.\n     */\n    virtual bool isValid() const = 0;\n    /**\n     * Interrupts poll method, blocked in other thread.\n     * This is the only method which is allowed to be called from different thread.\n     * poll, called after interrupt, will return immediately.\n     * But, it is unspecified whether it will return multiple times\n     *   if interrupt has been called multiple times.\n     */\n    virtual void interrupt() = 0;\n    /**\n     * Add socket to set. Does not take socket ownership.\n     * @param eventType event to monitor on socket sock.\n     * @param userData\n     * @return true, if socket added to set.\n     * NOTE: This method does not check, whether sock is already in pollset.\n     * NOTE: Invalidates all iterators.\n     * NOTE: userData is associated with pair (sock, eventType).\n     */\n    virtual bool add(Pollable* const sock, EventType eventType, void* userData = NULL) = 0;\n    /**\n     * Do not monitor event eventType on socket sock anymore.\n     * NOTE: Invalidates all iterators to the left of removed element.\n     * So, it is ok to iterate signaled sockets and remove current element:\n     *   following iterator increment operation will perform safely.\n     */\n    virtual void remove(Pollable* const sock, EventType eventType) = 0;\n    /**\n     * Returns number of sockets in pollset.\n     * Returned value should only be used for comparison against size of another PollSet instance.\n     */\n    virtual size_t size() const = 0;\n    /**\n     * @param millisToWait if 0, method returns immediately. If &gt; 0, returns on event or after millisToWait milliseconds.\n     *   If &lt; 0, method blocks till event.\n     * @return -1 on error, 0 if millisToWait timeout has expired, &gt; 0 - number of socket whose state has been changed.\n     * NOTE: If multiple event occurred on same socket each event will be present as a single element.\n     */\n    virtual int poll(int millisToWait = kInfiniteTimeout) = 0;\n    /**\n     * Returns iterator pointing just before first socket event read with AbstractPollSet::poll.\n     * NOTE: One has to call AbstractPollSetIterator::next() to move iterator to the first position.\n     */\n    virtual std::unique_ptr&lt;AbstractPollSetIterator&gt; getSocketEventsIterator() = 0;\n};\n\n} // namespace aio\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_event_handler.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_event_handler.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_event_handler.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &quot;event_type.h&quot;\n#include &quot;pollable.h&quot;\n\nnamespace nx {\nnamespace network {\n\nclass Pollable;\n\nnamespace aio {\n\nclass NX_NETWORK_API AIOEventHandler\n{\npublic:\n    virtual ~AIOEventHandler() = default;\n\n    /**\n     * Receives socket state change event.\n     * Implementation MUST NOT block otherwise it will result poor performance and/or deadlock.\n     */\n    virtual void eventTriggered(Pollable* sock, aio::EventType eventType) = 0;\n};\n\n} // namespace aio\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_service.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_service.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_service.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n\n#include &lt;nx/utils/move_only_func.h&gt;\n\n#include &quot;aio_event_handler.h&quot;\n#include &quot;aio_statistics.h&quot;\n#include &quot;aio_thread.h&quot;\n#include &quot;aio_thread_watcher.h&quot;\n\nnamespace nx::network::aio {\n\n/**\n * Monitors multiple sockets for asynchronous events and triggers handler (AIOEventHandler) on event.\n * Holds multiple threads inside, handler triggered from random thread.\n *   Number of internal threads can be specified during initialization.\n *   If not, it is selected at run-time as number of logical CPUs.\n * This class encapsulates aio thread pool and dispatches socket call to a corresponding thread.\n * NOTE: Suggested use of this class: few add/remove, many notifications.\n * NOTE: A specific socket always receives all events within the same thread.\n * NOTE: All methods are thread-safe.\n */\nclass NX_NETWORK_API AIOService\n{\npublic:\n    /**\n     * After object instantiation one must call AIOService::isInitialized to check\n     * whether instantiation was a success.\n     */\n    AIOService() = default;\n    virtual ~AIOService();\n\n    AIOService(const AIOService&amp;) = delete;\n    AIOService&amp; operator=(const AIOService&amp;) = delete;\n\n    void pleaseStopSync();\n\n    /**\n     * @param aioThreadPoolSize Number of threads to launch. If zero, then it is auto-detected.\n     * In most cases it is equal to the number of virtual cores.\n     * @param enableAioWatcherThread if true, an extra thread is created to monitor the aio threads\n     * for deadlocks.\n     * @return true, if object has been successfully initialized.\n     */\n    bool initialize(unsigned int aioThreadPoolSize = 0, bool enableAioWatcherThread = false);\n\n    /**\n     * Monitor sock for event eventToWatch and trigger eventHandler on event.\n     * @return true, if added successfully. If false, error can be read by SystemError::getLastOSErrorCode().\n     * NOTE: if no event in corresponding socket timeout (if not 0), then aio::etTimedOut event will be reported.\n     * NOTE: If not called from aio thread sock can be added to event loop with some delay.\n     */\n    void startMonitoring(\n        Pollable* const sock,\n        aio::EventType eventToWatch,\n        AIOEventHandler* const eventHandler,\n        std::optional&lt;std::chrono::milliseconds&gt; timeoutMillis = std::nullopt,\n        nx::MoveOnlyFunc&lt;void()&gt; socketAddedToPollHandler = nx::MoveOnlyFunc&lt;void()&gt;());\n\n    /**\n     * Cancel monitoring sock for event eventType.\n     * NOTE: If this method is called from socket&#x27;s aio thread,\n     *   then it is executed without blocking.\n     *   Otherwise, it blocks until already running handler has returned.\n     */\n    void stopMonitoring(Pollable* const socket, aio::EventType eventType);\n\n    /**\n     * Register timeout, associated with socket sock.\n     * eventHandler-&gt;eventTriggered(sock, aio::etTimedOut) will be called every\n     * timeoutMillis milliseconds until cancelled with\n     * aio::AIOService::stopMonitoring(sock, aio::etTimedOut ).\n     */\n    void registerTimer(\n        Pollable* const sock,\n        std::chrono::milliseconds timeoutMillis,\n        AIOEventHandler* const eventHandler );\n\n    /**\n     * @returns true, if socket is still listened for state changes.\n     */\n    bool isSocketBeingMonitored(Pollable* sock);\n\n    /**\n     * Call handler from within aio thread sock is bound to.\n     * NOTE: Call will always be queued. I.e., if called from handler\n     *   running in aio thread, it will be called after handler has returned.\n     * WARNING: Currently, there is no way to find out whether call\n     *   has been posted or being executed currently.\n     */\n    void post(Pollable* sock, nx::MoveOnlyFunc&lt;void()&gt; handler);\n\n    /**\n     * Calls handler in random aio thread.\n     */\n    void post(nx::MoveOnlyFunc&lt;void()&gt; handler);\n\n    /**\n     * Call handler from within aio thread sock is bound to.\n     * NOTE: If called in aio thread, handler will be called from within this method,\n     *   otherwise - queued like aio::AIOService::post does.\n     */\n    void dispatch(Pollable* sock, nx::MoveOnlyFunc&lt;void()&gt; handler);\n\n    AbstractAioThread* getRandomAioThread() const;\n    AbstractAioThread* getCurrentAioThread() const;\n    std::vector&lt;AbstractAioThread*&gt; getAllAioThreads() const;\n    bool isInAnyAioThread() const;\n\n    AbstractAioThread* findLeastUsedAioThread() const;\n\n    std::vector&lt;int&gt; aioThreadsQueueSize() const;\n\n    /**\n     * @return nullptr if enableAioWatcherThread was false during the call to\n     * AIOService::initialize().\n     */\n    AioThreadWatcher* aioThreadWatcher() const;\n\n    AioStatistics statistics() const;\n\nprivate:\n    void initializeAioThreadPool(unsigned int threadCount, bool enableAioWatcherThread);\n\nprivate:\n    std::unique_ptr&lt;AioThreadWatcher&gt; m_aioThreadWatcher;\n    std::vector&lt;std::unique_ptr&lt;AioThread&gt;&gt; m_aioThreadPool;\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n\n#include &lt;nx/utils/thread/thread.h&gt;\n\n#include &quot;abstract_pollset.h&quot;\n#include &quot;aio_event_handler.h&quot;\n#include &quot;event_type.h&quot;\n\nnamespace nx::network { class Pollable; }\n\nnamespace nx::network::aio {\n\nclass AioThreadWatcher;\n\nnamespace detail { class AioTaskQueue; }\n\nclass NX_NETWORK_API AbstractAioThread:\n    public nx::utils::Thread\n{\npublic:\n    virtual ~AbstractAioThread() = default;\n\n    /**\n     * Queues functor to be executed from within this aio thread as soon as possible.\n     */\n    virtual void post(Pollable* const sock, nx::MoveOnlyFunc&lt;void()&gt; functor) = 0;\n\n    /**\n     * If called in this aio thread, then calls functor immediately.\n     * Otherwise, invokes AioThread::post.\n     */\n    virtual void dispatch(Pollable* const sock, nx::MoveOnlyFunc&lt;void()&gt; functor) = 0;\n\n    /**\n     * Cancels calls scheduled with aio::AioThread::post and aio::AioThread::dispatch.\n     */\n    virtual void cancelPostedCalls(Pollable* const sock) = 0;\n\n    virtual bool isSocketBeingMonitored(Pollable* sock) const = 0;\n};\n\n/**\n * This class implements socket event loop using PollSet class to do actual polling.\n * Also supports:\n *   - Asynchronous functor execution via AioThread::post or AioThread::dispatch.\n *   - Maximum timeout to wait for desired event.\n */\nclass NX_NETWORK_API AioThread:\n    public AbstractAioThread\n{\npublic:\n    /**\n     * @param pollSet If null, will be created using PollSetFactory.\n     */\n    AioThread(\n        std::unique_ptr&lt;AbstractPollSet&gt; pollSet = nullptr,\n        AioThreadWatcher* aioThreadsWatcher = nullptr);\n    virtual ~AioThread();\n\n    virtual void pleaseStop() override;\n\n    virtual void post(\n        Pollable* const sock,\n        nx::MoveOnlyFunc&lt;void()&gt; functor) override;\n\n    virtual void dispatch(\n        Pollable* const sock,\n        nx::MoveOnlyFunc&lt;void()&gt; functor) override;\n\n    virtual void cancelPostedCalls(Pollable* const sock) override;\n\n    /**\n     * Start monitoring socket sock for event eventToWatch and trigger eventHandler when event happens.\n     */\n    void startMonitoring(\n        Pollable* const sock,\n        aio::EventType eventToWatch,\n        AIOEventHandler* const eventHandler,\n        std::optional&lt;std::chrono::milliseconds&gt; timeoutMillis = std::nullopt,\n        nx::MoveOnlyFunc&lt;void()&gt; socketAddedToPollHandler = nullptr);\n\n    /**\n     * Stop monitoring sock for event eventType.\n     * Guarantees that no AIOEventHandler::eventTriggered will be called after return of this method.\n     * If AIOEventHandler::eventTriggered is running and stopMonitoring called not from AIOEventHandler::eventTriggered,\n     *   method blocks until AIOEventHandler::eventTriggered had returned.\n     * NOTE: Calling this method with same parameters simultaneously from\n     *   multiple threads can cause undefined behavior.\n     */\n    void stopMonitoring(Pollable* const sock, aio::EventType eventType);\n\n    /**\n     * Returns number of sockets handled by this object.\n     */\n    size_t socketsHandled() const;\n\n    virtual bool isSocketBeingMonitored(Pollable* sock) const override;\n\n    const detail::AioTaskQueue&amp; taskQueue() const;\n\nprotected:\n    virtual void run() override;\n\nprivate:\n    std::unique_ptr&lt;AbstractPollSet&gt; m_pollSet;\n    std::unique_ptr&lt;detail::AioTaskQueue&gt; m_taskQueue;\n    std::atomic&lt;int&gt; m_processingPostedCalls{0};\n    // TODO: #akolesnikov This mutex seem to be redundant after introduction of detail::AioTaskQueue.\n    mutable nx::Mutex m_mutex;\n\n    bool getSocketTimeout(\n        Pollable* const sock,\n        aio::EventType eventToWatch,\n        std::chrono::milliseconds* timeout);\n\n    void stopMonitoringInternal(Pollable* sock, aio::EventType eventType);\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;queue&gt;\n\n#include &quot;aio_thread.h&quot;\n\nnamespace nx::network::aio {\n\n/**\n * Watches for stuck AIO threads.\n * A thread is considered stuck when its execution time exceeds either its average execution time\n * multiplied by some factor or an absolute time threshold.\n */\nclass NX_NETWORK_API AioThreadWatcher: private nx::utils::Thread\n{\npublic:\n    struct StuckThread\n    {\n        const AbstractAioThread* aioThread = nullptr;\n        std::chrono::microseconds currentExecutionTime;\n        std::chrono::microseconds averageExecutionTime;\n        std::string_view functionType;\n\n        QString toString() const\n        {\n            return nx::format(\n                &quot;%1, id: %2, functionType: %3, currentExecutionTime: %4,&quot;\n                    &quot; averageExecutionTime: %5&quot;,\n                aioThread, aioThread-&gt;systemThreadId(), functionType, currentExecutionTime,\n                averageExecutionTime);\n        }\n    };\n\n    using StuckThreadHandler = nx::MoveOnlyFunc&lt;void(StuckThread)&gt;;\n\n    AioThreadWatcher(\n        int pollRatePerSecond,\n        int averageTimeMultiplier,\n        std::chrono::milliseconds absoluteThreshold,\n        StuckThreadHandler handler);\n    ~AioThreadWatcher();\n\n    // Functions below are thread safe.\n\n    void startWatcherThread(const std::vector&lt;const AbstractAioThread*&gt;&amp; threadsToWatch);\n\n    using nx::utils::Thread::stop;\n\n    void setAverageTimeMultiplier(int multiplier);\n    int averageTimeMultiplier() const;\n\n    void setAbsoluteThreshold(std::chrono::milliseconds absoluteThreshold);\n    std::chrono::milliseconds absoluteThreshold() const;\n\n    /**\n     * Get a list of stuck threads. Performs the same computation as internal watcher thread.\n     */\n    std::vector&lt;StuckThread&gt; detectStuckThreads();\n\n    void aboutToInvoke(const AbstractAioThread* thread, const char* functionType);\n    void doneInvoking(\n        const AbstractAioThread* thread,\n        std::chrono::microseconds averageExecutionTime);\n\nprivate:\n    struct WatchContext\n    {\n        const AbstractAioThread* aioThread = nullptr;\n        std::atomic&lt;std::chrono::steady_clock::time_point&gt; watchStart;\n        std::atomic&lt;std::chrono::microseconds&gt; averageExecutionTime;\n        std::atomic&lt;const char*&gt; functionType = nullptr;\n        std::atomic_bool stuck = false;\n\n        WatchContext() = default;\n\n        WatchContext(const WatchContext&amp; other):\n            aioThread(other.aioThread),\n            watchStart(other.watchStart.load()),\n            averageExecutionTime(other.averageExecutionTime.load()),\n            functionType(other.functionType.load()),\n            stuck(other.stuck.load())\n        {\n        }\n    };\n\n    virtual void run() override;\n\n    WatchContext&amp; find(const AbstractAioThread* aioThread);\n    /**\n     * @return a value if thread is stuck.\n     * @param newlyStuck set to true if the thread watch transitioned from not stuck to stuck in\n     * this call.\n     */\n    std::optional&lt;StuckThread&gt; detectStuckThread(WatchContext* ctx);\n\nprivate:\n    std::chrono::milliseconds m_threadSleep;\n    std::atomic_int m_averageTimeMultiplier;\n    std::atomic&lt;std::chrono::milliseconds&gt; m_absoluteThreshold;\n    StuckThreadHandler m_stuckThreadHandler;\n    std::vector&lt;WatchContext&gt; m_threadsToWatch;\n\n    nx::Mutex m_mutex;\n    nx::WaitCondition m_waitCondition;\n    std::queue&lt;StuckThread&gt; m_newlyStuckThreads;\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/basic_pollable.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/basic_pollable.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/basic_pollable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/interruption_flag.h&gt;\n#include &lt;nx/utils/std/future.h&gt;\n\n#include &quot;abstract_pollable.h&quot;\n#include &quot;pollable.h&quot;\n\nnamespace nx::network::aio {\n\nclass AIOService;\n\n/**\n * This class should be inherited by any class that tends to provide asynchronous operation\n * through nx::network::aio.\n *\n * It implements AbstractPollable and simplifies asynchronous operation cancellation by introducing\n * BasicPollable::stopWhileInAioThread method.\n * It is recommended that BasicPollable::stopWhileInAioThread implementation can be safely\n * called multiple times.\n *\n * Sample implementation:\n * &lt;pre&gt;&lt;code&gt;\n * class SampleClassWithAsyncOperations:\n *     public nx::network::aio::BasicPollable\n * {\n *     using base_type = nx::network::aio::BasicPollable;\n *\n * public:\n *     SampleClassWithAsyncOperations(std::unique_ptr&lt;HttpConnection&gt; httpConnection):\n *         m_httpConnection(std::move(httpConnection))\n *     {\n *         // Making sure this, m_httpConnection and m_timer are bound to the same AIO thread.\n *         bindToAioThread(m_httpConnection-&gt;getAioThread());\n *     }\n *\n *     virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override\n *     {\n *         base_type::bindToAioThread(aioThread);\n *\n *         if (m_httpConnection)\n *             m_httpConnection-&gt;bindToAioThread(aioThread);\n *         m_timer.bindToAioThread(aioThread);\n *     }\n *\n *     void doSomethingAsync(CompletionHandler handler)\n *     {\n *         m_httpConnection-&gt;any_async_call(... handler);\n *     }\n *\n * protected:\n *     virtual void stopWhileInAioThread() override\n *     {\n *         base_type::stopWhileInAioThread();\n *\n *         m_httpConnection.reset();\n *         m_timer.pleaseStopSync();\n *     }\n *\n * private:\n *     // HttpConnection and aio::Timer inherit aio::BasicPollable.\n *\n *     std::unique_ptr&lt;HttpConnection&gt; m_httpConnection;\n *     aio::Timer m_timer;\n * };\n * &lt;/code&gt;&lt;/pre&gt;\n *\n * See BasicPollable::pleaseStopSync() comment for more details.\n *\n * Successor to this class MUST support safe object deletion while in object&#x27;s aio thread\n * (usually, it is achieved automatically).\n * QnStoppableAsync::pleaseStop and BasicPollable::stopWhileInAioThread are not called in this case.\n *\n * TODO #akolesnikov Name conflicts with Pollable. Consider renaming Pollable, AbstractPollable, BasicPollable.\n */\nclass NX_NETWORK_API BasicPollable:\n    public AbstractPollable\n{\npublic:\n    /**\n     * @param aioThread If nullptr, then object is bound to the current AIO thread\n     * (if called in AIO thread) or to a random AIO thread (if current thread is not AIO).\n     */\n    BasicPollable(aio::AbstractAioThread* aioThread = nullptr);\n    /**\n     * @param aioThread See description in the previous constructor.\n     */\n    BasicPollable(\n        aio::AIOService* aioService,\n        aio::AbstractAioThread* aioThread);\n    virtual ~BasicPollable() override;\n\n    /**\n     * @param completionHandler Called in object&#x27;s AIO thread (returned by getAioThread()) after\n     * completion or cancellation of all scheduled asynchronous operations.\n     * Object can be safely deleted after completion of this call.\n     * WARNING: All usage of this object from non-AIO thread should be halted before invoking\n     * this method. Otherwise, undefined behavior will happen. All usage in AIO thread is safe\n     * (it will be cancelled or waited for completion).\n     * NOTE: In most cases, you don&#x27;t need to override this.\n     * Override BasicPollable::stopWhileInAioThread instead.\n     */\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; completionHandler) override;\n\n    /**\n     * If called within object&#x27;s AIO thread (returned by getAioThread()) then cancels all\n     * scheduled operations without blocking and returns immediately.\n     * Otherwise, invokes BasicPollable::pleaseStop and waits for completion.\n     * NOTE: In most cases, you don&#x27;t need to override this.\n     * Override BasicPollable::stopWhileInAioThread instead.\n     */\n    virtual void pleaseStopSync() override;\n\n    virtual aio::AbstractAioThread* getAioThread() const override;\n    /**\n     * Generally, binding to aio thread can be done just after object creation before scheduling\n     * any asynchronous operations.\n     * Some implementation may allow more. E.g., binding if all async operations have completed.\n     * NOTE: Calling this method while there are scheduled asynchronous operations is\n     * undefined behavior.\n     * NOTE: Re-binding is allowed.\n     */\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override;\n\n    /**\n     * Posts func to be called in object&#x27;s AIO thread ASAP.\n     * Returns immediately (without waiting for func to be executed).\n     */\n    virtual void post(nx::MoveOnlyFunc&lt;void()&gt; func) override;\n\n    /**\n     * If called within AIO thread (same as returned by getAioThread()) then func is executed\n     * right in this call and dispatch returns after that.\n     * Otherwise, invokes BasicPollable::post.\n     */\n    virtual void dispatch(nx::MoveOnlyFunc&lt;void()&gt; func) override;\n\n    /**\n     * @return true if called within same thread as reported by getAioThread().\n     */\n    bool isInSelfAioThread() const;\n\n    /**\n     * @param completionHandler Will be called in object&#x27;s AIO thread (returned by getAioThread())\n     * after completion or cancellation of every call posted with BasicPollable::post.\n     */\n    void cancelPostedCalls(nx::MoveOnlyFunc&lt;void()&gt; completionHandler);\n\n    /**\n     * When called from object&#x27;s AIO thread, then cancels all posted calls immediately and returns.\n     * Otherwise, invokes BasicPollable::cancelPostedCalls and waits for its completion.\n     */\n    void cancelPostedCallsSync();\n\n    /**\n     * If called within object&#x27;s AIO thread then invokes func immediately and returns.\n     * Otherwise, posts func using BasicPollable::post and waits for completion.\n     */\n    template&lt;typename Func&gt;\n    auto executeInAioThreadSync(Func func) -&gt; decltype(func())\n    {\n        using Result = decltype(func());\n\n        if (isInSelfAioThread())\n        {\n            return func();\n        }\n        else\n        {\n            nx::utils::promise&lt;Result&gt; done;\n            post(\n                [this, &amp;func, &amp;done]()\n                {\n                    // TODO: #akolesnikov This function call is a work-around for msvc2017 bug\n                    // that causes it to compile else statement in if constexpr(...) {} else {}\n                    // when inside a lambda inside a template function.\n                    this-&gt;executeAndSetResultToPromise(func, done);\n                });\n            return done.get_future().get();\n        }\n    }\n\n    /**\n     * @return Object, that can be used directly with AioThread::startMonitoring.\n     * NOTE: If you think you need it, consider it one more time.\n     * If you still think you need it, go and talk to someone about it.\n     */\n    Pollable&amp; pollable();\n    const Pollable&amp; pollable() const;\n\nprotected:\n    /**\n     * Reimplement and cancel your asynchronous operations here.\n     * NOTE: See class description for an example.\n     * NOTE: Always called in object&#x27;s AIO thread.\n     */\n    virtual void stopWhileInAioThread();\n\n    nx::utils::InterruptionFlag::Watcher interruptionWatcher() { return {&amp;m_interruptionFlag}; }\n\nprivate:\n    mutable Pollable m_pollable;\n    AIOService* m_aioService = nullptr;\n    nx::utils::InterruptionFlag m_interruptionFlag;\n\n    template&lt;typename Func, typename Promise&gt;\n    void executeAndSetResultToPromise(Func&amp; func, Promise&amp; promise)\n    {\n        using Result = decltype(func());\n\n        if constexpr (std::is_void&lt;Result&gt;::value)\n        {\n            func();\n            promise.set_value();\n        }\n        else\n        {\n            promise.set_value(func());\n        }\n    }\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/timer.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/timer.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/timer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n\n#include &lt;nx/utils/interruption_flag.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n#include &lt;nx/utils/thread/cf/cfuture.h&gt;\n\n#include &quot;aio_event_handler.h&quot;\n#include &quot;basic_pollable.h&quot;\n\nnamespace nx::network::aio {\n\nusing TimerEventHandler = nx::MoveOnlyFunc&lt;void()&gt;;\n\n/**\n * Single-shot timer that runs in aio thread.\n */\nclass NX_NETWORK_API Timer:\n    public BasicPollable,\n    private AIOEventHandler\n{\npublic:\n    Timer(aio::AbstractAioThread* aioThread = nullptr);\n    virtual ~Timer() override;\n\n    Timer(const Timer&amp;) = delete;\n    Timer&amp; operator=(const Timer&amp;) = delete;\n\n    /**\n     * NOTE: If timer is already started, this method overwrites timer, not adds a new one!\n     */\n    void start(\n        std::chrono::milliseconds timeout,\n        TimerEventHandler timerFunc);\n\n    /**\n     * Future-based wrapper for start.\n     *\n     * @throws std::system_error with std::errc::operation_canceled error code when operation is\n     * canceled.\n     */\n    cf::future&lt;cf::unit&gt; start(std::chrono::milliseconds timeout);\n\n    std::optional&lt;std::chrono::nanoseconds&gt; timeToEvent() const;\n\n    void cancelAsync(nx::MoveOnlyFunc&lt;void()&gt; completionHandler);\n\n    /**\n     * Future-based wrapper for cancelAsync.\n     */\n    cf::future&lt;cf::unit&gt; cancel();\n\n    /**\n     * Cancels timer waiting for timerFunc to complete.\n     * Can be safely called within timer&#x27;s aio thread.\n     * Can be safely called within non aio thread, only if called not under the same mutex, that is used\n     * in callback function.\n     */\n    void cancelSync();\n\nprotected:\n    virtual void stopWhileInAioThread() override;\n    virtual void eventTriggered(Pollable* sock, aio::EventType eventType) throw() override;\n\nprivate:\n    TimerEventHandler m_handler;\n    std::chrono::milliseconds m_timeout;\n    std::optional&lt;std::chrono::steady_clock::time_point&gt; m_timerStartClock;\n    AIOService&amp; m_aioService;\n    nx::utils::InterruptionFlag m_destructionFlag;\n    int m_internalTimerId;\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/async_stoppable.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/async_stoppable.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/async_stoppable.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/utils/move_only_func.h&gt;\n\nnamespace nx {\nnamespace network {\n\nnamespace aio { class AIOService; }\n\n/**\n * Abstract interface to interrupt asynchronous operation with completion notification.\n */\nclass NX_NETWORK_API QnStoppableAsync\n{\npublic:\n    virtual ~QnStoppableAsync() = default;\n\n    /**\n     * Ask object to interrupt all asynchronous operations.\n     * Caller MUST ensure that no asynchronous operations are started after this call\n     * @param completionHandler Executed when asynchronous operation is interrupted.\n     *   For example, in case with async socket operations,\n     *   completionHandler is triggered when socket completion handler returned or will never be called.\n     *   Allowed to be null.\n     * NOTE: If operation is already stopped it is allowed for completionHandler\n     *   to be executed directly in QnStoppableAsync::pleaseStop.\n     */\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; completionHandler) = 0;\n\n    /**\n     * Stops object&#x27;s asynchronous operations and waits for completion.\n     * Default implementation Cannot be called in aio thread.\n     * Also, it is not recommended to call default implementation with mutex locked.\n     * It is a potential deadlock.\n     */\n    virtual void pleaseStopSync();\n\nprotected:\n    /**\n     * Calls QnStoppableAsync::pleaseStop and waits for completion.\n     * Also, contains some asserts.\n     */\n    void pleaseStopSync(const nx::network::aio::AIOService* aioService);\n};\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/server_statistics.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/server_statistics.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/server_statistics.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;compare&gt;\n#include &lt;vector&gt;\n\n#include &lt;nx/reflect/instrument.h&gt;\n\nnamespace nx {\nnamespace network {\nnamespace server {\n\nstruct NX_NETWORK_API Statistics\n{\n    int connectionCount = 0;\n    int connectionsAcceptedPerMinute = 0;\n    int requestsReceivedPerMinute = 0;\n    /**\n     * Calculated for connections closed in the last minute.\n     */\n    int requestsAveragePerConnection = 0;\n\n    /**\n     * Sums up *this and right statistics.\n     */\n    void add(const Statistics&amp; right);\n\n    auto operator&lt;=&gt;(const Statistics&amp;) const = default;\n};\n\n#define Statistics_server_Fields (connectionCount)(connectionsAcceptedPerMinute) \\\n    (requestsReceivedPerMinute)(requestsAveragePerConnection)\n\nNX_REFLECTION_INSTRUMENT(Statistics, Statistics_server_Fields)\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_NETWORK_API AbstractStatisticsProvider\n{\npublic:\n    virtual ~AbstractStatisticsProvider() = default;\n\n    virtual Statistics statistics() const = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_NETWORK_API AggregateStatisticsProvider:\n    public AbstractStatisticsProvider\n{\npublic:\n    AggregateStatisticsProvider(const std::vector&lt;const AbstractStatisticsProvider*&gt;&amp; providers);\n\n    virtual Statistics statistics() const;\n\nprivate:\n    const std::vector&lt;const AbstractStatisticsProvider*&gt; m_providers;\n};\n\n} // namespace server\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/detail/server_statistics_calculator.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/detail/server_statistics_calculator.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/detail/server_statistics_calculator.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n\n#include &lt;nx/utils/math/average_per_period.h&gt;\n#include &lt;nx/utils/math/sum_per_period.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n#include &quot;../server_statistics.h&quot;\n\nnamespace nx {\nnamespace network {\nnamespace server {\nnamespace detail {\n\nclass NX_NETWORK_API StatisticsCalculator\n{\npublic:\n    StatisticsCalculator();\n    virtual ~StatisticsCalculator() = default;\n\n    Statistics statistics(int aliveConnectionCount) const;\n\n    void messageReceived();\n\n    void connectionAccepted();\n\nprivate:\n    nx::utils::math::SumPerPeriod&lt;int&gt; m_connectionsPerMinuteCalculator;\n    nx::utils::math::SumPerPeriod&lt;int&gt; m_requestsReceivedPerMinuteCalculator;\n    nx::utils::math::AveragePerPeriod&lt;int&gt; m_requestsAveragePerConnectionCalculator;\n    mutable nx::Mutex m_mutex;\n};\n\n} // namespace detail\n} // namespace server\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;set&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;nx/network/abstract_socket.h&gt;\n#include &lt;nx/network/abstract_stream_socket_acceptor.h&gt;\n#include &lt;nx/network/aio/basic_pollable.h&gt;\n#include &lt;nx/network/async_stoppable.h&gt;\n#include &lt;nx/network/socket_common.h&gt;\n#include &lt;nx/network/socket_factory.h&gt;\n#include &lt;nx/network/stream_server_socket_to_acceptor_wrapper.h&gt;\n#include &lt;nx/reflect/type_utils.h&gt;\n#include &lt;nx/utils/log/log.h&gt;\n#include &lt;nx/utils/member_detector.h&gt;\n#include &lt;nx/utils/std/optional.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/thread/wait_condition.h&gt;\n\n#include &quot;detail/connection_statistics.h&quot;\n#include &quot;detail/server_statistics_calculator.h&quot;\n\nnamespace nx {\nnamespace network {\nnamespace server {\n\ntemplate&lt;class _ConnectionType&gt;\nclass StreamConnectionHolder\n{\npublic:\n    using ConnectionType = _ConnectionType;\n\n    virtual ~StreamConnectionHolder() = default;\n\n    virtual void closeConnection(\n        SystemError::ErrorCode closeReason,\n        ConnectionType* connection) = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename ConnectionType&gt;\nclass StreamServerConnectionHolder:\n    public StreamConnectionHolder&lt;ConnectionType&gt;,\n    public AbstractStatisticsProvider\n{\nprivate:\n    template &lt;typename T, typename = void&gt;\n    struct HasConnectionStatistics: std::false_type {};\n\n    template&lt;typename T&gt;\n    struct HasConnectionStatistics&lt;\n        T,\n        std::enable_if_t&lt;\n            std::is_same_v&lt;\n                detail::ConnectionStatistics,\n                decltype(std::declval&lt;T&gt;().connectionStatistics)\n            &gt;\n        &gt;\n    &gt;: std::true_type {};\n\npublic:\n    virtual ~StreamServerConnectionHolder()\n    {\n        closeAllConnections();\n    }\n\n    virtual Statistics statistics() const override\n    {\n        return m_statisticsCalculator.statistics(\n            static_cast&lt;int&gt;(this-&gt;connectionCount()));\n    }\n\n    virtual void closeConnection(\n        SystemError::ErrorCode /*closeReason*/,\n        ConnectionType* connection) override\n    {\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n\n        auto connectionIter = m_connections.find(connection);\n        if (connectionIter == m_connections.end())\n            return;\n        auto connectionCtx = std::move(*connectionIter);\n        m_connections.erase(connectionIter);\n\n        ++m_connectionsBeingClosedCount;\n        lk.unlock();\n\n        //we are in connection&#x27;s aio thread, so we can just free connection\n        connectionCtx.second.reset();\n\n        lk.relock();\n        --m_connectionsBeingClosedCount;\n        m_cond.wakeAll();\n    }\n\n    std::size_t connectionCount() const\n    {\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n        return m_connections.size();\n    }\n\n    void saveConnection(std::shared_ptr&lt;ConnectionType&gt; connection)\n    {\n        m_statisticsCalculator.connectionAccepted();\n\n        if constexpr (HasConnectionStatistics&lt;ConnectionType&gt;::value)\n        {\n            connection-&gt;connectionStatistics.setMessageReceivedHandler(\n                [this](){ m_statisticsCalculator.messageReceived(); });\n        }\n\n        auto connectionPtr = connection.get();\n        if constexpr (registerCloseHandlerExists&lt;ConnectionType&gt;::value)\n        {\n            connection-&gt;registerCloseHandler(\n                [this, connectionPtr](auto closeReason, auto /*connectionDestroyed*/)\n                {\n                    closeConnection(closeReason, connectionPtr);\n                });\n        }\n\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n\n        m_connections.emplace(connectionPtr, std::move(connection));\n    }\n\n    template&lt;typename Func&gt;\n    void forEachConnection(Func func)\n    {\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n        for (const auto&amp; connection: m_connections)\n            func(connection.first);\n    }\n\n    void closeAllConnections()\n    {\n        // We MUST be sure to remove all connections.\n        std::map&lt;ConnectionType*, std::shared_ptr&lt;ConnectionType&gt;&gt; connections;\n        {\n            NX_MUTEX_LOCKER lk(&amp;m_mutex);\n            connections.swap(m_connections);\n        }\n        for (auto&amp; connection: connections)\n        {\n            connection.first-&gt;executeInAioThreadSync(\n                [conn = std::exchange(connection.second, nullptr)]() mutable\n                {\n                    // Someone else may have strong refs to the connection, so invoking\n                    // pleaseStopSync() explicitly since reset() may not destroy the connection.\n                    conn-&gt;pleaseStopSync();\n                    conn.reset();\n                });\n        }\n        connections.clear();\n\n        // Waiting connections being cancelled through closeConnection call to finish...\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n        while (m_connectionsBeingClosedCount &gt; 0)\n            m_cond.wait(lk.mutex());\n    }\n\nprivate:\n    NX_UTILS_DECLARE_FIELD_DETECTOR_SIMPLE(registerCloseHandlerExists, registerCloseHandler);\n\n    mutable nx::Mutex m_mutex;\n    nx::WaitCondition m_cond;\n    int m_connectionsBeingClosedCount = 0;\n    //TODO #akolesnikov this map types seems strange. Replace with std::set?\n    std::map&lt;ConnectionType*, std::shared_ptr&lt;ConnectionType&gt;&gt; m_connections;\n    detail::StatisticsCalculator m_statisticsCalculator;\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename Connection&gt;\nstruct MessageSender\n{\n    MessageSender(typename Connection::MessageType message):\n        m_message(std::move(message))\n    {\n    }\n\n    void operator()(Connection* connection)\n    {\n        connection-&gt;post(\n            [message = m_message, connection]() mutable\n            {\n                connection-&gt;sendMessage(\n                    std::move(message),\n                    [](SystemError::ErrorCode) {});\n            });\n    }\n\nprivate:\n    typename Connection::MessageType m_message;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n// TODO: #akolesnikov It seems to make sense to decouple\n//   StreamSocketServer &amp; StreamServerConnectionHolder responsibility.\n\n/**\n * Listens local tcp address, accepts incoming connections\n *   and forwards them to the specified handler.\n */\ntemplate&lt;class CustomServerType, class ConnectionType&gt;\nclass StreamSocketServer:\n    public StreamServerConnectionHolder&lt;ConnectionType&gt;,\n    public aio::BasicPollable\n{\n    using base_type = StreamServerConnectionHolder&lt;ConnectionType&gt;;\n    using self_type = StreamSocketServer&lt;CustomServerType, ConnectionType&gt;;\n\npublic:\n    StreamSocketServer(std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket):\n        m_serverSocket(serverSocket.get()),\n        m_acceptor(\n            std::make_unique&lt;StreamServerSocketToAcceptorWrapper&gt;(\n                std::move(serverSocket)))\n    {\n        bindToAioThread(m_acceptor-&gt;getAioThread());\n    }\n\n    StreamSocketServer(std::unique_ptr&lt;AbstractStreamSocketAcceptor&gt; acceptor):\n        m_acceptor(std::move(acceptor))\n    {\n        bindToAioThread(m_acceptor-&gt;getAioThread());\n    }\n\n    /**\n     * Initializes regular (non-SSL) connection listener.\n     */\n    StreamSocketServer():\n        StreamSocketServer(SocketFactory::createStreamServerSocket(/*sslRequired*/ false))\n    {\n    }\n\n    /**\n     * Initializes SSL connection listener.\n     */\n    StreamSocketServer(ssl::Context* sslContext):\n        StreamSocketServer(\n            SocketFactory::createSslAdapter(\n                SocketFactory::createStreamServerSocket(/*sslRequired*/ false),\n                sslContext,\n                ssl::EncryptionUse::autoDetectByReceivedData))\n    {\n    }\n\n    virtual ~StreamSocketServer()\n    {\n        pleaseStopSync();\n        this-&gt;closeAllConnections();\n    }\n\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) override\n    {\n        aio::BasicPollable::bindToAioThread(aioThread);\n        m_acceptor-&gt;bindToAioThread(aioThread);\n    }\n\n    /**\n     * Set to true to allow binding multiple StreamSocketServer to the same address:port.\n     */\n    bool setReusePort(bool val)\n    {\n        return m_serverSocket-&gt;setReuseAddrFlag(val) &amp;&amp; m_serverSocket-&gt;setReusePortFlag(val);\n    }\n\n    bool bind(const SocketAddress&amp; socketAddress)\n    {\n        NX_CRITICAL(m_serverSocket);\n\n        bool result =\n            m_serverSocket-&gt;setRecvTimeout(0) &amp;&amp;\n            m_serverSocket-&gt;setReuseAddrFlag(true) &amp;&amp;\n            m_serverSocket-&gt;bind(socketAddress);\n        if (result)\n            m_localAddress = m_serverSocket-&gt;getLocalAddress();\n        return result;\n    }\n\n    bool listen(int backlogSize = AbstractStreamServerSocket::kDefaultBacklogSize)\n    {\n        NX_CRITICAL(m_serverSocket);\n\n        if (!m_serverSocket-&gt;setNonBlockingMode(true) ||\n            !m_serverSocket-&gt;listen(backlogSize))\n        {\n            return false;\n        }\n\n        start();\n        return true;\n    }\n\n    SocketAddress address() const\n    {\n        return m_localAddress;\n    }\n\n    void start()\n    {\n        using namespace std::placeholders;\n\n        m_acceptor-&gt;acceptAsync(\n            std::bind(&amp;StreamSocketServer::newConnectionAccepted, this, _1, _2));\n    }\n\n    void setConnectionInactivityTimeout(std::optional&lt;std::chrono::milliseconds&gt; value)\n    {\n        m_connectionInactivityTimeout = value;\n    }\n\n    void setConnectionKeepAliveOptions(std::optional&lt;KeepAliveOptions&gt; options)\n    {\n        m_keepAliveOptions = std::move(options);\n    }\n\nprotected:\n    virtual std::shared_ptr&lt;ConnectionType&gt; createConnection(\n        std::unique_ptr&lt;AbstractStreamSocket&gt; streamSocket) = 0;\n\n    virtual void stopWhileInAioThread() override\n    {\n        m_acceptor-&gt;pleaseStopSync();\n        m_serverSocket = nullptr;\n    }\n\nprivate:\n    // TODO: #akolesnikov Deal with m_serverSocket &amp; m_acceptor.\n    // The idea is to use this class with AbstractStreamSocketAcceptor only.\n    // That in turn will allow using HttpServer with any acceptor (e.g., relay/reverse acceptor).\n    // CLOUD-1925.\n\n    AbstractStreamServerSocket* m_serverSocket = nullptr;\n    SocketAddress m_localAddress;\n    std::unique_ptr&lt;AbstractStreamSocketAcceptor&gt; m_acceptor;\n    std::optional&lt;std::chrono::milliseconds&gt; m_connectionInactivityTimeout;\n    std::optional&lt;KeepAliveOptions&gt; m_keepAliveOptions;\n\n    StreamSocketServer(StreamSocketServer&amp;);\n    StreamSocketServer&amp; operator=(const StreamSocketServer&amp;);\n\n    void newConnectionAccepted(\n        SystemError::ErrorCode code,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; socket)\n    {\n        // TODO: #akolesnikov handle errorCode: try to call acceptAsync after some delay?\n        m_acceptor-&gt;acceptAsync(\n            [this](\n                SystemError::ErrorCode code,\n                std::unique_ptr&lt;AbstractStreamSocket&gt; socket)\n            {\n                newConnectionAccepted(code, std::move(socket));\n            });\n\n        if (code != SystemError::noError)\n        {\n            NX_WARNING(this, nx::format(&quot;Accept has failed: %1&quot;)\n                .arg(SystemError::toString(code)));\n            return;\n        }\n\n        if (!socket-&gt;setNonBlockingMode(true))\n        {\n            const auto errorCode = SystemError::getLastOSErrorCode();\n            NX_WARNING(this, nx::format(&quot;Failed to switch socket to a non blocking mode: %1&quot;)\n                .arg(SystemError::toString(errorCode)));\n            return;\n        }\n\n        if (m_keepAliveOptions)\n        {\n            const auto isKeepAliveSet = socket-&gt;setKeepAlive(m_keepAliveOptions);\n            NX_ASSERT(isKeepAliveSet, SystemError::getLastOSErrorText());\n        }\n\n        auto connection = createConnection(std::move(socket));\n        auto connectionPtr = connection.get();\n        this-&gt;saveConnection(std::move(connection));\n        // It is guaranteed that connection is alive here because\n        // connection can be deleted by an event from itself only.\n        // And event can arrive not sooner than connection is started.\n        connectionPtr-&gt;startReadingConnection(m_connectionInactivityTimeout);\n    }\n};\n\n} // namespace server\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/network/socket_global.h&gt;\n\n#include &quot;object_counters.h&quot;\n\nnamespace nx::network::debug {\n\n/**\n * Counts type T instantiations by invoking SocketGlobals::instance().debugCounters().\n * To use it, object of this class should be made a private member. Example:\n * &lt;pre&gt;&lt;code&gt;\n * class ObjectOfInterest\n * {\n * public:\n *     ....\n * private:\n *     ....\n *     ObjectInstanceCounter&lt;ObjectOfInterest&gt; m_objectInstanceCounter;\n * };\n * &lt;/code&gt;&lt;/pre&gt;\n *\n * SocketGlobals::instance().debugCounters().toJson() will report number of alive ObjectOfInterest.\n */\ntemplate&lt;typename T&gt;\nclass ObjectInstanceCounter\n{\npublic:\n    ObjectInstanceCounter();\n    ObjectInstanceCounter(const ObjectInstanceCounter&amp;);\n    ObjectInstanceCounter(ObjectInstanceCounter&amp;&amp;);\n\n    ObjectInstanceCounter&amp; operator=(const ObjectInstanceCounter&amp;) = default;\n    ObjectInstanceCounter&amp; operator=(ObjectInstanceCounter&amp;&amp;) = default;\n\n    ~ObjectInstanceCounter();\n};\n\ntemplate&lt;class T&gt;\nObjectInstanceCounter&lt;T&gt;::ObjectInstanceCounter()\n{\n    SocketGlobals::instance().allocationAnalyzer().recordObjectCreation(this);\n    SocketGlobals::instance().debugCounters().recordObjectCreation&lt;T&gt;();\n}\n\ntemplate&lt;class T&gt;\nObjectInstanceCounter&lt;T&gt;::ObjectInstanceCounter(const ObjectInstanceCounter&amp;)\n{\n    SocketGlobals::instance().allocationAnalyzer().recordObjectCreation(this);\n    SocketGlobals::instance().debugCounters().recordObjectCreation&lt;T&gt;();\n}\n\n// This move constructor may throw, that breaks C++ Core Guidelines F.6 and is very unusual.\n// We mark it with explicit `noexcept(false)` and suppress the warning.\ntemplate&lt;class T&gt;\nObjectInstanceCounter&lt;T&gt;::ObjectInstanceCounter(ObjectInstanceCounter&amp;&amp;)\n    #if defined(_MSC_VER)\n        #pragma warning(suppress: 26439)\n    #endif\n    noexcept(false)\n{\n    SocketGlobals::instance().allocationAnalyzer().recordObjectCreation(this);\n    SocketGlobals::instance().debugCounters().recordObjectCreation&lt;T&gt;();\n}\n\ntemplate&lt;class T&gt;\nObjectInstanceCounter&lt;T&gt;::~ObjectInstanceCounter()\n{\n    SocketGlobals::instance().debugCounters().recordObjectDestruction&lt;T&gt;();\n    SocketGlobals::instance().allocationAnalyzer().recordObjectDestruction(this);\n}\n\n} // namespace nx::network::debug\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/dns_resolver.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/dns_resolver.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/dns_resolver.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n\n#include &lt;nx/utils/data_structures/time_out_cache.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n#include &lt;nx/utils/singleton.h&gt;\n#include &lt;nx/utils/system_error.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/thread/sync_queue.h&gt;\n#include &lt;nx/utils/thread/wait_condition.h&gt;\n\n#include &quot;resolve/abstract_resolver.h&quot;\n#include &quot;socket_common.h&quot;\n\nnamespace nx {\nnamespace network {\n\nclass PredefinedHostResolver;\n\nstatic constexpr auto kDefaultDnsResolveTimeout = std::chrono::seconds(15);\n\nclass NX_NETWORK_API DnsResolver\n{\npublic:\n    using RequestId = void*;\n    using Handler = nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode, std::deque&lt;HostAddress&gt;)&gt;;\n\n    static constexpr int kDefaultResolveThreadCount = 4;\n\n    DnsResolver(int resolveThreadCount = kDefaultResolveThreadCount);\n    virtual ~DnsResolver();\n\n    void stop();\n\n    std::chrono::milliseconds resolveTimeout() const;\n    void setResolveTimeout(std::chrono::milliseconds value);\n\n    // TODO: #akolesnikov Use internal sequence instead of RequestId.\n\n    /**\n     * @param handler MUST not block\n     * @param requestId Used to cancel request. Multiple requests can be started using same request id.\n     * @return false if failed to start asynchronous resolve operation\n     * NOTE: It is guaranteed that reqID is set before completionHandler is called.\n     */\n    void resolveAsync(const std::string&amp; hostname, Handler handler, int ipVersion, RequestId requestId);\n\n    SystemError::ErrorCode resolveSync(\n        const std::string&amp; hostname,\n        int ipVersion,\n        ResolveResult* resolveResult);\n\n    // TODO: #akolesnikov following two methods do not belong here.\n    /** Has even greater priority than /etc/hosts. */\n    void addEtcHost(const std::string&amp; name, std::vector&lt;HostAddress&gt; addresses);\n    void removeEtcHost(const std::string&amp; name);\n\n    /**\n     * Every attempt to resolve hostname will fails with SystemError::hostNotFound.\n     */\n    void blockHost(const std::string&amp; hostname);\n    void unblockHost(const std::string&amp; hostname);\n\n    /**\n     * @param priority Greater value increases priority.\n     */\n    void registerResolver(std::unique_ptr&lt;AbstractResolver&gt; resolver, int priority);\n    int minRegisteredResolverPriority() const;\n    int maxRegisteredResolverPriority() const;\n\nprotected:\n    void resolveThreadMain();\n    void reportCachedResultThreadMain();\n\nprivate:\n    class ResolveTask\n    {\n    public:\n        std::string hostAddress;\n        Handler completionHandler;\n        RequestId requestId = nullptr;\n        size_t sequence = 0;\n        int ipVersion = AF_INET;\n        std::chrono::steady_clock::time_point creationTime;\n\n        ResolveTask(\n            std::string hostAddress, Handler handler, RequestId requestId,\n            size_t sequence, int ipVersion);\n    };\n\n    bool m_terminated = false;\n    mutable nx::Mutex m_mutex;\n    mutable nx::WaitCondition m_cond;\n    std::deque&lt;size_t /*sequence*/&gt; m_taskQueue;\n    std::unordered_map&lt;size_t /*sequence*/, ResolveTask&gt; m_tasks;\n    std::vector&lt;std::thread&gt; m_resolveThreads;\n    std::unordered_set&lt;RequestId&gt; m_runningTaskRequestIds;\n    size_t m_currentSequence = 0;\n    std::chrono::milliseconds m_resolveTimeout = kDefaultDnsResolveTimeout;\n    PredefinedHostResolver* m_predefinedHostResolver = nullptr;\n    std::multimap&lt;int, std::unique_ptr&lt;AbstractResolver&gt;, std::greater&lt;int&gt;&gt; m_resolversByPriority;\n    std::set&lt;std::string&gt; m_blockedHosts;\n\n    nx::utils::SyncQueue&lt;std::tuple&lt;Handler, std::deque&lt;HostAddress&gt;&gt;&gt; m_cachedResults;\n    std::thread m_reportCachedResultThread;\n\n    nx::utils::TimeOutCache&lt;\n        std::tuple&lt;int /*ipVersion*/, std::string /*hostname*/&gt;,\n        std::deque&lt;HostAddress&gt;,\n        std::map\n    &gt; m_resolveCache;\n\n    bool isExpired(const ResolveTask&amp; task) const;\n};\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/resolve/abstract_resolver.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/resolve/abstract_resolver.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/resolve/abstract_resolver.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;deque&gt;\n#include &lt;string_view&gt;\n\n#include &lt;nx/utils/system_error.h&gt;\n\n#include &quot;../socket_common.h&quot;\n#include &quot;address_entry.h&quot;\n\nnamespace nx {\nnamespace network {\n\nstruct ResolveResult\n{\n    std::deque&lt;AddressEntry&gt; entries;\n    std::optional&lt;std::chrono::milliseconds&gt; ttl;\n};\n\nclass AbstractResolver\n{\npublic:\n    virtual ~AbstractResolver() = default;\n\n    /**\n     * @param resolveResult Not empty in case if SystemError::noError is returned.\n     */\n    virtual SystemError::ErrorCode resolve(\n        const std::string_view&amp; hostName,\n        int ipVersion,\n        ResolveResult* resolveResult) = 0;\n};\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_factory.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_factory.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_factory.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;functional&gt;\n#include &lt;optional&gt;\n\n#include &quot;abstract_socket.h&quot;\n#include &quot;socket_common.h&quot;\n#include &quot;ssl/ssl_stream_server_socket.h&quot;\n\nnamespace nx::network {\n\nnamespace ssl {\n\nusing AdapterFunc = std::function&lt;std::unique_ptr&lt;nx::network::AbstractEncryptedStreamSocket&gt;(\n    std::unique_ptr&lt;nx::network::AbstractStreamSocket&gt; connection)&gt;;\n\nNX_NETWORK_API extern const AdapterFunc kDefaultCertificateCheck;\nNX_NETWORK_API extern const AdapterFunc kAcceptAnyCertificate;\n\n} // namespace ssl\n\nclass SocketFactoryImpl;\n\n/**\n * Contains factory methods for creating sockets.\n * All factory methods return objects created with operator new.\n * TODO: #akolesnikov Refactor to a single static instance instead of every field being static as of now.\n */\nclass NX_NETWORK_API SocketFactory\n{\npublic:\n    enum class SocketType\n    {\n        cloud,  //&lt; Production mode.\n        tcp,    //&lt; \\class TcpSocket and \\class TcpServerSocket.\n        udt,    //&lt; \\class UdtSocket and \\class UdtServerSocket.\n    };\n\n    using CreateStreamSocketFuncType = std::function&lt;std::unique_ptr&lt;AbstractStreamSocket&gt;(\n        ssl::AdapterFunc adapterFunc,\n        bool /*sslRequired*/,\n        nx::network::NatTraversalSupport /*natTraversalRequired*/,\n        std::optional&lt;int&gt; /*ipVersion*/)&gt;;\n\n    using CreateStreamServerSocketFuncType = std::function&lt;std::unique_ptr&lt;AbstractStreamServerSocket&gt;(\n        bool /*sslRequired*/,\n        std::optional&lt;int&gt; /*ipVersion*/)&gt;;\n\n    using DatagramSocketFactoryFunc = nx::MoveOnlyFunc&lt;\n        std::unique_ptr&lt;AbstractDatagramSocket&gt;(int /*e.g., AF_INET*/)&gt;;\n\n    static std::unique_ptr&lt;AbstractDatagramSocket&gt; createDatagramSocket();\n\n    /**\n     * @return Old function.\n     */\n    static DatagramSocketFactoryFunc setCustomDatagramSocketFactoryFunc(\n        DatagramSocketFactoryFunc func);\n\n    /**\n     * @param sslRequired If true then it is guaranteed that returned object can be safely cast to\n     * AbstractEncryptedStreamSocket.\n     */\n    static std::unique_ptr&lt;AbstractStreamSocket&gt; createStreamSocket(\n        ssl::AdapterFunc adapterFunc,\n        bool sslRequired = false,\n        NatTraversalSupport natTraversalRequired = NatTraversalSupport::enabled,\n        std::optional&lt;int&gt; ipVersion = std::nullopt);\n\n    static std::unique_ptr&lt; AbstractStreamServerSocket &gt; createStreamServerSocket(\n        bool sslRequired = false,\n        std::optional&lt;int&gt; ipVersion = std::nullopt);\n\n    static std::unique_ptr&lt;nx::network::AbstractStreamServerSocket&gt; createSslAdapter(\n        std::unique_ptr&lt;nx::network::AbstractStreamServerSocket&gt; serverSocket,\n        ssl::Context* context,\n        ssl::EncryptionUse encryptionUse);\n\n    static std::string toString(SocketType type);\n    static SocketType stringToSocketType(std::string type);\n\n    /**\n     * Enforces factory to produce certain sockets\n     * NOTE: DEBUG use ONLY!\n     */\n    static void enforceStreamSocketType(SocketType type);\n    static void enforceStreamSocketType(std::string type);\n    static bool isStreamSocketTypeEnforced();\n\n    /**\n     * Set new factory.\n     * @return old factory.\n     */\n    static CreateStreamSocketFuncType\n        setCreateStreamSocketFunc(CreateStreamSocketFuncType newFactoryFunc);\n    static CreateStreamServerSocketFuncType\n        setCreateStreamServerSocketFunc(CreateStreamServerSocketFuncType newFactoryFunc);\n\n    static void setIpVersion(const std::string&amp; ipVersion);\n\n    /**\n     * @return Previous version.\n     */\n    static nx::network::IpVersion setUdpIpVersion(nx::network::IpVersion ipVersion);\n\n    static int udpIpVersion();\n    static int tcpClientIpVersion();\n    static int tcpServerIpVersion();\n\n    static SocketFactory&amp; instance();\n\n    static std::unique_ptr&lt;AbstractStreamSocket&gt; defaultStreamSocketFactoryFunc(\n        ssl::AdapterFunc adapterFunc,\n        bool sslRequired,\n        nx::network::NatTraversalSupport nttType,\n        std::optional&lt;int&gt; _ipVersion);\n\n    static std::unique_ptr&lt;AbstractStreamServerSocket&gt; defaultStreamServerSocketFactoryFunc(\n        bool sslRequired,\n        std::optional&lt;int&gt; _ipVersion);\n\nprivate:\n    std::unique_ptr&lt;SocketFactoryImpl&gt; m_impl;\n\n    SocketFactory();\n    SocketFactory(const SocketFactory&amp;) = delete;\n    SocketFactory&amp; operator=(const SocketFactory&amp;) = delete;\n\n    ~SocketFactory();\n\n    static std::atomic&lt;SocketType&gt; s_enforcedStreamSocketType;\n\n    static std::atomic&lt;int&gt; s_udpIpVersion;\n    static std::atomic&lt;int&gt; s_tcpClientIpVersion;\n    static std::atomic&lt;int&gt; s_tcpServerIpVersion;\n};\n\n} // namespace nx::network\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include &lt;nx/kit/ini_config.h&gt;\n#include &lt;nx/utils/argument_parser.h&gt;\n#include &lt;nx/utils/debug/allocation_analyzer.h&gt;\n#include &lt;nx/utils/log/log.h&gt;\n\n#include &quot;debug/object_counters.h&quot;\n#include &quot;socket_common.h&quot;\n\nnamespace nx {\nnamespace network {\n\nnamespace aio { class AIOService; }\nclass AddressResolver;\n\nnamespace http { class GlobalContext; }\nnamespace cloud { class CloudConnectController; }\n\nstruct SocketGlobalsImpl;\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Contains objects that are required to use the network subsystem.\n * This object MUST be created before the first socket usage and destroyed after the last socket usage.\n * It can be created/destroyed with\n * &lt;pre&gt;&lt;code&gt;\n * nx::network::SocketGlobalsHolder socketGlobals;\n * ...\n * &lt;/code&gt;&lt;/pre&gt;\n * or\n * &lt;pre&gt;&lt;code&gt;\n * nx::network::SocketGlobals::init();\n * ...\n * nx::network::SocketGlobals::deinit();\n * &lt;/code&gt;&lt;/pre&gt;\n */\nclass NX_NETWORK_API SocketGlobals\n{\npublic:\n    static aio::AIOService&amp; aioService();\n    static AddressResolver&amp; addressResolver();\n    static http::GlobalContext&amp; httpGlobalContext();\n    static cloud::CloudConnectController&amp; cloud();\n    static int initializationFlags();\n\n    /**\n     * Allocates required resources. E.g., starts AIO threads.\n     * Must be called before any socket use.\n     * @param arguments Command-line arguments\n     * The following command-line arguments are supported:\n     * - aio-thread-pool-size Number of AIO threads to create. By default, 0 (the number of threads is auto-detected)\n     * - cloud-host Cloud domain name to use\n     */\n    static void init(\n        const ArgumentParser&amp; arguments,\n        int initializationFlags = 0);\n\n    /**\n     * Must be called before any socket use.\n     */\n    static void init(\n        int initializationFlags = 0,\n        const std::string&amp; customCloudHost = std::string());\n\n    static void deinit(); /**&lt; Should be called when sockets are not needed any more. */\n    static void verifyInitialization();\n    static bool isInitialized();\n\n    /**\n     * Change the cloud host to the given value.\n     * Warning! This function is not safe in any means. Do not use it directly in the production\n     * code. For debug/support/developer purposes only.\n     */\n    static void switchCloudHost(const std::string&amp; customCloudHost);\n\n    static void printArgumentsHelp(std::ostream* outputStream);\n    static void applyArguments(const ArgumentParser&amp; arguments);\n\n    bool isUdtEnabled() const;\n\n    /**\n     * Block sockets from connecting to a host that matches the regular expression given with\n     * hostnameRegexp argument.\n     */\n    void blockHost(const std::string&amp; hostnameRegexp);\n\n    /**\n     * Remove hostnameRegexp from the list of blocked hosts.\n     */\n    void unblockHost(const std::string&amp; hostnameRegexp);\n\n    /**\n     * @return true if address has been blocked with SocketGlobals::blockHost.\n     */\n    bool isHostBlocked(const HostAddress&amp; address) const;\n\n    const debug::ObjectCounters&amp; debugCounters() const;\n    debug::ObjectCounters&amp; debugCounters();\n\n    nx::utils::debug::AllocationAnalyzer&amp; allocationAnalyzer();\n\n    static SocketGlobals&amp; instance();\n\n    class InitGuard\n    {\n    public:\n        InitGuard(int initializationFlags = 0)\n        {\n            init(initializationFlags);\n        }\n\n        InitGuard(const ArgumentParser&amp; arguments, int initializationFlags = 0)\n        {\n            init(arguments, initializationFlags);\n        }\n\n        ~InitGuard() { deinit(); }\n\n        InitGuard(const InitGuard&amp;) = delete;\n        InitGuard(InitGuard&amp;&amp;) = delete;\n        InitGuard&amp; operator=(const InitGuard&amp;) = delete;\n        InitGuard&amp; operator=(InitGuard&amp;&amp;) = delete;\n    };\n\nprivate:\n    std::unique_ptr&lt;SocketGlobalsImpl&gt; m_implGuard;\n    SocketGlobalsImpl* m_impl = nullptr;\n    debug::ObjectCounters m_debugCounters;\n    nx::utils::debug::AllocationAnalyzer m_allocationAnalyzer;\n\n    /**\n     * @param initializationFlags Bitset of nx::network::InitializationFlags.\n     */\n    SocketGlobals(int initializationFlags);\n    ~SocketGlobals();\n\n    SocketGlobals(const SocketGlobals&amp;) = delete;\n    SocketGlobals&amp; operator=(const SocketGlobals&amp;) = delete;\n\n    void reloadIni();\n\n    void initializeNetworking(const ArgumentParser&amp; arguments);\n\n    void initializeCloudConnectivity(const std::string&amp; customCloudHost);\n    void deinitializeCloudConnectivity();\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Invokes SocketGlobals::init() when constructed and SocketGlobals::deinit() just before destruction.\n */\nclass NX_NETWORK_API SocketGlobalsHolder\n{\npublic:\n    /**\n     * Invokes SocketGlobalsHolder::initialize(false).\n     */\n    SocketGlobalsHolder(int initializationFlags = 0);\n    SocketGlobalsHolder(const ArgumentParser&amp; arguments, int initializationFlags = 0);\n    ~SocketGlobalsHolder();\n\n    void initialize(bool initializePeerId = true);\n    void uninitialize();\n    void reinitialize(bool initializePeerId = true);\n\n    static SocketGlobalsHolder* instance();\n\nprivate:\n    const nx::ArgumentParser m_args;\n    const int m_initializationFlags;\n    std::unique_ptr&lt;SocketGlobals::InitGuard&gt; m_socketGlobalsGuard;\n};\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_async_channel.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_async_channel.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_async_channel.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;memory&gt;\n\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/system_error.h&gt;\n#include &lt;nx/utils/thread/cf/cfuture.h&gt;\n\n#include &quot;basic_pollable.h&quot;\n#include &quot;event_type.h&quot;\n\nnamespace nx::network::aio {\n\n/**\n * Interface for any entity that support asynchronous read/write operations.\n */\nclass NX_NETWORK_API AbstractAsyncChannel:\n    public BasicPollable\n{\npublic:\n    virtual ~AbstractAsyncChannel() override = default;\n\n    virtual void readSomeAsync(\n        nx::Buffer* const buffer,\n        IoCompletionHandler handler) = 0;\n\n    /**\n     * Future-based wrapper for readSomeAsync.\n     *\n     * @returns Count of bytes transferred (i.e. second parameter of readSomeAsync handler).\n     * @throws std::system_error with error code (i.e. first parameter of readSomeAsync) and\n     * std::system_category() when operation fails.\n     * @throws std::system_error with std::errc::operation_canceled error code when operation is\n     * canceled.\n     */\n    virtual cf::future&lt;std::size_t&gt; readSome(nx::Buffer* buffer);\n\n    virtual void sendAsync(\n        const nx::Buffer* buffer,\n        IoCompletionHandler handler) = 0;\n\n    /**\n     * Future-based wrapper for sendAsync.\n     *\n     * @returns Count of bytes transferred (i.e. second parameter of sendAsync handler).\n     * @throws std::system_error with error code (i.e. first parameter of sendAsync) and\n     * std::system_category() when operation fails.\n     * @throws std::system_error with std::errc::operation_canceled error code when operation is\n     * canceled.\n     */\n    virtual cf::future&lt;std::size_t&gt; send(const nx::Buffer* buffer);\n\n    /**\n     * Cancel async socket operation. cancellationDoneHandler is invoked when cancelled.\n     * @param eventType event to cancel.\n     */\n    virtual void cancelIOAsync(\n        nx::network::aio::EventType eventType,\n        nx::MoveOnlyFunc&lt;void()&gt; handler) final;\n\n    /**\n     * Future-based wrapper for cancelIOAsync.\n     */\n    cf::future&lt;cf::unit&gt; cancelIO(nx::network::aio::EventType eventType);\n\n    /**\n     * Does not block if called within object&#x27;s AIO thread.\n     * If called from any other thread then returns after asynchronous handler completion.\n     */\n    virtual void cancelIOSync(nx::network::aio::EventType eventType) final;\n    virtual void cancelIoInAioThread(nx::network::aio::EventType eventType) = 0;\n\n    void cancelRead() { cancelIOSync(aio::etRead); };\n    void cancelWrite() { cancelIOSync(aio::etWrite); };\n};\n\nusing AsyncChannelPtr = std::unique_ptr&lt;nx::network::aio::AbstractAsyncChannel&gt;;\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/stream_transforming_async_channel.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/stream_transforming_async_channel.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/stream_transforming_async_channel.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;deque&gt;\n#include &lt;memory&gt;\n#include &lt;tuple&gt;\n\n#include &lt;nx/reflect/enum_instrument.h&gt;\n#include &lt;nx/utils/byte_stream/pipeline.h&gt;\n#include &lt;nx/utils/interruption_flag.h&gt;\n#include &lt;nx/utils/std/optional.h&gt;\n\n#include &quot;abstract_async_channel.h&quot;\n\nnamespace nx::network::aio {\n\nnamespace detail {\n\nNX_REFLECTION_ENUM_CLASS(UserTaskType,\n    read,\n    write\n);\n\nNX_REFLECTION_ENUM_CLASS(UserTaskStatus,\n    inProgress,\n    done\n);\n\n} // namespace detail\n\nusing UserIoHandler = IoCompletionHandler;\n\n/**\n * Delegates read/write calls to the wrapped AbstractAsyncChannel\n *   moving data through nx::utils::bstream::Converter first.\n * WARNING: Converter MUST NOT generate wouldBlock error by itself before\n *   invoking underlying input/output. Otherwise, behavior is undefined.\n *   Effectively, that means conversion cannot change size of data.\n */\nclass NX_NETWORK_API StreamTransformingAsyncChannel:\n    public AbstractAsyncChannel\n{\n    using base_type = AbstractAsyncChannel;\n\npublic:\n    StreamTransformingAsyncChannel(\n        std::unique_ptr&lt;AbstractAsyncChannel&gt; rawDataChannel,\n        nx::utils::bstream::Converter* converter);\n    virtual ~StreamTransformingAsyncChannel() override;\n\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override;\n\n    virtual void readSomeAsync(nx::Buffer* const buffer, UserIoHandler handler) override;\n    virtual void sendAsync(const nx::Buffer* buffer, UserIoHandler handler) override;\n\n    int readRawDataFromCache(void* data, size_t count);\n\n    /**\n     * Stops handing of any I/O events from the wrapped channel until the\n     * corresponding resume() call. Recursive calling is supported.\n     */\n    void pause();\n\n    /**\n     * Resumes previously stopped I/O events handling. Every pause() call\n     * must have corresponding resume() call. All deferred events will be\n     * handled upon the resumption.\n     */\n    void resume();\n\nprotected:\n    virtual void cancelIoInAioThread(aio::EventType eventType) override;\n\nprivate:\n    struct UserTask\n    {\n        const detail::UserTaskType type;\n        UserIoHandler handler;\n        detail::UserTaskStatus status = detail::UserTaskStatus::inProgress;\n\n        UserTask(detail::UserTaskType type, UserIoHandler handler):\n            type(type),\n            handler(std::move(handler))\n        {\n        }\n    };\n\n    struct ReadTask: UserTask\n    {\n        nx::Buffer* buffer;\n\n        ReadTask(nx::Buffer* const buffer, UserIoHandler handler):\n            UserTask(detail::UserTaskType::read, std::move(handler)),\n            buffer(buffer)\n        {\n        }\n    };\n\n    struct WriteTask: UserTask\n    {\n        const nx::Buffer* buffer;\n\n        WriteTask(const nx::Buffer* buffer, UserIoHandler handler):\n            UserTask(detail::UserTaskType::write, std::move(handler)),\n            buffer(buffer)\n        {\n        }\n    };\n\n    struct RawSendContext\n    {\n        nx::Buffer data;\n        int userByteCount = 0;\n        UserIoHandler userHandler;\n        bool inProgress = false;\n    };\n\n    std::unique_ptr&lt;AbstractAsyncChannel&gt; m_rawDataChannel;\n    nx::utils::bstream::Converter* m_converter;\n    nx::Buffer m_readBuffer;\n    nx::Buffer m_encodedDataBuffer;\n    BasicPollable m_readScheduler;\n    BasicPollable m_sendScheduler;\n    std::function&lt;void(SystemError::ErrorCode, size_t)&gt; m_userReadHandler;\n    std::function&lt;void(SystemError::ErrorCode, size_t)&gt; m_userWriteHandler;\n    std::unique_ptr&lt;nx::utils::bstream::AbstractInput&gt; m_inputPipeline;\n    std::unique_ptr&lt;nx::utils::bstream::AbstractOutput&gt; m_outputPipeline;\n    std::deque&lt;std::shared_ptr&lt;UserTask&gt;&gt; m_userTaskQueue;\n    nx::Buffer m_rawDataReadBuffer;\n    std::deque&lt;nx::Buffer&gt; m_readRawData;\n    std::deque&lt;RawSendContext&gt; m_rawWriteQueue;\n    bool m_asyncReadInProgress = false;\n    bool m_asyncReadPostponed = false;\n    nx::utils::InterruptionFlag m_aioInterruptionFlag;\n    bool m_sendShutdown = false;\n    std::atomic&lt;int&gt; m_pauseLevel = 0;\n\n    virtual void stopWhileInAioThread() override;\n\n    void tryToCompleteUserTasks();\n    void tryToCompleteUserTasks(\n        const std::deque&lt;std::shared_ptr&lt;UserTask&gt;&gt;&amp; userTaskQueue);\n    void processTask(UserTask* task);\n    void processReadTask(ReadTask* task);\n    void processWriteTask(WriteTask* task);\n\n    template&lt;typename TransformerFunc&gt;\n    std::tuple&lt;SystemError::ErrorCode, int /*bytesTransferred*/&gt;\n        invokeConverter(TransformerFunc func);\n\n    void issueIoOperationsScheduledByConverter();\n\n    int readRawBytes(void* data, size_t count);\n    void readRawChannelAsync();\n    void onSomeRawDataRead(SystemError::ErrorCode, std::size_t);\n    int writeRawBytes(const void* data, size_t count);\n\n    void onRawDataWritten(SystemError::ErrorCode, std::size_t);\n    template&lt;typename Range&gt; std::deque&lt;RawSendContext&gt; takeRawSendTasks(Range range);\n\n    /**\n     * @return False if was interrupted. All further processing should be stopped until the next event.\n     */\n    bool completeRawSendTasks(\n        std::deque&lt;RawSendContext&gt; completedRawSendTasks,\n        SystemError::ErrorCode sysErrorCode);\n\n    void scheduleNextRawSendTaskIfAny();\n\n    void reportFailureOfEveryUserTask(SystemError::ErrorCode sysErrorCode);\n    void reportFailureToTasksFilteredByType(\n        SystemError::ErrorCode sysErrorCode,\n        std::optional&lt;detail::UserTaskType&gt; userTypeFilter);\n\n    void removeUserTask(UserTask* task);\n\n    static std::string toString(const std::deque&lt;std::shared_ptr&lt;UserTask&gt;&gt;&amp; taskQueue);\n    static std::string toString(const UserTask&amp; task);\n};\n\n} // namespace nx::network::aio\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/custom_handshake_connection_acceptor.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/custom_handshake_connection_acceptor.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/custom_handshake_connection_acceptor.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;deque&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n#include &lt;nx/network/aio/aio_service.h&gt;\n#include &lt;nx/network/aio/timer.h&gt;\n#include &lt;nx/network/debug/object_instance_counter.h&gt;\n#include &lt;nx/network/socket_global.h&gt;\n#include &lt;nx/utils/async_operation_guard.h&gt;\n#include &lt;nx/utils/counter.h&gt;\n#include &lt;nx/utils/log/log.h&gt;\n#include &lt;nx/utils/std/optional.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n#include &quot;abstract_stream_socket_acceptor.h&quot;\n\nnamespace nx::network {\n\n/**\n * Helper class for implementing acceptors (e.g., StreamServerSocket) of connections\n * that require some custom handshake before being provided to the user.\n * E.g., SSL connection requires handshake before connection can be considered &quot;accepted&quot;.\n * So, before returning to the user connection is undergoing some custom handshake.\n */\ntemplate&lt;typename AcceptorDelegate, typename CustomHandshakeConnection&gt;\n// requires AsyncAcceptor&lt;AcceptorDelegate&gt; &amp;&amp;\n//   std::is_base_of&lt;AbstractStreamSocket, CustomHandshakeConnection&gt;::value\nclass CustomHandshakeConnectionAcceptor:\n    public AbstractStreamSocketAcceptor\n{\n    // TODO: #akolesnikov CustomHandshakeConnectionAcceptor should not be a template after inheriting\n    //   AbstractStreamServerSocket from AbstractStreamSocketAcceptor.\n\n    using base_type = AbstractStreamSocketAcceptor;\n\npublic:\n    using CustomHandshakeConnectionFactory =\n        nx::MoveOnlyFunc&lt;std::unique_ptr&lt;CustomHandshakeConnection&gt;(\n            std::unique_ptr&lt;AbstractStreamSocket&gt;)&gt;;\n\n    constexpr static std::size_t kDefaultMaxReadyConnectionCount = 32;\n    // 24 seconds is a default TCP handshake timeout in Linux.\n    constexpr static std::chrono::seconds kDefaultHandshakeTimeout =\n        std::chrono::seconds(24);\n\n    CustomHandshakeConnectionAcceptor(\n        std::unique_ptr&lt;AcceptorDelegate&gt; delegate,\n        CustomHandshakeConnectionFactory customHandshakeConnectionFactory)\n        :\n        m_delegate(std::move(delegate)),\n        m_customHandshakeConnectionFactory(\n            std::move(customHandshakeConnectionFactory))\n    {\n        bindToAioThread(m_delegate-&gt;getAioThread());\n    }\n\n    ~CustomHandshakeConnectionAcceptor()\n    {\n        NX_CRITICAL(!SocketGlobals::instance().aioService().isInAnyAioThread());\n        this-&gt;pleaseStopSync();\n        m_startedAsyncHandshakeCancellationsCounter.wait();\n    }\n\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override\n    {\n        base_type::bindToAioThread(aioThread);\n\n        m_delegate-&gt;bindToAioThread(aioThread);\n        m_acceptCallScheduler.bindToAioThread(aioThread);\n\n        // NOTE: Not binding connections to the specified thread to distribute work between\n        // multiple AIO threads.\n    }\n\n    /**\n     * When ready-to-use connection count is greater or equal to this value,\n     * then creation of new connections is stopped until there is more room in the queue.\n     */\n    void setReadyConnectionQueueSize(std::size_t count)\n    {\n        m_maxReadyConnectionCount = count;\n    }\n\n    std::size_t readyConnectionQueueSize() const\n    {\n        return m_maxReadyConnectionCount;\n    }\n\n    void setHandshakeTimeout(std::chrono::milliseconds timeout)\n    {\n        m_handshakeTimeout = timeout;\n    }\n\n    std::chrono::milliseconds handshakeTimeout() const\n    {\n        return m_handshakeTimeout;\n    }\n\n    void start()\n    {\n        post(\n            [this]()\n            {\n                NX_MUTEX_LOCKER lock(&amp;m_mutex);\n                openConnections(lock);\n            });\n    }\n\n    virtual void acceptAsync(AcceptCompletionHandler handler) override\n    {\n        m_acceptCallScheduler.post(\n            [this, handler = std::move(handler)]() mutable\n            {\n                m_acceptHandler = std::move(handler);\n\n                NX_MUTEX_LOCKER lock(&amp;m_mutex);\n\n                if (!m_acceptedConnections.empty())\n                    return provideConnectionToTheCallerIfAppropriate(lock);\n\n                openConnections(lock);\n            });\n    }\n\n    virtual void cancelIOSync() override\n    {\n        if (isInSelfAioThread())\n        {\n            cancelIoWhileInOwnAioThread();\n        }\n        else\n        {\n            std::promise&lt;void&gt; done;\n            post(\n                [this, &amp;done]()\n                {\n                    cancelIoWhileInOwnAioThread();\n                    done.set_value();\n                });\n            done.get_future().wait();\n        }\n    }\n\n    /**\n     * @return null if connection could not been accepted.\n     * Use SystemError::getLastOsErrorCode() to get error code.\n     * If accepted connections queue is empty, error code is set to SystemError::wouldBlock.\n     */\n    std::unique_ptr&lt;CustomHandshakeConnection&gt; getNextConnectionIfAny()\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n\n        auto acceptResult = takeNextAcceptedConnection(lock);\n        if (!acceptResult)\n        {\n            SystemError::setLastErrorCode(SystemError::wouldBlock);\n            return nullptr;\n        }\n\n        post(\n            [this]()\n            {\n                NX_MUTEX_LOCKER lock(&amp;m_mutex);\n                openConnections(lock);\n            });\n\n        if (acceptResult-&gt;resultCode != SystemError::noError)\n            SystemError::setLastErrorCode(acceptResult-&gt;resultCode);\n        return std::move(acceptResult-&gt;connection);\n    }\n\nprotected:\n    virtual void stopWhileInAioThread() override\n    {\n        m_delegate-&gt;pleaseStopSync();\n        m_acceptCallScheduler.pleaseStopSync();\n\n        m_acceptedConnections.clear();\n\n        cancelHandshakes();\n    }\n\nprivate:\n    struct ConnectionContext\n    {\n        std::unique_ptr&lt;CustomHandshakeConnection&gt; connection;\n        aio::Timer handshakeTimer;\n\n        ConnectionContext(\n            std::unique_ptr&lt;CustomHandshakeConnection&gt; connection)\n            :\n            connection(std::move(connection))\n        {\n        }\n\n    private:\n        nx::network::debug::ObjectInstanceCounter&lt;ConnectionContext&gt; m_instanceCounter;\n    };\n\n    struct AcceptResult\n    {\n        SystemError::ErrorCode resultCode;\n        std::unique_ptr&lt;CustomHandshakeConnection&gt; connection;\n\n        AcceptResult(\n            SystemError::ErrorCode resultCode,\n            std::unique_ptr&lt;CustomHandshakeConnection&gt; connection)\n            :\n            resultCode(resultCode),\n            connection(std::move(connection))\n        {\n        }\n\n    private:\n        nx::network::debug::ObjectInstanceCounter&lt;AcceptResult&gt; m_instanceCounter;\n    };\n\n    using Connections = std::map&lt;int /*seq*/, std::unique_ptr&lt;ConnectionContext&gt;&gt;;\n\n    nx::utils::AsyncOperationGuard m_guard;\n    std::unique_ptr&lt;AcceptorDelegate&gt; m_delegate;\n    Connections m_connectionsBeingHandshaked;\n    AcceptCompletionHandler m_acceptHandler;\n    std::deque&lt;AcceptResult&gt; m_acceptedConnections;\n    std::size_t m_maxReadyConnectionCount = kDefaultMaxReadyConnectionCount;\n    std::chrono::milliseconds m_handshakeTimeout = kDefaultHandshakeTimeout;\n    aio::BasicPollable m_acceptCallScheduler;\n    mutable nx::Mutex m_mutex;\n    bool m_isDelegateAccepting = false;\n    CustomHandshakeConnectionFactory m_customHandshakeConnectionFactory;\n    bool m_acceptSuspended = false;\n    std::atomic&lt;int&gt; m_connectionSequence = 0;\n    nx::utils::Counter m_startedAsyncHandshakeCancellationsCounter;\n\n    void openConnections(const nx::Locker&lt;nx::Mutex&gt;&amp; /*lock*/)\n    {\n        using namespace std::placeholders;\n\n        NX_ASSERT(isInSelfAioThread());\n\n        if (m_acceptedConnections.size() &gt;= m_maxReadyConnectionCount)\n        {\n            if (!m_isDelegateAccepting &amp;&amp; !m_acceptSuspended)\n            {\n                NX_VERBOSE(this, &quot;Suspending accepting new connections since there are already %1&quot;,\n                    m_acceptedConnections.size());\n                m_acceptSuspended = true;\n            }\n            return;\n        }\n\n        if (m_acceptSuspended)\n            m_acceptSuspended = false;\n\n        if (!m_isDelegateAccepting)\n        {\n            NX_VERBOSE(this, &quot;Accepting new connection. There are already %1 accepted&quot;,\n                m_acceptedConnections.size());\n\n            m_delegate-&gt;acceptAsync(std::bind(\n                &amp;CustomHandshakeConnectionAcceptor::onConnectionAccepted, this, _1, _2));\n            m_isDelegateAccepting = true;\n        }\n    }\n\n    void onConnectionAccepted(\n        SystemError::ErrorCode systemErrorCode,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; socket)\n    {\n        using namespace std::placeholders;\n\n        NX_ASSERT(isInSelfAioThread());\n\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n\n        m_isDelegateAccepting = false;\n\n        // Not forwarding timedOut since user may not even called\n        // CustomHandshakeConnectionAcceptor::acceptAsync.\n        // So, he should not receive timedOut right after calling acceptAsync.\n        if (systemErrorCode != SystemError::noError &amp;&amp;\n            systemErrorCode != SystemError::timedOut)\n        {\n            m_acceptedConnections.emplace_back(systemErrorCode, nullptr);\n\n            post(\n                [this]()\n                {\n                    NX_MUTEX_LOCKER lock(&amp;m_mutex);\n                    provideConnectionToTheCallerIfAppropriate(lock);\n                });\n        }\n        else if (socket &amp;&amp; socket-&gt;setNonBlockingMode(true))\n        {\n            // NOTE: connection is bound to unknown AIO thread here.\n            // Leaving it so that multiple AIO threads are loaded by this object.\n\n            const auto seq = ++m_connectionSequence;\n\n            auto ctx = std::make_unique&lt;ConnectionContext&gt;(\n                m_customHandshakeConnectionFactory(std::move(socket)));\n            auto ctxPtr = ctx.get();\n\n            m_connectionsBeingHandshaked.emplace(seq, std::move(ctx));\n            ctxPtr-&gt;connection-&gt;bindToAioThread(\n                SocketGlobals::aioService().getRandomAioThread());\n            ctxPtr-&gt;handshakeTimer.bindToAioThread(ctxPtr-&gt;connection-&gt;getAioThread());\n\n            auto handshakeDone =\n                std::bind(&amp;CustomHandshakeConnectionAcceptor::onHandshakeDone, this,\n                    m_guard.sharedGuard(), seq, ctxPtr, _1);\n\n            ctxPtr-&gt;handshakeTimer.start(\n                m_handshakeTimeout,\n                std::bind(handshakeDone, SystemError::timedOut));\n            ctxPtr-&gt;connection-&gt;handshakeAsync(handshakeDone);\n\n            NX_VERBOSE(this, &quot;Started handshake of connection %1&quot;, ctxPtr-&gt;connection.get());\n        }\n\n        openConnections(lock);\n    }\n\n    void onHandshakeDone(\n        std::shared_ptr&lt;nx::utils::AsyncOperationGuard::SharedGuard&gt; sharedGuard,\n        int seq,\n        ConnectionContext* ctxPtr,\n        SystemError::ErrorCode handshakeResult)\n    {\n        // NOTE: We are in connection&#x27;s AIO thread which may be different from this-&gt;getAioThread().\n        // That guarantees that the connection context object is alive.\n        ctxPtr-&gt;handshakeTimer.pleaseStopSync();\n\n        ctxPtr-&gt;connection-&gt;cancelIOSync(aio::EventType::etAll);\n\n        // Invoking connection-&gt;post to make sure the connection has completed its job and can be\n        // safely deleted in any thread.\n        ctxPtr-&gt;connection-&gt;post(\n            [this, sharedGuard, seq, handshakeResult]()\n            {\n                const auto lock = sharedGuard-&gt;lock();\n                if (!lock)\n                    return;\n\n                // this-&gt;post to switch to the acceptor&#x27;s AIO thread.\n                post(\n                    [this, seq, handshakeResult]()\n                    {\n                        // NOTE: There is no guarantee that ctxPtr is alive.\n\n                        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n\n                        auto connectionIter = m_connectionsBeingHandshaked.find(seq);\n                        if (connectionIter == m_connectionsBeingHandshaked.end())\n                            return; // Connection has been removed, just ignoring.\n\n                        auto connection = std::move(connectionIter-&gt;second-&gt;connection);\n                        m_connectionsBeingHandshaked.erase(connectionIter);\n\n                        NX_VERBOSE(this, &quot;Handshake completed. Connection %1, result %2&quot;,\n                            connection.get(), SystemError::toString(handshakeResult));\n\n                        if (handshakeResult != SystemError::noError)\n                        {\n                            openConnections(lock);\n                            return;\n                        }\n\n                        m_acceptedConnections.emplace_back(\n                            SystemError::noError,\n                            std::move(connection));\n\n                        provideConnectionToTheCallerIfAppropriate(lock);\n                    });\n            });\n    }\n\n    void provideConnectionToTheCallerIfAppropriate(\n        const nx::Locker&lt;nx::Mutex&gt;&amp; lock)\n    {\n        NX_ASSERT(isInSelfAioThread());\n\n        if (!m_acceptHandler)\n            return;\n\n        auto acceptResult = takeNextAcceptedConnection(lock);\n        openConnections(lock);\n        if (acceptResult)\n        {\n            nx::swapAndCall(\n                m_acceptHandler,\n                acceptResult-&gt;resultCode,\n                std::move(acceptResult-&gt;connection));\n        }\n    }\n\n    std::optional&lt;AcceptResult&gt; takeNextAcceptedConnection(\n        const nx::Locker&lt;nx::Mutex&gt;&amp; /*lock*/)\n    {\n        std::optional&lt;AcceptResult&gt; acceptResult;\n        if (!m_acceptedConnections.empty())\n        {\n            acceptResult = std::move(m_acceptedConnections.front());\n            m_acceptedConnections.pop_front();\n        }\n\n        return acceptResult;\n    }\n\n    void cancelIoWhileInOwnAioThread()\n    {\n        m_acceptHandler = nullptr;\n        m_acceptCallScheduler.cancelPostedCallsSync();\n    }\n\n    void cancelHandshakes()\n    {\n        m_guard.reset();\n\n        // NOTE: Removing connections asynchronously since they live in different AIO threads.\n        Connections connectionsBeingHandshaked;\n        {\n            NX_MUTEX_LOCKER lock(&amp;m_mutex);\n            connectionsBeingHandshaked = std::exchange(m_connectionsBeingHandshaked, {});\n        }\n\n        std::map&lt;aio::AbstractAioThread*, std::vector&lt;std::unique_ptr&lt;ConnectionContext&gt;&gt;&gt;\n            connectionContextsByAioThread;\n        for (auto&amp; [seq, ctx]: connectionsBeingHandshaked)\n        {\n            connectionContextsByAioThread[ctx-&gt;connection-&gt;getAioThread()]\n                .push_back(std::move(ctx));\n        }\n\n        for (auto&amp; [aioThread, connections]: connectionContextsByAioThread)\n        {\n            aioThread-&gt;post(\n                nullptr,\n                [\n                    connections = std::move(connections),\n                    guard =\n                        m_startedAsyncHandshakeCancellationsCounter.getScopedIncrement()]() mutable\n                {\n                    connections.clear();\n                });\n        }\n    }\n};\n\n} // namespace nx::network\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_delegate.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_delegate.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_delegate.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &quot;abstract_socket.h&quot;\n\nnamespace nx {\nnamespace network {\n\nnamespace detail {\n\nNX_NETWORK_API void recordSocketDelegateCreation(void* ptr);\nNX_NETWORK_API void recordSocketDelegateDestruction(void* ptr);\n\n} // namespace detail\n\n/**\n * Base for some class that wants to extend socket functionality a bit\n * and delegate rest of API calls to existing implementation.\n */\ntemplate&lt;typename SocketInterfaceToImplement, typename TargetType&gt;\n// requires std::is_base_of&lt;AbstractSocket, SocketInterfaceToImplement&gt;::value\nclass SocketDelegate:\n    public SocketInterfaceToImplement\n{\n    static_assert(\n        std::is_base_of&lt;AbstractSocket, SocketInterfaceToImplement&gt;::value,\n        &quot;You MUST use class derived of AbstractSocket as a template argument&quot;);\n\npublic:\n    SocketDelegate(TargetType* target):\n        m_target(target)\n    {\n        detail::recordSocketDelegateCreation(this);\n    }\n\n    ~SocketDelegate()\n    {\n        detail::recordSocketDelegateDestruction(this);\n    }\n\n    virtual bool getLastError(SystemError::ErrorCode* errorCode) const override\n    {\n        return m_target-&gt;getLastError(errorCode);\n    }\n\n    virtual AbstractSocket::SOCKET_HANDLE handle() const override\n    {\n        return m_target-&gt;handle();\n    }\n\n    virtual bool getRecvTimeout(unsigned int* millis) const override\n    {\n        return m_target-&gt;getRecvTimeout(millis);\n    }\n\n    virtual bool getSendTimeout(unsigned int* millis) const override\n    {\n        return m_target-&gt;getSendTimeout(millis);\n    }\n\n    virtual nx::network::aio::AbstractAioThread* getAioThread() const override\n    {\n        return m_target-&gt;getAioThread();\n    }\n\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) override\n    {\n        return m_target-&gt;bindToAioThread(aioThread);\n    }\n\n    virtual bool isInSelfAioThread() const override\n    {\n        return m_target-&gt;isInSelfAioThread();\n    }\n\n    virtual bool bind(const SocketAddress&amp; localAddress) override\n    {\n        return m_target-&gt;bind(localAddress);\n    }\n\n    virtual SocketAddress getLocalAddress() const override\n    {\n        return m_target-&gt;getLocalAddress();\n    }\n\n    virtual bool close() override\n    {\n        return m_target-&gt;close();\n    }\n\n    virtual bool shutdown() override\n    {\n        return m_target-&gt;shutdown();\n    }\n\n    virtual bool isClosed() const override\n    {\n        return m_target-&gt;isClosed();\n    }\n\n    virtual bool setReuseAddrFlag(bool reuseAddr) override\n    {\n        return m_target-&gt;setReuseAddrFlag(reuseAddr);\n    }\n\n    virtual bool getReuseAddrFlag(bool* val) const override\n    {\n        return m_target-&gt;getReuseAddrFlag(val);\n    }\n\n    virtual bool setReusePortFlag(bool value) override\n    {\n        return m_target-&gt;setReusePortFlag(value);\n    }\n\n    virtual bool getReusePortFlag(bool* value) const override\n    {\n        return m_target-&gt;getReusePortFlag(value);\n    }\n\n    virtual bool setNonBlockingMode(bool val) override\n    {\n        return m_target-&gt;setNonBlockingMode(val);\n    }\n\n    virtual bool getNonBlockingMode(bool* val) const override\n    {\n        return m_target-&gt;getNonBlockingMode(val);\n    }\n\n    virtual bool getMtu(unsigned int* mtuValue) const override\n    {\n        return m_target-&gt;getMtu(mtuValue);\n    }\n\n    virtual bool setSendBufferSize(unsigned int buffSize) override\n    {\n        return m_target-&gt;setSendBufferSize(buffSize);\n    }\n\n    virtual bool getSendBufferSize(unsigned int* buffSize) const override\n    {\n        return m_target-&gt;getSendBufferSize(buffSize);\n    }\n\n    virtual bool setRecvBufferSize(unsigned int buffSize) override\n    {\n        return m_target-&gt;setRecvBufferSize(buffSize);\n    }\n\n    virtual bool getRecvBufferSize(unsigned int* buffSize) const override\n    {\n        return m_target-&gt;getRecvBufferSize(buffSize);\n    }\n\n    virtual bool setRecvTimeout(unsigned int ms) override\n    {\n        return m_target-&gt;setRecvTimeout(ms);\n    }\n\n    virtual bool setSendTimeout(unsigned int ms) override\n    {\n        return m_target-&gt;setSendTimeout(ms);\n    }\n\n    virtual bool setIpv6Only(bool val) override\n    {\n        return m_target-&gt;setIpv6Only(val);\n    }\n\n    virtual bool getProtocol(int* protocol) const override\n    {\n        return m_target-&gt;getProtocol(protocol);\n    }\n\n    virtual Pollable* pollable() override\n    {\n        return m_target-&gt;pollable();\n    }\n\n    virtual void post(nx::MoveOnlyFunc&lt;void()&gt; handler) override\n    {\n        return m_target-&gt;post(std::move(handler));\n    }\n\n    virtual void dispatch(nx::MoveOnlyFunc&lt;void()&gt; handler) override\n    {\n        return m_target-&gt;dispatch(std::move(handler));\n    }\n\nprotected:\n    TargetType* m_target;\n};\n\ntemplate&lt;typename SocketInterfaceToImplement, typename TargetType&gt;\nclass CommunicatingSocketDelegate:\n    public SocketDelegate&lt;SocketInterfaceToImplement, TargetType&gt;\n{\n    static_assert(\n        std::is_base_of&lt;AbstractCommunicatingSocket, SocketInterfaceToImplement&gt;::value,\n        &quot;You MUST use class derived of AbstractCommunicatingSocket as a template argument&quot;);\n\n    using base_type = SocketDelegate&lt;SocketInterfaceToImplement, TargetType&gt;;\n\npublic:\n    CommunicatingSocketDelegate(TargetType* target):\n        base_type(target)\n    {\n    }\n\n    virtual bool connect(\n        const SocketAddress&amp; remoteSocketAddress,\n        std::chrono::milliseconds timeout) override\n    {\n        return this-&gt;m_target-&gt;connect(remoteSocketAddress, timeout);\n    }\n\n    virtual int recv(void* buffer, std::size_t bufferLen, int flags) override\n    {\n        return this-&gt;m_target-&gt;recv(buffer, bufferLen, flags);\n    }\n\n    virtual int send(const void* buffer, std::size_t bufferLen) override\n    {\n        return this-&gt;m_target-&gt;send(buffer, bufferLen);\n    }\n\n    virtual SocketAddress getForeignAddress() const override\n    {\n        return this-&gt;m_target-&gt;getForeignAddress();\n    }\n\n    virtual std::string getForeignHostName() const override\n    {\n        return this-&gt;m_target-&gt;getForeignHostName();\n    }\n\n    virtual bool isConnected() const override\n    {\n        return this-&gt;m_target-&gt;isConnected();\n    }\n\n    virtual void connectAsync(\n        const SocketAddress&amp; address,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) override\n    {\n        return this-&gt;m_target-&gt;connectAsync(address, std::move(handler));\n    }\n\n    virtual void readSomeAsync(\n        nx::Buffer* const buffer,\n        IoCompletionHandler handler) override\n    {\n        return this-&gt;m_target-&gt;readSomeAsync(buffer, std::move(handler));\n    }\n\n    /*\n     * Warning! Buffer should live at least till asynchronous send occurs, so\n     * do not use buffers with local scope here.\n     */\n    virtual void sendAsync(\n        const nx::Buffer* buffer,\n        IoCompletionHandler handler) override\n    {\n        return this-&gt;m_target-&gt;sendAsync(buffer, std::move(handler));\n    }\n\n    virtual void registerTimer(\n        std::chrono::milliseconds timeout,\n        nx::MoveOnlyFunc&lt;void()&gt; handler) override\n    {\n        return this-&gt;m_target-&gt;registerTimer(timeout, std::move(handler));\n    }\n\nprotected:\n    virtual void cancelIoInAioThread(nx::network::aio::EventType eventType) override\n    {\n        return this-&gt;m_target-&gt;cancelIOSync(eventType);\n    }\n};\n\n/**\n * Does not takes ownership.\n */\ntemplate&lt;typename SocketInterfaceToImplement, typename TargetType&gt;\nclass CustomStreamSocketDelegate:\n    public CommunicatingSocketDelegate&lt;SocketInterfaceToImplement, TargetType&gt;\n{\n    using base_type = CommunicatingSocketDelegate&lt;SocketInterfaceToImplement, TargetType&gt;;\n\npublic:\n    CustomStreamSocketDelegate(TargetType* target):\n        base_type(target)\n    {\n    }\n\n    virtual bool setNoDelay(bool value) override\n    {\n        return this-&gt;m_target-&gt;setNoDelay(value);\n    }\n\n    virtual bool getNoDelay(bool* value) const override\n    {\n        return this-&gt;m_target-&gt;getNoDelay(value);\n    }\n\n    virtual bool toggleStatisticsCollection(bool value) override\n    {\n        return this-&gt;m_target-&gt;toggleStatisticsCollection(value);\n    }\n\n    virtual bool getConnectionStatistics(StreamSocketInfo* info) override\n    {\n        return this-&gt;m_target-&gt;getConnectionStatistics(info);\n    }\n\n    virtual bool setKeepAlive(std::optional&lt; KeepAliveOptions &gt; info) override\n    {\n        return this-&gt;m_target-&gt;setKeepAlive(info);\n    }\n\n    virtual bool getKeepAlive(std::optional&lt; KeepAliveOptions &gt;* result) const override\n    {\n        return this-&gt;m_target-&gt;getKeepAlive(result);\n    }\n};\n\nclass NX_NETWORK_API StreamSocketDelegate:\n    public CustomStreamSocketDelegate&lt;AbstractStreamSocket, AbstractStreamSocket&gt;\n{\n    using base_type =\n        CustomStreamSocketDelegate&lt;AbstractStreamSocket, AbstractStreamSocket&gt;;\n\npublic:\n    StreamSocketDelegate(AbstractStreamSocket* target);\n};\n\nclass NX_NETWORK_API StreamServerSocketDelegate:\n    public SocketDelegate&lt;AbstractStreamServerSocket, AbstractStreamServerSocket&gt;\n{\n    using base_type = SocketDelegate&lt;AbstractStreamServerSocket, AbstractStreamServerSocket&gt;;\n\npublic:\n    StreamServerSocketDelegate(AbstractStreamServerSocket* target);\n\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n    virtual void pleaseStopSync() override;\n    virtual bool listen(int backlog = kDefaultBacklogSize) override;\n    virtual std::unique_ptr&lt;AbstractStreamSocket&gt; accept() override;\n    virtual void acceptAsync(AcceptCompletionHandler handler) override;\n\nprotected:\n    virtual void cancelIoInAioThread() override;\n};\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#ifdef ENABLE_SSL\n\n#include &lt;chrono&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &lt;openssl/ssl.h&gt;\n\n#include &lt;nx/network/socket_common.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/string.h&gt;\n\nnamespace nx::network::ssl {\n\n// https://cabforum.org/2017/03/17/ballot-193-825-day-certificate-lifetimes/\n// https://support.apple.com/en-us/HT211025\nconstexpr auto kCertMaxDuration = std::chrono::hours(24) * 397;\n\nconstexpr int kRsaLength = 2048;\n\nstruct X509Name\n{\n    /**\n     * map&lt;name, value&gt;.\n     * Typical fields:\n     * CN - common name\n     * C - country code\n     * O - organization\n     * OU - organization unit\n     */\n    std::map&lt;std::string, std::string&gt; attrs;\n\n    X509Name() = default;\n    X509Name(const struct X509_name_st* name);\n\n    X509Name(\n        const std::string&amp; commonName,\n        const std::string&amp; country,\n        const std::string&amp; organization,\n        const std::string&amp; organizationUnit = {})\n    {\n        attrs.emplace(SN_commonName, commonName);\n        attrs.emplace(SN_countryName, country);\n        attrs.emplace(SN_organizationName, organization);\n        if (!organizationUnit.empty())\n            attrs.emplace(SN_organizationalUnitName, organizationUnit);\n    }\n\n    std::string toString() const\n    {\n        return nx::utils::join(\n            attrs.begin(), attrs.end(), &quot;,&quot;,\n            [](const auto&amp; attr) { return nx::utils::buildString(attr.first, &quot;=&quot;, attr.second); });\n    }\n\n    bool operator==(const X509Name&amp; right) const\n    {\n        return attrs == right.attrs;\n    }\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X509Name&amp; issuer)\n{\n    os &lt;&lt; issuer.toString();\n    return os;\n}\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Non-owning certificate wrapper.\n */\nclass NX_NETWORK_API CertificateView\n{\npublic:\n    struct Extension\n    {\n        int nameId = NID_undef;\n        std::string value;\n        bool isCritical = false;\n\n        const char* name() const { return OBJ_nid2ln(nameId); }\n\n        bool operator==(const Extension&amp; rhs) const\n        {\n            return nameId == rhs.nameId &amp;&amp; value == rhs.value &amp;&amp; isCritical == rhs.isCritical;\n        }\n    };\n\n    struct NX_NETWORK_API KeyInformation\n    {\n        struct Rsa\n        {\n            std::vector&lt;uint8_t&gt; exponent;\n            int bits = 0;\n        };\n\n        int algorithmId = NID_undef;\n        std::vector&lt;uint8_t&gt; modulus;\n        std::optional&lt;Rsa&gt; rsa;\n\n        bool operator==(const KeyInformation&amp; rhs) const;\n\n        bool operator!=(const KeyInformation&amp; rhs) const\n        {\n            return !(*this == rhs);\n        }\n\n        const char* algorithm() const { return OBJ_nid2ln(algorithmId); }\n\n        bool parsePem(const std::string&amp; str);\n    };\n\n    CertificateView(X509* x509);\n\n    X509Name issuer() const;\n    long serialNumber() const;\n    std::chrono::system_clock::time_point notBefore() const;\n    std::chrono::system_clock::time_point notAfter() const;\n    int version() const; //&lt; Correct version is in the range [0:2].\n    X509Name subject() const;\n    std::vector&lt;uint8_t&gt; signature() const;\n    const char* signatureAlgorithm() const;\n    std::string publicKey() const;\n    KeyInformation publicKeyInformation() const;\n    std::vector&lt;Extension&gt; extensions() const;\n    std::set&lt;std::string&gt; hosts() const;\n\n    /**\n     * Generates user-readable text representation of the &quot;Subject Alternative Names&quot; extension of\n     * the certificate (same as openssl x509 -text).\n     */\n    std::string subjectAltNames() const;\n\n    std::vector&lt;unsigned char&gt; sha1() const;\n    std::vector&lt;unsigned char&gt; sha256() const;\n\n    /**\n     * Generates user-readable text representation of the certificate (same as openssl x509 -text).\n     */\n    std::string printedText() const;\n\n    X509* x509() const { return m_x509; }\n\nprivate:\n    X509* m_x509;\n};\n\nNX_NETWORK_API bool operator==(const CertificateView&amp; lhs, const CertificateView&amp; rhs);\n\n/**\n * Owning certificate wrapper.\n */\nclass NX_NETWORK_API Certificate: public CertificateView\n{\npublic:\n    using Extension = CertificateView::Extension;\n    using KeyInformation = CertificateView::KeyInformation;\n\n    Certificate(X509* x509 = nullptr);\n    explicit Certificate(const CertificateView&amp; view);\n\n    static std::vector&lt;Certificate&gt; parse(\n        const std::string&amp; pemString);\n\nprivate:\n    std::shared_ptr&lt;X509&gt; m_x509;\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Certificate&amp; cert)\n{\n    os &lt;&lt; &quot;Serial Number:\\n&quot; &lt;&lt;\n        &quot;    &quot; &lt;&lt; cert.serialNumber() &lt;&lt; &quot;\\n&quot;\n        &quot;Issuer: &quot; &lt;&lt; cert.issuer() &lt;&lt; &quot;\\n&quot;;\n    return os;\n}\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Wraps X.509 openssl certificate object.\n */\nclass NX_NETWORK_API X509Certificate\n{\npublic:\n    X509Certificate(X509* x509 = nullptr);\n    X509Certificate(const X509Certificate&amp; certificate);\n    X509Certificate&amp; operator=(const X509Certificate&amp; certificate);\n\n    /**\n     * @return true if certificate was parsed successfully.\n     * WARNING: This function reads only certificate from the pem, not the private key.\n     */\n    bool parsePem(\n        const std::string&amp; buf,\n        std::optional&lt;int&gt; maxChainLength = std::nullopt,\n        std::string* errorMessage = nullptr);\n\n    /**\n     * Validates the certificate against the current local time.\n     */\n    bool isValid(const std::chrono::seconds&amp; maxDuration = kCertMaxDuration) const;\n\n    /**\n     * @return (notAfter - notBefore). std::nullopt if certificate is invalid or does not have\n     * both dates.\n     */\n    std::optional&lt;std::chrono::seconds&gt; duration() const;\n\n    bool isSignedBy(const X509Name&amp; issuer) const;\n\n    bool bindToContext(SSL_CTX* sslContext, std::string* errorMessage = nullptr) const;\n\n    std::string toString() const;\n    std::string idForToStringFromPtr() const;\n    std::string pemString() const;\n    std::vector&lt;Certificate&gt; certificates() const;\n    std::set&lt;std::string&gt; hosts() const;\n    X509* x509() const;\n\n    /**\n     * Generates user-readable text representation of the &quot;Subject Alternative Names&quot; extension of\n     * the certificate (same as openssl x509 -text).\n     */\n    std::string subjectAltNames() const;\n\nprivate:\n    static std::string toString(const X509* x509);\n    static std::string toString(const ASN1_TIME* time);\n\nprivate:\n    using X509Ptr = std::unique_ptr&lt;X509, decltype(&amp;X509_free)&gt;;\n\n    X509Ptr m_x509;\n    std::vector&lt;X509Ptr&gt; m_extraChainCerts;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nusing PKeyPtr = std::unique_ptr&lt;EVP_PKEY, decltype(&amp;EVP_PKEY_free)&gt;;\n\n/**\n * Wraps PEM (X.509 certificate + private key)\n */\nclass NX_NETWORK_API Pem\n{\npublic:\n    Pem();\n    Pem(const Pem&amp; pem);\n    Pem&amp; operator=(const Pem&amp; pem);\n\n    bool parse(\n        const std::string&amp; str,\n        std::string* errorMessage = nullptr,\n        bool allowEcdsaCertificates = false);\n\n    bool bindToContext(SSL_CTX* sslContext, std::string* errorMessage = nullptr) const;\n\n    std::string toString() const;\n\n    X509Certificate&amp; certificate();\n    const X509Certificate&amp; certificate() const;\n\n    const PKeyPtr&amp; privateKey() const { return m_pkey; }\n\nprivate:\n    bool loadPrivateKey(\n        const std::string&amp; pem,\n        std::string* errorMessage = nullptr,\n        bool allowEcdsaCertificates = false);\n\nprivate:\n    X509Certificate m_certificate;\n    PKeyPtr m_pkey;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nstatic constexpr char kLocalhostCertificateAlternativeNames[] =\n    &quot;localhost, IP Address:127.0.0.1, IP Address:::1&quot;;\n\n/**\n * @param serialNumber If not specified then a random number is used.\n * @param hostName Specifies the list of hostnames and/or IP addresses, which will be included in\n *     the certificate as Subject Alternative Names. The string has the following format:\n *     name[, name, ..., name]\n *     where name must have one of the following formats:\n *         - &lt;host&gt; or DNS:&lt;host&gt; - DNS-name,\n *         - IP Address:&lt;ip&gt; - IPv4 or IPv6 address.\n * @return Certificate and private key in PEM format.\n */\nNX_NETWORK_API std::string makeCertificateAndKey(\n    const X509Name&amp; issuerAndSubject,\n    const std::string&amp; hostName = kLocalhostCertificateAlternativeNames,\n    std::optional&lt;long&gt; serialNumber = std::nullopt,\n    std::chrono::seconds notBeforeAdjust = std::chrono::seconds::zero(),\n    std::chrono::seconds notAfterAdjust = kCertMaxDuration);\n\nNX_NETWORK_API bool makeCertificateAndKeyFile(\n    const std::string&amp; filePath,\n    const X509Name&amp; issuerAndSubject,\n    const std::string&amp; hostName = kLocalhostCertificateAlternativeNames,\n    std::optional&lt;long&gt; serialNumber = std::nullopt,\n    std::chrono::seconds notBeforeAdjust = std::chrono::seconds::zero(),\n    std::chrono::seconds notAfterAdjust = kCertMaxDuration);\n\nNX_NETWORK_API PKeyPtr generateKey(int length = kRsaLength);\n\nNX_NETWORK_API bool generateKeyFiles(\n    const std::string&amp; privateKeyFileName,\n    const std::string&amp; publicKeyFileName,\n    int rsaKeyLength = kRsaLength);\n\nNX_NETWORK_API std::string makeCertificate(\n    const PKeyPtr&amp; privateKey,\n    const X509Name&amp; issuerAndSubject,\n    const std::string&amp; hostName,\n    std::optional&lt;long&gt; serialNumber = std::nullopt,\n    std::chrono::seconds notBeforeAdjust = std::chrono::seconds::zero(),\n    std::chrono::seconds notAfterAdjust = kCertMaxDuration);\n\nNX_NETWORK_API std::string makeCertificate(\n    const PKeyPtr&amp; keyPair,\n    const PKeyPtr&amp; signingKey,\n    const X509Name&amp; subject,\n    std::optional&lt;CertificateView&gt; issuerCertificate,\n    const std::string&amp; hostName,\n    std::optional&lt;long&gt; serialNumber = std::nullopt,\n    std::chrono::seconds notBeforeAdjust = std::chrono::seconds::zero(),\n    std::chrono::seconds notAfterAdjust = kCertMaxDuration,\n    std::optional&lt;bool&gt; isCa = std::nullopt);\n\n/**\n * If the certificate is valid and is generated by the issuer, then sets the certificate as default\n * and returns true. Otherwise returns false.\n */\nNX_NETWORK_API bool useCertificate(\n    const Pem&amp; pem,\n    const X509Name&amp; issuer,\n    const std::chrono::seconds&amp; maxDuration = kCertMaxDuration);\n\n/**\n * Loads certificate from filePath and sets it as default with\n * Context::instance()-&gt;setDefaultCertificate call.\n * If file is NOT found OR the certificate IS NOT valid OR generated by issuer AND expired,\n * then a new certificate is generated and written to filePath.\n * Optional argument certificate can be used for reading out the certificate that has been set.\n * @return true a valid certificate was read from filePath or a certificate was generated\n * and set as default one.\n */\nNX_NETWORK_API bool useOrCreateCertificate(\n    const std::string&amp; filePath,\n    const X509Name&amp; issuer,\n    const std::string&amp; hostName = kLocalhostCertificateAlternativeNames,\n    const std::chrono::seconds&amp; maxDuration = kCertMaxDuration,\n    std::string* certificate = nullptr);\n\n/**\n * Loads certificate from filePath and sets it as default.\n * @return true if a certificate was read from the file and was successfully set as the default one.\n */\nNX_NETWORK_API bool loadCertificateFromFile(const std::string&amp; filePath);\n\n/**\n * Generates certificate and sets it as default.\n */\nNX_NETWORK_API void useRandomCertificate(\n    const std::string&amp; module_,\n    const std::string&amp; hostName = kLocalhostCertificateAlternativeNames);\n\nNX_NETWORK_API std::optional&lt;Pem&gt; readPemFile(const std::string&amp; filePath);\n\nNX_NETWORK_API bool verifyBySystemCertificates(\n    STACK_OF(X509)* chain, const std::string&amp; hostName, std::string* outErrorMessage = nullptr);\n\nNX_NETWORK_API std::vector&lt;Certificate&gt; completeCertificateChain(\n    STACK_OF(X509)* chain, bool* ok = nullptr);\n\nNX_NETWORK_API void addTrustedRootCertificate(const CertificateView&amp; cert);\n\n} // namespace nx::network::ssl\n\n#endif // ENABLE_SSL\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/context.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/context.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/context.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#ifdef ENABLE_SSL\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;regex&gt;\n#include &lt;string_view&gt;\n\n#include &lt;openssl/ssl.h&gt;\n\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n#include &quot;certificate.h&quot;\n\nnamespace nx::network::ssl {\n\n/**\n * SSL context.\n * Carries data common for multiple SSL sockets. E.g., SSL certificates, the set of enabled\n * algorithms/ciphers and other things.\n * It is also responsible for providing appropriate certificate depending on the SNI extension.\n * See Context::configureVirtualHost for more details.\n * Different SSL sockets can have different contexts associated. See nx::network::ssl::StreamSocket.\n */\nclass NX_NETWORK_API Context\n{\npublic:\n    Context();\n    ~Context();\n\n    /**\n     * @return The default server context. It contains the default certificate\n     * (if set with setDefaultCertificate).\n     */\n    std::shared_ptr&lt;SSL_CTX&gt; defaultServerContext();\n\n    std::shared_ptr&lt;SSL_CTX&gt; clientContext();\n\n    const std::string_view&amp; sslSessionId();\n\n    /**\n     * Set default certificate for connections where a custom certificate was not specified\n     * using configureVirtualHost call.\n     * @return true If the certificate was parsed successfully. false if the certificate could not\n     * be loaded. Nothing changes in case of an error, the object state is not altered in any way.\n     *\n     * NOTE: If default certificate is not specified and no certificate set with configureVirtualHost\n     * was selected, TLS server rejects connections with SSL_TLSEXT_ERR_NOACK error code.\n     *\n     * NOTE: Default certificate may be changed. Connections accepted after this call will use the new\n     * certificate.\n     */\n    bool setDefaultCertificate(const std::string&amp; pem, bool allowEcdsaCertificates = false);\n\n    bool setDefaultCertificate(Pem pem, std::string* errorMessage = nullptr);\n\n    Pem getDefaultCertificate() const;\n\n    /**\n     * Set certificate to be used for connections with a SNI server name satisfying hostnameRegex.\n     * If such virtual host already exists then its certificate is replaced.\n     * @return false if the certificate is invalid.\n     * NOTE: Hostname regular expressions are sorted and verified in descending length order.\n     * NOTE: Virtual host&#x27;s certificate may be changed. Connections accepted after this call will\n     * use the new certificate.\n     */\n    bool configureVirtualHost(const std::string&amp; hostnameRegex, const std::string&amp; certDataPem);\n\n    /**\n     * Removes virtual host previously configured, that matches hostnameRegex.\n     * @return False if there is no virtual host to remove, true otherwise.\n     */\n    bool removeVirtualHost(const std::string&amp; hostnameRegex);\n\n    /**\n     * @param versions List of SSL/TLS protocols separated by |.\n     * The protocol name has the following format:\n     * &quot;tls&quot;|&quot;ssl&quot; [v] major_version &quot;_&quot; minor_version.\n     * Example: sslv3|tls1_1|tls1_2.\n     * By default, TLS 1.1+ are enabled.\n     * @return true if protocol versions have been applied. false if versions is not valid.\n     */\n    bool setAllowedServerVersions(const std::string&amp; versions);\n\n    /**\n     * Set allowed cipher list for TLSv1.2 and below.\n     * @param ciphers Passed directly to SSL_CTX_set_cipher_list function.\n     * For the format description see SSL_CTX_set_cipher_list docs.\n     * @return true if protocol ciphers have been applied. false if not valid.\n     */\n    bool setAllowedServerCiphers(const std::string&amp; ciphers);\n\n    /**\n     * Applies appropriate configuration to SSL connection.\n     * This includes but not limited to: enabled server protocols, protocol ciphers.\n     * MUST be invoked just after instantiation of SSL type.\n     */\n    void configure(SSL* ssl);\n\n    /**\n     * @return Static instance of the Context. This is used by SSL sockets by default.\n     */\n    static Context* instance();\n\nprivate:\n    std::shared_ptr&lt;SSL_CTX&gt; createServerContext();\n\n    static int chooseSslContextForIncomingConnectionStatic(SSL* s, int* al, void* arg);\n    int chooseSslContextForIncomingConnection(SSL* s, int* al);\n\n    bool bindCertificateToSslContext(\n        SSL_CTX* sslContext,\n        const std::string&amp; pem);\n\n    bool x509load(SSL_CTX* sslContext, const std::string&amp; pem);\n    bool pKeyLoad(SSL_CTX* sslContext, const std::string&amp; pem);\n\nprivate:\n    struct VirtualHostContext\n    {\n        std::regex hostnameRegex;\n        std::shared_ptr&lt;SSL_CTX&gt; sslContext;\n    };\n\n    struct HostnameRegexComparator\n    {\n        bool operator()(const std::string&amp; left, const std::string&amp; right) const\n        {\n            return left.size() != right.size()\n                ? left.size() &gt; right.size()\n                : left &lt; right;\n        }\n    };\n\n    std::shared_ptr&lt;SSL_CTX&gt; m_defaultServerContext;\n    std::shared_ptr&lt;SSL_CTX&gt; m_clientContext;\n    Pem m_defaultServerPem;\n    mutable nx::Mutex m_mutex;\n    std::map&lt;\n        std::string /*hostname regexp*/, VirtualHostContext,\n        HostnameRegexComparator\n    &gt; m_virtualHosts;\n\n    std::atomic&lt;int&gt; m_disabledServerVersions = 0;\n    std::string m_allowedServerCiphers;\n};\n\n} // namespace nx::network::ssl\n\n#endif // ENABLE_SSL\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_pipeline.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_pipeline.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_pipeline.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include &lt;openssl/ssl.h&gt;\n\n#include &lt;nx/utils/byte_stream/pipeline.h&gt;\n#include &lt;nx/utils/move_only_func.h&gt;\n\n#include &quot;certificate.h&quot;\n#include &quot;helpers.h&quot;\n\nnamespace nx::network::aio { class BasicPollable; }\n\nnamespace nx::network::ssl {\n\nclass Context;\nclass Pipeline;\n\n/**\n * Type of function being called on synchronous certificate chain verification.\n * @param chain The chain that must be verified.\n * @return true if the chain has been verified, false otherwise.\n */\nusing VerifyCertificateChainCallback = nx::MoveOnlyFunc&lt;\n    bool(CertificateChainView /*chain*/)&gt;;\n\n/**\n * NOTE: Not thread-safe.\n */\nclass NX_NETWORK_API Pipeline:\n    public nx::utils::bstream::Converter\n{\npublic:\n    /**\n     * @param context\n     * @param sslContext Caller may use different contexts on client &amp; server sides.\n     * TODO: #akolesnikov remove sslContext\n     */\n    Pipeline(\n        Context* context,\n        std::shared_ptr&lt;SSL_CTX&gt; sslContext);\n\n    ~Pipeline() = default;\n\n    /**\n     * If not empty, ClientHello will contain &quot;servername&quot; attribute.\n     */\n    void setServerName(const std::string&amp; serverName);\n\n    std::string serverNameFromClientHello() const;\n\n    /**\n     * NOTE: SSL pipeline does not recover from any I/O error because openssl supports\n     * retrying write only with the same data. That does not conform to\n     * nx::utils::bstream::AbstractOutput.\n     * So, even after wouldBlock write error, next write will always produce non-recoverable\n     * failure. Though, it conforms to nx::utils::bstream::AbstractOutput.\n     */\n    virtual int write(const void* data, size_t size) override;\n    virtual int read(void* data, size_t size) override;\n\n    virtual bool eof() const override;\n    virtual bool failed() const override;\n\n    bool performHandshake();\n    bool isHandshakeCompleted() const;\n\n    bool isReadThirsty() const;\n    bool isWriteThirsty() const;\n\n    void shutdown();\n\n    void setFailed(bool val);\n    void setVerifyCertificateChainCallback(VerifyCertificateChainCallback func);\n\n    /**\n     * Blocks any I/O with user data. It means read() and write() functions will return wouldBlock\n     * even if some data is available. User I/O can only be paused after the handshake is done.\n     * If it&#x27;s already done, completionHandler will be called immediately. Otherwise, it will be\n     * called upon completion of the handshake.\n     * Note that:\n     *     - function can be invoked concurrently with I/O\n     *     - completionHandler will be invoked in the context of the I/O thread, which drives\n     *         its I/O\n     *     - completionHandler may never be called if the handshake fails or if\n     *         resumeDataProcessing() was invoked just after pauseDataProcessingAfterHandshake().\n     */\n    void pauseDataProcessingAfterHandshake(nx::MoveOnlyFunc&lt;void()&gt; completionHandler);\n\n    /**\n     * Resumes previously paused user I/O. I/O can be resumed even if it wasn&#x27;t fully paused,\n     * i.e. completionHandler of pauseDataProcessingAfterHandshake() is not called yet. In this\n     * case, the callback will be never called and will be destroyed by this function.\n     */\n    void resumeDataProcessing();\n\nprotected:\n    SSL* ssl();\n\nprivate:\n    enum class State\n    {\n        init,\n        handshakeDone,\n    };\n\n    Context* m_context = nullptr;\n    State m_state = State::init;\n    std::unique_ptr&lt;BIO_METHOD, decltype(&amp;BIO_meth_free)&gt; m_bioMethods;\n    std::unique_ptr&lt;SSL, decltype(&amp;SSL_free)&gt; m_ssl;\n    bool m_readThirsty = false;\n    bool m_writeThirsty = false;\n    bool m_eof = false;\n    bool m_failed = false;\n    VerifyCertificateChainCallback m_verifyCertificateChainCallback;\n    std::atomic&lt;bool&gt; m_isPausePending = false;\n    std::atomic&lt;bool&gt; m_isPaused = false;\n    nx::MoveOnlyFunc&lt;void()&gt; m_onIoPausedAfterHandshake;\n\n    void initSslBio(std::shared_ptr&lt;SSL_CTX&gt; sslContext);\n\n    template&lt;typename Func, typename Data&gt;\n    int performSslIoOperation(Func sslFunc, Data* data, size_t size);\n    int performHandshakeInternal();\n    int bioRead(void* buffer, unsigned int bufferLen);\n    int bioWrite(const void* buffer, unsigned int bufferLen);\n\n    int handleSslIoResult(int result);\n    std::string sslErrorCodeToString(int errorCode);\n    void analyzeSslErrorQueue(bool* fatalErrorFound);\n\n    static int bioRead(BIO* b, char* out, int outl);\n    static int bioWrite(BIO* b, const char* in, int inl);\n    static int bioPuts(BIO* bio, const char* str);\n    static long bioCtrl(BIO* bio, int cmd, long num, void* /*ptr*/);\n    static int bioNew(BIO* bio);\n    static int bioFree(BIO* bio);\n    static int verifyServerCertificateCallback(int preverify_ok, X509_STORE_CTX* x509_ctx);\n    static int verifyServerChainCallback(X509_STORE_CTX* x509_ctx);\n\n    /** SSL_allow_early_data_cb_fn. */\n    static int verifyEarlyData(SSL* s, void* arg);\n};\n\nclass NX_NETWORK_API ConnectingPipeline:\n    public Pipeline\n{\npublic:\n    /**\n     * @param context If null, global context (Context::instance()) is used.\n     */\n    ConnectingPipeline(Context* context = nullptr);\n};\n\nclass NX_NETWORK_API AcceptingPipeline:\n    public Pipeline\n{\npublic:\n    /**\n     * @param context If null, global context (Context::instance()) is used.\n     */\n    AcceptingPipeline(Context* context = nullptr);\n};\n\n} // namespace nx::network::ssl\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_server_socket.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_server_socket.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_server_socket.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;nx/network/aio/timer.h&gt;\n\n#include &quot;../custom_handshake_connection_acceptor.h&quot;\n#include &quot;../socket_delegate.h&quot;\n\nnamespace nx {\nnamespace network {\nnamespace ssl {\n\nclass Context;\n\nnamespace detail {\n\nclass NX_NETWORK_API AbstractAcceptedSslStreamSocketWrapper:\n    public CustomStreamSocketDelegate&lt;AbstractEncryptedStreamSocket, AbstractStreamSocket&gt;\n{\n    using base_type =\n        CustomStreamSocketDelegate&lt;AbstractEncryptedStreamSocket, AbstractStreamSocket&gt;;\n\npublic:\n    template&lt;typename ...Args&gt;\n    AbstractAcceptedSslStreamSocketWrapper(Args... args):\n        base_type(std::move(args)...)\n    {\n    }\n};\n\n} // namespace detail\n\n//-------------------------------------------------------------------------------------------------\n\nenum class EncryptionUse\n{\n    always,\n    autoDetectByReceivedData,\n    never,\n};\n\n/**\n * NOTE: Provides connections that have already completed SSL handshake.\n *   So, Accepting TCP connections and performing SSL handshake is done\n *   right after StreamServerSocket::listen call.\n */\nclass NX_NETWORK_API StreamServerSocket:\n    public StreamServerSocketDelegate\n{\n    using base_type = StreamServerSocketDelegate;\n\npublic:\n    StreamServerSocket(\n        Context* context,\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; delegate,\n        EncryptionUse encryptionUse);\n\n    ~StreamServerSocket();\n\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; completionHandler) override;\n    virtual void pleaseStopSync() override;\n\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) override;\n\n    virtual bool setNonBlockingMode(bool value) override;\n    virtual bool getNonBlockingMode(bool* value) const override;\n\n    virtual bool listen(int backlog = kDefaultBacklogSize) override;\n    virtual void acceptAsync(AcceptCompletionHandler handler) override;\n    virtual std::unique_ptr&lt;AbstractStreamSocket&gt; accept() override;\n\nprotected:\n    virtual void cancelIoInAioThread() override;\n\nprivate:\n    using Acceptor = CustomHandshakeConnectionAcceptor&lt;\n        AbstractStreamServerSocket,\n        detail::AbstractAcceptedSslStreamSocketWrapper&gt;;\n\n    Context* m_context = nullptr;\n    Acceptor m_acceptor;\n    aio::Timer m_timer;\n    EncryptionUse m_encryptionUse;\n    AcceptCompletionHandler m_userHandler;\n    bool m_nonBlockingModeEnabled = false;\n\n    std::unique_ptr&lt;detail::AbstractAcceptedSslStreamSocketWrapper&gt; createSocketWrapper(\n        std::unique_ptr&lt;AbstractStreamSocket&gt; delegate);\n\n    std::unique_ptr&lt;AbstractStreamSocket&gt; acceptNonBlocking();\n    std::unique_ptr&lt;AbstractStreamSocket&gt; acceptBlocking();\n\n    void acceptAsyncInternal(AcceptCompletionHandler handler);\n\n    void startTimer(std::chrono::milliseconds timeout);\n\n    void onAccepted(\n        SystemError::ErrorCode systemErrorCode,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; connection);\n\n    void stopWhileInAioThread();\n};\n\n} // namespace ssl\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;thread&gt;\n#include &lt;variant&gt;\n\n#include &lt;nx/utils/async_operation_guard.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\n#include &quot;../aio/stream_transforming_async_channel.h&quot;\n#include &quot;../aio/timer.h&quot;\n#include &quot;../socket_delegate.h&quot;\n#include &quot;helpers.h&quot;\n#include &quot;ssl_pipeline.h&quot;\n\nnamespace nx::network::ssl {\n\nclass Context;\n\nnamespace detail {\n\nclass NX_NETWORK_API StreamSocketToTwoWayPipelineAdapter:\n    public nx::utils::bstream::AbstractInput,\n    public nx::utils::bstream::AbstractOutput\n{\npublic:\n    StreamSocketToTwoWayPipelineAdapter(\n        AbstractStreamSocket* streamSocket,\n        aio::StreamTransformingAsyncChannel* asyncSslChannel);\n    virtual ~StreamSocketToTwoWayPipelineAdapter() override;\n\n    virtual int read(void* data, size_t count) override;\n    virtual int write(const void* data, size_t count) override;\n\n    void setFlagsForCallsInThread(std::thread::id threadId, int flags);\n\nprivate:\n    AbstractStreamSocket* m_streamSocket = nullptr;\n    aio::StreamTransformingAsyncChannel* m_asyncSslChannel = nullptr;\n    mutable nx::Mutex m_mutex;\n    std::map&lt;std::thread::id, int&gt; m_threadIdToFlags;\n\n    int bytesTransferredToPipelineReturnCode(int bytesTransferred);\n    int getFlagsForCurrentThread() const;\n};\n\n} // namespace detail\n\n//-------------------------------------------------------------------------------------------------\n\nclass StreamSocket;\n\n/**\n * Type of function being called on synchronous certificate chain verification.\n * @param chain The chain that must be verified.\n * @param socket The socket that wants to verify a certificate.\n * @return true if the chain has been verified, false otherwise.\n */\nusing VerifyCertificateChainCallbackSync = nx::MoveOnlyFunc&lt;\n    bool(CertificateChainView /*chain*/, StreamSocket* /*socket*/)&gt;;\n\n/**\n * Type of function being called on the completion of asynchronous certificate chain verification.\n * @param result The result of the verification.\n */\nusing VerifyCertificateCallbackAsyncCompletionHandler =\n    nx::MoveOnlyFunc&lt;void(bool /*result*/)&gt;;\n\n/**\n * Type of the function being called on asynchronous certificate chain verification start.\n * @param chain The chain that must be verified.\n * @param socket The socket that wants to verify a certificate.\n * @param completionHandler The callback function which is called on completion.\n */\nusing VerifyCertificateChainCallbackAsync = nx::MoveOnlyFunc&lt;\n    void(\n        CertificateChainView /*chain*/,\n        StreamSocket* /*socket*/,\n        VerifyCertificateCallbackAsyncCompletionHandler /*completionHandler*/)&gt;;\n\nNX_NETWORK_API extern const std::function&lt;\n    bool(CertificateChainView /*chain*/,\n        StreamSocket* /*socket*/)&gt; kDefaultCertificateCheckCallback;\n\nNX_NETWORK_API extern const std::function&lt;\n    bool(CertificateChainView /*chain*/, StreamSocket* /*socket*/)&gt; kAcceptAnyCertificateCallback;\n\nclass NX_NETWORK_API StreamSocket:\n    public CustomStreamSocketDelegate&lt;AbstractEncryptedStreamSocket, AbstractStreamSocket&gt;\n{\n    using base_type =\n        CustomStreamSocketDelegate&lt;AbstractEncryptedStreamSocket, AbstractStreamSocket&gt;;\n\npublic:\n    StreamSocket(\n        Context* context,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; delegate,\n        bool isServerSide,  //&lt; TODO: #akolesnikov Get rid of this argument.\n        VerifyCertificateChainCallbackSync verifyChainCallback);\n\n    virtual ~StreamSocket() override;\n\n    StreamSocket(const StreamSocket&amp;) = delete;\n    StreamSocket&amp; operator=(const StreamSocket&amp;) = delete;\n\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n    virtual void pleaseStopSync() override;\n\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override;\n\n    virtual bool connect(\n        const SocketAddress&amp; remoteSocketAddress,\n        std::chrono::milliseconds timeout) override;\n\n    virtual void connectAsync(\n        const SocketAddress&amp; address,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) override;\n\n    virtual int recv(void* buffer, std::size_t bufferLen, int flags = 0) override;\n\n    virtual int send(const void* buffer, std::size_t bufferLen) override;\n\n    virtual void readSomeAsync(\n        nx::Buffer* const buffer,\n        IoCompletionHandler handler) override;\n\n    virtual void sendAsync(\n        const nx::Buffer* buffer,\n        IoCompletionHandler handler) override;\n\n    virtual bool isConnected() const override;\n\n    virtual bool isEncryptionEnabled() const override;\n\n    virtual void handshakeAsync(\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) override;\n\n    virtual std::string serverName() const override;\n\n    void setSyncVerifyCertificateChainCallback(VerifyCertificateChainCallbackSync func);\n    void setAsyncVerifyCertificateChainCallback(VerifyCertificateChainCallbackAsync func);\n    void setServerName(const std::string&amp; serverName);\n\nprotected:\n    virtual void cancelIoInAioThread(nx::network::aio::EventType eventType) override;\n\nprivate:\n    std::unique_ptr&lt;aio::StreamTransformingAsyncChannel&gt; m_asyncTransformingChannel;\n    std::unique_ptr&lt;AbstractStreamSocket&gt; m_delegate;\n    std::unique_ptr&lt;ssl::Pipeline&gt; m_sslPipeline;\n    std::unique_ptr&lt;detail::StreamSocketToTwoWayPipelineAdapter&gt; m_socketToPipelineAdapter;\n    nx::utils::bstream::ProxyConverter m_proxyConverter;\n    nx::Buffer m_emptyBuffer;\n    aio::Timer m_handshakeTimer;\n    nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; m_handshakeHandler;\n    std::optional&lt;unsigned int&gt; m_recvTimeoutBak;\n    std::optional&lt;unsigned int&gt; m_sendTimeoutBak;\n    std::optional&lt;std::string&gt; m_serverName;\n    std::variant&lt;VerifyCertificateChainCallbackSync,\n        VerifyCertificateChainCallbackAsync&gt; m_verifyCertificateChainCallback;\n    nx::utils::AsyncOperationGuard m_asyncOperationGuard;\n\n    void startHandshakeTimer(std::chrono::milliseconds timout);\n    void doHandshake();\n\n    // TODO: #akolesnikov Make it virtual override after inheriting AbtractStreamSocket from aio::BasicPollable.\n    void stopWhileInAioThread();\n    void switchToSyncModeIfNeeded();\n    void switchToAsyncModeIfNeeded();\n\n    void handleSslError(int sslPipelineResultCode);\n\n    bool saveTimeouts();\n    bool restoreTimeouts();\n\n    template&lt;typename T&gt;\n    void setVerifyCertificateChainCallback(\n        T&amp;&amp; func,\n        bool (StreamSocket::*method)(CertificateChainView));\n\n    bool syncVerifyCertificateChainCallbackHandler(\n        CertificateChainView chain);\n\n    bool asyncVerifyCertificateChainCallbackHandler(\n        CertificateChainView chain);\n};\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_NETWORK_API ClientStreamSocket:\n    public StreamSocket\n{\n    using base_type = StreamSocket;\n\npublic:\n    ClientStreamSocket(\n        Context* context,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; delegate,\n        VerifyCertificateChainCallbackSync verifyChainCallback);\n};\n\nclass NX_NETWORK_API ServerSideStreamSocket:\n    public StreamSocket\n{\n    using base_type = StreamSocket;\n\npublic:\n    ServerSideStreamSocket(\n        Context* context,\n        std::unique_ptr&lt;AbstractStreamSocket&gt; delegate);\n};\n\n} // namespace nx::network::ssl\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/system_socket.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/system_socket.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/system_socket.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n// This header includes &lt;windows.h&gt; and _must_ be included before everything\n#include &lt;nx/utils/system_network_headers.h&gt;\n/////////////////////////////////////////////////////////////////////////////////////////\n\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#ifndef _WIN32\n    #include &lt;netinet/in.h&gt;\n    #include &lt;sys/socket.h&gt;\n    #include &lt;sys/types.h&gt;\n#endif\n\n#include &lt;nx/utils/access_tracker.h&gt;\n#include &lt;nx/utils/system_error.h&gt;\n\n#include &quot;abstract_socket.h&quot;\n#include &quot;aio/pollable.h&quot;\n#include &quot;nettools.h&quot;\n#include &quot;socket_factory.h&quot;\n#include &quot;system_socket_address.h&quot;\n\nnamespace nx {\nnamespace network {\n\nclass CommonSocketImpl;\n\nnamespace aio {\ntemplate&lt;class SocketType&gt; class BaseAsyncSocketImplHelper;\ntemplate&lt;class SocketType&gt; class AsyncSocketImplHelper;\nclass AIOService;\n} // namespace aio\n\n#ifdef _WIN32\ntypedef int socklen_t;\n#endif\n\n/**\n * Implements AbstractSocket class on top of OS socket API.\n */\ntemplate&lt;typename SocketInterfaceToImplement&gt;\nclass NX_NETWORK_API Socket:\n    public SocketInterfaceToImplement,\n    public nx::network::Pollable\n{\n    static_assert(\n        std::is_base_of&lt;AbstractSocket, SocketInterfaceToImplement&gt;::value,\n        &quot;You MUST use class derived of AbstractSocket as a template argument&quot;);\n\npublic:\n    Socket(\n        aio::AbstractAioThread* aioThread,\n        int type,\n        int protocol,\n        int ipVersion,\n        std::unique_ptr&lt;CommonSocketImpl&gt; impl);\n\n    Socket(\n        aio::AbstractAioThread* aioThread,\n        int sockDesc,\n        int ipVersion,\n        std::unique_ptr&lt;CommonSocketImpl&gt; impl);\n\n    Socket(const Socket&amp;) = delete;\n    Socket&amp; operator=(const Socket&amp;) = delete;\n    Socket(Socket&amp;&amp;) = delete;\n    Socket&amp; operator=(Socket&amp;&amp;) = delete;\n    virtual ~Socket();\n\n    virtual bool getLastError(SystemError::ErrorCode* errorCode) const override;\n\n    virtual AbstractSocket::SOCKET_HANDLE handle() const override;\n    virtual bool getRecvTimeout(unsigned int* millis) const override;\n    virtual bool getSendTimeout(unsigned int* millis) const override;\n    virtual nx::network::aio::AbstractAioThread* getAioThread() const override;\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) override;\n    virtual bool isInSelfAioThread() const override;\n\n    virtual bool bind(const SocketAddress&amp; localAddress) override;\n    virtual SocketAddress getLocalAddress() const override;\n    virtual bool close() override;\n    virtual bool shutdown() override;\n\n    virtual bool isClosed() const override;\n    virtual bool setReuseAddrFlag(bool reuseAddr) override;\n    virtual bool getReuseAddrFlag(bool* val) const override;\n    virtual bool setReusePortFlag(bool value) override;\n    virtual bool getReusePortFlag(bool* value) const override;\n    virtual bool setNonBlockingMode(bool val) override;\n    virtual bool getNonBlockingMode(bool* val) const override;\n    virtual bool getMtu(unsigned int* mtuValue) const override;\n    virtual bool setSendBufferSize(unsigned int buffSize) override;\n    virtual bool getSendBufferSize(unsigned int* buffSize) const override;\n    virtual bool setRecvBufferSize(unsigned int buffSize) override;\n    virtual bool getRecvBufferSize(unsigned int* buffSize) const override;\n    virtual bool setRecvTimeout(unsigned int ms) override;\n    virtual bool setSendTimeout(unsigned int ms) override;\n    virtual bool setIpv6Only(bool val) override;\n\n    virtual Pollable* pollable() override;\n    virtual void post(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n    virtual void dispatch(nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n\n    bool createSocket(int type, int protocol);\n\nprotected:\n    const int m_ipVersion;\n\nprivate:\n    bool m_nonBlockingMode = false;\n};\n\n/**\n * Socket that is able to connect, send, and receive.\n */\ntemplate&lt;class SocketInterfaceToImplement&gt;\nclass NX_NETWORK_API CommunicatingSocket:\n    public Socket&lt;SocketInterfaceToImplement&gt;\n{\n    static_assert(\n        std::is_base_of&lt;AbstractCommunicatingSocket, SocketInterfaceToImplement&gt;::value,\n        &quot;You MUST use class derived of AbstractCommunicatingSocket as a template argument&quot;);\n\n    using base_type = Socket&lt;SocketInterfaceToImplement&gt;;\n    using self_type = CommunicatingSocket&lt;SocketInterfaceToImplement&gt;;\n\npublic:\n    CommunicatingSocket(\n        aio::AbstractAioThread* aioThread,\n        int type,\n        int protocol,\n        int ipVersion);\n\n    CommunicatingSocket(\n        aio::AbstractAioThread* aioThread,\n        int type,\n        int protocol,\n        int ipVersion,\n        std::unique_ptr&lt;CommonSocketImpl&gt; sockImpl);\n\n    CommunicatingSocket(\n        aio::AbstractAioThread* aioThread,\n        int newConnSD,\n        int ipVersion);\n\n    CommunicatingSocket(\n        aio::AbstractAioThread* aioThread,\n        int newConnSD,\n        int ipVersion,\n        std::unique_ptr&lt;CommonSocketImpl&gt; sockImpl);\n\n    virtual ~CommunicatingSocket();\n\n    virtual void bindToAioThread(nx::network::aio::AbstractAioThread* aioThread) override;\n\n    virtual bool connect(\n        const SocketAddress&amp; remoteAddress,\n        std::chrono::milliseconds timeout) override;\n\n    virtual void connectAsync(\n        const SocketAddress&amp; addr,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode)&gt; handler) override;\n\n    virtual bool isConnected() const override;\n\n    virtual int recv(void* buffer, std::size_t bufferLen, int flags) override;\n    virtual int send(const void* buffer, std::size_t bufferLen) override;\n    virtual SocketAddress getForeignAddress() const override;\n\n    virtual void readSomeAsync(\n        nx::Buffer* const buf,\n        IoCompletionHandler handler) override;\n\n    virtual void sendAsync(\n        const nx::Buffer* buf,\n        IoCompletionHandler handler) override;\n\n    virtual void registerTimer(\n        std::chrono::milliseconds timeoutMs,\n        nx::MoveOnlyFunc&lt;void()&gt; handler) override;\n\n    virtual bool close() override;\n    virtual bool shutdown() override;\n\nprotected:\n    virtual void cancelIoInAioThread(nx::network::aio::EventType eventType) override;\n\nprotected:\n    std::unique_ptr&lt;aio::AsyncSocketImplHelper&lt;self_type&gt;&gt; m_aioHelper;\n    bool m_connected;\n\nprivate:\n    bool connectToIp(\n        const SocketAddress&amp; remoteAddress,\n        std::chrono::milliseconds timeout);\n};\n\n/**\n * Client tcp socket.\n */\nclass NX_NETWORK_API TCPSocket:\n    public CommunicatingSocket&lt;AbstractStreamSocket&gt;\n{\n    typedef CommunicatingSocket&lt;AbstractStreamSocket&gt; base_type;\n\npublic:\n    explicit TCPSocket(int ipVersion = AF_INET);\n    virtual ~TCPSocket();\n\n    TCPSocket(const TCPSocket&amp;) = delete;\n    TCPSocket&amp; operator=(const TCPSocket&amp;) = delete;\n    TCPSocket(TCPSocket&amp;&amp;) = delete;\n    TCPSocket&amp; operator=(TCPSocket&amp;&amp;) = delete;\n\n    virtual bool getProtocol(int* protocol) const override;\n    virtual bool setNoDelay(bool value) override;\n    virtual bool getNoDelay(bool* value) const override;\n    virtual bool toggleStatisticsCollection(bool val) override;\n    virtual bool getConnectionStatistics(StreamSocketInfo* info) override;\n    virtual bool setKeepAlive(std::optional&lt; KeepAliveOptions &gt; info) override;\n    virtual bool getKeepAlive(std::optional&lt; KeepAliveOptions &gt;* result) const override;\n\n    bool reopen();\n\nprivate:\n    friend class TCPServerSocketPrivate;\n\n    #if defined(_WIN32)\n        KeepAliveOptions m_keepAlive;\n    #endif\n\n    /** Used by TCPServerSocket class. */\n    TCPSocket(\n        aio::AbstractAioThread* aioThread,\n        int newConnSD,\n        int ipVersion);\n};\n\nclass NX_NETWORK_API TCPServerSocket:\n    public Socket&lt;AbstractStreamServerSocket&gt;\n{\n    typedef Socket&lt;AbstractStreamServerSocket&gt; base_type;\n\npublic:\n    explicit TCPServerSocket(int ipVersion = AF_INET);\n    ~TCPServerSocket();\n\n    TCPServerSocket(const TCPServerSocket&amp;) = delete;\n    TCPServerSocket&amp; operator=(const TCPServerSocket&amp;) = delete;\n    TCPServerSocket(TCPServerSocket&amp;&amp;) = delete;\n    TCPServerSocket&amp; operator=(TCPServerSocket&amp;&amp;) = delete;\n\n    virtual void bindToAioThread(aio::AbstractAioThread* aioThread) override;\n\n    /**\n     * Blocks until a new connection is established on this socket or error.\n     * @return new connection socket.\n     */\n    static int accept(int sockDesc);\n\n    virtual bool getProtocol(int* protocol) const override;\n\n    virtual bool listen(int queueLen = AbstractStreamServerSocket::kDefaultBacklogSize) override;\n    virtual std::unique_ptr&lt;AbstractStreamSocket&gt; accept() override;\n    virtual void pleaseStop(nx::MoveOnlyFunc&lt; void() &gt; handler) override;\n    virtual void pleaseStopSync() override;\n\n    virtual void acceptAsync(AcceptCompletionHandler handler) override;\n\n    std::unique_ptr&lt;AbstractStreamSocket&gt; systemAccept();\n\nprotected:\n    virtual void cancelIoInAioThread() override;\n\nprivate:\n    bool setListen(int queueLen);\n    void stopWhileInAioThread();\n};\n\nclass NX_NETWORK_API UDPSocket:\n    public CommunicatingSocket&lt;AbstractDatagramSocket&gt;\n{\n    typedef CommunicatingSocket&lt;AbstractDatagramSocket&gt; base_type;\n\npublic:\n    static const unsigned int MAX_IP_DATAGRAM_LENGTH = 64 * 1024;\n    static const unsigned int IP_HEADER_MAX_LENGTH = 24;\n    static const unsigned int UDP_HEADER_LENGTH = 8;\n    static const unsigned int MAX_PACKET_SIZE =\n        MAX_IP_DATAGRAM_LENGTH - IP_HEADER_MAX_LENGTH - UDP_HEADER_LENGTH;\n\n    explicit UDPSocket(int ipVersion = AF_INET);\n    virtual ~UDPSocket() override;\n    UDPSocket(const UDPSocket&amp;) = delete;\n    UDPSocket&amp; operator=(const UDPSocket&amp;) = delete;\n    UDPSocket(UDPSocket&amp;&amp;) = delete;\n    UDPSocket&amp; operator=(UDPSocket&amp;&amp;) = delete;\n\n    virtual bool getProtocol(int* protocol) const override;\n\n    virtual SocketAddress getForeignAddress() const override;\n\n    /**\n     * Send the given buffer as a UDP datagram to the specified address/port.\n     * @param buffer buffer to be written.\n     * @param bufferLen number of bytes to write.\n     * @param foreignAddress address (IP address or name) to send to.\n     * @param foreignPort port number to send to.\n     * @return true if send is successful.\n     */\n    bool sendTo(const void *buffer, int bufferLen);\n\n    /**\n     * Set the multicast TTL.\n     * @param multicastTTL multicast TTL.\n     */\n    bool setMulticastTTL(unsigned char multicastTTL) ;\n\n    virtual bool joinGroup(const HostAddress&amp; multicastGroup) override;\n    virtual bool joinGroup(const HostAddress&amp; multicastGroup, const HostAddress&amp; multicastIF) override;\n\n    virtual bool leaveGroup(const HostAddress&amp; multicastGroup) override;\n    virtual bool leaveGroup(const HostAddress&amp; multicastGroup, const HostAddress&amp; multicastIF) override;\n\n    virtual int send( const void* buffer, std::size_t bufferLen ) override;\n\n    virtual bool setDestAddr( const SocketAddress&amp; foreignEndpoint ) override;\n\n    virtual bool sendTo(\n        const void* buffer,\n        std::size_t bufferLen,\n        const SocketAddress&amp; foreignEndpoint ) override;\n\n    virtual void sendToAsync(\n        const nx::Buffer* buf,\n        const SocketAddress&amp; foreignAddress,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode, SocketAddress, size_t)&gt; completionHandler) override;\n\n    /**\n     * Actually calls UDPSocket::recvFrom and makes datagram source address/port\n     *   available through UDPSocket::lastDatagramSourceAddress.\n     */\n    virtual int recv( void* buffer, std::size_t bufferLen, int flags ) override;\n\n    virtual int recvFrom(\n        void* buffer,\n        std::size_t bufferLen,\n        SocketAddress* const sourceAddress ) override;\n\n    virtual void recvFromAsync(\n        nx::Buffer* const buf,\n        nx::MoveOnlyFunc&lt;void(SystemError::ErrorCode, SocketAddress, size_t)&gt; handler) override;\n\n    virtual SocketAddress lastDatagramSourceAddress() const override;\n    virtual bool hasData() const override;\n    /**\n     * Sets the multicast send interface.\n     * @param multicastIF multicast interface for sending packets.\n     */\n    virtual bool setMulticastIF( const std::string&amp; multicastIF ) override;\n\nprivate:\n    SystemSocketAddress m_destAddr;\n    SocketAddress m_prevDatagramAddress;\n\n    void setBroadcast();\n    /**\n     * @param sourcePort Port is returned in host byte order.\n     */\n    int recvFrom(\n        void* buffer,\n        std::size_t bufferLen,\n        HostAddress* const sourceAddress,\n        quint16* const sourcePort );\n};\n\nqint64 NX_NETWORK_API totalSocketBytesSent();\n\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n/**@file\n * Contains template tests that verify the behavior of an nx::network::AbstractStreamSocket\n * implementation.\n * Refer to an existing StreamSocketAcceptance usage for an example.\n */\n\n#pragma once\n\n#include &lt;gtest/gtest.h&gt;\n\n#include &lt;nx/network/address_resolver.h&gt;\n#include &lt;nx/network/connection_server/simple_message_server.h&gt;\n#include &lt;nx/network/socket_common.h&gt;\n#include &lt;nx/network/socket_factory.h&gt;\n#include &lt;nx/network/socket_global.h&gt;\n#include &lt;nx/network/system_socket.h&gt;\n#include &lt;nx/utils/random.h&gt;\n#include &lt;nx/utils/std/thread.h&gt;\n#include &lt;nx/utils/string.h&gt;\n#include &lt;nx/utils/test_support/test_pipeline.h&gt;\n#include &lt;nx/utils/thread/sync_queue.h&gt;\n\n#include &quot;synchronous_tcp_server.h&quot;\n\nnamespace nx {\nnamespace network {\nnamespace test {\n\nnamespace {\n\nconstexpr int kIterations = 100;\nconstexpr int kBufferSize = 1024 * 32;\nconstexpr std::chrono::milliseconds kClientDelay(1);\nconstexpr int kConcurrentConnections = 11;\nconstexpr int kTotalConnections = 37;\n\n} // namespace\n\n/**\n * Adapted group of old socket tests.\n */\ntemplate&lt;typename SocketTypeSet&gt;\nclass SocketStreamingTestGroupFixture\n{\nprotected:\n    struct StreamingTestConfig\n    {\n        bool doServerDelay = false;\n        bool doClientDelay = false;\n        bool assertOnError = true;\n    };\n\n    bool runStreamingTest(const StreamingTestConfig&amp; conf)\n    {\n        using namespace std::chrono;\n\n        std::promise&lt;bool&gt; streamingServerResult;\n        std::promise&lt;SocketAddress&gt; serverAddressAvailable;\n        nx::utils::thread serverThread(\n            [this, &amp;conf, &amp;serverAddressAvailable, &amp;streamingServerResult]()\n            {\n                streamingServerResult.set_value(streamingServerMain(conf, &amp;serverAddressAvailable));\n            });\n\n        typename SocketTypeSet::ClientSocket clientSocket;\n        const auto addr = serverAddressAvailable.get_future().get();\n        EXPECT_TRUE(clientSocket.connect(addr, nx::network::kNoTimeout))\n            &lt;&lt; SystemError::getLastOSErrorText();\n        if (conf.doServerDelay)\n        {\n            EXPECT_TRUE(clientSocket.setSendTimeout(duration_cast&lt;milliseconds&gt;(kClientDelay).count()));\n        }\n\n        std::vector&lt;int&gt; buffer(kBufferSize);\n        for (int i = 0; i &lt; kBufferSize; ++i)\n            buffer[i] = i;\n\n        bool failed = false;\n        for (int i = 0; i &lt; kIterations; ++i)\n        {\n            const int bufferSize = kBufferSize * sizeof(int);\n            int offset = 0;\n            while (offset &lt; bufferSize)\n            {\n                int bytesSent = clientSocket.send((char *)buffer.data() + offset, bufferSize - offset);\n                if (bytesSent &gt; 0)\n                {\n                    offset += bytesSent;\n                }\n                else\n                {\n                    auto error = SystemError::getLastOSErrorCode();\n                    if (error != SystemError::timedOut &amp;&amp; error != SystemError::wouldBlock)\n                    {\n                        if (conf.assertOnError)\n                        {\n                            EXPECT_EQ(SystemError::noError, error);\n                            failed = true;\n                        }\n                        break; //&lt; Send error.\n                    }\n                }\n            }\n            if (conf.doClientDelay)\n                std::this_thread::sleep_for(kClientDelay);\n        }\n        clientSocket.close();\n        serverThread.join();\n\n        return !failed &amp;&amp; streamingServerResult.get_future().get();\n    }\n\nprivate:\n    bool streamingServerMain(\n        const StreamingTestConfig&amp; conf,\n        std::promise&lt;SocketAddress&gt;* serverAddressAvailable)\n    {\n        const auto server = std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;();\n\n        EXPECT_TRUE(server-&gt;bind(SocketAddress::anyPrivateAddress));\n        EXPECT_TRUE(server-&gt;listen());\n        serverAddressAvailable-&gt;set_value(server-&gt;getLocalAddress());\n\n        auto client = server-&gt;accept();\n        EXPECT_TRUE((bool)client);\n        EXPECT_TRUE(client-&gt;setRecvTimeout(kClientDelay));\n\n        constexpr int wholeDataSize = kBufferSize * sizeof(int) * kIterations;\n        nx::Buffer wholeData;\n        wholeData.reserve(wholeDataSize);\n        std::vector&lt;char&gt; buffer(1024 * 1024);\n        SystemError::ErrorCode error = SystemError::noError;\n        for (;;)\n        {\n            auto recv = client-&gt;recv(buffer.data(), (int)buffer.size());\n            if (recv &gt; 0)\n            {\n                wholeData.append(buffer.data(), recv);\n            }\n            else if (recv == 0)\n            {\n                break;\n            }\n            else\n            {\n                error = SystemError::getLastOSErrorCode();\n                if (error != SystemError::timedOut &amp;&amp;\n                    error != SystemError::again &amp;&amp;\n                    error != SystemError::interrupted &amp;&amp;\n                    error != SystemError::wouldBlock)\n                {\n                    // Connection has been broken.\n                    break;\n                }\n            }\n            if (conf.doServerDelay)\n                std::this_thread::sleep_for(kClientDelay);\n        }\n\n        if (conf.assertOnError)\n        {\n            EXPECT_EQ(wholeData.size(), wholeDataSize) &lt;&lt; SystemError::toString(error);\n        }\n\n        if (wholeData.size() != wholeDataSize)\n            return false;\n\n        const int* testData = (const int*)wholeData.data();\n        const int* endData = (const int*)(wholeData.data() + wholeData.size());\n        int expectedValue = 0;\n        while (testData &lt; endData)\n        {\n            if (conf.assertOnError)\n            {\n                EXPECT_EQ(expectedValue, *testData);\n            }\n\n            if (expectedValue != *testData)\n                return false;\n\n            testData++;\n            expectedValue = (expectedValue + 1) % kBufferSize;\n        }\n\n        return true;\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename SocketTypeSet&gt;\nclass StreamSocketStoppingMultipleConnectionsTestFixture\n{\npublic:\n    StreamSocketStoppingMultipleConnectionsTestFixture():\n        m_startedConnectionsCount(0),\n        m_completedConnectionsCount(0)\n    {\n    }\n\nprotected:\n    void startMaximumConcurrentConnections(const SocketAddress&amp; serverEndpoint)\n    {\n        m_serverEndpoint = serverEndpoint;\n        m_startedConnectionsCount = kConcurrentConnections;\n        {\n            NX_MUTEX_LOCKER lk(&amp;m_mutex);\n            for (int i = 0; i &lt; kConcurrentConnections; ++i)\n                startAnotherSocketNonSafe();\n        }\n    }\n\n    void startAnotherSocketNonSafe()\n    {\n        using namespace std::placeholders;\n\n        auto connection = std::make_unique&lt;typename SocketTypeSet::ClientSocket&gt;();\n\n        ASSERT_TRUE(connection-&gt;setNonBlockingMode(true));\n        typename SocketTypeSet::ClientSocket* connectionPtr = connection.get();\n        m_connections.push_back(std::move(connection));\n        connectionPtr-&gt;connectAsync(\n            m_serverEndpoint,\n            std::bind(&amp;StreamSocketStoppingMultipleConnectionsTestFixture::onConnectionComplete,\n                this, connectionPtr, _1));\n    }\n\n    void onConnectionComplete(\n        typename SocketTypeSet::ClientSocket* connectionPtr,\n        SystemError::ErrorCode errorCode)\n    {\n        ASSERT_EQ(SystemError::noError, errorCode);\n\n        NX_MUTEX_LOCKER lk(&amp;m_mutex);\n\n        auto iterToRemove = std::remove_if(\n            m_connections.begin(), m_connections.end(),\n            [connectionPtr](const auto&amp; elem) -&gt; bool\n            {\n                return elem.get() == connectionPtr;\n            });\n        if (iterToRemove != m_connections.end())\n        {\n            ++m_completedConnectionsCount;\n            m_connections.erase(iterToRemove, m_connections.end());\n        }\n\n        while (m_connections.size() &lt; kConcurrentConnections)\n        {\n            if ((++m_startedConnectionsCount) &lt;= kTotalConnections)\n                startAnotherSocketNonSafe();\n            else\n                break;\n        }\n    }\n\n    int startedConnectionsCount() const\n    {\n        return m_startedConnectionsCount;\n    }\n\n    int completedConnectionsCount() const\n    {\n        return m_completedConnectionsCount;\n    }\n\n    mutable nx::Mutex m_mutex;\n    std::deque&lt;std::unique_ptr&lt;typename SocketTypeSet::ClientSocket&gt;&gt; m_connections;\n\nprivate:\n    SocketAddress m_serverEndpoint;\n    std::atomic&lt;int&gt; m_startedConnectionsCount;\n    std::atomic&lt;int&gt; m_completedConnectionsCount;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Writes and reads socket concurrently using synchronous socket API.\n * Two threads are created internally for that purpose.\n */\ntemplate&lt;typename SocketType&gt;\nclass ConcurrentSocketPipe\n{\npublic:\n    ConcurrentSocketPipe(\n        std::unique_ptr&lt;SocketType&gt; socket,\n        nx::utils::SyncQueue&lt;nx::Buffer&gt;* dataToSendQueue,\n        nx::utils::SyncQueue&lt;nx::Buffer&gt;* dataReceivedQueue)\n        :\n        m_socket(std::move(socket)),\n        m_dataToSendQueue(dataToSendQueue),\n        m_dataReceivedQueue(dataReceivedQueue),\n        m_terminated(false)\n    {\n    }\n\n    ~ConcurrentSocketPipe()\n    {\n        m_terminated = true;\n\n        if (m_readThread.joinable())\n            m_readThread.join();\n        if (m_writeThread.joinable())\n            m_writeThread.join();\n    }\n\n    bool start()\n    {\n        if (!m_socket-&gt;setNonBlockingMode(false) ||\n            !m_socket-&gt;setRecvTimeout(std::chrono::milliseconds(1)))\n        {\n            return false;\n        }\n\n        m_readThread = std::thread(\n            std::bind(&amp;ConcurrentSocketPipe::readThreadMain, this));\n        m_writeThread = std::thread(\n            std::bind(&amp;ConcurrentSocketPipe::writeThreadMain, this));\n\n        return true;\n    }\n\nprivate:\n    std::unique_ptr&lt;SocketType&gt; m_socket;\n    nx::utils::SyncQueue&lt;nx::Buffer&gt;* m_dataToSendQueue;\n    nx::utils::SyncQueue&lt;nx::Buffer&gt;* m_dataReceivedQueue;\n    std::atomic&lt;bool&gt; m_terminated;\n    std::thread m_readThread;\n    std::thread m_writeThread;\n\n    void readThreadMain()\n    {\n        while (!m_terminated)\n        {\n            nx::Buffer readBuf;\n            readBuf.resize(4*1024);\n            int bytesRead = m_socket-&gt;recv(readBuf.data(), readBuf.size(), 0);\n            if (bytesRead &lt; 0)\n            {\n                if (socketCannotRecoverFromError(SystemError::getLastOSErrorCode()))\n                    break;\n                continue;\n            }\n\n            if (bytesRead == 0)\n                break;\n\n            readBuf.resize(bytesRead);\n            m_dataReceivedQueue-&gt;push(std::move(readBuf));\n        }\n    }\n\n    void writeThreadMain()\n    {\n        while (!m_terminated)\n        {\n            auto dataToSend = m_dataToSendQueue-&gt;pop(std::chrono::milliseconds(1));\n            if (!dataToSend)\n                continue;\n\n            const auto size = dataToSend-&gt;size();\n            auto remain = size;\n            while (remain &gt; 0)\n            {\n                const auto sent = m_socket-&gt;send(dataToSend-&gt;data() + (size - remain), remain);\n                if (sent &lt; 0)\n                {\n                    if (socketCannotRecoverFromError(SystemError::getLastOSErrorCode()))\n                        return;\n                    continue;\n                }\n                if (sent == 0)\n                    return;\n                remain -= sent;\n            }\n        }\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\nenum class SocketTypeLimitation\n{\n    noConcurrentBlockingIo,\n    notUsableAfterSendInterrupt,\n};\n\ntemplate&lt;typename SocketTypeSet&gt;\nclass StreamSocketAcceptance:\n    public ::testing::Test,\n    public SocketStreamingTestGroupFixture&lt;SocketTypeSet&gt;,\n    public StreamSocketStoppingMultipleConnectionsTestFixture&lt;SocketTypeSet&gt;\n{\npublic:\n    StreamSocketAcceptance():\n        m_addressResolver(&amp;nx::network::SocketGlobals::addressResolver()),\n        m_clientMessage(&quot;request_&quot; + nx::utils::random::generateName(17)),\n        m_serverMessage(&quot;response_&quot; + nx::utils::random::generateName(17))\n    {\n    }\n\n    ~StreamSocketAcceptance()\n    {\n        if (m_connection)\n        {\n            m_connection-&gt;pleaseStopSync();\n            m_connection.reset();\n        }\n        if (m_serverSocket)\n            m_serverSocket-&gt;pleaseStopSync();\n        if (m_server)\n            m_server-&gt;pleaseStopSync();\n        if (m_synchronousServer)\n            m_synchronousServer-&gt;stop();\n\n        for (const auto&amp; connectionContext: m_clientConnections)\n            connectionContext-&gt;connection.pleaseStopSync();\n    }\n\nprotected:\n    AddressResolver* m_addressResolver = nullptr;\n\n    void givenListeningServerSocket(\n        int backLogSize = AbstractStreamServerSocket::kDefaultBacklogSize)\n    {\n        m_serverSocket = std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;();\n        ASSERT_TRUE(m_serverSocket-&gt;bind(SocketAddress::anyPrivateAddress));\n        ASSERT_TRUE(m_serverSocket-&gt;listen(backLogSize));\n    }\n\n    void setServerSocketAcceptTimeout(std::chrono::milliseconds timeout)\n    {\n        ASSERT_TRUE(m_serverSocket-&gt;setRecvTimeout(timeout.count()));\n    }\n\n    void givenAcceptingServerSocket()\n    {\n        givenListeningServerSocket();\n        whenStartAcceptingConnections();\n    }\n\n    void givenListeningNonBlockingServerSocket()\n    {\n        givenListeningServerSocket();\n        ASSERT_TRUE(m_serverSocket-&gt;setNonBlockingMode(true));\n    }\n\n    void givenListeningSynchronousServer()\n    {\n        m_synchronousServer = std::make_unique&lt;SynchronousReceivingServer&gt;(\n            std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;(),\n            &amp;m_synchronousServerReceivedData);\n        ASSERT_TRUE(m_synchronousServer-&gt;bindAndListen(SocketAddress::anyPrivateAddress));\n        m_synchronousServer-&gt;start();\n    }\n\n    void givenSynchronousPingPongServer()\n    {\n        m_synchronousServer = std::make_unique&lt;SynchronousPingPongServer&gt;(\n            std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;(),\n            m_clientMessage,\n            m_serverMessage);\n        ASSERT_TRUE(m_synchronousServer-&gt;bindAndListen(SocketAddress::anyPrivateAddress));\n        m_synchronousServer-&gt;start();\n    }\n\n    void givenSilentServer()\n    {\n        givenListeningServerSocket();\n    }\n\n    void givenRandomNameMappedToServerHostIp()\n    {\n        givenRandomHostName();\n        m_mappedEndpoint.port = serverEndpoint().port;\n\n        m_addressResolver-&gt;addFixedAddress(\n            m_mappedEndpoint.address,\n            serverEndpoint());\n    }\n\n    void givenRandomHostName()\n    {\n        m_mappedEndpoint.address = nx::utils::random::generateName(7);\n        m_mappedEndpoint.port = nx::utils::random::number&lt;std::uint16_t&gt;();\n    }\n\n    void givenMessageServer()\n    {\n        m_server = std::make_unique&lt;server::SimpleMessageServer&gt;(\n            std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;());\n        m_server-&gt;setResponse(m_serverMessage);\n        m_server-&gt;setKeepConnection(true);\n        ASSERT_TRUE(m_server-&gt;bind(SocketAddress::anyPrivateAddress));\n        ASSERT_TRUE(m_server-&gt;listen());\n    }\n\n    void givenClientSocket()\n    {\n        if (m_connection)\n            m_connection-&gt;pleaseStopSync();\n\n        m_connection = std::make_unique&lt;typename SocketTypeSet::ClientSocket&gt;();\n    }\n\n    void givenConnectedSocket()\n    {\n        givenClientSocket();\n        whenSynchronouslyConnectToServer();\n    }\n\n    void givenPingPongServer()\n    {\n        givenMessageServer();\n        m_server-&gt;setRequest(m_clientMessage);\n    }\n\n    void givenSpamServer()\n    {\n        m_synchronousServer = std::make_unique&lt;SynchronousSpamServer&gt;(\n            std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;());\n        ASSERT_TRUE(m_synchronousServer-&gt;bindAndListen(SocketAddress::anyPrivateAddress));\n        m_synchronousServer-&gt;start();\n    }\n\n    void givenSocketInConnectStage()\n    {\n        givenListeningServerSocket();\n        givenRandomNameMappedToServerHostIp();\n\n        whenConnectUsingHostName();\n    }\n\n    void givenClientConnectionTimedOutOnSend()\n    {\n        givenAcceptingServerSocket();\n        givenConnectedSocket();\n        setClientSocketSendTimeout(std::chrono::milliseconds(1));\n\n        whenClientSendsRandomDataSynchronouslyUntilFailure();\n        thenClientSendTimesOutEventually();\n    }\n\n    void whenSynchronouslyConnectToServer()\n    {\n        ASSERT_TRUE(m_connection-&gt;connect(serverEndpoint(), nx::network::kNoTimeout))\n            &lt;&lt; SystemError::getLastOSErrorText();\n    }\n\n    template&lt;typename AuxiliaryConnectCompletionHandler&gt;\n    void whenConnectToServer(AuxiliaryConnectCompletionHandler&amp;&amp; handler)\n    {\n        givenClientSocket();\n        whenConnectToServerAsync(serverEndpoint(), std::move(handler));\n        thenConnectionIsEstablished();\n    }\n\n    template&lt;typename AuxiliaryConnectCompletionHandler&gt;\n    void whenConnectToServerAsync(\n        const SocketAddress&amp; endpoint,\n        AuxiliaryConnectCompletionHandler&amp;&amp; handler)\n    {\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(true));\n        m_connection-&gt;connectAsync(\n            endpoint,\n            [this, handler = std::move(handler)](SystemError::ErrorCode resultCode)\n            {\n                handler();\n                this-&gt;saveConnectResult(resultCode);\n            });\n    }\n\n    void whenConnectToServerAsync()\n    {\n        whenConnectToServerAsync(serverEndpoint(), []() {});\n    }\n\n    void whenReceivedMessageFromServerAsync(\n        nx::MoveOnlyFunc&lt;void()&gt; auxiliaryHandler)\n    {\n        m_auxiliaryRecvHandler.swap(auxiliaryHandler);\n\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(true));\n        continueReceiving();\n\n        thenServerMessageIsReceived();\n    }\n\n    void whenConnectUsingHostName()\n    {\n        givenClientSocket();\n        whenConnectToServerAsync(m_mappedEndpoint, [](){});\n    }\n\n    nx::Buffer whenSendRandomDataToServer()\n    {\n        m_sentData = nx::utils::generateRandomName(1023);\n        EXPECT_EQ(\n            m_sentData.size(),\n            m_connection-&gt;send(m_sentData.data(), m_sentData.size()))\n            &lt;&lt; SystemError::getLastOSErrorText();\n\n        return m_sentData;\n    }\n\n    void whenSendAsyncRandomDataToServer(\n        std::function&lt;void()&gt; auxiliaryHandler = nullptr)\n    {\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(true));\n\n        m_sentData = nx::utils::generateRandomName(16*1024);\n        m_connection-&gt;sendAsync(\n            &amp;m_sentData,\n            [auxiliaryHandler = std::move(auxiliaryHandler)](\n                SystemError::ErrorCode, std::size_t)\n            {\n                if (auxiliaryHandler)\n                    auxiliaryHandler();\n            });\n    }\n\n    void whenServerReadsWithFlags(int recvFlags)\n    {\n        whenAcceptConnection();\n        thenConnectionHasBeenAccepted();\n\n        whenServerReadsBytesWithFlags(m_sentData.size(), recvFlags);\n    }\n\n    void whenServerReadsBytesWithFlags(std::size_t bytesExpected, int recvFlags)\n    {\n        std::vector&lt;uint8_t&gt; readBuf(bytesExpected, &#x27;x&#x27;);\n\n        std::size_t totalBytesReceived = 0;\n        while (totalBytesReceived &lt; bytesExpected)\n        {\n            auto bytesReceived = std::get&lt;1&gt;(m_prevAcceptResult)-&gt;recv(\n                readBuf.data(),\n                (unsigned int) (bytesExpected - totalBytesReceived),\n                recvFlags);\n            ASSERT_GT(bytesReceived, 0) &lt;&lt; SystemError::getLastOSErrorText();\n            totalBytesReceived += bytesReceived;\n            m_synchronousServerReceivedData.write(readBuf.data(), bytesReceived);\n        }\n    }\n\n    std::tuple&lt;int /*bytesReadCnt*/, std::vector&lt;uint8_t&gt; /*buf*/&gt; whenServerReadsSome()\n    {\n        std::vector&lt;uint8_t&gt; readBuf(4096, &#x27;x&#x27;);\n\n        int bytesReceived = std::get&lt;1&gt;(m_prevAcceptResult)-&gt;recv(readBuf.data(), readBuf.size(), 0);\n        if (bytesReceived &gt; 0)\n        {\n            m_synchronousServerReceivedData.write(readBuf.data(), bytesReceived);\n            readBuf.resize(bytesReceived);\n        }\n        else\n        {\n            readBuf.clear();\n        }\n\n        return std::make_tuple(bytesReceived, std::move(readBuf));\n    }\n\n    void whenClientConnectionIsClosed()\n    {\n        m_connection.reset();\n    }\n\n    void startReadingConnectionAsync()\n    {\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(true));\n\n        m_waitForSingleRecvResult = false;\n        continueReceiving();\n    }\n\n    void continueReceiving()\n    {\n        using namespace std::placeholders;\n\n        m_readBuffer.reserve(m_readBuffer.size() + 1024);\n        m_connection-&gt;readSomeAsync(\n            &amp;m_readBuffer,\n            std::bind(&amp;StreamSocketAcceptance::saveReadResult, this, _1, _2));\n    }\n\n    void waitForConnectionRecvTimeout()\n    {\n        for (;;)\n        {\n            if (std::get&lt;0&gt;(m_recvResultQueue.pop()) == SystemError::timedOut)\n                break;\n        }\n    }\n\n    void whenCancelAllSocketOperations()\n    {\n        m_connection-&gt;pleaseStopSync();\n    }\n\n    void whenClientSentPing()\n    {\n        whenClientSendsPing();\n        thenSendSucceeded();\n    }\n\n    void whenClientSendsPing()\n    {\n        const auto bytesSent =\n            m_connection-&gt;send(m_clientMessage.data(), m_clientMessage.size());\n\n        m_sendResultQueue.push(\n            bytesSent == (int) m_clientMessage.size()\n            ? SystemError::noError\n            : SystemError::getLastOSErrorCode());\n    }\n\n    void whenClientSentPingAsync(std::function&lt;void()&gt; auxiliaryHandler = nullptr)\n    {\n        whenClientSendsPingAsync(std::move(auxiliaryHandler));\n        thenSendSucceeded();\n    }\n\n    void whenClientSendsPingAsync(std::function&lt;void()&gt; auxiliaryHandler = nullptr)\n    {\n        m_connection-&gt;sendAsync(\n            &amp;m_clientMessage,\n            [this, auxiliaryHandler = std::move(auxiliaryHandler)](\n                SystemError::ErrorCode systemErrorCode,\n                std::size_t /*bytesSent*/)\n            {\n                if (auxiliaryHandler)\n                    auxiliaryHandler();\n                m_sendResultQueue.push(systemErrorCode);\n            });\n    }\n\n    void thenSendSucceeded()\n    {\n        ASSERT_EQ(SystemError::noError, m_sendResultQueue.pop());\n    }\n\n    void thenClientSendTimesOutEventually()\n    {\n        thenSendFailedWith(SystemError::timedOut);\n    }\n\n    void thenSendFailedWith(SystemError::ErrorCode systemErrorCode)\n    {\n        ASSERT_EQ(systemErrorCode, m_sendResultQueue.pop());\n    }\n\n    void thenSendFailedWithUnrecoverableError()\n    {\n        const auto errorCode = m_sendResultQueue.pop();\n        ASSERT_NE(SystemError::noError, errorCode);\n        ASSERT_TRUE(socketCannotRecoverFromError(errorCode));\n    }\n\n    void whenClientSendsRandomDataSynchronouslyUntilFailure()\n    {\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(false));\n        if (m_randomDataBuffer.empty())\n            m_randomDataBuffer = nx::utils::generateRandomName(64 * 1024);\n\n        for (int bytesSent = 0;\n            (bytesSent = m_connection-&gt;send(m_randomDataBuffer.data(), m_randomDataBuffer.size())) &gt; 0;)\n        {\n            m_sentData += m_randomDataBuffer.substr(0, bytesSent);\n            m_randomDataBuffer = nx::utils::generateRandomName(64 * 1024);\n        }\n\n        m_sendResultQueue.push(SystemError::getLastOSErrorCode());\n    }\n\n    void whenClientSendsRandomDataAsyncNonStop()\n    {\n        ASSERT_TRUE(m_connection-&gt;setNonBlockingMode(true));\n        if (m_randomDataBuffer.empty())\n            m_randomDataBuffer = nx::utils::generateRandomName(64*1024);\n\n        m_connection-&gt;sendAsync(\n            &amp;m_randomDataBuffer,\n            [this](SystemError::ErrorCode systemErrorCode, std::size_t /*bytesSent*/)\n            {\n                if (systemErrorCode == SystemError::noError)\n                {\n                    whenClientSendsRandomDataAsyncNonStop();\n                    return;\n                }\n\n                m_sendResultQueue.push(systemErrorCode);\n            });\n    }\n\n    void whenSendMultiplePingsViaMultipleConnections(int connectionCount)\n    {\n        m_expectedResponseCount = connectionCount;\n        for (int i = 0; i &lt; m_expectedResponseCount; ++i)\n        {\n            m_clientConnections.push_back(\n                std::make_unique&lt;ClientConnectionContext&gt;());\n            ASSERT_TRUE(m_clientConnections.back()-&gt;connection.connect(\n                serverEndpoint(), kNoTimeout));\n            ASSERT_TRUE(m_clientConnections.back()-&gt;connection.setNonBlockingMode(true));\n            m_clientConnections.back()-&gt;buffer.reserve(m_serverMessage.size());\n\n            m_clientConnections.back()-&gt;connection.sendAsync(\n                &amp;m_clientMessage,\n                [this, connectionCtx = m_clientConnections.back().get()](\n                    SystemError::ErrorCode errorCode,\n                    std::size_t bytesTransferred)\n                {\n                    if (errorCode != SystemError::noError ||\n                        bytesTransferred != m_clientMessage.size())\n                    {\n                        // m_recvResultQueue serves as result storage in this particular test.\n                        m_recvResultQueue.push(std::make_tuple(errorCode, nx::Buffer()));\n                        return;\n                    }\n\n                    connectionCtx-&gt;connection.readAsyncAtLeast(\n                        &amp;connectionCtx-&gt;buffer, m_serverMessage.size(),\n                        [this, connectionCtx](\n                            SystemError::ErrorCode errorCode, size_t /*size*/)\n                        {\n                            m_recvResultQueue.push(\n                                std::make_tuple(errorCode, connectionCtx-&gt;buffer));\n                        });\n                });\n        }\n    }\n\n    void whenReadSocketInBlockingWay()\n    {\n        whenReadSocketInBlockingWayWithFlags(0);\n    }\n\n    void whenReadSocketInBlockingWayWithFlags(int flags)\n    {\n        nx::Buffer readBuf;\n        readBuf.resize(64 * 1024);\n        int bytesRead = m_connection-&gt;recv(readBuf.data(), readBuf.capacity(), flags);\n        if (bytesRead &gt;= 0)\n        {\n            readBuf.resize(bytesRead);\n            m_recvResultQueue.push({ SystemError::noError, readBuf });\n        }\n        else\n        {\n            m_recvResultQueue.push({ SystemError::getLastOSErrorCode(), readBuf });\n        }\n    }\n\n    void whenAcceptNonBlocking()\n    {\n        ASSERT_TRUE(m_serverSocket-&gt;setNonBlockingMode(true))\n            &lt;&lt; SystemError::getLastOSErrorText();\n\n        whenAcceptConnection();\n    }\n\n    void whenAcceptConnection()\n    {\n        auto acceptedConnection = m_serverSocket-&gt;accept();\n        const auto systemErrorCode =\n            acceptedConnection == nullptr\n            ? SystemError::getLastOSErrorCode()\n            : SystemError::noError;\n        m_acceptedConnections.push(\n            std::make_tuple(systemErrorCode, std::move(acceptedConnection)));\n    }\n\n    void whenStartAcceptingConnections()\n    {\n        ASSERT_TRUE(m_serverSocket-&gt;setNonBlockingMode(true));\n\n        m_serverSocket-&gt;acceptAsync(\n            [this](\n                SystemError::ErrorCode systemErrorCode,\n                std::unique_ptr&lt;AbstractStreamSocket&gt; connection)\n            {\n                if (connection)\n                {\n                    m_acceptedConnections.push(\n                        std::make_tuple(\n                            systemErrorCode,\n                            std::move(connection)));\n                }\n\n                this-&gt;whenStartAcceptingConnections();\n            });\n    }\n\n    void whenAcceptConnectionAsync(std::function&lt;void()&gt; customHandler = nullptr)\n    {\n        m_serverSocket-&gt;acceptAsync(\n            [this, customHandler = std::move(customHandler)](\n                SystemError::ErrorCode systemErrorCode,\n                std::unique_ptr&lt;AbstractStreamSocket&gt; connection)\n            {\n                if (customHandler)\n                    customHandler();\n\n                m_acceptedConnections.push(\n                    std::make_tuple(systemErrorCode, std::move(connection)));\n            });\n    }\n\n    void whenCancelAccept()\n    {\n        serverSocket()-&gt;cancelIOSync();\n    }\n\n    void whenStopServerSocket()\n    {\n        serverSocket()-&gt;pleaseStopSync();\n    }\n\n    void waitUntilConnectionIsAcceptedInNonBlockingMode()\n    {\n        ASSERT_TRUE(m_serverSocket-&gt;setNonBlockingMode(true))\n            &lt;&lt; SystemError::getLastOSErrorText();\n\n        waitUntilConnectionIsAccepted();\n    }\n\n    void waitUntilConnectionIsAccepted()\n    {\n        for (;;)\n        {\n            whenAcceptConnection();\n\n            m_prevAcceptResult = m_acceptedConnections.pop();\n            if (std::get&lt;0&gt;(m_prevAcceptResult) == SystemError::wouldBlock)\n            {\n                std::this_thread::sleep_for(std::chrono::milliseconds(1));\n                continue;\n            }\n\n            ASSERT_NE(nullptr, std::move(std::get&lt;1&gt;(m_prevAcceptResult)));\n            break;\n        }\n    }\n\n    void whenConnectionIsAccepted()\n    {\n        this-&gt;givenConnectedSocket();\n        // E.g., for socket with encryption auto-detection\n        this-&gt;whenClientSentPing();\n\n        this-&gt;waitUntilConnectionIsAccepted();\n    }\n\n    void whenEstablishMultipleConnectionsAsync(int connectionCount)\n    {\n        m_clientConnections.resize(connectionCount);\n\n        for (auto&amp; connectionCtx: m_clientConnections)\n        {\n            connectionCtx = std::make_unique&lt;ClientConnectionContext&gt;();\n            ASSERT_TRUE(connectionCtx-&gt;connection.setNonBlockingMode(true));\n            connectionCtx-&gt;connection.connectAsync(\n                serverEndpoint(),\n                [this, &amp;connectionCtx](SystemError::ErrorCode systemErrorCode)\n                {\n                    m_connectResultQueue.push(systemErrorCode);\n                    if (systemErrorCode != SystemError::noError)\n                        return;\n\n                    // TODO: #akolesnikov Have to send something here because server socket with\n                    // encryption auto-detection will not return socket until something is received.\n                    // This condition should be handled by a more generic approach.\n                    connectionCtx-&gt;connection.sendAsync(\n                        &amp;m_clientMessage,\n                        [](SystemError::ErrorCode, std::size_t) {});\n                });\n        }\n    }\n\n    void assertAcceptedConnectionNonBlockingModeIs(bool expected)\n    {\n        bool isNonBlockingMode = false;\n        ASSERT_TRUE(std::get&lt;1&gt;(m_prevAcceptResult)-&gt;getNonBlockingMode(&amp;isNonBlockingMode));\n        ASSERT_EQ(expected, isNonBlockingMode);\n    }\n\n    void thenAcceptReported(SystemError::ErrorCode expected)\n    {\n        m_prevAcceptResult = m_acceptedConnections.pop();\n\n        ASSERT_EQ(expected, std::get&lt;0&gt;(m_prevAcceptResult));\n    }\n\n    void thenAcceptFailed()\n    {\n        m_prevAcceptResult = m_acceptedConnections.pop();\n\n        ASSERT_NE(SystemError::noError, std::get&lt;0&gt;(m_prevAcceptResult));\n    }\n\n    void thenConnectionHasBeenAccepted()\n    {\n        thenAcceptReported(SystemError::noError);\n\n        ASSERT_NE(nullptr, std::get&lt;1&gt;(m_prevAcceptResult));\n    }\n\n    void thenNoConnectionCanBeAccepted()\n    {\n        auto connection = std::make_unique&lt;typename SocketTypeSet::ClientSocket&gt;();\n        ASSERT_TRUE(connection-&gt;setNonBlockingMode(true));\n        connection-&gt;connect(serverEndpoint(), nx::network::kNoTimeout);\n\n        ASSERT_FALSE(m_acceptedConnections.pop(std::chrono::milliseconds(10)));\n    }\n\n    void thenConnectionIsEstablished()\n    {\n        ASSERT_EQ(SystemError::noError, m_connectResultQueue.pop());\n    }\n\n    void thenConnectionIsNotEstablished()\n    {\n        ASSERT_NE(SystemError::noError, m_connectResultQueue.pop());\n    }\n\n    void thenEveryConnectionEstablishedSuccessfully()\n    {\n        for (std::size_t i = 0; i &lt; m_clientConnections.size(); ++i)\n        {\n            ASSERT_EQ(SystemError::noError, m_connectResultQueue.pop());\n        }\n    }\n\n    void thenServerSocketReceivesAllDataBeforeEof()\n    {\n        thenConnectionHasBeenAccepted();\n\n        assertAcceptedConnectionReceivedAllSentData();\n        assertAcceptedConnectionReceivedEof();\n    }\n\n    static constexpr auto kDefaultTimerValue = std::chrono::milliseconds(10);\n\n    int whenRegisterTimer(\n        std::optional&lt;std::chrono::milliseconds&gt; timeout = std::nullopt)\n    {\n        m_connection-&gt;registerTimer(\n            timeout ? *timeout : kDefaultTimerValue,\n            [this, seq = ++m_lastTimerSequence]() { m_timerShots.push(seq); });\n        return m_lastTimerSequence;\n    }\n\n    void whenCancelTimer()\n    {\n        m_connection-&gt;cancelIOSync(aio::EventType::etTimedOut);\n    }\n\n    int thenTimerIsInvoked()\n    {\n        return m_timerShots.pop();\n    }\n\n    void thenTimerIsNotInvoked()\n    {\n        ASSERT_FALSE(m_timerShots.pop(kDefaultTimerValue * 3));\n    }\n\n    void assertAcceptedConnectionReceivedAllSentData()\n    {\n        assertAcceptedConnectionReceived(m_sentData);\n    }\n\n    void assertAcceptedConnectionReceived(const nx::Buffer&amp; expected)\n    {\n        ASSERT_TRUE(lastAcceptedSocket()-&gt;setNonBlockingMode(false));\n\n        whenServerReadsBytesWithFlags(expected.size(), 0);\n\n        ASSERT_EQ(expected, m_synchronousServerReceivedData.internalBuffer());\n        m_synchronousServerReceivedData = nx::utils::bstream::test::NotifyingOutput();\n    }\n\n    void assertAcceptedConnectionReceivedEof()\n    {\n        char buf[16];\n        // Sometimes, connection will report connection break, not graceful shutdown. But it&#x27;s ok.\n        int bytesRead = std::get&lt;1&gt;(m_prevAcceptResult)-&gt;recv(buf, sizeof(buf));\n        ASSERT_LE(bytesRead, 0);\n    }\n\n    void assertAcceptedConnectionReportsNotConnected()\n    {\n        ASSERT_FALSE(std::get&lt;1&gt;(m_prevAcceptResult)-&gt;isConnected());\n    }\n\n    void assertClientConnectionReportsNotConnected()\n    {\n        ASSERT_FALSE(m_connection-&gt;isConnected());\n    }\n\n    void assertConnectionToServerCanBeEstablishedUsingMappedName()\n    {\n        whenConnectUsingHostName();\n        thenConnectionIsEstablished();\n    }\n\n    void setClientSocketRecvTimeout(std::chrono::milliseconds timeout)\n    {\n        ASSERT_TRUE(m_connection-&gt;setRecvTimeout(timeout.count()));\n    }\n\n    void setClientSocketSendTimeout(std::chrono::milliseconds timeout)\n    {\n        ASSERT_TRUE(m_connection-&gt;setSendTimeout(timeout.count()));\n    }\n\n    void thenServerMessageIsReceived(bool ignoreError = true)\n    {\n        for (;;)\n        {\n            const auto prevRecvResult = m_recvResultQueue.pop();\n            if (ignoreError &amp;&amp;\n                std::get&lt;0&gt;(prevRecvResult) != SystemError::noError)\n            {\n                continue;\n            }\n\n            ASSERT_EQ(SystemError::noError, std::get&lt;0&gt;(prevRecvResult));\n            const auto&amp; messageReceived = std::get&lt;1&gt;(prevRecvResult);\n            ASSERT_TRUE(messageReceived.starts_with(m_serverMessage));\n            break;\n        }\n    }\n\n    void thenClientSocketReported(SystemError::ErrorCode expected)\n    {\n        const auto prevRecvResult = m_recvResultQueue.pop();\n        ASSERT_EQ(expected, std::get&lt;0&gt;(prevRecvResult));\n    }\n\n    void thenClientSocketReportedTimedout()\n    {\n        thenClientSocketReported(SystemError::timedOut);\n    }\n\n    void thenClientSocketReportedFailure()\n    {\n        const auto prevRecvResult = m_recvResultQueue.pop();\n        ASSERT_NE(SystemError::noError, std::get&lt;0&gt;(prevRecvResult));\n    }\n\n    void thenPongIsReceivedViaEachConnection()\n    {\n        for (int i = 0; i &lt; m_expectedResponseCount; ++i)\n        {\n            auto recvResult = m_recvResultQueue.pop();\n            ASSERT_EQ(SystemError::noError, std::get&lt;0&gt;(recvResult));\n            ASSERT_EQ(m_serverMessage, std::get&lt;1&gt;(recvResult));\n        }\n    }\n\n    void thenSocketCanBeSafelyRemoved()\n    {\n        m_connection.reset();\n    }\n\n    void thenServerReceivedData()\n    {\n        m_synchronousServerReceivedData.waitForReceivedDataToMatch(m_sentData);\n    }\n\n    void thenSocketCanBeUsedForAsyncIo()\n    {\n        this-&gt;whenClientSentPingAsync();\n\n        this-&gt;thenServerMessageIsReceived();\n    }\n\n    void thenEveryConnectionIsAccepted()\n    {\n        for (int i = 0; i &lt; (int) m_clientConnections.size(); ++i)\n        {\n            ASSERT_NE(nullptr, std::get&lt;1&gt;(m_acceptedConnections.pop()));\n        }\n    }\n\n    void assertConnectionCanDoSyncIo()\n    {\n        ASSERT_TRUE(connection()-&gt;setNonBlockingMode(false));\n\n        whenClientSentPing();\n\n        whenReadSocketInBlockingWay();\n        thenServerMessageIsReceived(false);\n    }\n\n    void assertConnectionCanDoAsyncIo()\n    {\n        ASSERT_TRUE(connection()-&gt;setNonBlockingMode(true));\n\n        whenClientSendsPingAsync();\n        thenSendSucceeded();\n\n        startReadingConnectionAsync();\n        thenServerMessageIsReceived(false);\n    }\n\n    void doSyncIoUntilFirstFailure()\n    {\n        ASSERT_TRUE(connection()-&gt;setNonBlockingMode(false));\n\n        doIoUntilFirstFailure(\n            std::bind(&amp;StreamSocketAcceptance::whenClientSendsPing, this),\n            std::bind(&amp;StreamSocketAcceptance::whenReadSocketInBlockingWay, this));\n    }\n\n    void doAsyncIoUntilFirstFailure()\n    {\n        ASSERT_TRUE(connection()-&gt;setNonBlockingMode(true));\n\n        doIoUntilFirstFailure(\n            [this](auto&amp;&amp;... args) { whenClientSendsPingAsync(std::move(args)...); },\n            [this](auto&amp;&amp;... args) { startReadingConnectionAsync(std::move(args)...); });\n    }\n\n    template&lt;typename SendPingFunc, typename RecvPingFunc&gt;\n    void doIoUntilFirstFailure(\n        SendPingFunc sendPingFunc,\n        RecvPingFunc recvPingFunc)\n    {\n        sendPingFunc();\n        if (m_sendResultQueue.pop() != SystemError::noError)\n            return;\n\n        recvPingFunc();\n\n        const auto prevRecvResult = m_recvResultQueue.pop();\n\n        if (std::get&lt;0&gt;(prevRecvResult) != SystemError::noError ||\n            std::get&lt;1&gt;(prevRecvResult).empty()) //&lt; Connection closed.\n        {\n            return;\n        }\n\n        const auto&amp; messageReceived = std::get&lt;1&gt;(prevRecvResult);\n        ASSERT_TRUE(messageReceived.starts_with(m_serverMessage));\n    }\n\n    //---------------------------------------------------------------------------------------------\n\n    template&lt;typename T&gt;\n    SocketAddress getServerEndpointForConnectShutdown(\n        typename std::enable_if_t&lt;\n            std::is_same&lt;\n                typename std::remove_const_t&lt;decltype(T::serverEndpointForConnectShutdown)&gt;,\n                SocketAddress&gt;::value&gt;* = nullptr)\n    {\n        return T::serverEndpointForConnectShutdown;\n    }\n\n    template&lt;typename T&gt;\n    SocketAddress getServerEndpointForConnectShutdown(...)\n    {\n        return serverEndpoint();\n    }\n\n    bool hasLimitation(SocketTypeLimitation limitation) const\n    {\n        return hasLimitationImpl&lt;SocketTypeSet&gt;(limitation);\n    }\n\n    //---------------------------------------------------------------------------------------------\n\n    void givenConnectionBlockedInConnect()\n    {\n        givenSilentServer();\n\n        auto connectResultQueue = std::make_shared&lt;nx::utils::SyncQueue&lt;bool&gt;&gt;();\n\n        m_clientSocketThread = std::thread(\n            [this, connectResultQueue]()\n            {\n                NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n\n                for (;;)\n                {\n                    m_connection = std::make_unique&lt;typename SocketTypeSet::ClientSocket&gt;();\n\n                    nx::Unlocker&lt;nx::Mutex&gt; unlock(&amp;lock);\n\n                    const auto connectResult = m_connection-&gt;connect(\n                        getServerEndpointForConnectShutdown&lt;SocketTypeSet&gt;(nullptr),\n                        nx::network::kNoTimeout);\n\n                    if (!connectResult)\n                        break; //&lt; Assuming that socket has been shutdown.\n                    connectResultQueue-&gt;push(connectResult);\n                }\n            });\n\n        for (;;)\n        {\n            const auto connectResult = connectResultQueue-&gt;pop(std::chrono::milliseconds(100));\n            if (!connectResult)\n                break; //&lt; Assuming that connect has blocked.\n            ASSERT_TRUE(*connectResult);\n        }\n    }\n\n    void givenConnectionBlockedInSend()\n    {\n        givenSilentServer();\n        givenConnectedSocket();\n\n        auto sendResultQueue = std::make_shared&lt;nx::utils::SyncQueue&lt;int&gt;&gt;();\n\n        m_clientSocketThread = std::thread(\n            [this, sendResultQueue]()\n            {\n                std::array&lt;char, 16*1024&gt; sendBuffer;\n                for (;;)\n                {\n                    // This send will block eventually.\n                    const int bytesSent = m_connection-&gt;send(\n                        sendBuffer.data(), sendBuffer.size());\n                    if (bytesSent &lt;= 0)\n                        break; //&lt; Assuming that socket has been shutdown.\n                    sendResultQueue-&gt;push(bytesSent);\n                }\n            });\n\n        for (;;)\n        {\n            const auto bytesSent = sendResultQueue-&gt;pop(std::chrono::milliseconds(100));\n            if (!bytesSent)\n            {\n                // Assuming that send has blocked.\n                // There is no way to reliably check that m_clientSocketThread is blocked in send,\n                // but it will happen at least sometimes, so this test will catch\n                // an existing problem (if any) with number of runs -&gt; infinity.\n                break;\n            }\n            ASSERT_GT(*bytesSent, 0);\n        }\n    }\n\n    void givenConnectionBlockedInRecv()\n    {\n        givenSilentServer();\n        givenConnectedSocket();\n\n        m_clientSocketThread = std::thread(\n            [this]()\n            {\n                char buf[16];\n                m_connection-&gt;recv(buf, sizeof(buf), 0);\n            });\n    }\n\n    void whenInvokeShutdown()\n    {\n        NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n\n        m_connection-&gt;shutdown();\n    }\n\n    void whenInvokeShutdownInTimer()\n    {\n        NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n\n        std::promise&lt;void&gt; promise;\n        nx::network::aio::Timer timer;\n        timer.start(std::chrono::milliseconds(1),\n            [this, &amp;promise]()\n            {\n                m_connection-&gt;shutdown();\n                promise.set_value();\n            });\n        promise.get_future().wait();\n        timer.pleaseStopSync();\n    }\n\n    void thenConnectionOperationIsInterrupted()\n    {\n        m_clientSocketThread.join();\n    }\n\n    void thenPollableIsStillValid()\n    {\n        ASSERT_NE(nullptr, m_connection-&gt;pollable());\n    }\n\n    //---------------------------------------------------------------------------------------------\n\n    void whenSendDataConcurrentlyThroughConnectedSockets()\n    {\n        m_sentData = nx::utils::generateRandomName(1024 * 1024);\n\n        givenListeningServerSocket();\n        whenStartAcceptingConnections();\n\n        givenConnectedSocket();\n        m_concurrentSocketPipes.push_back(\n            std::make_unique&lt;ConcurrentSocketPipeContext&gt;(\n                std::exchange(m_connection, nullptr)));\n        m_concurrentSocketPipes.back()-&gt;dataToSendQueue.push(m_sentData);\n\n        auto acceptResult = m_acceptedConnections.pop();\n        ASSERT_NE(nullptr, std::get&lt;1&gt;(acceptResult));\n        m_concurrentSocketPipes.push_back(\n            std::make_unique&lt;ConcurrentSocketPipeContext&gt;(\n                std::exchange(std::get&lt;1&gt;(acceptResult), nullptr)));\n        m_concurrentSocketPipes.back()-&gt;dataToSendQueue.push(m_sentData);\n    }\n\n    void thenBothSocketsReceiveExpectedData()\n    {\n        for (auto&amp; pipe: m_concurrentSocketPipes)\n            pipe-&gt;waitUntilReceivedDataMatch(m_sentData);\n    }\n\n    //---------------------------------------------------------------------------------------------\n\n    SocketAddress mappedEndpoint() const\n    {\n        return m_mappedEndpoint;\n    }\n\n    SocketAddress serverEndpoint() const\n    {\n        if (m_server)\n            return SocketAddress(m_server-&gt;address());\n        else if (m_serverSocket)\n            return m_serverSocket-&gt;getLocalAddress();\n        else if (m_synchronousServer)\n            return m_synchronousServer-&gt;endpoint();\n        else\n            return SocketAddress();\n    }\n\n    std::unique_ptr&lt;typename SocketTypeSet::ServerSocket&gt; createServerSocket()\n    {\n        return std::make_unique&lt;typename SocketTypeSet::ServerSocket&gt;();\n    }\n\n    typename SocketTypeSet::ClientSocket* connection()\n    {\n        return m_connection.get();\n    }\n\n    std::unique_ptr&lt;typename SocketTypeSet::ClientSocket&gt; takeConnection()\n    {\n        return std::exchange(m_connection, {});\n    }\n\n    typename SocketTypeSet::ServerSocket* serverSocket()\n    {\n        return m_serverSocket.get();\n    }\n\n    AbstractStreamSocket* lastAcceptedSocket()\n    {\n        return std::get&lt;1&gt;(m_prevAcceptResult).get();\n    }\n\n    void freeServerSocket()\n    {\n        m_serverSocket.reset();\n    }\n\n    const nx::Buffer&amp; clientMessage() const\n    {\n        return m_clientMessage;\n    }\n\nprivate:\n    template&lt;typename SocketTypeSet_&gt;\n    static bool hasLimitationImpl(\n        SocketTypeLimitation value,\n        typename std::enable_if_t&lt;std::is_same_v&lt;\n            std::void_t&lt;decltype(SocketTypeSet_::limitations)&gt;, void&gt;&gt;* = nullptr)\n    {\n        for (auto c: SocketTypeSet::limitations)\n        {\n            if (c == value)\n                return true;\n        }\n\n        return false;\n    }\n\n    template&lt;typename&gt;\n    static bool hasLimitationImpl(...)\n    {\n        // If SocketTypeSet does not specify limitations, then assuming everything supported.\n        return false;\n    }\n\nprivate:\n    using RecvResult = std::tuple&lt;SystemError::ErrorCode, nx::Buffer&gt;;\n    using AcceptResult =\n        std::tuple&lt;SystemError::ErrorCode, std::unique_ptr&lt;AbstractStreamSocket&gt;&gt;;\n\n    struct ClientConnectionContext\n    {\n        typename SocketTypeSet::ClientSocket connection;\n        nx::Buffer buffer;\n    };\n\n    int m_expectedResponseCount = 0;\n    SocketAddress m_mappedEndpoint;\n    nx::utils::SyncQueue&lt;SystemError::ErrorCode&gt; m_connectResultQueue;\n    const nx::Buffer m_clientMessage;\n    const nx::Buffer m_serverMessage;\n    nx::Buffer m_readBuffer;\n    nx::utils::SyncQueue&lt;RecvResult&gt; m_recvResultQueue;\n    nx::utils::SyncQueue&lt;SystemError::ErrorCode&gt; m_sendResultQueue;\n    nx::Buffer m_randomDataBuffer;\n    std::unique_ptr&lt;typename SocketTypeSet::ServerSocket&gt; m_serverSocket;\n    std::unique_ptr&lt;typename SocketTypeSet::ClientSocket&gt; m_connection;\n    std::unique_ptr&lt;server::SimpleMessageServer&gt; m_server;\n    nx::MoveOnlyFunc&lt;void()&gt; m_auxiliaryRecvHandler;\n    std::vector&lt;std::unique_ptr&lt;ClientConnectionContext&gt;&gt; m_clientConnections;\n    nx::utils::SyncQueue&lt;AcceptResult&gt; m_acceptedConnections;\n    AcceptResult m_prevAcceptResult;\n    bool m_waitForSingleRecvResult = true;\n    std::thread m_clientSocketThread;\n    int m_lastTimerSequence = 0;\n    nx::utils::SyncQueue&lt;int /*timer sequence*/&gt; m_timerShots;\n\n    //---------------------------------------------------------------------------------------------\n    // Concurrent I/O.\n\n    class ConcurrentSocketPipeContext\n    {\n    public:\n        nx::utils::SyncQueue&lt;nx::Buffer&gt; dataToSendQueue;\n        nx::utils::SyncQueue&lt;nx::Buffer&gt; dataReceivedQueue;\n        ConcurrentSocketPipe&lt;AbstractStreamSocket&gt; pipe;\n\n        ConcurrentSocketPipeContext(std::unique_ptr&lt;AbstractStreamSocket&gt; socket):\n            pipe(\n                std::move(socket),\n                &amp;dataToSendQueue,\n                &amp;dataReceivedQueue)\n        {\n            pipe.start();\n        }\n\n        void waitUntilReceivedDataMatch(const nx::Buffer&amp; expected)\n        {\n            nx::Buffer received;\n            while (!received.starts_with(expected))\n                received += dataReceivedQueue.pop();\n        }\n    };\n\n    std::vector&lt;std::unique_ptr&lt;ConcurrentSocketPipeContext&gt;&gt; m_concurrentSocketPipes;\n\n    //---------------------------------------------------------------------------------------------\n\n    std::unique_ptr&lt;BasicSynchronousReceivingServer&gt; m_synchronousServer;\n    nx::Buffer m_sentData;\n    nx::utils::bstream::test::NotifyingOutput m_synchronousServerReceivedData;\n\n    void saveConnectResult(SystemError::ErrorCode connectResult)\n    {\n        m_connectResultQueue.push(connectResult);\n    }\n\n    void saveReadResult(SystemError::ErrorCode systemErrorCode, std::size_t bytesRead)\n    {\n        if (systemErrorCode == SystemError::noError &amp;&amp; bytesRead &gt; 0)\n        {\n            m_recvResultQueue.push(\n                std::make_tuple(SystemError::noError, m_readBuffer));\n            m_readBuffer.clear();\n        }\n        else\n        {\n            m_recvResultQueue.push(std::make_tuple(systemErrorCode, nx::Buffer()));\n        }\n\n        if (m_auxiliaryRecvHandler)\n            nx::swapAndCall(m_auxiliaryRecvHandler);\n\n        if (!m_waitForSingleRecvResult)\n            continueReceiving();\n    }\n};\n\nTYPED_TEST_SUITE_P(StreamSocketAcceptance);\n\n//-------------------------------------------------------------------------------------------------\n\n// Windows 8/10 does not support client-&gt;server send timeout.\n// It closes connection automatically with error 10053 after client send timeout.\nTYPED_TEST_P(StreamSocketAcceptance, DISABLED_receiveDelay)\n{\n    this-&gt;runStreamingTest({.doServerDelay = true, .doClientDelay = false, .assertOnError = true});\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, sendDelay)\n{\n    // NOTE: there is a weird trouble with this test on win32 that results in WSA_IO_PENDING error\n    // reported by recv which leads to the test failure.\n    // This situation is unexpected and can be a bug in a network driver.\n    // So, working around the issue by retrying test multiple times.\n\n    static constexpr int kTries = 11;\n    for (int i = 0; i &lt; kTries; ++i)\n    {\n        if (this-&gt;runStreamingTest({.doServerDelay = false, .doClientDelay = true, .assertOnError = false}))\n            return;\n    }\n\n    FAIL() &lt;&lt; &quot;The test did not pass in &quot;&lt;&lt; kTries &lt;&lt; &quot; tries&quot;;\n}\n\n//-------------------------------------------------------------------------------------------------\n// Connect tests.\n\nTYPED_TEST_P(StreamSocketAcceptance, connect_uses_address_resolver)\n{\n    this-&gt;givenMessageServer();\n    this-&gt;givenRandomNameMappedToServerHostIp();\n\n    this-&gt;assertConnectionToServerCanBeEstablishedUsingMappedName();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    connect_including_resolve_is_cancelled_correctly)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;givenRandomNameMappedToServerHostIp();\n\n    this-&gt;whenConnectUsingHostName();\n    this-&gt;whenCancelAllSocketOperations();\n\n    // then process does not crash.\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    connect_including_resolving_unknown_name_is_cancelled_correctly)\n{\n    this-&gt;givenRandomHostName();\n\n    this-&gt;whenConnectUsingHostName();\n    this-&gt;whenCancelAllSocketOperations();\n\n    // then process does not crash.\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, async_connect_is_cancelled_by_cancelling_write)\n{\n    this-&gt;givenSocketInConnectStage();\n\n    this-&gt;connection()-&gt;cancelIOSync(aio::etWrite);\n\n    this-&gt;thenSocketCanBeSafelyRemoved();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, async_connect_is_cancelled_by_pleaseStopSync)\n{\n    this-&gt;givenSocketInConnectStage();\n\n    this-&gt;connection()-&gt;pleaseStopSync();\n\n    this-&gt;thenSocketCanBeSafelyRemoved();\n}\n\n//---------------------------------------------------------------------------------------------\n// I/O data transfer tests.\n\nTYPED_TEST_P(StreamSocketAcceptance, transfer_async)\n{\n    constexpr int connectionCount = 7;\n\n    this-&gt;givenPingPongServer();\n    this-&gt;whenSendMultiplePingsViaMultipleConnections(connectionCount);\n    this-&gt;thenPongIsReceivedViaEachConnection();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, synchronous_server_receives_data)\n{\n    this-&gt;givenListeningSynchronousServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenSendRandomDataToServer();\n\n    this-&gt;thenServerReceivedData();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, synchronous_server_responds_to_request)\n{\n    this-&gt;givenSynchronousPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n\n    this-&gt;whenReadSocketInBlockingWay();\n    this-&gt;thenServerMessageIsReceived();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, recv_sync_with_wait_all_flag)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenSendAsyncRandomDataToServer();\n    this-&gt;whenServerReadsWithFlags(MSG_WAITALL);\n\n    this-&gt;thenServerReceivedData();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, recv_timeout_is_reported)\n{\n    this-&gt;givenSilentServer();\n    this-&gt;givenConnectedSocket();\n    this-&gt;setClientSocketRecvTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenReadSocketInBlockingWay();\n\n    this-&gt;thenClientSocketReportedTimedout();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, msg_dont_wait_flag_makes_recv_call_nonblocking)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenReadSocketInBlockingWayWithFlags(MSG_DONTWAIT);\n    this-&gt;thenClientSocketReported(SystemError::wouldBlock);\n\n    this-&gt;whenClientSendsPing();\n    this-&gt;whenReadSocketInBlockingWay();\n    this-&gt;thenServerMessageIsReceived();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, concurrent_recv_send_in_blocking_mode)\n{\n    if (this-&gt;hasLimitation(SocketTypeLimitation::noConcurrentBlockingIo))\n        GTEST_SKIP() &lt;&lt; &quot;Current socket type does not support concurrent blocking I/O&quot;;\n\n    this-&gt;whenSendDataConcurrentlyThroughConnectedSockets();\n    this-&gt;thenBothSocketsReceiveExpectedData();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, socket_is_reusable_after_recv_timeout)\n{\n    this-&gt;givenPingPongServer();\n\n    this-&gt;givenConnectedSocket();\n    this-&gt;setClientSocketRecvTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;startReadingConnectionAsync();\n    this-&gt;waitForConnectionRecvTimeout();\n\n    this-&gt;whenClientSentPingAsync();\n    this-&gt;thenServerMessageIsReceived();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, DISABLED_socket_is_reusable_after_send_timeout)\n{\n    if (this-&gt;hasLimitation(SocketTypeLimitation::notUsableAfterSendInterrupt))\n        GTEST_SKIP() &lt;&lt; &quot;Current socket type cannot be used further after send timeout&quot;;\n\n    this-&gt;givenClientConnectionTimedOutOnSend();\n\n    // Receiving data sent before timedOut.\n    this-&gt;thenConnectionHasBeenAccepted();\n    this-&gt;assertAcceptedConnectionReceivedAllSentData();\n\n    // Verifying that socket can be used after timedOut.\n    this-&gt;whenSendRandomDataToServer();\n    this-&gt;assertAcceptedConnectionReceivedAllSentData();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, sync_send_reports_timedOut)\n{\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;givenConnectedSocket();\n    this-&gt;setClientSocketSendTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenClientSendsRandomDataSynchronouslyUntilFailure();\n\n    this-&gt;thenClientSendTimesOutEventually();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, async_send_reports_timedOut)\n{\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;givenConnectedSocket();\n    this-&gt;setClientSocketSendTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenClientSendsRandomDataAsyncNonStop();\n\n    this-&gt;thenClientSendTimesOutEventually();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    all_data_sent_is_received_after_remote_end_closed_connection)\n{\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;givenConnectedSocket();\n\n    auto expectedData = this-&gt;whenSendRandomDataToServer();\n\n    // Ensuring that the SSL handshake is completed before the client connection is closed.\n    // Otherwise, the accepted connection may not be able to read (depends on SSL version).\n    this-&gt;thenConnectionHasBeenAccepted();\n    this-&gt;assertAcceptedConnectionReceived(expectedData.substr(0, 1));\n    expectedData = expectedData.substr(1);\n\n    this-&gt;whenClientConnectionIsClosed();\n\n    this-&gt;assertAcceptedConnectionReceived(expectedData);\n    this-&gt;assertAcceptedConnectionReceivedEof();\n    this-&gt;assertAcceptedConnectionReportsNotConnected();\n}\n\n//---------------------------------------------------------------------------------------------\n// I/O cancellation tests.\n\nTYPED_TEST_P(StreamSocketAcceptance, randomly_stopping_multiple_simultaneous_connections)\n{\n    this-&gt;givenListeningServerSocket(kTotalConnections);\n    this-&gt;givenRandomNameMappedToServerHostIp();\n\n    this-&gt;startMaximumConcurrentConnections(this-&gt;mappedEndpoint());\n\n    // TODO: #akolesnikov Refactor this test\n\n    int canCancelIndex = 0;\n    int cancelledConnectionsCount = 0;\n    NX_MUTEX_LOCKER lk(&amp;this-&gt;m_mutex);\n    while ((this-&gt;completedConnectionsCount() + cancelledConnectionsCount) &lt; kTotalConnections)\n    {\n        std::unique_ptr&lt;AbstractStreamSocket&gt; connectionToCancel;\n        if (this-&gt;m_connections.size() &gt; 1 &amp;&amp; (canCancelIndex &lt; this-&gt;startedConnectionsCount()))\n        {\n            auto connectionToCancelIter = this-&gt;m_connections.begin();\n            size_t index = nx::utils::random::number&lt;size_t&gt;(0, this-&gt;m_connections.size() - 1);\n            std::advance(connectionToCancelIter, index);\n            connectionToCancel = std::move(*connectionToCancelIter);\n            this-&gt;m_connections.erase(connectionToCancelIter);\n            canCancelIndex += /*index +*/ 1;\n        }\n        lk.unlock();\n        if (connectionToCancel)\n        {\n            connectionToCancel-&gt;pleaseStopSync();\n            connectionToCancel.reset();\n            ++cancelledConnectionsCount;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        lk.relock();\n    }\n\n    ASSERT_TRUE(this-&gt;m_connections.empty());\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, receive_timeout_change_is_not_ignored)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n    this-&gt;whenReceivedMessageFromServerAsync(\n        [this]()\n        {\n            this-&gt;setClientSocketRecvTimeout(std::chrono::milliseconds(1));\n            this-&gt;continueReceiving();\n        });\n\n    this-&gt;thenClientSocketReportedTimedout();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, socket_removed_while_receiving_data)\n{\n    this-&gt;givenSpamServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n    // The server starts sending random data.\n    this-&gt;whenReadSocketInBlockingWay();\n\n    this-&gt;whenClientConnectionIsClosed();\n\n    // then server has received an error and can be freed.\n}\n\n// TODO: #akolesnikov Modify and uncomment this test.\n// But, the use case is not valid in case of encryption\n// auto-detection is enabled on server side.\n//TYPED_TEST_P(StreamSocketAcceptance, server_sends_first)\n//{\n//    this-&gt;givenMessageServer();\n//    this-&gt;givenConnectedSocket();\n//\n//    this-&gt;whenReadClientSocket();\n\n//    this-&gt;thenServerMessageIsReceived();\n//}\n\nTYPED_TEST_P(StreamSocketAcceptance, cancel_io)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n    this-&gt;whenReceivedMessageFromServerAsync(\n        [this]()\n        {\n            this-&gt;connection()-&gt;cancelIOSync(aio::etNone);\n        });\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, socket_is_ready_for_io_after_read_cancellation)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    ASSERT_TRUE(this-&gt;connection()-&gt;setNonBlockingMode(true));\n    this-&gt;startReadingConnectionAsync();\n    this-&gt;connection()-&gt;cancelIOSync(aio::etRead);\n\n    this-&gt;assertConnectionCanDoSyncIo();\n    this-&gt;assertConnectionCanDoAsyncIo();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    socket_is_usable_after_exception_is_thrown_by_read_completion_handler)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n    this-&gt;whenReceivedMessageFromServerAsync([]() { throw std::runtime_error(&quot;test&quot;); });\n\n    this-&gt;assertConnectionCanDoSyncIo();\n    this-&gt;assertConnectionCanDoAsyncIo();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    exception_thrown_by_recv_handler_is_handled_properly_even_when_socket_was_removed)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenClientSentPing();\n\n    std::promise&lt;void&gt; done;\n    this-&gt;whenReceivedMessageFromServerAsync(\n        [this, &amp;done]()\n        {\n            this-&gt;whenClientConnectionIsClosed();\n\n            // Making sure we signal the promise after this handler completion.\n            SocketGlobals::instance().aioService().getCurrentAioThread()-&gt;post(\n                nullptr, [&amp;done]() { done.set_value(); });\n\n            throw std::runtime_error(&quot;test&quot;);\n        });\n\n    done.get_future().wait();\n\n    // assert process does not crash.\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    socket_is_usable_after_exception_is_thrown_by_send_completion_handler)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenSendAsyncRandomDataToServer([]() { throw std::runtime_error(&quot;test&quot;); });\n    this-&gt;whenServerReadsWithFlags(MSG_WAITALL);\n\n    this-&gt;thenServerReceivedData();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    exception_thrown_by_send_handler_is_handled_properly_even_when_socket_was_removed)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;givenConnectedSocket();\n\n    std::promise&lt;void&gt; done;\n\n    this-&gt;whenSendAsyncRandomDataToServer(\n        [this, &amp;done]()\n        {\n            this-&gt;whenClientConnectionIsClosed();\n\n            // Making sure we signal the promise after this handler completion.\n            SocketGlobals::instance().aioService().getCurrentAioThread()-&gt;post(\n                nullptr, [&amp;done]() { done.set_value(); });\n\n            throw std::runtime_error(&quot;test&quot;);\n        });\n\n    done.get_future().wait();\n\n    this-&gt;whenAcceptConnection();\n    this-&gt;thenConnectionHasBeenAccepted();\n    this-&gt;whenServerReadsSome();\n\n    // assert process does not crash.\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    socket_aio_thread_can_be_changed_after_io_cancellation_during_connect_completion)\n{\n    this-&gt;givenPingPongServer();\n\n    this-&gt;whenConnectToServer(\n        [this]()\n        {\n            this-&gt;connection()-&gt;cancelIOSync(aio::etNone);\n            this-&gt;connection()-&gt;bindToAioThread(\n                SocketGlobals::aioService().getRandomAioThread());\n\n            this-&gt;startReadingConnectionAsync();\n        });\n\n    this-&gt;thenSocketCanBeUsedForAsyncIo();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    socket_aio_thread_can_be_changed_after_io_cancellation_during_send_completion)\n{\n    this-&gt;givenPingPongServer();\n    this-&gt;givenConnectedSocket();\n    ASSERT_TRUE(this-&gt;connection()-&gt;setNonBlockingMode(true));\n    this-&gt;startReadingConnectionAsync();\n\n    this-&gt;whenClientSentPingAsync(\n        [this]()\n        {\n            this-&gt;connection()-&gt;cancelIOSync(aio::etNone);\n            this-&gt;connection()-&gt;bindToAioThread(\n                SocketGlobals::aioService().getRandomAioThread());\n\n            this-&gt;startReadingConnectionAsync();\n        });\n\n    this-&gt;thenServerMessageIsReceived();\n    this-&gt;thenSocketCanBeUsedForAsyncIo();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    change_aio_thread_of_accepted_connection)\n{\n    this-&gt;givenPingPongServer();\n\n    this-&gt;givenConnectedSocket();\n    this-&gt;startReadingConnectionAsync();\n    this-&gt;whenClientSentPingAsync();\n\n    this-&gt;thenServerMessageIsReceived();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, socket_is_usable_after_send_cancellation)\n{\n    if (this-&gt;hasLimitation(SocketTypeLimitation::notUsableAfterSendInterrupt))\n        GTEST_SKIP() &lt;&lt; &quot;Current socket type cannot be used further after send cancellation&quot;;\n\n    // SSL socket cannot recover from incomplete send.\n    // So, it can be ready for I/O or can report an error.\n    // Checking that it does not crash at least.\n\n    this-&gt;givenPingPongServer();\n\n    for (int i = 0; i &lt; 2; ++i)\n    {\n        this-&gt;givenConnectedSocket();\n\n        ASSERT_TRUE(this-&gt;connection()-&gt;setNonBlockingMode(true));\n        this-&gt;whenClientSendsPingAsync();\n        this-&gt;connection()-&gt;cancelIOSync(aio::etWrite);\n\n        if (i == 0)\n            this-&gt;doSyncIoUntilFirstFailure();\n        else\n            this-&gt;doAsyncIoUntilFirstFailure();\n    }\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, DISABLED_shutdown_interrupts_connect)\n{\n    this-&gt;givenConnectionBlockedInConnect();\n    this-&gt;whenInvokeShutdown();\n    this-&gt;thenConnectionOperationIsInterrupted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, shutdown_interrupts_send)\n{\n    this-&gt;givenConnectionBlockedInSend();\n    this-&gt;whenInvokeShutdown();\n    this-&gt;thenConnectionOperationIsInterrupted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, shutdown_interrupts_recv)\n{\n    this-&gt;givenConnectionBlockedInRecv();\n    this-&gt;whenInvokeShutdown();\n    this-&gt;thenConnectionOperationIsInterrupted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, shutdown_in_timer_interrupts_recv)\n{\n    this-&gt;givenConnectionBlockedInRecv();\n    this-&gt;whenInvokeShutdownInTimer();\n    this-&gt;thenConnectionOperationIsInterrupted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, pollable_is_valid_after_shutdown)\n{\n    this-&gt;givenSilentServer();\n    this-&gt;givenConnectedSocket();\n\n    this-&gt;whenInvokeShutdown();\n\n    this-&gt;thenPollableIsStillValid();\n}\n\n//-------------------------------------------------------------------------------------------------\n// Accepting side tests.\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    nonblocking_accept_reports_wouldBlock_if_no_incoming_connections)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;whenAcceptNonBlocking();\n    this-&gt;thenAcceptReported(SystemError::wouldBlock);\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, nonblocking_accept_actually_accepts_connections)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;givenConnectedSocket();\n    // E.g., for socket with encryption auto-detection\n    this-&gt;whenClientSentPing();\n\n    this-&gt;waitUntilConnectionIsAcceptedInNonBlockingMode();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    accepted_socket_is_in_blocking_mode_when_server_socket_is_nonblocking)\n{\n    this-&gt;givenListeningNonBlockingServerSocket();\n    this-&gt;whenConnectionIsAccepted();\n    this-&gt;assertAcceptedConnectionNonBlockingModeIs(false);\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    accepted_socket_is_in_blocking_mode_when_server_socket_is_blocking)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;whenConnectionIsAccepted();\n    this-&gt;assertAcceptedConnectionNonBlockingModeIs(false);\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    server_socket_accepts_many_connections_in_a_row)\n{\n    constexpr int connectionCount = 11;\n\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;whenEstablishMultipleConnectionsAsync(connectionCount);\n    this-&gt;thenEveryConnectionIsAccepted();\n}\n\nTYPED_TEST_P(\n    StreamSocketAcceptance,\n    server_socket_accepts_multiple_connections_found_in_socket_backlog)\n{\n    constexpr int connectionCount = 11;\n\n    this-&gt;givenListeningServerSocket();\n\n    this-&gt;whenEstablishMultipleConnectionsAsync(connectionCount);\n    this-&gt;whenStartAcceptingConnections();\n\n    this-&gt;thenEveryConnectionIsAccepted();\n}\n\n// TODO: #akolesnikov Following test is not relevant for MacosX since server socket there\n// has a queue of connect requests, not connections with fulfilled handshake.\n// Adapt for Mac or erase.\nTYPED_TEST_P(StreamSocketAcceptance, DISABLED_server_socket_listen_queue_size_is_used)\n{\n    constexpr int listenQueueSize =\n        AbstractStreamServerSocket::kDefaultBacklogSize + 11;\n\n    this-&gt;givenListeningServerSocket(listenQueueSize + 10);\n    this-&gt;whenEstablishMultipleConnectionsAsync(listenQueueSize);\n    this-&gt;thenEveryConnectionEstablishedSuccessfully();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, server_socket_accept_times_out)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;setServerSocketAcceptTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenAcceptConnection();\n\n    this-&gt;thenAcceptReported(SystemError::timedOut);\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, server_socket_accept_async_times_out)\n{\n    this-&gt;givenListeningNonBlockingServerSocket();\n    this-&gt;setServerSocketAcceptTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenAcceptConnectionAsync();\n\n    this-&gt;thenAcceptReported(SystemError::timedOut);\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, accept_async_on_blocking_socket_results_in_error)\n{\n    this-&gt;givenListeningServerSocket();\n    this-&gt;whenAcceptConnectionAsync();\n    this-&gt;thenAcceptFailed();\n}\n\n// TODO: #akolesnikov Delete or enable in NXLIB-338.\nTYPED_TEST_P(StreamSocketAcceptance, DISABLED_server_socket_can_be_freed_in_accept_handler)\n{\n    this-&gt;givenListeningNonBlockingServerSocket();\n    this-&gt;setServerSocketAcceptTimeout(std::chrono::milliseconds(1));\n\n    this-&gt;whenAcceptConnectionAsync(\n        [this]()\n        {\n            this-&gt;freeServerSocket();\n        });\n\n    this-&gt;thenAcceptReported(SystemError::timedOut);\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, accept_is_cancelled_with_cancelIo)\n{\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;whenCancelAccept();\n    this-&gt;thenNoConnectionCanBeAccepted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, accept_is_cancelled_with_pleaseStop)\n{\n    this-&gt;givenAcceptingServerSocket();\n    this-&gt;whenStopServerSocket();\n    this-&gt;thenNoConnectionCanBeAccepted();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, reuse_addr)\n{\n    auto server1 = this-&gt;createServerSocket();\n    ASSERT_TRUE(server1-&gt;setReuseAddrFlag(true));\n    ASSERT_TRUE(server1-&gt;bind(SocketAddress::anyAddress));\n\n    auto server2 = this-&gt;createServerSocket();\n    ASSERT_TRUE(server2-&gt;setReuseAddrFlag(true));\n    ASSERT_TRUE(server2-&gt;bind(\n        SocketAddress(HostAddress::localhost, server1-&gt;getLocalAddress().port)));\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, reuse_port)\n{\n    auto server1 = this-&gt;createServerSocket();\n    if (!server1-&gt;setReusePortFlag(true))\n    {\n        ASSERT_EQ(SystemError::unknownProtocolOption, SystemError::getLastOSErrorCode());\n        std::cout &lt;&lt; &quot;SO_REUSEPORT is unsupported. Skipping this test&quot; &lt;&lt; std::endl;\n        return;\n    }\n    ASSERT_TRUE(server1-&gt;bind(SocketAddress::anyPrivateAddress));\n\n    auto server2 = this-&gt;createServerSocket();\n    ASSERT_TRUE(server2-&gt;setReusePortFlag(true));\n    ASSERT_TRUE(server2-&gt;bind(server1-&gt;getLocalAddress()));\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, timer_works)\n{\n    this-&gt;givenClientSocket();\n    this-&gt;whenRegisterTimer();\n    this-&gt;thenTimerIsInvoked();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, timer_can_be_cancelled)\n{\n    this-&gt;givenClientSocket();\n\n    std::promise&lt;void&gt; done;\n    this-&gt;connection()-&gt;post(\n        [this, &amp;done]()\n        {\n            this-&gt;whenRegisterTimer();\n            this-&gt;whenCancelTimer();\n            done.set_value();\n        });\n    done.get_future().wait();\n\n    this-&gt;thenTimerIsNotInvoked();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, existing_timer_can_be_changed)\n{\n    this-&gt;givenClientSocket();\n\n    std::promise&lt;void&gt; done;\n    this-&gt;connection()-&gt;post(\n        [this, &amp;done]()\n        {\n            this-&gt;whenRegisterTimer(std::chrono::hours(24));\n            this-&gt;whenRegisterTimer(std::chrono::milliseconds(10));\n            done.set_value();\n        });\n    done.get_future().wait();\n\n    this-&gt;thenTimerIsInvoked();\n}\n\nTYPED_TEST_P(StreamSocketAcceptance, timer_can_be_rescheduled)\n{\n    using namespace std::chrono;\n\n    static constexpr auto kDelay = std::chrono::milliseconds(200);\n    static constexpr auto kRescheduleCount = 3;\n\n    // NOTE: In general case timers cannot be expected to shoot in time. They can shoot later.\n    // But, an early timer shot should not happen and is considered to be a bug.\n\n    this-&gt;givenClientSocket();\n\n    for (int i = 0; i &lt; kRescheduleCount; ++i)\n    {\n        this-&gt;whenRegisterTimer(kDelay);\n        std::this_thread::sleep_for(kDelay / (kRescheduleCount + 1));\n    }\n\n    const auto timerScheduleTime = steady_clock::now();\n    const auto expectedTimerSequence = this-&gt;whenRegisterTimer(kDelay);\n\n    while (this-&gt;thenTimerIsInvoked() != expectedTimerSequence) {}\n\n    // Early timer shot means that at least one of previous timers shots was not cancelled.\n    // Rounding up to compensate precision errors in nanosecond-resolution clock.\n    ASSERT_GE(\n        ceil&lt;milliseconds&gt;(steady_clock::now() - timerScheduleTime),\n        kDelay);\n}\n\nGTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(StreamSocketAcceptance);\nREGISTER_TYPED_TEST_SUITE_P(StreamSocketAcceptance,\n    DISABLED_receiveDelay,\n    sendDelay,\n\n    //---------------------------------------------------------------------------------------------\n    // Connect tests.\n    connect_uses_address_resolver,\n    connect_including_resolve_is_cancelled_correctly,\n    connect_including_resolving_unknown_name_is_cancelled_correctly,\n    async_connect_is_cancelled_by_cancelling_write,\n    async_connect_is_cancelled_by_pleaseStopSync,\n\n    //---------------------------------------------------------------------------------------------\n    // I/O data transfer tests.\n    transfer_async,\n    synchronous_server_receives_data,\n    synchronous_server_responds_to_request,\n    recv_sync_with_wait_all_flag,\n    recv_timeout_is_reported,\n    msg_dont_wait_flag_makes_recv_call_nonblocking,\n    concurrent_recv_send_in_blocking_mode,\n    socket_is_reusable_after_recv_timeout,\n\n    // This test doesn&#x27;t work for SSL connections because SSL_write doesn&#x27;t allow to send different\n    // data after SSL_ERROR_WANT_WRITE.\n    DISABLED_socket_is_reusable_after_send_timeout,\n\n    sync_send_reports_timedOut,\n    async_send_reports_timedOut,\n    all_data_sent_is_received_after_remote_end_closed_connection,\n\n    //---------------------------------------------------------------------------------------------\n    // I/O cancellation tests.\n    randomly_stopping_multiple_simultaneous_connections,\n    receive_timeout_change_is_not_ignored,\n    socket_removed_while_receiving_data,\n    cancel_io,\n    socket_is_ready_for_io_after_read_cancellation,\n    socket_is_usable_after_exception_is_thrown_by_read_completion_handler,\n    exception_thrown_by_recv_handler_is_handled_properly_even_when_socket_was_removed,\n    socket_is_usable_after_exception_is_thrown_by_send_completion_handler,\n    exception_thrown_by_send_handler_is_handled_properly_even_when_socket_was_removed,\n    socket_aio_thread_can_be_changed_after_io_cancellation_during_connect_completion,\n    socket_aio_thread_can_be_changed_after_io_cancellation_during_send_completion,\n    change_aio_thread_of_accepted_connection,\n    socket_is_usable_after_send_cancellation,\n\n    // This test is disabled because currently it does not work on Linux and Mac. In future, we may\n    // introduce connect implementation with shutdown support.\n    DISABLED_shutdown_interrupts_connect,\n\n    shutdown_interrupts_send,\n    shutdown_interrupts_recv,\n    shutdown_in_timer_interrupts_recv,\n    pollable_is_valid_after_shutdown,\n\n    //---------------------------------------------------------------------------------------------\n    // Accepting side tests.\n    nonblocking_accept_reports_wouldBlock_if_no_incoming_connections,\n    nonblocking_accept_actually_accepts_connections,\n    accepted_socket_is_in_blocking_mode_when_server_socket_is_nonblocking,\n    accepted_socket_is_in_blocking_mode_when_server_socket_is_blocking,\n    server_socket_accepts_many_connections_in_a_row,\n    server_socket_accepts_multiple_connections_found_in_socket_backlog,\n    DISABLED_server_socket_listen_queue_size_is_used,\n    server_socket_accept_times_out,\n    server_socket_accept_async_times_out,\n    accept_async_on_blocking_socket_results_in_error,\n    DISABLED_server_socket_can_be_freed_in_accept_handler,\n\n    accept_is_cancelled_with_cancelIo,\n    accept_is_cancelled_with_pleaseStop,\n\n    //---------------------------------------------------------------------------------------------\n    // Socket options.\n    reuse_addr,\n    reuse_port,\n\n    //---------------------------------------------------------------------------------------------\n    // Socket timer (AbstractCommunicatingSocket::registerTimer).\n    // Not to be confused with recv/send timeouts.\n    timer_works,\n    timer_can_be_cancelled,\n    timer_can_be_rescheduled,\n    existing_timer_can_be_changed\n);\n\n} // namespace test\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/synchronous_tcp_server.h": {"id": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/synchronous_tcp_server.h", "filePath": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/synchronous_tcp_server.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n\n#include &lt;nx/network/abstract_socket.h&gt;\n#include &lt;nx/utils/atomic_unique_ptr.h&gt;\n#include &lt;nx/utils/byte_stream/pipeline.h&gt;\n#include &lt;nx/utils/std/thread.h&gt;\n\nnamespace nx {\nnamespace network {\nnamespace test {\n\nclass NX_NETWORK_API SynchronousStreamSocketServer\n{\npublic:\n    /**\n     * Initializes regular TCP v4 server socket.\n     */\n    SynchronousStreamSocketServer();\n    SynchronousStreamSocketServer(\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket);\n    virtual ~SynchronousStreamSocketServer();\n\n    bool bindAndListen(const SocketAddress&amp; endpoint);\n    SocketAddress endpoint() const;\n    void start();\n    void stop();\n\n    void waitForAtLeastOneConnection();\n    AbstractStreamSocket* anyConnection();\n\nprotected:\n    virtual void processConnection(AbstractStreamSocket* connection) = 0;\n\n    bool isStopped() const;\n\nprivate:\n    nx::utils::thread m_thread;\n    std::unique_ptr&lt;AbstractStreamServerSocket&gt; m_serverSocket;\n    std::atomic&lt;bool&gt; m_stopped;\n    nx::utils::AtomicUniquePtr&lt;AbstractStreamSocket&gt; m_connection;\n\n    void threadMain();\n};\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_NETWORK_API BasicSynchronousReceivingServer:\n    public SynchronousStreamSocketServer\n{\n    using base_type = SynchronousStreamSocketServer;\n\npublic:\n    BasicSynchronousReceivingServer(\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket);\n\nprotected:\n    virtual void processConnection(AbstractStreamSocket* connection) override;\n\n    virtual void processDataReceived(\n        AbstractStreamSocket* connection,\n        const char* data,\n        int dataSize) = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Reads socket and pushes all received data to nx::utils::bstream::AbstractOutput.\n */\nclass NX_NETWORK_API SynchronousReceivingServer:\n    public BasicSynchronousReceivingServer\n{\n    using base_type = BasicSynchronousReceivingServer;\n\npublic:\n    SynchronousReceivingServer(\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket,\n        nx::utils::bstream::AbstractOutput* synchronousServerReceivedData);\n\nprotected:\n    virtual void processDataReceived(\n        AbstractStreamSocket* connection,\n        const char* data,\n        int dataSize) override;\n\nprivate:\n    nx::utils::bstream::AbstractOutput* m_synchronousServerReceivedData = nullptr;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Waits for a ping message on connection and responds with a pong message.\n */\nclass NX_NETWORK_API SynchronousPingPongServer:\n    public BasicSynchronousReceivingServer\n{\n    using base_type = BasicSynchronousReceivingServer;\n\npublic:\n    SynchronousPingPongServer(\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket,\n        const nx::Buffer&amp; ping,\n        const nx::Buffer&amp; pong);\n\nprotected:\n    virtual void processDataReceived(\n        AbstractStreamSocket* connection,\n        const char* data,\n        int dataSize) override;\n\nprivate:\n    const nx::Buffer m_ping;\n    const nx::Buffer m_pong;\n};\n\n//-------------------------------------------------------------------------------------------------\n\n/**\n * Starts sending an infinite stream of random data after receiving any data on the connection.\n */\nclass NX_NETWORK_API SynchronousSpamServer:\n    public BasicSynchronousReceivingServer\n{\n    using base_type = BasicSynchronousReceivingServer;\n\npublic:\n    SynchronousSpamServer(\n        std::unique_ptr&lt;AbstractStreamServerSocket&gt; serverSocket);\n\nprotected:\n    virtual void processDataReceived(\n        AbstractStreamSocket* connection,\n        const char* data,\n        int dataSize) override;\n};\n\n} // namespace test\n} // namespace network\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/argument_parser.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/argument_parser.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/argument_parser.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &lt;QtCore/QString&gt;\n\nnamespace nx {\n\n/**\n * Stand-alone &amp; simple function for parsing arguments.\n * Supports both &quot;-a value&quot; and &quot;--arg=value&quot; syntax. &quot;-&quot; and &quot;--&quot; are omitted.\n */\nclass NX_UTILS_API ArgumentParser\n{\npublic:\n    ArgumentParser(int argc = 0, const char* argv[] = nullptr);\n    ArgumentParser(const QStringList&amp; args);\n    ArgumentParser(ArgumentParser&amp;&amp;) = default;\n    ArgumentParser(const ArgumentParser&amp;) = default;\n\n    void parse(int argc, const char* argv[]);\n    void parse(const QStringList&amp; args);\n\n    bool read(const QString&amp; name, QString* const value) const;\n    bool read(const QString&amp; name, std::string* const value) const;\n    bool read(const QString&amp; name, int* const value) const;\n    bool read(const QString&amp; name, size_t* const value) const;\n    bool read(const QString&amp; name, double* const value) const;\n    /**\n     * sets the bool value to true or false if the argument name is one of:\n     * TRUE, true, T, t, 1, FALSE, false, F, f, 0\n     */\n    bool read(const QString&amp; name, bool* const value) const;\n\n    template&lt;typename ValueType = QString, typename MainName, typename ... AltNames&gt;\n    std::optional&lt;ValueType&gt; get(MainName mainName, AltNames ... altNames) const;\n\n    template&lt;typename ValueType = QString&gt;\n    std::optional&lt;ValueType&gt; get() const { return std::nullopt; }\n\n    bool contains(const QString&amp; name) const;\n\n    template&lt;typename Handler&gt;\n    void forEach(const QString&amp; name, const Handler&amp; handler) const;\n\n    std::multimap&lt;QString, QString&gt; allArgs() const;\n\n    /**\n     * @return Arguments without name in the order of appearance.\n     */\n    std::vector&lt;QString&gt; getPositionalArgs() const;\n\nprivate:\n    template&lt;typename ValueType = QString&gt;\n    std::optional&lt;ValueType&gt; getImpl(const QString&amp; name) const;\n\n    template&lt;typename ValueType = QString&gt;\n    std::optional&lt;ValueType&gt; getImpl(const char* name) const;\n\n    std::multimap&lt;QString, QString&gt; m_args;\n    std::vector&lt;QString&gt; m_positionalArgs;\n};\n\ntemplate&lt;typename ValueType, typename MainName, typename ... AltNames&gt;\nstd::optional&lt;ValueType&gt; ArgumentParser::get(MainName mainName, AltNames ... altNames) const\n{\n    if (const auto value = getImpl&lt;ValueType&gt;(std::forward&lt;MainName&gt;(mainName)))\n        return value;\n\n    return get&lt;ValueType&gt;(std::forward&lt;AltNames&gt;(altNames) ...);\n}\n\ntemplate&lt;typename Handler&gt;\nvoid ArgumentParser::forEach(const QString&amp; name, const Handler&amp; handler) const\n{\n    const auto range = m_args.equal_range(name);\n    for (auto it = range.first; it != range.second; it++)\n        handler(it-&gt;second);\n}\n\ntemplate&lt;typename ValueType&gt;\nstd::optional&lt;ValueType&gt; ArgumentParser::getImpl(const QString&amp; name) const\n{\n    ValueType value;\n    if (read(name, &amp;value))\n        return value;\n    else\n        return std::nullopt;\n}\n\ntemplate&lt;typename ValueType&gt;\nstd::optional&lt;ValueType&gt; ArgumentParser::getImpl(const char* name) const\n{\n    return get&lt;ValueType&gt;(QLatin1String(name));\n}\n\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx {\nnamespace utils {\n\n/** Async Operation Guard helps to synchronize async operations\n *  \\code\n *      const auto sharedGuard = m_asyncOperationGuard.sharedGuard();\n *      doAsyncOperation([sharedGuard]() {\n *          if (auto lock = sharedGuard-&gt;lock()) {\n *              // do stuff with object holding m_asyncOperationGuard safe\n *          }\n *      });\n *  \\endcode\n */\nclass NX_UTILS_API AsyncOperationGuard\n{\npublic:\n    AsyncOperationGuard();\n    /**\n     * Blocks while SharedGuard::Lock instance is alive.\n     */\n    ~AsyncOperationGuard();\n\n    /**\n     * The guard shall be passed in every async operation handler to be able to\n     * find out if master object has been deleted.\n     */\n    class NX_UTILS_API SharedGuard\n    {\n        friend class AsyncOperationGuard;\n\n        SharedGuard();\n        SharedGuard(const SharedGuard&amp;) = delete;\n        SharedGuard(SharedGuard&amp;&amp;) = delete;\n        SharedGuard&amp; operator=(const SharedGuard&amp;) = delete;\n        SharedGuard&amp; operator=(SharedGuard&amp;&amp;) = delete;\n\n    public:\n        /**\n         * This lock is supposed to be held as long as operation is in progress\n         * NOTE: the lock must be verified right after obtaining to find\n         * out if operation has been canceled.\n         */\n        class NX_UTILS_API Lock\n        {\n            friend class SharedGuard;\n\n            Lock(SharedGuard* sharedGuard);\n            Lock(const Lock&amp;) = delete;\n            Lock&amp; operator=(const Lock&amp;) = delete;\n            Lock&amp; operator=(Lock&amp;&amp;) = delete;\n\n        public:\n            Lock(Lock&amp;&amp; rhs) noexcept;\n            void unlock();\n            operator bool() const;\n            bool operator!() const;\n            ~Lock();\n\n        private:\n            SharedGuard* m_sharedGuard;\n            bool m_locked;\n        };\n\n        Lock lock();\n\n        /**\n         * Causes all further created lock be invalid.\n         */\n        void terminate();\n\n    private:\n        bool begin();\n        void end();\n\n        nx::Mutex m_mutex;\n        bool m_terminated;\n    };\n\n    const std::shared_ptr&lt;SharedGuard&gt;&amp; sharedGuard();\n\n    /**\n     * Terminates current async guard and creates a new one.\n     */\n    void reset();\n\n    /**\n     * Forward all of the sharedGuard public methods.\n     */\n    SharedGuard* operator-&gt;() const;\n\n    template &lt;typename Handler&gt;\n    auto wrap(Handler&amp;&amp; handler)\n    {\n        return [sharedGuard = m_sharedGuard, handler = std::forward&lt;Handler&gt;(handler)](\n            auto&amp;&amp;... args) mutable\n        {\n            if (const auto lock = sharedGuard-&gt;lock())\n                std::move(handler)(std::forward&lt;decltype(args)&gt;(args)...);\n        };\n    }\n\nprivate:\n    std::shared_ptr&lt;SharedGuard&gt; m_sharedGuard;\n};\n\n} // namespace utils\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n\nnamespace nx {\nnamespace utils {\n\n/**\n * Same as std::unique_ptr, but all operations with internal pointer are done atomically.\n */\ntemplate&lt;typename T&gt;\nclass AtomicUniquePtr\n{\n    typedef void (AtomicUniquePtr&lt;T&gt;::*bool_type)() const;\n    void this_type_does_not_support_comparisons() const {}\n\npublic:\n    AtomicUniquePtr(T* ptr = nullptr)\n    :\n        m_ptr(ptr)\n    {\n    }\n    template&lt;class D&gt;\n    AtomicUniquePtr(std::unique_ptr&lt;D&gt; ptr)\n    :\n        m_ptr(ptr.release())\n    {\n    }\n    AtomicUniquePtr(AtomicUniquePtr&amp;&amp; rhs)\n    {\n        auto ptr = rhs.m_ptr.exchange(nullptr);\n        m_ptr.store(ptr);\n    }\n    ~AtomicUniquePtr()\n    {\n        auto ptr = m_ptr.exchange(nullptr);\n        delete ptr;\n    }\n\n    void reset(T* ptr = nullptr)\n    {\n        auto oldPtr = m_ptr.exchange(ptr);\n        delete oldPtr;\n    }\n    T* release()\n    {\n        return m_ptr.exchange(nullptr);\n    }\n    T* get() const\n    {\n        return m_ptr.load();\n    }\n\n    template&lt;typename D&gt;\n    AtomicUniquePtr&amp; operator=(AtomicUniquePtr&lt;D&gt;&amp;&amp; rhs)\n    {\n        if (this == &amp;rhs)\n            return *this;\n\n        reset(rhs.release());\n        return *this;\n    }\n    template&lt;typename D&gt;\n    AtomicUniquePtr&amp; operator=(std::unique_ptr&lt;D&gt;&amp;&amp; rhs)\n    {\n        reset(rhs.release());\n        return *this;\n    }\n    T* operator-&gt;() const\n    {\n        return get();\n    }\n\n    T&amp; operator*()\n    {\n        return *get();\n    }\n\n    const T&amp; operator*() const\n    {\n        return *get();\n    }\n\n    operator bool_type() const\n    {\n        return m_ptr.load()\n            ? &amp;AtomicUniquePtr&lt;T&gt;::this_type_does_not_support_comparisons\n            : nullptr;\n    }\n\nprivate:\n    std::atomic&lt;T*&gt; m_ptr;\n};\n\ntemplate&lt;typename T, typename ... Param&gt;\nAtomicUniquePtr&lt;T&gt; make_atomic_unique(Param&amp;&amp; ... params)\n{\n    return AtomicUniquePtr&lt;T&gt;(new T(std::forward&lt;Param&gt;(params)...));\n}\n\n}   //utils\n}   //nx\n\nnamespace std {\n\ntemplate &lt;typename T&gt;\nstruct DependentFalse\n{\n    static constexpr bool value = false;\n};\n\ntemplate&lt;typename T&gt;\nvoid swap(nx::utils::AtomicUniquePtr&lt;T&gt;&amp; /*one*/, nx::utils::AtomicUniquePtr&lt;T&gt;&amp; /*two*/)\n{\n    // DependentFalse is needed for assert to work at template instantiation time, not at definition time.\n    static_assert(\n        DependentFalse&lt;T&gt;::value,\n        &quot;There is no swap implementation for nx::utils::AtomicUniquePtr yet. Use std::move&quot;);\n}\n\n} // namespace std\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;QtCore/QObject&gt;\n\n#include &quot;thread/mutex.h&quot;\n#include &quot;thread/wait_condition.h&quot;\n\nnamespace nx {\nnamespace utils {\n\nclass NX_UTILS_API Counter\n{\npublic:\n    class NX_UTILS_API ScopedIncrement\n    {\n    public:\n        ScopedIncrement() = default;\n        ScopedIncrement(Counter* const counter);\n        ScopedIncrement(ScopedIncrement&amp;&amp; right);\n        ScopedIncrement(const ScopedIncrement&amp; right);\n\n        ScopedIncrement&amp; operator=(ScopedIncrement&amp;&amp; right);\n\n        ~ScopedIncrement();\n\n    private:\n        Counter* m_counter = nullptr;\n    };\n\n    Counter(int initialCount = 0);\n    virtual ~Counter() = default;\n\n    /**\n     * Increments internal counter.\n     * Counter will be decremented when returned ScopedIncrement is destroyed.\n     */\n    ScopedIncrement getScopedIncrement();\n\n    /**\n     * Blocks until internal counter reaches zero.\n     */\n    void wait();\n\n    /**\n     * Blocks until internal counter reaches zero or timeout passes.\n     * @return true if counter has reached zero. false if timeout has passed.\n     */\n    bool waitFor(std::chrono::milliseconds timeout);\n\n    /**\n     * @return New counter value.\n     */\n    int increment();\n\n    /**\n     * @return New counter value.\n     */\n    virtual int decrement();\n\n    /**\n     * Provides current counter value. Usually, this value is of not much use, because it can be\n     * changed concurrently. But, it may still be useful to compare it against zero in some cases.\n     * @return Current value.\n     */\n    int value() const;\n\nprivate:\n    mutable nx::Mutex m_mutex;\n    nx::WaitCondition m_counterReachedZeroCondition;\n    int m_count;\n};\n\n//-------------------------------------------------------------------------------------------------\n\nclass NX_UTILS_API CounterWithSignal:\n    public QObject,\n    public Counter\n{\n    Q_OBJECT\n\n    using base_type = Counter;\n\npublic:\n    CounterWithSignal(int initialCount = 0, QObject* parent = NULL);\n\npublic slots:\n    virtual int decrement() override;\n\nsignals:\n    void reachedZero();\n};\n\n} // namespace utils\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/debug/allocation_analyzer.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/debug/allocation_analyzer.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/debug/allocation_analyzer.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\nnamespace nx::utils::debug {\n\nstruct AllocationAnalyzerImpl;\n\n/**\n * Should be used to selectively track allocations and report current allocations.\n * This class can be useful in cases when valgrind is too slow.\n * To use it invoke AllocationAnalyzer::recordObjectCreation(this) just after creating object\n * and AllocationAnalyzer::recordObjectDestruction(this) just before destruction.\n */\nclass NX_UTILS_API AllocationAnalyzer\n{\npublic:\n    AllocationAnalyzer(bool isEnabled = true);\n    virtual ~AllocationAnalyzer();\n\n    void recordObjectCreation(void* ptr);\n    void recordObjectDestruction(void* ptr);\n    void recordObjectMove(void* ptr);\n\n    /**\n     * @return Human-readable report which contains allocations stacks sorted by\n     * actual allocation count descending.\n     */\n    std::optional&lt;std::string&gt; generateReport() const;\n\nprivate:\n    std::atomic&lt;bool&gt; m_isEnabled{true};\n    std::unique_ptr&lt;AllocationAnalyzerImpl&gt; m_impl;\n};\n\n} // namespace nx::utils::debug\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/interruption_flag.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/interruption_flag.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/interruption_flag.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;thread&gt;\n\n#include &lt;boost/container/small_vector.hpp&gt;\n\nnamespace nx::utils {\n\n/**\n * InterruptionFlag and InterruptionFlag::Watcher are used to allow\n * &quot;this&quot; destruction in some event handler.\n *\n * Example:\n * @code{.cpp}\n * class SomeProtocolClient\n * {\n *     //..\n * private:\n *     //...\n *     InterruptionFlag m_destructionFlag;\n * }\n\n * void SomeProtocolClient::readFromSocket(...)\n * {\n *     //...\n *     InterruptionFlag::Watcher watcher(&amp;m_destructionFlag);\n *     eventHandler(); //this handler can free this object\n *     if (watcher.interrupted())\n *     {\n *         // &quot;this&quot; destroyed, or interrupt() was invoked,\n *         // but watcher is still valid since created on stack.\n *         return;\n *     }\n *     //...\n * }\n * @endcode\n */\nclass NX_UTILS_API InterruptionFlag\n{\npublic:\n    InterruptionFlag();\n\n    /**\n     * Invokes InterruptionFlag::interrupt().\n     */\n    virtual ~InterruptionFlag();\n\n    InterruptionFlag(const InterruptionFlag&amp;) = delete;\n    InterruptionFlag&amp; operator=(const InterruptionFlag&amp;) = delete;\n\n    /**\n     * After this call no Watcher will use InterruptionFlag.\n     * So, InterruptionFlag instance can be safely freed.\n     */\n    void interrupt();\n\n    /**\n     * NOTE: Multiple objects using same InterruptionFlag instance can be stacked.\n     */\n    class NX_UTILS_API Watcher\n    {\n    public:\n        Watcher(InterruptionFlag* const flag);\n        ~Watcher();\n\n        Watcher(const Watcher&amp;) = delete;\n        Watcher&amp; operator=(const Watcher&amp;) = delete;\n        Watcher(Watcher&amp;&amp;) = delete;\n        Watcher&amp; operator=(Watcher&amp;&amp;) = delete;\n\n        bool interrupted() const;\n\n    private:\n        bool m_interrupted = false;\n        InterruptionFlag* const m_objectDestructionFlag;\n    };\n\nprivate:\n    // The number of elements in this array is very low (e.g., one) at most times.\n    // Using 15 elements on all platforms - previously the MSVC implementation of std::basic_string\n    // was used and it&#x27;s in-place storage was 15 elements.\n    boost::container::small_vector&lt;bool*, 15&gt; m_watcherStates;\n    std::thread::id m_lastWatchingThreadId;\n\n    void pushWatcherState(bool* watcherState);\n    void popWatcherState(bool* watcherState);\n};\n\n} // namespace nx::utils\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/singleton.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/singleton.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/singleton.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;typeinfo&gt;\n\nclass NX_UTILS_API SingletonBase\n{\nprotected:\n    void printInstantiationError(const std::type_info&amp; typeInfo);\n};\n\n/**\n * Singleton base class that provides instance access, but does not manage the object&#x27;s lifetime,\n * just like a &lt;tt&gt;QApplication&lt;/tt&gt;. Derived classes must instantiate single s_instance member in\n * an appropriate translation unit. This member failed to be static inline as GCC and Clang produce\n * its duplicates in case of hidden visibility shared libraries.\n *\n * \\param Derived                       Actual type of the singleton, must be\n *                                      derived from this class.\n */\ntemplate&lt;class Derived&gt;\nclass Singleton: public SingletonBase\n{\npublic:\n    static Derived* instance()\n    {\n        return s_instance;\n    }\n\nprotected:\n    Singleton()\n    {\n        // Init global instance.\n        if (s_instance)\n            printInstantiationError(typeid(Derived));\n        else\n            s_instance = static_cast&lt;Derived*&gt;(this);\n    }\n\n    ~Singleton()\n    {\n        if (s_instance == this)\n            s_instance = nullptr;\n    }\n\nprivate:\n    #if defined(__clang__) &amp;&amp; defined(_MSC_VER)\n    static inline NX_FORCE_EXPORT Derived* s_instance = nullptr;\n    #else\n    static NX_FORCE_EXPORT Derived* s_instance;\n    #endif\n};\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;future&gt; //for some enums\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;optional&gt;\n#include &lt;stdexcept&gt;\n#include &lt;system_error&gt;\n\n#include &lt;nx/utils/std/cpp14.h&gt;\n\nnamespace nx {\nnamespace utils {\n\n//enum class future_status\n//{\n//    ready,\n//    timeout,\n//    deferred\n//};\n//\n//enum class future_errc\n//{\n//    broken_promise,\n//    future_already_retrieved,\n//    promise_already_satisfied,\n//    no_state\n//};\n\n//class future_error\n//:\n//    public std::logic_error\n//{\n//public:\n//    future_error(std::error_code ec)\n//    {\n//    }\n//\n//    virtual const char* what() const;\n//    const std::error_code&amp; code() const;\n//};\n\n\nnamespace detail {\n\ntemplate&lt;typename T&gt;\nclass shared_future_state_base\n{\npublic:\n    shared_future_state_base()\n    :\n        m_satisfied(false)\n    {\n    }\n\n    shared_future_state_base(const shared_future_state_base&amp;) = delete;\n    shared_future_state_base&amp; operator=(const shared_future_state_base&amp;) = delete;\n\n    void abandon()\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n\n        if (m_satisfied)\n            return;\n        //storing exception\n        set_exception(\n            lk,\n            std::make_exception_ptr(\n                std::future_error(std::future_errc::broken_promise)));\n    }\n\n    void set_exception(std::exception_ptr p)\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n        set_exception(\n            lk,\n            std::move(p));\n        m_cond.notify_all();\n    }\n\n    void wait() const\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n        wait(lk);\n    }\n\n    template&lt;class Rep, class Period&gt;\n    std::future_status wait_for(\n        const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration) const\n    {\n        return wait_until(std::chrono::steady_clock::now() + timeout_duration);\n    }\n\n    template&lt;class Clock, class Duration&gt;\n    std::future_status wait_until(\n        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time) const\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n        while (!m_satisfied)\n        {\n            if (m_cond.wait_until(lk, timeout_time) == std::cv_status::timeout)\n                return std::future_status::timeout;\n        }\n        return std::future_status::ready;\n    }\n\nprotected:\n    bool m_satisfied;\n    mutable std::mutex m_mutex;\n    mutable std::condition_variable m_cond;\n    std::optional&lt;std::exception_ptr&gt; m_exception;\n\n    void wait(std::unique_lock&lt;std::mutex&gt;&amp; lk) const\n    {\n        m_cond.wait(\n            lk,\n            [this] { return m_satisfied; });\n    }\n\n    void set_exception(\n        std::unique_lock&lt;std::mutex&gt;&amp; /*lk*/,\n        std::exception_ptr p)\n    {\n        if (m_satisfied)\n            throw std::future_error(std::future_errc::promise_already_satisfied);\n        m_exception = std::move(p);\n        m_satisfied = true;\n        m_cond.notify_all();\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass shared_future_state\n:\n    public shared_future_state_base&lt;T&gt;\n{\npublic:\n    template&lt;class RRef&gt;\n    void set_value(RRef&amp;&amp; value)\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(this-&gt;m_mutex);\n        if (this-&gt;m_satisfied)\n            throw std::future_error(std::future_errc::promise_already_satisfied);\n        m_value = std::forward&lt;RRef&gt;(value);\n        this-&gt;m_satisfied = true;\n        this-&gt;m_cond.notify_all();\n    }\n\n    T get()\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(this-&gt;m_mutex);\n        this-&gt;wait(lk);\n        if (this-&gt;m_exception)\n        {\n            auto except = std::move(*this-&gt;m_exception);\n            this-&gt;m_exception.reset();\n            std::rethrow_exception(std::move(except));\n        }\n        auto value = std::move(*m_value);\n        m_value.reset();\n        return value;\n    }\n\nprivate:\n    std::optional&lt;T&gt; m_value;\n};\n\ntemplate&lt;&gt;\nclass shared_future_state&lt;void&gt;\n:\n    public shared_future_state_base&lt;void&gt;\n{\npublic:\n    void set_value()\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n        if (m_satisfied)\n            throw std::future_error(std::future_errc::promise_already_satisfied);\n        m_satisfied = true;\n        m_cond.notify_all();\n    }\n\n    void get()\n    {\n        std::unique_lock&lt;std::mutex&gt; lk(m_mutex);\n        wait(lk);\n        if (m_exception)\n        {\n            auto except = std::move(*m_exception);\n            m_exception.reset();\n            std::rethrow_exception(std::move(except));\n            return;\n        }\n        return;\n    }\n};\n\n}   // namespace detail\n\n\ntemplate&lt;typename T&gt;\nclass future\n{\n    typedef detail::shared_future_state&lt;T&gt; SharedStateType;\n\npublic:\n    future()\n    {\n    }\n\n    future(std::shared_ptr&lt;SharedStateType&gt; sharedStatePtr)\n    :\n        m_sharedState(std::move(sharedStatePtr))\n    {\n    }\n\n    future(future&amp;&amp; other)\n    :\n        m_sharedState(std::move(other.m_sharedState))\n    {\n        other.m_sharedState.reset();\n    }\n\n    future(const future&amp; other) = delete;\n\n    ~future()\n    {\n    }\n\n    future&amp; operator=(future&amp;&amp; other)\n    {\n        m_sharedState = std::move(other.m_sharedState);\n        other.m_sharedState.reset();\n        return *this;\n    }\n\n    T get()\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        auto sharedState = std::move(m_sharedState);\n        m_sharedState.reset();\n        return sharedState-&gt;get();\n    }\n\n    bool valid() const noexcept\n    {\n        return m_sharedState != nullptr;\n    }\n\n    void wait() const\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        m_sharedState-&gt;wait();\n    }\n\n    template&lt;class Rep, class Period&gt;\n    std::future_status wait_for(\n        const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration) const\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        return m_sharedState-&gt;wait_for(timeout_duration);\n    }\n\n    template&lt;class Clock, class Duration&gt;\n    std::future_status wait_until(\n        const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time) const\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        return m_sharedState-&gt;wait_until(timeout_time);\n    }\n\nprivate:\n    std::shared_ptr&lt;SharedStateType&gt; m_sharedState;\n};\n\ntemplate&lt;class R&gt;\nclass promise_base\n{\n    typedef detail::shared_future_state&lt;R&gt; SharedStateType;\n\npublic:\n    promise_base()\n    :\n        m_sharedState(std::make_shared&lt;SharedStateType&gt;()),\n        m_futureAlreadyRetrieved(false)\n    {\n    }\n\n    promise_base(promise_base&amp;&amp; other)\n    :\n        m_sharedState(std::move(other.m_sharedState)),\n        m_futureAlreadyRetrieved(other.m_futureAlreadyRetrieved)\n    {\n        other.m_sharedState.reset();\n        other.m_futureAlreadyRetrieved = false;\n    }\n    promise_base(const promise_base&amp; other) = delete;\n\n    ~promise_base()\n    {\n        if (m_sharedState)\n            m_sharedState-&gt;abandon();\n    }\n\n    promise_base&amp; operator=(promise_base&amp;&amp; other)\n    {\n        m_sharedState = std::move(other.m_sharedState);\n        m_futureAlreadyRetrieved = other.m_futureAlreadyRetrieved;\n\n        other.m_sharedState.reset();\n        other.m_futureAlreadyRetrieved = false;\n        return *this;\n    }\n\n    void swap(promise_base&amp; other)\n    {\n        auto tmpState = std::move(other.m_sharedState);\n        other.m_sharedState = std::move(m_sharedState);\n        m_sharedState = std::move(tmpState);\n        std::swap(m_futureAlreadyRetrieved, other.m_futureAlreadyRetrieved);\n    }\n\n    future&lt;R&gt; get_future()\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        if (m_futureAlreadyRetrieved)\n            throw std::future_error(std::future_errc::future_already_retrieved);\n        m_futureAlreadyRetrieved = true;\n        return future&lt;R&gt;(m_sharedState);\n    }\n\n    void set_exception(std::exception_ptr p)\n    {\n        if (!m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        m_sharedState-&gt;set_exception(std::move(p));\n    }\n\nprotected:\n    std::shared_ptr&lt;SharedStateType&gt; m_sharedState;\n    bool m_futureAlreadyRetrieved;\n};\n\ntemplate&lt;class R&gt;\nclass promise\n:\n    public promise_base&lt;R&gt;\n{\npublic:\n    promise() = default;\n    promise(promise&amp;&amp;) = default;\n    promise&amp; operator=(promise&amp;&amp;) = default;\n\n    void set_value(const R&amp; value)\n    {\n        if (!this-&gt;m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        this-&gt;m_sharedState-&gt;set_value(value);\n    }\n\n    void set_value(R&amp;&amp; value)\n    {\n        if (!this-&gt;m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        this-&gt;m_sharedState-&gt;set_value(std::move(value));\n    }\n};\n\ntemplate&lt;&gt;\nclass promise&lt;void&gt;\n:\n    public promise_base&lt;void&gt;\n{\npublic:\n    promise() = default;\n    promise(promise&amp;&amp;) = default;\n    promise&amp; operator=(promise&amp;&amp;) = default;\n\n    void set_value()\n    {\n        if (!this-&gt;m_sharedState)\n            throw std::future_error(std::future_errc::no_state);\n        this-&gt;m_sharedState-&gt;set_value();\n    }\n};\n\n\n//TODO std::swap(promise_base&amp; one, promise_base&amp; two);\n\n//TODO promise_base&lt;void&gt;\n\n}   // namespace utils\n}   // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;system_error&gt;\n#include &lt;thread&gt;\n\n#include &lt;QtCore/QThread&gt;\n\n#include &lt;nx/utils/std/cpp14.h&gt;\n\n#include &quot;../move_only_func.h&quot;\n#include &quot;../type_utils.h&quot;\n#include &quot;future.h&quot;\n\nnamespace nx {\nnamespace utils {\n\nnamespace detail {\n\nclass NX_UTILS_API thread\n:\n    public QThread\n{\npublic:\n    thread(nx::MoveOnlyFunc&lt;void()&gt; threadFunc) noexcept(false);\n    thread(const thread&amp;) = delete;\n    thread&amp; operator=(const thread&amp;) = delete;\n\n    void join() noexcept(false);\n    std::thread::id get_id() const;\n    uintptr_t native_handle() const;\n\nprivate:\n    virtual void run() override;\n\nprivate:\n    promise&lt;void&gt; m_idFilledPromise;\n    promise&lt;void&gt; m_threadCanBeStarted;\n    std::thread::id m_id;\n    uintptr_t m_nativeHandle;\n    nx::MoveOnlyFunc&lt;void()&gt; m_threadFunc;\n};\n\n}   //namespace detail\n\nclass NX_UTILS_API thread\n{\npublic:\n    typedef std::thread::id id;\n    typedef std::thread::native_handle_type native_handle_type;\n\n    thread() noexcept {}\n    thread(thread&amp;&amp; other) noexcept;\n\n    template&lt; class Function, class... Args &gt;\n        explicit thread(Function&amp;&amp; f, Args&amp;&amp;... args) noexcept(false)\n    {\n        auto argsTuple = std::make_tuple(std::forward&lt;Args&gt;(args)...);\n        m_actualThread = std::make_unique&lt;detail::thread&gt;(\n            [f1 = std::forward&lt;Function&gt;(f), argsTuple = std::move(argsTuple)]() mutable\n            {\n                expandTupleIntoArgs(std::move(f1), std::move(argsTuple));\n            });\n    }\n\n    thread(const thread&amp;) = delete;\n    ~thread();\n    thread&amp; operator=(thread&amp;&amp; other) noexcept;\n\n    bool joinable() const noexcept;\n    id get_id() const noexcept;\n    native_handle_type native_handle() noexcept;\n    void join() noexcept(false);\n    void detach() noexcept (false);\n    void swap(thread&amp; other) noexcept;\n\n    static unsigned int hardware_concurrency() noexcept;\n\nprivate:\n    std::unique_ptr&lt;detail::thread&gt; m_actualThread;\n};\n\nclass NX_UTILS_API DetachedThreads\n{\npublic:\n    DetachedThreads();\n    ~DetachedThreads();\n\n    void addThread(std::unique_ptr&lt;detail::thread&gt; thread);\n\nprivate:\n    utils::promise&lt;void&gt; m_stopPromise;\n    std::mutex m_mutex;\n    std::list&lt;std::unique_ptr&lt;detail::thread&gt;&gt; m_garbage;\n    thread m_collector;\n};\n\n}   //namespace utils\n}   //namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;memory&gt;\n\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/std/cpp14.h&gt;\n#include &lt;nx/utils/thread/mutex.h&gt;\n\nnamespace nx {\nnamespace utils {\nnamespace bstream {\n\nnamespace StreamIoError {\n\n/**\n * Use SystemError::getLastOSErrorCode() to receive error detail.\n */\nconstexpr int osError = -1;\nconstexpr int wouldBlock = -2;\nconstexpr int nonRecoverableError = -3;\n\n} // namespace StreamIoError\n\n/**\n * Interface of class that can be used as an output for some byte stream.\n * E.g., it can write stream to some file or send via network.\n */\nclass NX_UTILS_API AbstractOutput\n{\npublic:\n    virtual ~AbstractOutput() = default;\n\n    /**\n     * @return Bytes written. In case of failure one of StreamIoError* values.\n     */\n    virtual int write(const void* data, size_t count) = 0;\n};\n\nclass NX_UTILS_API AbstractInput\n{\npublic:\n    virtual ~AbstractInput() = default;\n\n    /**\n     * @return Bytes read. In case of failure one of StreamIoError* values.\n     */\n    virtual int read(void* data, size_t count) = 0;\n};\n\n//-------------------------------------------------------------------------------------------------\n// Converters.\n\n/**\n * Output that converts byte stream and passes it to another output.\n * Can be used to organize chains of converters.\n */\nclass NX_UTILS_API AbstractOutputConverter:\n    public AbstractOutput\n{\npublic:\n    virtual void setOutput(AbstractOutput*);\n\nprotected:\n    AbstractOutput* m_outputStream = nullptr;\n};\n\n// TODO: #akolesnikov It makes sense to remove AbstractInputConverter and make Converter implement only\n// AbstractOutput.\n\nclass NX_UTILS_API AbstractInputConverter:\n    public AbstractInput\n{\npublic:\n    virtual void setInput(AbstractInput*);\n\nprotected:\n    AbstractInput* m_inputStream = nullptr;\n};\n\n/**\n * Interface of class that allows byte stream in both directions while converting it if needed.\n */\nclass NX_UTILS_API AbstractTwoWayConverter:\n    public AbstractInputConverter,\n    public AbstractOutputConverter\n{\n};\n\n// TODO: #akolesnikov Get rid of this class.\nclass NX_UTILS_API Converter:\n    public AbstractTwoWayConverter\n{\npublic:\n    virtual bool eof() const = 0;\n    virtual bool failed() const = 0;\n};\n\n/**\n * By default, just forwards data without any conversion.\n * Conversion can be enabled by setting converters with\n * CompositeConverter::setInputConverter and CompositeConverter::setOutputConverter.\n */\nclass NX_UTILS_API CompositeConverter:\n    public Converter\n{\n    using base_type = Converter;\n\npublic:\n    virtual int write(const void* data, size_t size) override;\n    virtual int read(void* data, size_t size) override;\n\n    virtual void setOutput(AbstractOutput*) override;\n    virtual void setInput(AbstractInput*) override;\n\n    virtual bool eof() const override;\n    virtual bool failed() const override;\n\n    void setInputConverter(AbstractInputConverter* inputConverter);\n    void setOutputConverter(AbstractOutputConverter* outputConverter);\n\nprivate:\n    AbstractInputConverter* m_inputConverter = nullptr;\n    AbstractOutputConverter* m_outputConverter = nullptr;\n};\n\n/**\n * Input stream that transfers all data through a converter.\n */\nclass NX_UTILS_API OutputConverterToInputAdapter:\n    public AbstractInputConverter,\n    private AbstractOutput\n{\npublic:\n    OutputConverterToInputAdapter(AbstractOutputConverter* converter);\n\n    virtual int read(void* data, size_t count) override;\n\nprivate:\n    AbstractOutputConverter* m_converter = nullptr;\n    std::string m_convertedData;\n\n    virtual int write(const void* data, size_t size) override;\n\n    int readCachedData(void* data, size_t count);\n};\n\n//-------------------------------------------------------------------------------------------------\n// ProxyConverter\n\n/**\n * Just forwards every call to another object.\n */\nclass NX_UTILS_API ProxyConverter:\n    public Converter\n{\n    using base_type = Converter;\n\npublic:\n    ProxyConverter(Converter* delegate);\n\n    virtual int read(void* data, size_t count) override;\n    virtual int write(const void* data, size_t count) override;\n\n    virtual void setInput(AbstractInput*) override;\n    virtual void setOutput(AbstractOutput*) override;\n\n    virtual bool eof() const override;\n    virtual bool failed() const override;\n\n    void setDelegate(Converter* delegate);\n\nprivate:\n    Converter* m_delegate;\n};\n\n//-------------------------------------------------------------------------------------------------\n// Pipe\n\n/**\n * Data that is written to object of this class with AbstractOutput::write,\n * becomes available through AbstractInput::read.\n */\nclass NX_UTILS_API Pipe:\n    public AbstractInput, public AbstractOutput\n{\npublic:\n    Pipe(nx::Buffer initialData = nx::Buffer());\n\n    virtual int write(const void* data, size_t count) override;\n    /**\n     * Reads data that has previously been written with Pipe::write.\n     */\n    virtual int read(void* data, size_t count) override;\n    nx::Buffer readAll();\n\n    /**\n     * @param maxSize 0 - no limit.\n     */\n    void setMaxBufferSize(std::size_t maxSize);\n\n    /**\n     * Total of bytes written and read.\n     */\n    std::size_t totalBytesThrough() const;\n\n    nx::Buffer internalBuffer() const;\n\n    /**\n     * Subsequent read operation will report read error after depleting internal buffer.\n     */\n    void writeEof();\n\nprivate:\n    mutable nx::Mutex m_mutex;\n    nx::Buffer m_buffer;\n    std::size_t m_totalBytesThrough;\n    std::size_t m_maxSize;\n    bool m_eof;\n};\n\n//-------------------------------------------------------------------------------------------------\n// RandomDataSource\n\nclass NX_UTILS_API RandomDataSource:\n    public AbstractInput\n{\npublic:\n    static constexpr std::size_t kDefaultMinReadSize = 4*1024;\n    static constexpr std::size_t kDefaultMaxReadSize = 64*1024;\n\n    RandomDataSource();\n\n    virtual int read(void* data, size_t count) override;\n\nprivate:\n    const std::pair&lt;std::size_t, std::size_t&gt; m_readSizeRange;\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename WriteFunc&gt;\nclass CustomOutput:\n    public AbstractOutput\n{\npublic:\n    template&lt;typename WriteFuncRef&gt;\n    CustomOutput(WriteFuncRef&amp;&amp; func):\n        m_func(std::forward&lt;WriteFuncRef&gt;(func))\n    {\n    }\n\n    virtual int write(const void* data, size_t count) override\n    {\n        return m_func(data, count);\n    }\n\nprivate:\n    WriteFunc m_func;\n};\n\ntemplate&lt;typename WriteFunc&gt;\nstd::unique_ptr&lt;CustomOutput&lt;WriteFunc&gt;&gt; makeCustomOutput(WriteFunc func)\n{\n    return std::make_unique&lt;CustomOutput&lt;WriteFunc&gt;&gt;(std::move(func));\n}\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename WriteFunc&gt;\nclass CustomInput:\n    public AbstractInput\n{\npublic:\n    template&lt;typename WriteFuncRef&gt;\n    CustomInput(WriteFuncRef&amp;&amp; func):\n        m_func(std::forward&lt;WriteFuncRef&gt;(func))\n    {\n    }\n\n    virtual int read(void* data, size_t count) override\n    {\n        return m_func(data, count);\n    }\n\nprivate:\n    WriteFunc m_func;\n};\n\ntemplate&lt;typename ReadFunc&gt;\nstd::unique_ptr&lt;CustomInput&lt;ReadFunc&gt;&gt; makeCustomInput(ReadFunc func)\n{\n    return std::make_unique&lt;CustomInput&lt;ReadFunc&gt;&gt;(std::move(func));\n}\n\n} // namespace bstream\n} // namespace utils\n} // namespace nx\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;atomic&gt;\n#include &lt;deque&gt;\n#include &lt;functional&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;nx/utils/thread/mutex.h&gt;\n#include &lt;nx/utils/thread/wait_condition.h&gt;\n\nnamespace nx {\nnamespace utils {\n\nusing QueueReaderId = std::size_t;\n\nstatic const QueueReaderId kInvalidQueueReaderId = (QueueReaderId)-1;\n\ntemplate&lt;typename Result&gt;\nclass SyncQueueBase\n{\npublic:\n    using ResultType = Result;\n\n    using OptionalResultType = std::conditional_t&lt;\n        std::is_same_v&lt;Result, void&gt;,\n        bool,\n        std::optional&lt;Result&gt;&gt;;\n\n    SyncQueueBase();\n\n    QueueReaderId generateReaderId();\n\n    ResultType pop();\n\n    OptionalResultType pop(QueueReaderId readerId);\n\n    OptionalResultType pop(\n        std::optional&lt;std::chrono::milliseconds&gt; timeout,\n        QueueReaderId readerId = kInvalidQueueReaderId);\n\n    /**\n     * Extracts queue element that satisfies conditionFunc.\n     * Note: has O(n) run-time complexity.\n     */\n    template&lt;typename ConditionFunc&gt;\n    OptionalResultType popIf(\n        ConditionFunc conditionFunc,\n        std::optional&lt;std::chrono::milliseconds&gt; timeout = std::nullopt,\n        QueueReaderId readerId = kInvalidQueueReaderId);\n\n    bool isEmpty();\n    bool empty() const;\n    std::size_t size() const;\n    void clear();\n    void retestPopIfCondition();\n\n    /**\n     * While reader is in terminated status, all pop operations with readerId\n     * supplied return immediately without value.\n     * WARNING: It is highly recommended to call SyncQueue::removeReaderFromTerminatedList\n     * after termination has been completed (e.g., reader thread has stopped) to prevent\n     * &quot;terminated reader list&quot; from holding redundant information.\n     */\n    void addReaderToTerminatedList(QueueReaderId readerId);\n    void removeReaderFromTerminatedList(QueueReaderId readerId);\n\nprotected:\n    using StorageType = std::conditional_t&lt;\n        std::is_same_v&lt;Result, void&gt;,\n        bool, // dummy type\n        Result&gt;;\n\n    mutable nx::Mutex m_mutex;\n    nx::WaitCondition m_condition;\n    std::deque&lt;StorageType&gt; m_queue;\n    std::set&lt;QueueReaderId&gt; m_terminatedReaders;\n    std::atomic&lt;QueueReaderId&gt; m_prevReaderId;\n\n    bool waitForNonEmptyQueue(\n        nx::Locker&lt;nx::Mutex&gt;* lock,\n        std::optional&lt;std::chrono::steady_clock::time_point&gt; deadline,\n        QueueReaderId readerId);\n\n    bool waitForEvent(\n        nx::Locker&lt;nx::Mutex&gt;* lock,\n        std::optional&lt;std::chrono::steady_clock::time_point&gt; deadline);\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename Result&gt;\nclass SyncQueue:\n    public SyncQueueBase&lt;Result&gt;\n{\n    using base_type = SyncQueueBase&lt;Result&gt;;\n\npublic:\n    using base_type::base_type;\n\n    void push(Result value);\n\n    /**\n     * Constructs Result in-place.\n     */\n    template&lt;typename... Args&gt;\n    void emplace(Args&amp;&amp;... args);\n\n    std::function&lt;void(Result)&gt; pusher();\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;&gt;\nclass SyncQueue&lt;void&gt;:\n    public SyncQueueBase&lt;void&gt;\n{\n    using base_type = SyncQueueBase&lt;void&gt;;\n\npublic:\n    using base_type::base_type;\n\n    void push()\n    {\n        NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n        const auto wasEmpty = this-&gt;m_queue.empty();\n\n        this-&gt;m_queue.push_back(/*dummy*/ true);\n        if (wasEmpty)\n            this-&gt;m_condition.wakeOne();\n    }\n\n    std::function&lt;void()&gt; pusher()\n    {\n        return [this]() { push(); };\n    }\n};\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename R1, typename R2&gt;\nclass SyncMultiQueue:\n    public SyncQueue&lt;std::pair&lt;R1, R2&gt;&gt;\n{\npublic:\n    void push(R1 r1, R2 r2) /* overlap */;\n    std::function&lt;void(R1, R2)&gt; pusher() /* overlap */;\n};\n\n//-------------------------------------------------------------------------------------------------\n// Implementation.\n\ntemplate&lt;typename Result&gt;\nSyncQueueBase&lt;Result&gt;::SyncQueueBase():\n    m_prevReaderId(0)\n{\n}\n\ntemplate&lt;typename Result&gt;\nQueueReaderId SyncQueueBase&lt;Result&gt;::generateReaderId()\n{\n    return ++m_prevReaderId;\n}\n\ntemplate&lt; typename Result&gt;\nResult SyncQueueBase&lt;Result&gt;::pop()\n{\n    auto value = pop(std::nullopt);\n    NX_ASSERT(value);\n\n    if constexpr (!std::is_same_v&lt;Result, void&gt;)\n    {\n        auto res = std::move(*value);\n        return res;\n    }\n    else\n        return;\n}\n\ntemplate&lt; typename Result&gt;\ntypename SyncQueueBase&lt;Result&gt;::OptionalResultType SyncQueueBase&lt;Result&gt;::pop(QueueReaderId readerId)\n{\n    return pop(std::nullopt, readerId);\n}\n\ntemplate&lt; typename Result&gt;\ntypename SyncQueueBase&lt;Result&gt;::OptionalResultType SyncQueueBase&lt;Result&gt;::pop(\n    std::optional&lt;std::chrono::milliseconds&gt; timeout,\n    QueueReaderId readerId)\n{\n    return popIf([](const StorageType&amp;) { return true; }, timeout, readerId);\n}\n\ntemplate&lt;typename Result&gt;\ntemplate&lt;typename ConditionFunc&gt;\ntypename SyncQueueBase&lt;Result&gt;::OptionalResultType SyncQueueBase&lt;Result&gt;::popIf(\n    ConditionFunc conditionFunc,\n    std::optional&lt;std::chrono::milliseconds&gt; timeout,\n    QueueReaderId readerId)\n{\n    using namespace std::chrono;\n\n    NX_MUTEX_LOCKER lock(&amp;m_mutex);\n\n    std::optional&lt;steady_clock::time_point&gt; deadline;\n    if (timeout)\n        deadline = steady_clock::now() + *timeout;\n\n    for (;;)\n    {\n        if (!waitForNonEmptyQueue(&amp;lock, deadline, readerId))\n            return OptionalResultType();\n\n        auto resultIter = std::find_if(m_queue.begin(), m_queue.end(), conditionFunc);\n        if (resultIter != m_queue.end())\n        {\n            auto result = std::move(*resultIter);\n            m_queue.erase(resultIter);\n            return result;\n        }\n\n        // Could not find satisfying element - waiting for an event or for a new element.\n        if (!waitForEvent(&amp;lock, deadline))\n            return OptionalResultType(); // std::nullopt or false.\n    }\n}\n\ntemplate&lt; typename Result&gt;\nbool SyncQueueBase&lt;Result&gt;::isEmpty()\n{\n    NX_MUTEX_LOCKER lock( &amp;m_mutex );\n    return m_queue.empty();\n}\n\ntemplate&lt; typename Result&gt;\nbool SyncQueueBase&lt;Result&gt;::empty() const\n{\n    NX_MUTEX_LOCKER lock(&amp;m_mutex);\n    return m_queue.empty();\n}\n\ntemplate&lt; typename Result&gt;\nstd::size_t SyncQueueBase&lt;Result&gt;::size() const\n{\n    NX_MUTEX_LOCKER lock( &amp;m_mutex );\n    return m_queue.size();\n}\n\ntemplate&lt; typename Result&gt;\nvoid SyncQueueBase&lt;Result&gt;::clear()\n{\n    NX_MUTEX_LOCKER lock( &amp;m_mutex );\n    decltype( m_queue ) queue;\n    std::swap( m_queue, queue );\n}\n\ntemplate&lt; typename Result&gt;\nvoid SyncQueueBase&lt;Result&gt;::retestPopIfCondition()\n{\n    // Mutex is required here to be sure popIf does not miss notification.\n    NX_MUTEX_LOCKER lock(&amp;m_mutex);\n    m_condition.wakeAll();\n}\n\ntemplate&lt;typename Result&gt;\nvoid SyncQueueBase&lt;Result&gt;::addReaderToTerminatedList(QueueReaderId readerId)\n{\n    {\n        NX_MUTEX_LOCKER lock(&amp;m_mutex);\n        m_terminatedReaders.insert(readerId);\n    }\n    m_condition.wakeAll();\n}\n\ntemplate&lt;typename Result&gt;\nvoid SyncQueueBase&lt;Result&gt;::removeReaderFromTerminatedList(QueueReaderId readerId)\n{\n    NX_MUTEX_LOCKER lock(&amp;m_mutex);\n    m_terminatedReaders.erase(readerId);\n}\n\ntemplate&lt;typename Result&gt;\nbool SyncQueueBase&lt;Result&gt;::waitForNonEmptyQueue(\n    nx::Locker&lt;nx::Mutex&gt;* lock,\n    std::optional&lt;std::chrono::steady_clock::time_point&gt; deadline,\n    QueueReaderId readerId)\n{\n    while (m_queue.empty())\n    {\n        if (m_terminatedReaders.find(readerId) != m_terminatedReaders.end())\n            return false;\n\n        if (!waitForEvent(lock, deadline))\n            return false;\n    }\n\n    if (m_terminatedReaders.find(readerId) != m_terminatedReaders.end())\n        return false;\n\n    return true;\n}\n\ntemplate&lt; typename Result&gt;\nbool SyncQueueBase&lt;Result&gt;::waitForEvent(\n    nx::Locker&lt;nx::Mutex&gt;* lock,\n    std::optional&lt;std::chrono::steady_clock::time_point&gt; deadline)\n{\n    using namespace std::chrono;\n\n    if (deadline)\n    {\n        const auto currentTime = steady_clock::now();\n        if (currentTime &gt;= *deadline)\n            return false;\n        if (!m_condition.wait(\n                lock-&gt;mutex(),\n                duration_cast&lt;milliseconds&gt;(*deadline - currentTime).count()))\n        {\n            return false;\n        }\n    }\n    else\n    {\n        m_condition.wait(lock-&gt;mutex());\n    }\n\n    return true;\n}\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename Result&gt;\nvoid SyncQueue&lt;Result&gt;::push(Result value)\n{\n    NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n    const auto wasEmpty = this-&gt;m_queue.empty();\n\n    this-&gt;m_queue.push_back(std::move(value));\n    if (wasEmpty)\n        this-&gt;m_condition.wakeOne();\n}\n\ntemplate&lt;typename Result&gt;\ntemplate&lt;typename... Args&gt;\nvoid SyncQueue&lt;Result&gt;::emplace(Args&amp;&amp;... args)\n{\n    NX_MUTEX_LOCKER lock(&amp;this-&gt;m_mutex);\n    const auto wasEmpty = this-&gt;m_queue.empty();\n\n    this-&gt;m_queue.emplace_back(std::forward&lt;Args&gt;(args)...);\n    if (wasEmpty)\n        this-&gt;m_condition.wakeOne();\n}\n\ntemplate&lt;typename Result&gt;\nstd::function&lt;void(Result)&gt; SyncQueue&lt;Result&gt;::pusher()\n{\n    return [this](Result result) { push(std::move(result)); };\n}\n\n//-------------------------------------------------------------------------------------------------\n\ntemplate&lt;typename R1, typename R2&gt;\nstd::function&lt;void(R1, R2)&gt; SyncMultiQueue&lt;R1, R2&gt;::pusher()\n{\n    return [this](R1 r1, R2 r2) { push(std::move(r1), std::move(r2)); };\n}\n\ntemplate&lt;typename R1, typename R2&gt;\nvoid SyncMultiQueue&lt;R1, R2&gt;::push(R1 r1, R2 r2)\n{\n    SyncQueue&lt;std::pair&lt;R1, R2&gt;&gt;::push(std::make_pair(std::move(r1), std::move(r2)));\n}\n\n} // namespace utils\n} // namespace nx\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/abstract_socket.h", "reportHash": "0f19e081f0fe44bdc4d75ccac92363c6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 460, "column": 22, "message": "class 'AbstractStreamSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractStreamSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/abstract_socket.h", "line": 460, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/address_resolver.h", "reportHash": "bc94fe874029739fc40dc5eb77514d49", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 22, "message": "class 'AddressResolver' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AddressResolver' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/address_resolver.h", "line": 24, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollable.h", "reportHash": "edd4f71fe237fe94fffd65e763e1d917", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 7, "message": "class 'AbstractPollable' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractPollable' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollable.h", "line": 18, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "reportHash": "2bcef796ea032393199437d056802640", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 7, "message": "class 'AbstractPollSetIterator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractPollSetIterator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "line": 19, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "reportHash": "cea43169b08b0575a165b20a5fa7ec26", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 44, "column": 7, "message": "class 'AbstractPollSet' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractPollSet' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_pollset.h", "line": 44, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_event_handler.h", "reportHash": "34799c327afaead22218a3d9b2fcb431", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 22, "message": "class 'AIOEventHandler' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AIOEventHandler' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_event_handler.h", "line": 15, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_service.h", "reportHash": "14d35036df71f8a9b5a76eea70392c4e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 28, "column": 22, "message": "class 'AIOService' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'AIOService' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_service.h", "line": 28, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "reportHash": "f939219da4186ddb671227e7e8371948", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 22, "message": "class 'AbstractAioThread' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAioThread' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "line": 23, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "reportHash": "bda53676c814e8f810d6953a81d3d857", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 54, "column": 22, "message": "class 'AioThread' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AioThread' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread.h", "line": 54, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "reportHash": "93d6bb2c82a34daed34b4f89f741f8c4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 16, "column": 22, "message": "class 'AioThreadWatcher' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AioThreadWatcher' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "line": 16, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "reportHash": "9bf4598afe3943983205aa0efe6152d9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 68, "column": 12, "message": "class 'WatchContext' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'WatchContext' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/aio_thread_watcher.h", "line": 68, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/basic_pollable.h", "reportHash": "dfc66651ba99e25d47179cdb7bc227a4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 78, "column": 22, "message": "class 'BasicPollable' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'BasicPollable' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/basic_pollable.h", "line": 78, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/timer.h", "reportHash": "21ad35d4c7fa3e50e47fb9355cd20cf1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 22, "message": "class 'Timer' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'Timer' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/timer.h", "line": 22, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/async_stoppable.h", "reportHash": "1a61010e9dc4974ca747d252dbf3606c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 22, "message": "class 'QnStoppableAsync' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'QnStoppableAsync' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/async_stoppable.h", "line": 15, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/server_statistics.h", "reportHash": "81833ff8161ca33ce8d1989b710050bc", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 39, "column": 22, "message": "class 'AbstractStatisticsProvider' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractStatisticsProvider' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/server_statistics.h", "line": 39, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/detail/server_statistics_calculator.h", "reportHash": "b36e01469545d683678e683ef87c95f8", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 18, "column": 22, "message": "class 'StatisticsCalculator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StatisticsCalculator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/detail/server_statistics_calculator.h", "line": 18, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "reportHash": "2b166a50d8e236dba2cb548d2663f4fd", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 7, "message": "class 'StreamConnectionHolder' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamConnectionHolder' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "line": 33, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "reportHash": "e082553a5eec56a5aa0d8a89b7c129a9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 48, "column": 7, "message": "class 'StreamServerConnectionHolder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamServerConnectionHolder' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "line": 48, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "reportHash": "a34f70acff0b91d13d36947a1ecfa050", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 214, "column": 7, "message": "class 'StreamSocketServer' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'StreamSocketServer' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "line": 214, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "reportHash": "01dfb45b1ffce841eef44df20299034e", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 324, "column": 30, "message": "std::move of the variable 'options' of the trivially-copyable type 'std::optional<KeepAliveOptions>' has no effect; remove std::move()", "events": [{"message": "std::move of the variable 'options' of the trivially-copyable type 'std::optional<KeepAliveOptions>' has no effect; remove std::move()", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/connection_server/stream_socket_server.h", "line": 324, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h", "reportHash": "df44258a51c491d9f6a6e8ac99268fc3", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                                    noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h", "line": 33, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/debug/object_instance_counter.h", "line": 33, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/dns_resolver.h", "reportHash": "a230a3379a0db17712f15121a9c596d1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 33, "column": 22, "message": "class 'DnsResolver' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DnsResolver' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/dns_resolver.h", "line": 33, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/resolve/abstract_resolver.h", "reportHash": "aea80eb618998d1e02fbb5a999a0c2b3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 7, "message": "class 'AbstractResolver' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractResolver' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/resolve/abstract_resolver.h", "line": 22, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_factory.h", "reportHash": "d913f15eda11573b0af374697525c9e3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 22, "message": "class 'SocketFactory' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'SocketFactory' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_factory.h", "line": 32, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "reportHash": "496d5aa97f666f831a104000ab1eeffb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 45, "column": 22, "message": "class 'SocketGlobals' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'SocketGlobals' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "line": 45, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "reportHash": "af204cb48956776a7038dba9d900f6f2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 161, "column": 22, "message": "class 'SocketGlobalsHolder' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SocketGlobalsHolder' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_global.h", "line": 161, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_async_channel.h", "reportHash": "88a10959e3839f96eb214164fa48cac3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 20, "column": 22, "message": "class 'AbstractAsyncChannel' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractAsyncChannel' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/abstract_async_channel.h", "line": 20, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/stream_transforming_async_channel.h", "reportHash": "5bbdd32d8b909c68e84c3a867ac5ee24", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 41, "column": 22, "message": "class 'StreamTransformingAsyncChannel' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamTransformingAsyncChannel' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/aio/stream_transforming_async_channel.h", "line": 41, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/custom_handshake_connection_acceptor.h", "reportHash": "e4a6afe0f7b62212ae1e1bff9d37c550", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 7, "message": "class 'CustomHandshakeConnectionAcceptor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CustomHandshakeConnectionAcceptor' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/custom_handshake_connection_acceptor.h", "line": 32, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_delegate.h", "reportHash": "e2a062715821e61be5ff30df1138b58e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 25, "column": 7, "message": "class 'SocketDelegate' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SocketDelegate' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/socket_delegate.h", "line": 25, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "reportHash": "9cfcf7154d176830cdd964cfc536a56b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 190, "column": 22, "message": "class 'X509Certificate' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'X509Certificate' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "line": 190, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "reportHash": "afa8ec6710807a7fba2734a5534106f6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 252, "column": 22, "message": "class 'Pem' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'Pem' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/certificate.h", "line": 252, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/context.h", "reportHash": "03ba42b57245ed8a9c98b26a315b4484", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 30, "column": 22, "message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Context' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/context.h", "line": 30, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_pipeline.h", "reportHash": "62723557e879d1e347e6b2b79598232f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 34, "column": 22, "message": "class 'Pipeline' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Pipeline' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_pipeline.h", "line": 34, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_server_socket.h", "reportHash": "d58efa59eb9a103cce737640ccf55c21", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 48, "column": 22, "message": "class 'StreamServerSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamServerSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_server_socket.h", "line": 48, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "reportHash": "d3bbc00f97af01a03e96b567f32dc644", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 26, "column": 22, "message": "class 'StreamSocketToTwoWayPipelineAdapter' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamSocketToTwoWayPipelineAdapter' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "line": 26, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "reportHash": "d555e533b308ec64ddeee214ff73dd84", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 92, "column": 22, "message": "class 'StreamSocket' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'StreamSocket' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/ssl/ssl_stream_socket.h", "line": 92, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/system_socket.h", "reportHash": "6c3a7f7d5634182cfd08ffa6d29b36e6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 121, "column": 22, "message": "class 'CommunicatingSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CommunicatingSocket' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/system_socket.h", "line": 121, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "2d47acc9ff443073b6bcb0feb269029b", "checker": {"name": "cert-dcl59-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl59-cpp.html"}, "analyzerName": "clang-tidy", "line": 31, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 31, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "5b3529b9cb81997489de815c3f6e5bbf", "checker": {"name": "google-build-namespaces", "url": "https://clang.llvm.org/extra/clang-tidy/checks/google/build-namespaces.html"}, "analyzerName": "clang-tidy", "line": 31, "column": 1, "message": "do not use unnamed namespaces in header files", "events": [{"message": "do not use unnamed namespaces in header files", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 31, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "f5c906fd3f71d56ff7f97d8ffe98f141", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 285, "column": 7, "message": "class 'ConcurrentSocketPipe' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ConcurrentSocketPipe' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 285, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "dff7d8725b2bb1bea198ae4523c5bf8d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 392, "column": 7, "message": "class 'StreamSocketAcceptance' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamSocketAcceptance' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 392, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "51811f7fcd7c5dda27ae838f1168f1d0", "checker": {"name": "bugprone-move-forwarding-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"}, "analyzerName": "clang-tidy", "line": 557, "column": 52, "message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "events": [{"message": "|                                                    std::forward<AuxiliaryConnectCompletionHandler> (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 557, "column": 7}, {"message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 557, "column": 52}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "d94bb6440597a300f2f43448fd78df1a", "checker": {"name": "bugprone-move-forwarding-reference", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/move-forwarding-reference.html"}, "analyzerName": "clang-tidy", "line": 569, "column": 30, "message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "events": [{"message": "|                              std::forward<AuxiliaryConnectCompletionHandler> (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 569, "column": 7}, {"message": "forwarding reference passed to std::move(), which may unexpectedly cause lvalues to be moved; use std::forward() instead", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 569, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "reportHash": "72855fcb2fbd694d904c2dad7d1cd5c0", "checker": {"name": "performance-move-const-arg", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/move-const-arg.html"}, "analyzerName": "clang-tidy", "line": 945, "column": 32, "message": "passing result of std::move() as a const reference argument; no move will actually happen", "events": [{"message": "passing result of std::move() as a const reference argument; no move will actually happen", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/stream_socket_acceptance_tests.h", "line": 945, "column": 32}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/synchronous_tcp_server.h", "reportHash": "61d950e1804d52b9d7c60faef8744185", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 17, "column": 22, "message": "class 'SynchronousStreamSocketServer' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SynchronousStreamSocketServer' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_network/src/nx/network/test_support/synchronous_tcp_server.h", "line": 17, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/argument_parser.h", "reportHash": "13701fe85f6cef98a9ea44d1e1bd8e7e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 19, "column": 20, "message": "class 'ArgumentParser' defines a copy constructor and a move constructor but does not define a destructor, a copy assignment operator or a move assignment operator", "events": [{"message": "class 'ArgumentParser' defines a copy constructor and a move constructor but does not define a destructor, a copy assignment operator or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/argument_parser.h", "line": 19, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "reportHash": "b052ec3a3350ab88038814279c14ec5e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 20, "message": "class 'AsyncOperationGuard' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AsyncOperationGuard' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "line": 22, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "reportHash": "444f30d58967adac72d1e883317e4c7e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 35, "column": 24, "message": "class 'SharedGuard' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'SharedGuard' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/async_operation_guard.h", "line": 35, "column": 24}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "reportHash": "54ab71c9318b0bbead82a12af30a78b5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 15, "column": 7, "message": "class 'AtomicUniquePtr' defines a non-default destructor and a move constructor but does not define a copy constructor, a copy assignment operator or a move assignment operator", "events": [{"message": "class 'AtomicUniquePtr' defines a non-default destructor and a move constructor but does not define a copy constructor, a copy assignment operator or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 15, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "reportHash": "2dab02cc1d0383fa56cbbc55e5dfe601", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 32, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "33 |     { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 32, "column": 4}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 32, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 32, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "reportHash": "9c3fb808dac6cc9b0cb6ccb659009c14", "checker": {"name": "cert-dcl58-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl58-cpp.html"}, "analyzerName": "clang-tidy", "line": 110, "column": 8, "message": "modification of 'std' namespace can result in undefined behavior", "events": [{"message": "'std' namespace opened here", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 107, "column": 11}, {"message": "modification of 'std' namespace can result in undefined behavior", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 110, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "reportHash": "e07c1d8291d06f6e54437d36bd3076f4", "checker": {"name": "cert-dcl58-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl58-cpp.html"}, "analyzerName": "clang-tidy", "line": 116, "column": 6, "message": "modification of 'std' namespace can result in undefined behavior", "events": [{"message": "'std' namespace opened here", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 107, "column": 11}, {"message": "modification of 'std' namespace can result in undefined behavior", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/atomic_unique_ptr.h", "line": 116, "column": 6}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "reportHash": "7c70100a5b35834e028eef7dc563f661", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 13, "column": 20, "message": "class 'Counter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Counter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 13, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "reportHash": "0529c04a95058971c4941d9305451d47", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 16, "column": 24, "message": "class 'ScopedIncrement' defines a destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "events": [{"message": "class 'ScopedIncrement' defines a destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 16, "column": 24}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "reportHash": "d6449112c452885b646c7c740efc6fca", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 21, "column": 9, "message": "move constructors should be marked noexcept", "events": [{"message": "|                                                  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 21, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 21, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "reportHash": "0e9c090405de48a70fc05322a23d0d7a", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 24, "column": 26, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                                             noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 24, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/counter.h", "line": 24, "column": 26}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/debug/allocation_analyzer.h", "reportHash": "0e97893b34d2322b21e7de538e7f784c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 20, "column": 20, "message": "class 'AllocationAnalyzer' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AllocationAnalyzer' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/debug/allocation_analyzer.h", "line": 20, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/interruption_flag.h", "reportHash": "e7543fa94e8f0b9b7c5e88fd01dee54a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 40, "column": 20, "message": "class 'InterruptionFlag' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'InterruptionFlag' defines a destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/interruption_flag.h", "line": 40, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/singleton.h", "reportHash": "619645b8705287a48850202c8af5392d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 23, "column": 7, "message": "class 'Singleton' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Singleton' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/singleton.h", "line": 23, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "8a94522c0d78cf43d619fa26b66d0d96", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 51, "column": 7, "message": "class 'shared_future_state_base' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'shared_future_state_base' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 51, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "c210034f6ec3f59dcd2cde09d633728e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 206, "column": 7, "message": "class 'future' defines a non-default destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "events": [{"message": "class 'future' defines a non-default destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 206, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "af8e5906c76fc3e3e2e9cc73887246f2", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 221, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "222 |     : (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 221, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 221, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 221, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "4a1392150506e67ba011d737483392a4", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 234, "column": 13, "message": "move assignment operators should be marked noexcept", "events": [{"message": "235 |     { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 234, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 234, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 234, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "0c99a91fd121dd67586f860d931b94e1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 285, "column": 7, "message": "class 'promise_base' defines a non-default destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "events": [{"message": "class 'promise_base' defines a non-default destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 285, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "7e69d8002c7d1ff4e1877fa06dc3705e", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 297, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "298 |     : (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 297, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 297, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 297, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "c58df45bae55297ec77c261edafb81f1", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 313, "column": 19, "message": "move assignment operators should be marked noexcept", "events": [{"message": "314 |     { (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 313, "column": 3}, {"message": "|  noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 313, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 313, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "4b8e08dc8f57a62fc717034acded3a39", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 354, "column": 7, "message": "class 'promise' defines a move constructor and a move assignment operator but does not define a destructor, a copy constructor or a copy assignment operator", "events": [{"message": "class 'promise' defines a move constructor and a move assignment operator but does not define a destructor, a copy constructor or a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 354, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "569242a2b65026bb4f7eaa09acb1b22e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 379, "column": 7, "message": "class 'promise' defines a move constructor and a move assignment operator but does not define a destructor, a copy constructor or a copy assignment operator", "events": [{"message": "class 'promise' defines a move constructor and a move assignment operator but does not define a destructor, a copy constructor or a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 379, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "3cc9a4328ceb8295c0f2d83f477da451", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 385, "column": 5, "message": "move constructors should be marked noexcept", "events": [{"message": "|                         noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 385, "column": 7}, {"message": "move constructors should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 385, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "reportHash": "daa3ed6cef206f6bbb3916bf1d4dba04", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 386, "column": 14, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                    noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 386, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/future.h", "line": 386, "column": 14}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "reportHash": "20f25dc2d4785b6c1b39910b3ddfe00c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 22, "column": 20, "message": "class 'thread' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'thread' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "line": 22, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "reportHash": "db1a30e5d4157ed9d9b3a9ca52456eb7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 48, "column": 20, "message": "class 'thread' defines a destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "events": [{"message": "class 'thread' defines a destructor, a copy constructor, a move constructor and a move assignment operator but does not define a copy assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "line": 48, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "reportHash": "75799ca3881491ae801bf3b5760d6ece", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 85, "column": 20, "message": "class 'DetachedThreads' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DetachedThreads' defines a destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/std/thread.h", "line": 85, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "reportHash": "c43a933e23b19fe782022bbf32d5bd70", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 30, "column": 20, "message": "class 'AbstractOutput' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractOutput' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "line": 30, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "reportHash": "81a28794e3cea41b1dc57ebafe071805", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 41, "column": 20, "message": "class 'AbstractInput' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractInput' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "line": 41, "column": 20}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "reportHash": "3bc2144fa7b545a46bb6ec54221f8cb0", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 249, "column": 5, "message": "constructor accepting a forwarding reference can hide the copy and move constructors", "events": [{"message": "constructor accepting a forwarding reference can hide the copy and move constructors", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "line": 249, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "reportHash": "307e91371cb03e154930291015b682d1", "checker": {"name": "bugprone-forwarding-reference-overload", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/forwarding-reference-overload.html"}, "analyzerName": "clang-tidy", "line": 277, "column": 5, "message": "constructor accepting a forwarding reference can hide the copy and move constructors", "events": [{"message": "constructor accepting a forwarding reference can hide the copy and move constructors", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/byte_stream/pipeline.h", "line": 277, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "reportHash": "90b6bef8a637d4fc9753d39a17ccd280", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 295, "column": 33, "message": "use 'contains' to check for membership", "events": [{"message": "|                                 contains (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "line": 295, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "line": 295, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "reportHash": "948fef531b14d9f0ac08a0575e46f331", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 302, "column": 29, "message": "use 'contains' to check for membership", "events": [{"message": "|                             contains (fixit)", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "line": 302, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/thread/sync_queue.h", "line": 302, "column": 29}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
