<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#include &quot;command_line_parser.h&quot;\n\n#include &lt;cassert&gt;\n\n#include &lt;QtCore/QStringList&gt;\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nnamespace {\n\nstatic const QString kUriDelimiter = &quot;://&quot;;\nstatic const auto kParamDelimiter = &#x27;=&#x27;;\n};\n\nvoid QnCommandLineParameter::init(void *target, int type, const QString &amp;longName, const QString &amp;shortName, const QString &amp;description, const QVariant &amp;impliedValue) {\n    m_target = target;\n    m_type = type;\n    m_metaType.reset(new QMetaType(type));\n    m_longName = longName;\n    m_shortName = shortName;\n    m_description = description;\n\n    if(impliedValue.userType() == qMetaTypeId&lt;QnCommandLineDefaultImpliedValue&gt;()) {\n        if(m_type == QMetaType::Bool) {\n            m_impliedValue = true; /* Default for booleans. */\n        } else {\n            m_impliedValue = QVariant();\n        }\n    } else {\n        m_impliedValue = impliedValue;\n\n        if(m_impliedValue.isValid()) {\n            if(m_impliedValue.canConvert(static_cast&lt;QVariant::Type&gt;(m_type))) {\n                m_impliedValue.convert(static_cast&lt;QVariant::Type&gt;(m_type));\n            } else {\n                NX_ASSERT(false, &quot;Type of the implied value of command line parameter &#x27;%1&#x27; does not match parameter&#x27;s type.&quot;, longName);\n                m_impliedValue = QVariant();\n            }\n        }\n    }\n}\n\n\nvoid QnCommandLineParser::addParameter(const QnCommandLineParameter &amp;parameter) {\n    int index = m_parameters.size();\n    m_parameters.push_back(parameter);\n    m_values.push_back(QVariant());\n\n    if(!parameter.longName().isEmpty())\n        addName(index, parameter.longName());\n    if(!parameter.shortName().isEmpty())\n        addName(index, parameter.shortName());\n}\n\nvoid QnCommandLineParser::storeUnparsed(QStringList* unparsed)\n{\n    m_unparsed = unparsed;\n}\n\nvoid QnCommandLineParser::addName(int index, const QString &amp;name)\n{\n    int currentIndex = m_indexByName.value(name, -1);\n    if(currentIndex != -1 &amp;&amp; currentIndex != index) {\n        NX_ASSERT(false, &quot;Given parameter name &#x27;%1&#x27; is already registered with this command line parser. This may lead to unexpected behavior when parsing command line.&quot;, name);\n        return;\n    }\n\n    m_indexByName[name] = index;\n}\n\nvoid QnCommandLineParser::addParameter(int type, const QString &amp;longName, const QString &amp;shortName, const QString &amp;description, const QVariant &amp;impliedValue) {\n    addParameter(QnCommandLineParameter(type, longName, shortName, description, impliedValue));\n}\n\nvoid QnCommandLineParser::addParameter(int type, const char *longName, const char *shortName, const QString &amp;description, const QVariant &amp;impliedValue) {\n    addParameter(QnCommandLineParameter(type, longName, shortName, description, impliedValue));\n}\n\nQVariant QnCommandLineParser::value(const QString &amp;name, const QVariant &amp;defaultValue) {\n    int index = m_indexByName.value(name, -1);\n    if(index == -1)\n        return defaultValue;\n\n    return m_values[index];\n}\n\nQVariant QnCommandLineParser::value(const char *name, const QVariant &amp;defaultValue) {\n    return value(QLatin1String(name), defaultValue);\n}\n\nvoid QnCommandLineParser::clear() {\n    m_parameters.clear();\n    m_values.clear();\n    m_indexByName.clear();\n}\n\nvoid QnCommandLineParser::print(QTextStream &amp;stream) const\n{\n    /* The dirty way, for now. */\n\n    int shortNameWidth = 0;\n    int longNameWidth = 0;\n    for(const QnCommandLineParameter &amp;parameter: m_parameters) {\n        shortNameWidth = qMax(shortNameWidth, parameter.shortName().size());\n        longNameWidth = qMax(longNameWidth, parameter.longName().size());\n    }\n    if(longNameWidth &gt; 0)\n        longNameWidth++; /* So that there is a single space between long &amp; short names. */\n\n    for(const QnCommandLineParameter &amp;parameter: m_parameters) {\n        stream.setFieldAlignment(QTextStream::AlignRight);\n\n        stream.setFieldWidth(shortNameWidth);\n        stream &lt;&lt; parameter.shortName();\n\n        stream.setFieldWidth(longNameWidth);\n        stream &lt;&lt; parameter.longName();\n\n        stream.setFieldWidth(0);\n        stream &lt;&lt; &quot; &quot; &lt;&lt; parameter.description();\n\n        stream &lt;&lt; Qt::endl;\n    }\n}\n\nbool QnCommandLineParser::parse(int argc, const char **argv, QTextStream *errorStream)\n{\n    // Starting from 1 to skip application name.\n    QStringList arguments;\n    for (int i = 1; i &lt; argc; ++i)\n        arguments &lt;&lt; QString::fromUtf8(argv[i]);\n    return parse(arguments, errorStream);\n}\n\nbool QnCommandLineParser::parse(int argc, const char **argv, FILE *errorFile)\n{\n    if (errorFile)\n    {\n        QTextStream errorStream(errorFile);\n        return parse(argc, argv, &amp;errorStream);\n    }\n    else\n    {\n        return parse(argc, argv, static_cast&lt;QTextStream*&gt;(nullptr));\n    }\n}\n\nbool QnCommandLineParser::parse(const QStringList&amp; arguments, FILE *errorFile)\n{\n    if (errorFile)\n    {\n        QTextStream errorStream(errorFile);\n        return parse(arguments, &amp;errorStream);\n    }\n    else\n    {\n        return parse(arguments, static_cast&lt;QTextStream*&gt;(nullptr));\n    }\n}\n\nbool QnCommandLineParser::parse(const QStringList&amp; arguments, QTextStream *errorStream)\n{\n    bool result = true;\n    int pos = 0;\n\n    while (pos &lt; arguments.size())\n    {\n        /* Extract name. */\n        const QString argument = arguments[pos];\n\n        const int delimiterIndex = argument.indexOf(kParamDelimiter);\n        const int uriDelimiterIndex = argument.indexOf(kUriDelimiter);\n        const bool isSingleUri = uriDelimiterIndex &gt;= 0\n            &amp;&amp; (delimiterIndex &lt; 0 || uriDelimiterIndex &lt; delimiterIndex);\n\n        const auto paramInfo = isSingleUri\n            ? argument.split(kUriDelimiter)\n            : argument.split(kParamDelimiter);\n        QString name = paramInfo[0];\n        if (isSingleUri)\n            name += kUriDelimiter;   /* So the registering code looks much better. */\n\n        int index = m_indexByName.value(name, -1);\n        if (index == -1)\n        {\n            if (m_unparsed)\n                m_unparsed-&gt;append(argument);\n            pos++;\n            continue;\n        }\n\n        const QnCommandLineParameter &amp;parameter = m_parameters[index];\n\n        /* Extract value. */\n        QVariant value;\n        if (paramInfo.size() &gt; 1)\n        {\n            value = paramInfo[1];\n        }\n        else if (parameter.impliedValue().isValid())\n        {\n            value = parameter.impliedValue();\n        }\n        else\n        {\n            pos++;\n            if (pos &gt;= arguments.size())\n            {\n                if (errorStream)\n                {\n                    *errorStream\n                        &lt;&lt; nx::format(&quot;No value provided for the &#x27;%1&#x27; argument.&quot;).arg(name) &lt;&lt; Qt::endl;\n                }\n                result = false;\n            }\n            else\n            {\n                value = arguments[pos];\n            }\n        }\n\n        /* Convert to typed value. */\n        QVariant typedValue = value;\n        bool success = typedValue.convert(static_cast&lt;QMetaType::Type&gt;(parameter.type()));\n        if (!success)\n        {\n            if (errorStream)\n            {\n                *errorStream\n                    &lt;&lt; nx::format(&quot;Invalid value for &#x27;%1&#x27; argument - expected %2, provided &#x27;%3&#x27;.&quot;).args(\n                        name, QMetaType::typeName(parameter.type()), value.toString())\n                    &lt;&lt; Qt::endl;\n            }\n            result = false;\n        }\n        else\n        {\n            value = typedValue;\n        }\n\n        /* Store value. */\n        m_values[index] = value;\n\n        /* Write value out if needed. */\n        if (parameter.target() &amp;&amp; parameter.metaType() &amp;&amp; result)\n        {\n            NX_ASSERT(value.userType() == parameter.type());\n\n            parameter.metaType()-&gt;construct(parameter.target(), value.data());\n        }\n\n        pos++;\n    }\n\n    return result;\n}\n"}, "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "content": "// Copyright (C) 2020 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#ifndef QVARIANT_H\n#define QVARIANT_H\n\n#include &lt;QtCore/qatomic.h&gt;\n#include &lt;QtCore/qcompare.h&gt;\n#include &lt;QtCore/qcontainerfwd.h&gt;\n#include &lt;QtCore/qmetatype.h&gt;\n#ifndef QT_NO_DEBUG_STREAM\n#include &lt;QtCore/qdebug.h&gt;\n#endif\n\n#include &lt;memory&gt;\n#include &lt;QtCore/q20type_traits.h&gt;\n#include &lt;QtCore/q23utility.h&gt;\n#include &lt;variant&gt;\n\n#if !defined(QT_LEAN_HEADERS) || QT_LEAN_HEADERS &lt; 1\n#  include &lt;QtCore/qlist.h&gt;\n#  include &lt;QtCore/qstringlist.h&gt;\n#  include &lt;QtCore/qbytearraylist.h&gt;\n#  include &lt;QtCore/qhash.h&gt;\n#  include &lt;QtCore/qmap.h&gt;\n#  include &lt;QtCore/qobject.h&gt;\n#endif\n\nQT_BEGIN_NAMESPACE\n\nQT_ENABLE_P0846_SEMANTICS_FOR(get_if)\nQT_ENABLE_P0846_SEMANTICS_FOR(get)\n\nclass QBitArray;\nclass QDataStream;\nclass QDate;\nclass QDateTime;\nclass QEasingCurve;\nclass QLine;\nclass QLineF;\nclass QLocale;\nclass QModelIndex;\nclass QPersistentModelIndex;\nclass QPoint;\nclass QPointF;\nclass QRect;\nclass QRectF;\nclass QRegularExpression;\nclass QSize;\nclass QSizeF;\nclass QTextFormat;\nclass QTextLength;\nclass QTime;\nclass QTransform;\nclass QUrl;\nclass QVariant;\n\ntemplate&lt;typename T&gt;\ninline T qvariant_cast(const QVariant &amp;);\n\nnamespace QtPrivate {\ntemplate&lt;&gt; constexpr inline bool qIsRelocatable&lt;QVariant&gt; = true;\n}\nclass Q_CORE_EXPORT QVariant\n{\n    template &lt;typename T, typename... Args&gt;\n    using if_constructible = std::enable_if_t&lt;\n        std::conjunction_v&lt;\n            std::is_copy_constructible&lt;q20::remove_cvref_t&lt;T&gt;&gt;,\n            std::is_destructible&lt;q20::remove_cvref_t&lt;T&gt;&gt;,\n            std::is_constructible&lt;q20::remove_cvref_t&lt;T&gt;, Args...&gt;\n        &gt;,\n    bool&gt;;\n\n    template &lt;typename T&gt;\n    using if_rvalue = std::enable_if_t&lt;!std::is_reference_v&lt;T&gt;, bool&gt;;\n\n    struct CborValueStandIn { qint64 n; void *c; int t; };\npublic:\n    struct PrivateShared\n    {\n    private:\n        inline PrivateShared() : ref(1) { }\n    public:\n        static int computeOffset(PrivateShared *ps, size_t align);\n        static size_t computeAllocationSize(size_t size, size_t align);\n        static PrivateShared *create(size_t size, size_t align);\n        static void free(PrivateShared *p);\n\n        alignas(8) QAtomicInt ref;\n        int offset;\n\n        const void *data() const { return reinterpret_cast&lt;const uchar *&gt;(this) + offset; }\n        void *data() { return reinterpret_cast&lt;uchar *&gt;(this) + offset; }\n    };\n\n    struct Private\n    {\n        static constexpr size_t MaxInternalSize = 3 * sizeof(void *);\n        template &lt;size_t S&gt; static constexpr bool FitsInInternalSize = S &lt;= MaxInternalSize;\n        template&lt;typename T&gt; static constexpr bool CanUseInternalSpace =\n                (QTypeInfo&lt;T&gt;::isRelocatable &amp;&amp; FitsInInternalSize&lt;sizeof(T)&gt; &amp;&amp; alignof(T) &lt;= alignof(double));\n        static constexpr bool canUseInternalSpace(const QtPrivate::QMetaTypeInterface *type)\n        {\n            Q_ASSERT(type);\n            return QMetaType::TypeFlags(type-&gt;flags) &amp; QMetaType::RelocatableType &amp;&amp;\n                   size_t(type-&gt;size) &lt;= MaxInternalSize &amp;&amp; size_t(type-&gt;alignment) &lt;= alignof(double);\n        }\n\n        union\n        {\n            uchar data[MaxInternalSize] = {};\n            PrivateShared *shared;\n            double _forAlignment; // we want an 8byte alignment on 32bit systems as well\n        } data;\n        quintptr is_shared : 1;\n        quintptr is_null : 1;\n        quintptr packedType : sizeof(QMetaType) * 8 - 2;\n\n        constexpr Private() noexcept : is_shared(false), is_null(true), packedType(0) {}\n        explicit Private(const QtPrivate::QMetaTypeInterface *iface) noexcept;\n        template &lt;typename T&gt; explicit Private(std::piecewise_construct_t, const T &amp;t);\n\n        const void *storage() const\n        { return is_shared ? data.shared-&gt;data() : &amp;data.data; }\n\n        template&lt;typename T&gt; const T &amp;get() const\n        { return *static_cast&lt;const T *&gt;(storage()); }\n\n        inline const QtPrivate::QMetaTypeInterface *typeInterface() const\n        {\n            return reinterpret_cast&lt;const QtPrivate::QMetaTypeInterface *&gt;(packedType &lt;&lt; 2);\n        }\n\n        inline QMetaType type() const\n        {\n            return QMetaType(typeInterface());\n        }\n    };\n\n#if QT_DEPRECATED_SINCE(6, 0)\n    enum QT_DEPRECATED_VERSION_X_6_0(&quot;Use QMetaType::Type instead.&quot;) Type\n    {\n        Invalid = QMetaType::UnknownType,\n        Bool = QMetaType::Bool,\n        Int = QMetaType::Int,\n        UInt = QMetaType::UInt,\n        LongLong = QMetaType::LongLong,\n        ULongLong = QMetaType::ULongLong,\n        Double = QMetaType::Double,\n        Char = QMetaType::QChar,\n        Map = QMetaType::QVariantMap,\n        List = QMetaType::QVariantList,\n        String = QMetaType::QString,\n        StringList = QMetaType::QStringList,\n        ByteArray = QMetaType::QByteArray,\n        BitArray = QMetaType::QBitArray,\n        Date = QMetaType::QDate,\n        Time = QMetaType::QTime,\n        DateTime = QMetaType::QDateTime,\n        Url = QMetaType::QUrl,\n        Locale = QMetaType::QLocale,\n        Rect = QMetaType::QRect,\n        RectF = QMetaType::QRectF,\n        Size = QMetaType::QSize,\n        SizeF = QMetaType::QSizeF,\n        Line = QMetaType::QLine,\n        LineF = QMetaType::QLineF,\n        Point = QMetaType::QPoint,\n        PointF = QMetaType::QPointF,\n#if QT_CONFIG(regularexpression)\n        RegularExpression = QMetaType::QRegularExpression,\n#endif\n        Hash = QMetaType::QVariantHash,\n#if QT_CONFIG(easingcurve)\n        EasingCurve = QMetaType::QEasingCurve,\n#endif\n        Uuid = QMetaType::QUuid,\n#if QT_CONFIG(itemmodel)\n        ModelIndex = QMetaType::QModelIndex,\n        PersistentModelIndex = QMetaType::QPersistentModelIndex,\n#endif\n        LastCoreType = QMetaType::LastCoreType,\n\n        Font = QMetaType::QFont,\n        Pixmap = QMetaType::QPixmap,\n        Brush = QMetaType::QBrush,\n        Color = QMetaType::QColor,\n        Palette = QMetaType::QPalette,\n        Image = QMetaType::QImage,\n        Polygon = QMetaType::QPolygon,\n        Region = QMetaType::QRegion,\n        Bitmap = QMetaType::QBitmap,\n        Cursor = QMetaType::QCursor,\n#if QT_CONFIG(shortcut)\n        KeySequence = QMetaType::QKeySequence,\n#endif\n        Pen = QMetaType::QPen,\n        TextLength = QMetaType::QTextLength,\n        TextFormat = QMetaType::QTextFormat,\n        Transform = QMetaType::QTransform,\n        Matrix4x4 = QMetaType::QMatrix4x4,\n        Vector2D = QMetaType::QVector2D,\n        Vector3D = QMetaType::QVector3D,\n        Vector4D = QMetaType::QVector4D,\n        Quaternion = QMetaType::QQuaternion,\n        PolygonF = QMetaType::QPolygonF,\n        Icon = QMetaType::QIcon,\n        LastGuiType = QMetaType::LastGuiType,\n\n        SizePolicy = QMetaType::QSizePolicy,\n\n        UserType = QMetaType::User,\n        LastType = 0xffffffff // need this so that gcc &gt;= 3.4 allocates 32 bits for Type\n    };\n#endif\n    QVariant() noexcept : d() {}\n    ~QVariant();\n    explicit QVariant(QMetaType type, const void *copy = nullptr);\n    QVariant(const QVariant &amp;other);\n\nprivate:\n    template &lt;typename T, typename ...Args&gt;\n    using is_noexcept_constructible = std::conjunction&lt;\n            std::bool_constant&lt;Private::CanUseInternalSpace&lt;T&gt;&gt;,\n            std::is_nothrow_constructible&lt;T, Args...&gt;\n        &gt;;\n\npublic:\n    template &lt;typename T, typename... Args,\n             if_constructible&lt;T, Args...&gt; = true&gt;\n    explicit QVariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;... args)\n            noexcept(is_noexcept_constructible&lt;q20::remove_cvref_t&lt;T&gt;, Args...&gt;::value)\n        : QVariant(std::in_place, QMetaType::fromType&lt;q20::remove_cvref_t&lt;T&gt;&gt;() )\n    {\n        void *data = const_cast&lt;void *&gt;(constData());\n        new (data) T(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template &lt;typename T, typename U, typename... Args,\n             if_constructible&lt;T, std::initializer_list&lt;U&gt; &amp;, Args...&gt; = true&gt;\n    explicit QVariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args)\n            noexcept(is_noexcept_constructible&lt;q20::remove_cvref_t&lt;T&gt;,\n                                               std::initializer_list&lt;U&gt; &amp;,\n                                               Args...\n                    &gt;::value)\n        : QVariant(std::in_place, QMetaType::fromType&lt;q20::remove_cvref_t&lt;T&gt;&gt;())\n    {\n        char *data = static_cast&lt;char *&gt;(const_cast&lt;void *&gt;(constData()));\n        new (data) T(il, std::forward&lt;Args&gt;(args)...);\n    }\n\n    // primitives\n    QVariant(int i) noexcept;\n    QVariant(uint ui) noexcept;\n    QVariant(qlonglong ll) noexcept;\n    QVariant(qulonglong ull) noexcept;\n    QVariant(bool b) noexcept;\n    QVariant(double d) noexcept;\n    QVariant(float f) noexcept;\n\n    // trivial, trivially-copyable or COW\n    QVariant(QChar qchar) noexcept;\n    QVariant(QDate date) noexcept;\n    QVariant(QTime time) noexcept;\n#ifndef QT_BOOTSTRAPPED\n    QVariant(const QBitArray &amp;bitarray) noexcept;\n#endif\n    QVariant(const QByteArray &amp;bytearray) noexcept;\n    QVariant(const QDateTime &amp;datetime) noexcept;\n    QVariant(const QHash&lt;QString, QVariant&gt; &amp;hash) noexcept;\n    QVariant(const QJsonArray &amp;jsonArray) noexcept;\n    QVariant(const QJsonObject &amp;jsonObject) noexcept;\n    QVariant(const QList&lt;QVariant&gt; &amp;list) noexcept;\n    QVariant(const QLocale &amp;locale) noexcept;\n    QVariant(const QMap&lt;QString, QVariant&gt; &amp;map) noexcept;\n    QVariant(const QRegularExpression &amp;re) noexcept;\n    QVariant(const QString &amp;string) noexcept;\n    QVariant(const QStringList &amp;stringlist) noexcept;\n    QVariant(const QUrl &amp;url) noexcept;\n\n    // conditionally noexcept trivial or trivially-copyable\n    // (most of these are noexcept on 64-bit)\n    QVariant(const QJsonValue &amp;jsonValue) noexcept(Private::FitsInInternalSize&lt;sizeof(CborValueStandIn)&gt;);\n    QVariant(const QModelIndex &amp;modelIndex) noexcept(Private::FitsInInternalSize&lt;8 + 2 * sizeof(quintptr)&gt;);\n    QVariant(QUuid uuid) noexcept(Private::FitsInInternalSize&lt;16&gt;);\n#ifndef QT_NO_GEOM_VARIANT\n    QVariant(QSize size) noexcept;\n    QVariant(QSizeF size) noexcept(Private::FitsInInternalSize&lt;sizeof(qreal) * 2&gt;);\n    QVariant(QPoint pt) noexcept;\n    QVariant(QPointF pt) noexcept(Private::FitsInInternalSize&lt;sizeof(qreal) * 2&gt;);\n    QVariant(QLine line) noexcept(Private::FitsInInternalSize&lt;sizeof(int) * 4&gt;);\n    QVariant(QLineF line) noexcept(Private::FitsInInternalSize&lt;sizeof(qreal) * 4&gt;);\n    QVariant(QRect rect) noexcept(Private::FitsInInternalSize&lt;sizeof(int) * 4&gt;);\n    QVariant(QRectF rect) noexcept(Private::FitsInInternalSize&lt;sizeof(qreal) * 4&gt;);\n#endif\n\n    // not noexcept\n    QVariant(const QEasingCurve &amp;easing) noexcept(false);\n    QVariant(const QJsonDocument &amp;jsonDocument) noexcept(false);\n    QVariant(const QPersistentModelIndex &amp;modelIndex) noexcept(false);\n\n#ifndef QT_NO_CAST_FROM_ASCII\n    QT_ASCII_CAST_WARN QVariant(const char *str) noexcept(false)\n        : QVariant(QString::fromUtf8(str))\n    {}\n#endif\n    QVariant(QLatin1StringView string) noexcept(false); // converts to QString\n\n#if !defined(Q_CC_GHS)\n    // GHS has an ICE with this code; use the simplified version below\n    template &lt;typename T,\n              std::enable_if_t&lt;std::disjunction_v&lt;std::is_pointer&lt;T&gt;, std::is_member_pointer&lt;T&gt;&gt;, bool&gt; = false&gt;\n    QVariant(T) = delete;\n#else\n    QVariant(const volatile void *) = delete;\n#endif\n\n#if QT_CORE_REMOVED_SINCE(6, 5)\n    QVariant(const QSize &amp;size);\n    QVariant(const QSizeF &amp;size);\n    QVariant(const QPoint &amp;pt);\n    QVariant(const QPointF &amp;pt);\n    QVariant(const QLine &amp;line);\n    QVariant(const QLineF &amp;line);\n    QVariant(const QRect &amp;rect);\n    QVariant(const QRectF &amp;rect);\n    QVariant(const QUuid &amp;uuid);\n#endif\n\n    QVariant&amp; operator=(const QVariant &amp;other);\n    inline QVariant(QVariant &amp;&amp;other) noexcept : d(other.d)\n    { other.d = Private(); }\n    QT_MOVE_ASSIGNMENT_OPERATOR_IMPL_VIA_MOVE_AND_SWAP(QVariant)\n\n    inline void swap(QVariant &amp;other) noexcept { std::swap(d, other.d); }\n\n    int userType() const { return typeId(); }\n    int typeId() const { return metaType().id(); }\n\n    const char *typeName() const;\n    QMetaType metaType() const;\n\n    bool canConvert(QMetaType targetType) const\n    { return QMetaType::canConvert(d.type(), targetType); }\n    bool convert(QMetaType type);\n\n    bool canView(QMetaType targetType) const\n    { return QMetaType::canView(d.type(), targetType); }\n\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_DEPRECATED_VERSION_6_0\n    bool canConvert(int targetTypeId) const\n    { return QMetaType::canConvert(d.type(), QMetaType(targetTypeId)); }\n    QT_DEPRECATED_VERSION_6_0\n    bool convert(int targetTypeId)\n    { return convert(QMetaType(targetTypeId)); }\n#endif\n\n    inline bool isValid() const;\n    bool isNull() const;\n\n    void clear();\n\n    void detach();\n    inline bool isDetached() const;\n\n    int toInt(bool *ok = nullptr) const;\n    uint toUInt(bool *ok = nullptr) const;\n    qlonglong toLongLong(bool *ok = nullptr) const;\n    qulonglong toULongLong(bool *ok = nullptr) const;\n    bool toBool() const;\n    double toDouble(bool *ok = nullptr) const;\n    float toFloat(bool *ok = nullptr) const;\n    qreal toReal(bool *ok = nullptr) const;\n    QByteArray toByteArray() const;\n#ifndef QT_BOOTSTRAPPED\n    QBitArray toBitArray() const;\n#endif\n    QString toString() const;\n    QStringList toStringList() const;\n    QChar toChar() const;\n    QDate toDate() const;\n    QTime toTime() const;\n    QDateTime toDateTime() const;\n    QList&lt;QVariant&gt; toList() const;\n    QMap&lt;QString, QVariant&gt; toMap() const;\n    QHash&lt;QString, QVariant&gt; toHash() const;\n\n#ifndef QT_NO_GEOM_VARIANT\n    QPoint toPoint() const;\n    QPointF toPointF() const;\n    QRect toRect() const;\n    QSize toSize() const;\n    QSizeF toSizeF() const;\n    QLine toLine() const;\n    QLineF toLineF() const;\n    QRectF toRectF() const;\n#endif\n    QLocale toLocale() const;\n#if QT_CONFIG(regularexpression)\n    QRegularExpression toRegularExpression() const;\n#endif // QT_CONFIG(regularexpression)\n#if QT_CONFIG(easingcurve)\n    QEasingCurve toEasingCurve() const;\n#endif\n    QUuid toUuid() const;\n#ifndef QT_BOOTSTRAPPED\n    QUrl toUrl() const;\n    QJsonValue toJsonValue() const;\n    QJsonObject toJsonObject() const;\n    QJsonArray toJsonArray() const;\n    QJsonDocument toJsonDocument() const;\n#endif // QT_BOOTSTRAPPED\n#if QT_CONFIG(itemmodel)\n    QModelIndex toModelIndex() const;\n    QPersistentModelIndex toPersistentModelIndex() const;\n#endif\n\n#ifndef QT_NO_DATASTREAM\n    void load(QDataStream &amp;ds);\n    void save(QDataStream &amp;ds) const;\n#endif\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_WARNING_PUSH\n    QT_WARNING_DISABLE_DEPRECATED\n    QT_DEPRECATED_VERSION_X_6_0(&quot;Use the constructor taking a QMetaType instead.&quot;)\n    explicit QVariant(Type type)\n        : QVariant(QMetaType(int(type)))\n    {}\n    QT_DEPRECATED_VERSION_X_6_0(&quot;Use typeId() or metaType().&quot;)\n    Type type() const\n    {\n        int type = d.type().id();\n        return type &gt;= QMetaType::User ? UserType : static_cast&lt;Type&gt;(type);\n    }\n    QT_DEPRECATED_VERSION_6_0\n    static const char *typeToName(int typeId)\n    { return QMetaType(typeId).name(); }\n    QT_DEPRECATED_VERSION_6_0\n    static Type nameToType(const char *name)\n    {\n        int metaType = QMetaType::fromName(name).id();\n        return metaType &lt;= int(UserType) ? QVariant::Type(metaType) : UserType;\n    }\n    QT_WARNING_POP\n#endif\n\n    void *data();\n    const void *constData() const\n    { return d.storage(); }\n    inline const void *data() const { return constData(); }\n\nprivate:\n    template &lt;typename T&gt;\n    void verifySuitableForEmplace()\n    {\n        static_assert(!std::is_reference_v&lt;T&gt;,\n                      &quot;QVariant does not support reference types&quot;);\n        static_assert(!std::is_const_v&lt;T&gt;,\n                      &quot;QVariant does not support const types&quot;);\n        static_assert(std::is_copy_constructible_v&lt;T&gt;,\n                      &quot;QVariant requires that the type is copyable&quot;);\n        static_assert(std::is_destructible_v&lt;T&gt;,\n                      &quot;QVariant requires that the type is destructible&quot;);\n    }\n\n    template &lt;typename T, typename... Args&gt;\n    T &amp;emplaceImpl(Args&amp;&amp;... args)\n    {\n        verifySuitableForEmplace&lt;T&gt;();\n        auto data = static_cast&lt;T *&gt;(prepareForEmplace(QMetaType::fromType&lt;T&gt;()));\n        return *q20::construct_at(data, std::forward&lt;Args&gt;(args)...);\n    }\n\npublic:\n    template &lt;typename T, typename... Args,\n              if_constructible&lt;T, Args...&gt; = true&gt;\n    T &amp;emplace(Args&amp;&amp;... args)\n    {\n        return emplaceImpl&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    template &lt;typename T, typename U, typename... Args,\n             if_constructible&lt;T, std::initializer_list&lt;U&gt; &amp;, Args...&gt; = true&gt;\n    T &amp;emplace(std::initializer_list&lt;U&gt; list, Args&amp;&amp;... args)\n    {\n        return emplaceImpl&lt;T&gt;(list, std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;typename T, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;T&gt;, QVariant&gt;&gt;&gt;\n    void setValue(T &amp;&amp;avalue)\n    {\n        using VT = std::decay_t&lt;T&gt;;\n        QMetaType metaType = QMetaType::fromType&lt;VT&gt;();\n        // If possible we reuse the current QVariant private.\n        if (isDetached() &amp;&amp; d.type() == metaType) {\n            *reinterpret_cast&lt;VT *&gt;(const_cast&lt;void *&gt;(constData())) = std::forward&lt;T&gt;(avalue);\n            d.is_null = false;\n        } else {\n            *this = QVariant::fromValue&lt;VT&gt;(std::forward&lt;T&gt;(avalue));\n        }\n    }\n\n    void setValue(const QVariant &amp;avalue)\n    {\n        *this = avalue;\n    }\n\n    void setValue(QVariant &amp;&amp;avalue)\n    {\n        *this = std::move(avalue);\n    }\n\n    template&lt;typename T&gt;\n    inline T value() const &amp;\n    { return qvariant_cast&lt;T&gt;(*this); }\n\n    template&lt;typename T&gt;\n    inline T view()\n    {\n        T t{};\n        QMetaType::view(metaType(), data(), QMetaType::fromType&lt;T&gt;(), &amp;t);\n        return t;\n    }\n\n    template&lt;typename T&gt;\n    inline T value() &amp;&amp;\n    { return qvariant_cast&lt;T&gt;(std::move(*this)); }\n\n    template&lt;typename T, if_rvalue&lt;T&gt; = true&gt;\n#ifndef Q_QDOC\n        /* needs is_copy_constructible for variants semantics, is_move_constructible so that moveConstruct works\n          (but copy_constructible implies move_constructble, so don&#x27;t bother checking)\n        */\n    static inline auto fromValue(T &amp;&amp;value)\n        noexcept(std::is_nothrow_copy_constructible_v&lt;T&gt; &amp;&amp; Private::CanUseInternalSpace&lt;T&gt;)\n        -&gt; std::enable_if_t&lt;std::conjunction_v&lt;std::is_copy_constructible&lt;T&gt;,\n                                               std::is_destructible&lt;T&gt;&gt;, QVariant&gt;\n#else\n    static inline QVariant fromValue(T &amp;&amp;value)\n#endif\n    {\n        // handle special cases\n        using Type = std::remove_cv_t&lt;T&gt;;\n        if constexpr (std::is_null_pointer_v&lt;Type&gt;)\n            return QVariant::fromMetaType(QMetaType::fromType&lt;std::nullptr_t&gt;());\n        else if constexpr (std::is_same_v&lt;Type, QVariant&gt;)\n            return std::forward&lt;T&gt;(value);\n        else if constexpr (std::is_same_v&lt;Type, std::monostate&gt;)\n            return QVariant();\n        QMetaType mt = QMetaType::fromType&lt;Type&gt;();\n        mt.registerType(); // we want the type stored in QVariant to always be registered\n\n        // We only try to move if the type is actually moveable and not if T is const\n        // as in const int i; QVariant::fromValue(std::move(i));\n        if constexpr (std::conjunction_v&lt;std::is_move_constructible&lt;Type&gt;, std::negation&lt;std::is_const&lt;T&gt;&gt;&gt;)\n            return moveConstruct(QMetaType::fromType&lt;Type&gt;(), std::addressof(value));\n        else\n            return copyConstruct(mt, std::addressof(value));\n    }\n\n    template&lt;typename T&gt;\n#ifndef Q_QDOC\n    static inline auto fromValue(const T &amp;value)\n        noexcept(std::is_nothrow_copy_constructible_v&lt;T&gt; &amp;&amp; Private::CanUseInternalSpace&lt;T&gt;)\n        -&gt; std::enable_if_t&lt;std::is_copy_constructible_v&lt;T&gt; &amp;&amp; std::is_destructible_v&lt;T&gt;, QVariant&gt;\n#else\n    static inline QVariant fromValue(const T &amp;value)\n#endif\n    {\n        if constexpr (std::is_null_pointer_v&lt;T&gt;)\n            return QVariant(QMetaType::fromType&lt;std::nullptr_t&gt;());\n        else if constexpr (std::is_same_v&lt;T, QVariant&gt;)\n            return value;\n        else if constexpr (std::is_same_v&lt;T, std::monostate&gt;)\n            return QVariant();\n        return QVariant(QMetaType::fromType&lt;T&gt;(), std::addressof(value));\n    }\n\n    template&lt;typename... Types&gt;\n    static inline QVariant fromStdVariant(const std::variant&lt;Types...&gt; &amp;value)\n    {\n        return fromStdVariantImpl(value);\n    }\n\n    template&lt;typename... Types&gt;\n    static QVariant fromStdVariant(std::variant&lt;Types...&gt; &amp;&amp;value)\n    {\n        return fromStdVariantImpl(std::move(value));\n    }\n\n    static QVariant fromMetaType(QMetaType type, const void *copy = nullptr);\n\n    template&lt;typename T&gt;\n    bool canConvert() const\n    { return canConvert(QMetaType::fromType&lt;T&gt;()); }\n\n    template&lt;typename T&gt;\n    bool canView() const\n    { return canView(QMetaType::fromType&lt;T&gt;()); }\n\n    static QPartialOrdering compare(const QVariant &amp;lhs, const QVariant &amp;rhs);\n\nprivate:\n    template &lt;typename StdVariant&gt;\n    static QVariant fromStdVariantImpl(StdVariant &amp;&amp;v)\n    {\n        if (Q_UNLIKELY(v.valueless_by_exception()))\n            return QVariant();\n        auto visitor = [](auto &amp;&amp;arg) {\n            return QVariant::fromValue(q23::forward_like&lt;StdVariant&gt;(arg));\n        };\n        return std::visit(visitor, std::forward&lt;StdVariant&gt;(v));\n    }\n\n    friend bool comparesEqual(const QVariant &amp;a, const QVariant &amp;b)\n    { return a.equals(b); }\n    Q_DECLARE_EQUALITY_COMPARABLE_NON_NOEXCEPT(QVariant)\n\n#ifndef QT_NO_DEBUG_STREAM\n    template &lt;typename T&gt;\n    friend auto operator&lt;&lt;(const QDebug &amp;debug, const T &amp;variant) -&gt; std::enable_if_t&lt;std::is_same_v&lt;T, QVariant&gt;, QDebug&gt; {\n        return  variant.qdebugHelper(debug);\n    }\n    QDebug qdebugHelper(QDebug) const;\n#endif\n\n    template &lt;typename T&gt;\n    friend T *get_if(QVariant *v) noexcept\n    {\n        // data() will detach from is_null, returning non-nullptr\n        if (!v || v-&gt;d.type() != QMetaType::fromType&lt;T&gt;())\n            return nullptr;\n        return static_cast&lt;T*&gt;(v-&gt;data());\n    }\n    template &lt;typename T&gt;\n    friend const T *get_if(const QVariant *v) noexcept\n    {\n        // (const) data() will not detach from is_null, return nullptr\n        if (!v || v-&gt;d.is_null || v-&gt;d.type() != QMetaType::fromType&lt;T&gt;())\n            return nullptr;\n        return static_cast&lt;const T*&gt;(v-&gt;data());\n    }\n\n#define Q_MK_GET(cvref) \\\n    template &lt;typename T&gt; \\\n    friend T cvref get(QVariant cvref v) \\\n    { \\\n        if constexpr (std::is_const_v&lt;T cvref&gt;) \\\n            Q_ASSERT(!v.d.is_null); \\\n        Q_ASSERT(v.d.type() == QMetaType::fromType&lt;q20::remove_cvref_t&lt;T&gt;&gt;()); \\\n        return static_cast&lt;T cvref&gt;(*get_if&lt;T&gt;(&amp;v)); \\\n    } \\\n    /* end */\n    Q_MK_GET(&amp;)\n    Q_MK_GET(const &amp;)\n    Q_MK_GET(&amp;&amp;)\n    Q_MK_GET(const &amp;&amp;)\n#undef Q_MK_GET\n\n    static QVariant moveConstruct(QMetaType type, void *data);\n    static QVariant copyConstruct(QMetaType type, const void *data);\n\n    template&lt;typename T&gt;\n    friend inline T qvariant_cast(const QVariant &amp;);\n    template&lt;typename T&gt;\n    friend inline T qvariant_cast(QVariant &amp;&amp;);\n\nprotected:\n    Private d;\n    void create(int type, const void *copy);\n    void create(QMetaType type, const void *copy);\n    bool equals(const QVariant &amp;other) const;\n    bool convert(int type, void *ptr) const;\n    bool view(int type, void *ptr);\n\nprivate:\n    // force compile error, prevent QVariant(bool) to be called\n    inline QVariant(void *) = delete;\n    // QVariant::Type is marked as \\obsolete, but we don&#x27;t want to\n    // provide a constructor from its intended replacement,\n    // QMetaType::Type, instead, because the idea behind these\n    // constructors is flawed in the first place. But we also don&#x27;t\n    // want QVariant(QMetaType::String) to compile and falsely be an\n    // int variant, so delete this constructor:\n    QVariant(QMetaType::Type) = delete;\n\n    // used to setup the QVariant internals for the &quot;real&quot; inplace ctor\n    QVariant(std::in_place_t, QMetaType type);\n    // helper for emplace\n    void *prepareForEmplace(QMetaType type);\n\n    // These constructors don&#x27;t create QVariants of the type associated\n    // with the enum, as expected, but they would create a QVariant of\n    // type int with the value of the enum value.\n    // Use QVariant v = QColor(Qt::red) instead of QVariant v = Qt::red for\n    // example.\n    QVariant(Qt::GlobalColor) = delete;\n    QVariant(Qt::BrushStyle) = delete;\n    QVariant(Qt::PenStyle) = delete;\n    QVariant(Qt::CursorShape) = delete;\n#ifdef QT_NO_CAST_FROM_ASCII\n    // force compile error when implicit conversion is not wanted\n    inline QVariant(const char *) = delete;\n#endif\npublic:\n    typedef Private DataPtr;\n    inline DataPtr &amp;data_ptr() { return d; }\n    inline const DataPtr &amp;data_ptr() const { return d; }\n};\n\ninline bool QVariant::isValid() const\n{\n    return d.type().isValid(QT6_CALL_NEW_OVERLOAD);\n}\n\n#ifndef QT_NO_DATASTREAM\nQ_CORE_EXPORT QDataStream &amp;operator&gt;&gt;(QDataStream &amp;s, QVariant &amp;p);\nQ_CORE_EXPORT QDataStream &amp;operator&lt;&lt;(QDataStream &amp;s, const QVariant &amp;p);\n\n#if QT_DEPRECATED_SINCE(6, 0)\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_DEPRECATED_VERSION_6_0\ninline QDataStream &amp;operator&gt;&gt;(QDataStream &amp;s, QVariant::Type &amp;p)\n{\n    quint32 u;\n    s &gt;&gt; u;\n    p = static_cast&lt;QVariant::Type&gt;(u);\n    return s;\n}\nQT_DEPRECATED_VERSION_6_0\ninline QDataStream &amp;operator&lt;&lt;(QDataStream &amp;s, const QVariant::Type p)\n{\n    s &lt;&lt; static_cast&lt;quint32&gt;(p);\n    return s;\n}\nQT_WARNING_POP\n#endif\n\n#endif\n\ninline bool QVariant::isDetached() const\n{ return !d.is_shared || d.data.shared-&gt;ref.loadRelaxed() == 1; }\n\ninline void swap(QVariant &amp;value1, QVariant &amp;value2) noexcept\n{ value1.swap(value2); }\n\n#ifndef QT_MOC\n\ntemplate&lt;typename T&gt; inline T qvariant_cast(const QVariant &amp;v)\n{\n    QMetaType targetType = QMetaType::fromType&lt;T&gt;();\n    if (v.d.type() == targetType)\n        return v.d.get&lt;T&gt;();\n    if constexpr (std::is_same_v&lt;T,std::remove_const_t&lt;std::remove_pointer_t&lt;T&gt;&gt; const *&gt;) {\n        using nonConstT = std::remove_const_t&lt;std::remove_pointer_t&lt;T&gt;&gt; *;\n        QMetaType nonConstTargetType = QMetaType::fromType&lt;nonConstT&gt;();\n        if (v.d.type() == nonConstTargetType)\n            return v.d.get&lt;nonConstT&gt;();\n    }\n\n    T t{};\n    QMetaType::convert(v.metaType(), v.constData(), targetType, &amp;t);\n    return t;\n}\n\ntemplate&lt;typename T&gt; inline T qvariant_cast(QVariant &amp;&amp;v)\n{\n    QMetaType targetType = QMetaType::fromType&lt;T&gt;();\n    if (v.d.type() == targetType) {\n        if (!v.d.is_shared) {\n            return std::move(*reinterpret_cast&lt;T *&gt;(v.d.data.data));\n        } else {\n            if (v.d.data.shared-&gt;ref.loadRelaxed() == 1)\n                return std::move(*reinterpret_cast&lt;T *&gt;(v.d.data.shared-&gt;data()));\n            else\n                return v.d.get&lt;T&gt;();\n        }\n    }\n    if constexpr (std::is_same_v&lt;T, QVariant&gt;) {\n        // if the metatype doesn&#x27;t match, but we want a QVariant, just return the current variant\n        return v;\n    } if constexpr (std::is_same_v&lt;T,std::remove_const_t&lt;std::remove_pointer_t&lt;T&gt;&gt; const *&gt;) {\n        // moving a pointer is pointless, just do the same as the const &amp; overload\n        using nonConstT = std::remove_const_t&lt;std::remove_pointer_t&lt;T&gt;&gt; *;\n        QMetaType nonConstTargetType = QMetaType::fromType&lt;nonConstT&gt;();\n        if (v.d.type() == nonConstTargetType)\n            return v.d.get&lt;nonConstT&gt;();\n    }\n\n    T t{};\n    QMetaType::convert(v.metaType(), v.constData(), targetType, &amp;t);\n    return t;\n}\n\n#  ifndef QT_NO_VARIANT\ntemplate&lt;&gt; inline QVariant qvariant_cast&lt;QVariant&gt;(const QVariant &amp;v)\n{\n    if (v.metaType().id() == QMetaType::QVariant)\n        return *reinterpret_cast&lt;const QVariant *&gt;(v.constData());\n    return v;\n}\n#  endif\n\n#endif // QT_MOC\n\n#ifndef QT_NO_DEBUG_STREAM\n#if QT_DEPRECATED_SINCE(6, 0)\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_DEPRECATED_VERSION_6_0\nQ_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QVariant::Type);\nQT_WARNING_POP\n#endif\n#endif\n\nnamespace QtPrivate {\nclass Q_CORE_EXPORT QVariantTypeCoercer\n{\npublic:\n    // ### Qt7: Pass QMetaType as value rather than const ref.\n    const void *convert(const QVariant &amp;value, const QMetaType &amp;type);\n    const void *coerce(const QVariant &amp;value, const QMetaType &amp;type);\n\nprivate:\n    QVariant converted;\n};\n}\n\ntemplate&lt;typename Pointer&gt;\nclass QVariantRef\n{\nprivate:\n    const Pointer *m_pointer = nullptr;\n\npublic:\n    explicit QVariantRef(const Pointer *reference) : m_pointer(reference) {}\n    QVariantRef(const QVariantRef &amp;) = default;\n    QVariantRef(QVariantRef &amp;&amp;) = default;\n    ~QVariantRef() = default;\n\n    operator QVariant() const;\n    QVariantRef &amp;operator=(const QVariant &amp;value);\n    QVariantRef &amp;operator=(const QVariantRef &amp;value) { return operator=(QVariant(value)); }\n    QVariantRef &amp;operator=(QVariantRef &amp;&amp;value) { return operator=(QVariant(value)); }\n\n    friend void swap(QVariantRef a, QVariantRef b)\n    {\n        QVariant tmp = a;\n        a = b;\n        b = std::move(tmp);\n    }\n};\n\nclass Q_CORE_EXPORT QVariantConstPointer\n{\nprivate:\n    QVariant m_variant;\n\npublic:\n    explicit QVariantConstPointer(QVariant variant);\n\n    QVariant operator*() const;\n    const QVariant *operator-&gt;() const;\n};\n\ntemplate&lt;typename Pointer&gt;\nclass QVariantPointer\n{\nprivate:\n    const Pointer *m_pointer = nullptr;\n\npublic:\n    explicit QVariantPointer(const Pointer *pointer) : m_pointer(pointer) {}\n    QVariantRef&lt;Pointer&gt; operator*() const { return QVariantRef&lt;Pointer&gt;(m_pointer); }\n    Pointer operator-&gt;() const { return *m_pointer; }\n};\n\nQT_END_NAMESPACE\n\n#endif // QVARIANT_H\n"}, "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "content": "// Copyright (C) 2022 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#ifndef QTDEPRECATIONMARKERS_H\n#define QTDEPRECATIONMARKERS_H\n\n#include &lt;QtCore/qtconfigmacros.h&gt;\n#include &lt;QtCore/qtclasshelpermacros.h&gt;\n#include &lt;QtCore/qtdeprecationdefinitions.h&gt;\n#include &lt;QtCore/qtversionchecks.h&gt;\n#include &lt;QtCore/qcompilerdetection.h&gt; // for Q_DECL_DEPRECATED\n\n#if 0\n#pragma qt_class(QtDeprecationMarkers)\n#pragma qt_sync_stop_processing\n#endif\n\nQT_BEGIN_NAMESPACE\n\n#if defined(QT_NO_DEPRECATED)\n#  undef QT_DEPRECATED\n#  undef QT_DEPRECATED_X\n#  undef QT_DEPRECATED_VARIABLE\n#  undef QT_DEPRECATED_CONSTRUCTOR\n#elif !defined(QT_NO_DEPRECATED_WARNINGS)\n#  undef QT_DEPRECATED\n#  define QT_DEPRECATED Q_DECL_DEPRECATED\n#  undef QT_DEPRECATED_X\n#  define QT_DEPRECATED_X(text) Q_DECL_DEPRECATED_X(text)\n#  undef QT_DEPRECATED_VARIABLE\n#  define QT_DEPRECATED_VARIABLE Q_DECL_VARIABLE_DEPRECATED\n#  undef QT_DEPRECATED_CONSTRUCTOR\n#  define QT_DEPRECATED_CONSTRUCTOR Q_DECL_CONSTRUCTOR_DEPRECATED explicit\n#else\n#  undef QT_DEPRECATED\n#  define QT_DEPRECATED\n#  undef QT_DEPRECATED_X\n#  define QT_DEPRECATED_X(text)\n#  undef QT_DEPRECATED_VARIABLE\n#  define QT_DEPRECATED_VARIABLE\n#  undef QT_DEPRECATED_CONSTRUCTOR\n#  define QT_DEPRECATED_CONSTRUCTOR\n#  undef Q_DECL_ENUMERATOR_DEPRECATED\n#  define Q_DECL_ENUMERATOR_DEPRECATED\n#  undef Q_DECL_ENUMERATOR_DEPRECATED_X\n#  define Q_DECL_ENUMERATOR_DEPRECATED_X(ignored)\n#endif\n\n/*\n    QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than\n    the deprecation point specified.\n\n    Use it to specify from which version of Qt a function or class has been deprecated\n\n    Example:\n        #if QT_DEPRECATED_SINCE(5,1)\n            QT_DEPRECATED void deprecatedFunction(); //function deprecated since Qt 5.1\n        #endif\n\n*/\n#ifdef QT_DEPRECATED\n#define QT_DEPRECATED_SINCE(major, minor) (QT_VERSION_CHECK(major, minor, 0) &gt; QT_DISABLE_DEPRECATED_UP_TO)\n#else\n#define QT_DEPRECATED_SINCE(major, minor) 0\n#endif\n\n/*\n    QT_REMOVAL_QT{VER}_DEPRECATED_SINCE(major, minor)\n\n    The macro should be used if the API is deprecated and should be removed\n    in the {VER} major release.\n\n    The \\a major and \\a minor parameters specify the deprecation version.\n\n    For now, we provide the macros to remove the deprecated APIs in Qt 7\n    and in Qt 8.\n\n    Example:\n\n    \\code\n    #if QT_REMOVAL_QT7_DEPRECATED_SINCE(6, 9)\n        QT_DEPRECATED_VERSION_X_6_9(&quot;The reason for the deprecation&quot;)\n        void deprecatedFunc();\n    #endif\n    \\endcode\n\n    The \\c {deprecatedFunc()} function is deprecated since Qt 6.9, and will be\n    completely removed in Qt 7.0.\n*/\n#define QT_DEPRECATED_TO_BE_REMOVED_HELPER(dep_major, dep_minor, rem_major) \\\n    (QT_DEPRECATED_SINCE(dep_major, dep_minor) &amp;&amp; (QT_VERSION &lt; QT_VERSION_CHECK(rem_major, 0, 0)))\n\n// For APIs that should be removed in Qt 7\n#define QT_REMOVAL_QT7_DEPRECATED_SINCE(major, minor) \\\n    QT_DEPRECATED_TO_BE_REMOVED_HELPER(major, minor, 7)\n\n// For APIs that should be removed in Qt 8\n#define QT_REMOVAL_QT8_DEPRECATED_SINCE(major, minor) \\\n    QT_DEPRECATED_TO_BE_REMOVED_HELPER(major, minor, 8)\n\n/*\n  QT_DEPRECATED_VERSION(major, minor) and QT_DEPRECATED_VERSION_X(major, minor, text)\n  outputs a deprecation warning if QT_WARN_DEPRECATED_UP_TO is equal to or greater\n  than the version specified as major, minor. This makes it possible to deprecate a\n  function without annoying a user who needs to stay compatible with a specified minimum\n  version and therefore can&#x27;t use the new function.\n*/\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(5, 12, 0)\n# define QT_DEPRECATED_VERSION_X_5_12(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_5_12         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_5_12(text)\n# define QT_DEPRECATED_VERSION_5_12\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(5, 13, 0)\n# define QT_DEPRECATED_VERSION_X_5_13(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_5_13         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_5_13(text)\n# define QT_DEPRECATED_VERSION_5_13\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(5, 14, 0)\n# define QT_DEPRECATED_VERSION_X_5_14(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_5_14         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_5_14(text)\n# define QT_DEPRECATED_VERSION_5_14\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(5, 15, 0)\n# define QT_DEPRECATED_VERSION_X_5_15(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_5_15         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_5_15(text)\n# define QT_DEPRECATED_VERSION_5_15\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 0, 0)\n# define QT_DEPRECATED_VERSION_X_6_0(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_0         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_0(text)\n# define QT_DEPRECATED_VERSION_6_0\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 1, 0)\n# define QT_DEPRECATED_VERSION_X_6_1(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_1         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_1(text)\n# define QT_DEPRECATED_VERSION_6_1\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 2, 0)\n# define QT_DEPRECATED_VERSION_X_6_2(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_2         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_2(text)\n# define QT_DEPRECATED_VERSION_6_2\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 3, 0)\n# define QT_DEPRECATED_VERSION_X_6_3(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_3         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_3(text)\n# define QT_DEPRECATED_VERSION_6_3\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 4, 0)\n# define QT_DEPRECATED_VERSION_X_6_4(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_4         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_4(text)\n# define QT_DEPRECATED_VERSION_6_4\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 5, 0)\n# define QT_DEPRECATED_VERSION_X_6_5(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_5         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_5(text)\n# define QT_DEPRECATED_VERSION_6_5\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 6, 0)\n# define QT_DEPRECATED_VERSION_X_6_6(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_6         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_6(text)\n# define QT_DEPRECATED_VERSION_6_6\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 7, 0)\n# define QT_DEPRECATED_VERSION_X_6_7(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_7         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_7(text)\n# define QT_DEPRECATED_VERSION_6_7\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 8, 0)\n# define QT_DEPRECATED_VERSION_X_6_8(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_8         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_8(text)\n# define QT_DEPRECATED_VERSION_6_8\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 9, 0)\n# define QT_DEPRECATED_VERSION_X_6_9(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_9         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_9(text)\n# define QT_DEPRECATED_VERSION_6_9\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 10, 0)\n# define QT_DEPRECATED_VERSION_X_6_10(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_10         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_10(text)\n# define QT_DEPRECATED_VERSION_6_10\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 11, 0)\n# define QT_DEPRECATED_VERSION_X_6_11(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_11         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_11(text)\n# define QT_DEPRECATED_VERSION_6_11\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 12, 0)\n# define QT_DEPRECATED_VERSION_X_6_12(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_12         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_12(text)\n# define QT_DEPRECATED_VERSION_6_12\n#endif\n\n#if QT_WARN_DEPRECATED_UP_TO &gt;= QT_VERSION_CHECK(6, 13, 0)\n# define QT_DEPRECATED_VERSION_X_6_13(text) QT_DEPRECATED_X(text)\n# define QT_DEPRECATED_VERSION_6_13         QT_DEPRECATED\n#else\n# define QT_DEPRECATED_VERSION_X_6_13(text)\n# define QT_DEPRECATED_VERSION_6_13\n#endif\n\n#define QT_DEPRECATED_VERSION_X_5(minor, text)      QT_DEPRECATED_VERSION_X_5_##minor(text)\n#define QT_DEPRECATED_VERSION_X(major, minor, text) QT_DEPRECATED_VERSION_X_##major##_##minor(text)\n\n#define QT_DEPRECATED_VERSION_5(minor)      QT_DEPRECATED_VERSION_5_##minor\n#define QT_DEPRECATED_VERSION(major, minor) QT_DEPRECATED_VERSION_##major##_##minor\n\n/*\n    QT_IF_DEPRECATED_SINCE(major, minor, whenTrue, whenFalse) expands to\n    \\a whenTrue if the specified (\\a major, \\a minor) version is less than or\n    equal to the deprecation version defined by QT_DISABLE_DEPRECATED_UP_TO,\n    and to \\a whenFalse otherwise.\n\n    Currently used for QT_INLINE_SINCE(maj, min), but can also be helpful for\n    other macros of that kind.\n\n    The implementation uses QT_DEPRECATED_SINCE(maj, min) to define a bunch of\n    helper QT_IF_DEPRECATED_SINCE_X_Y macros, which expand to \\a whenTrue or\n    \\a whenFalse depending on the value of QT_DEPRECATED_SINCE.\n\n    If you need to use QT_IF_DEPRECATED_SINCE() for a (major, minor) version,\n    that is not yet covered by the list below, you need to copy the definition\n    and change the major and minor versions accordingly. For example, for\n    version (X, Y), you will need to add\n\n    \\code\n    #if QT_DEPRECATED_SINCE(X, Y)\n    # define QT_IF_DEPRECATED_SINCE_X_Y(whenTrue, whenFalse) whenFalse\n    #else\n    # define QT_IF_DEPRECATED_SINCE_X_Y(whenTrue, whenFalse) whenTrue\n    #endif\n    \\endcode\n*/\n\n#define QT_IF_DEPRECATED_SINCE(major, minor, whenTrue, whenFalse) \\\n    QT_IF_DEPRECATED_SINCE_ ## major ## _ ## minor(whenTrue, whenFalse)\n\n#if QT_DEPRECATED_SINCE(6, 0)\n# define QT_IF_DEPRECATED_SINCE_6_0(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_0(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 1)\n# define QT_IF_DEPRECATED_SINCE_6_1(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_1(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 2)\n# define QT_IF_DEPRECATED_SINCE_6_2(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_2(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 3)\n# define QT_IF_DEPRECATED_SINCE_6_3(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_3(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 4)\n# define QT_IF_DEPRECATED_SINCE_6_4(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_4(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 5)\n# define QT_IF_DEPRECATED_SINCE_6_5(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_5(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 6)\n# define QT_IF_DEPRECATED_SINCE_6_6(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_6(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 7)\n# define QT_IF_DEPRECATED_SINCE_6_7(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_7(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 8)\n# define QT_IF_DEPRECATED_SINCE_6_8(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_8(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 9)\n# define QT_IF_DEPRECATED_SINCE_6_9(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_9(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 10)\n# define QT_IF_DEPRECATED_SINCE_6_10(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_10(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 11)\n# define QT_IF_DEPRECATED_SINCE_6_11(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_11(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 12)\n# define QT_IF_DEPRECATED_SINCE_6_12(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_12(whenTrue, whenFalse) whenTrue\n#endif\n\n#if QT_DEPRECATED_SINCE(6, 13)\n# define QT_IF_DEPRECATED_SINCE_6_13(whenTrue, whenFalse) whenFalse\n#else\n# define QT_IF_DEPRECATED_SINCE_6_13(whenTrue, whenFalse) whenTrue\n#endif\n\n#ifdef __cplusplus\n// A tag to help mark stuff deprecated (cf. QStringViewLiteral)\nnamespace QtPrivate {\ninline QT_DEFINE_TAG(Deprecated);\n}\n#endif\n\n#ifdef QT_ASCII_CAST_WARNINGS\n#  define QT_ASCII_CAST_WARN \\\n    Q_DECL_DEPRECATED_X(&quot;Use fromUtf8, QStringLiteral, or QLatin1StringView&quot;)\n#else\n#  define QT_ASCII_CAST_WARN\n#endif\n\nQT_END_NAMESPACE\n\n#endif // QTDEPRECATIONMARKERS_H\n"}, "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "content": "// Copyright (C) 2022 The Qt Company Ltd.\n// Copyright (C) 2016 Intel Corporation.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#if 0\n#pragma qt_class(QtCompilerDetection)\n#pragma qt_sync_skip_header_check\n#pragma qt_sync_stop_processing\n#endif\n\n#ifndef QCOMPILERDETECTION_H\n#define QCOMPILERDETECTION_H\n\n#include &lt;QtCore/qprocessordetection.h&gt;\n#include &lt;QtCore/qsystemdetection.h&gt;\n#include &lt;QtCore/qtconfiginclude.h&gt;\n\n/*\n   The compiler, must be one of: (Q_CC_x)\n\n     COVERITY - Coverity cov-scan\n     SYM      - Digital Mars C/C++ (used to be Symantec C++)\n     MSVC     - Microsoft Visual C/C++, Intel C++ for Windows\n     BOR      - Borland/Turbo C++\n     WAT      - Watcom C++\n     GNU      - GNU C++\n     COMEAU   - Comeau C++\n     EDG      - Edison Design Group C++\n     OC       - CenterLine C++\n     SUN      - Forte Developer, or Sun Studio C++\n     MIPS     - MIPSpro C++\n     DEC      - DEC C++\n     HPACC    - HP aC++\n     USLC     - SCO OUDK and UDK\n     CDS      - Reliant C++\n     KAI      - KAI C++\n     INTEL    - Intel C++ for Linux, Intel C++ for Windows\n     HIGHC    - MetaWare High C/C++\n     PGI      - Portland Group C++\n     GHS      - Green Hills Optimizing C++ Compilers\n     RVCT     - ARM Realview Compiler Suite\n     CLANG    - C++ front-end for the LLVM compiler\n\n\n   Should be sorted most to least authoritative.\n*/\n\n#if defined(__COVERITY__)\n#  define Q_CC_COVERITY\n#  define Q_COMPILER_COMPLAINS_ABOUT_RETURN_AFTER_UNREACHABLE\n#endif\n\n/* Symantec C++ is now Digital Mars */\n#if defined(__DMC__) || defined(__SC__)\n#  define Q_CC_SYM\n/* &quot;explicit&quot; semantics implemented in 8.1e but keyword recognized since 7.5 */\n#  if defined(__SC__) &amp;&amp; __SC__ &lt; 0x750\n#    error &quot;Compiler not supported&quot;\n#  endif\n\n#elif defined(_MSC_VER)\n#  define Q_CC_MSVC (_MSC_VER)\n#  define Q_CC_MSVC_NET\n#  define Q_CC_MSVC_ONLY Q_CC_MSVC\n#  ifdef __clang__\n#    undef Q_CC_MSVC_ONLY\n#    define Q_CC_CLANG ((__clang_major__ * 100) + __clang_minor__)\n#    define Q_CC_CLANG_ONLY Q_CC_CLANG\n#  endif\n#  define Q_OUTOFLINE_TEMPLATE inline\n#  define Q_COMPILER_MANGLES_RETURN_TYPE\n#  define Q_COMPILER_MANGLES_ACCESS_SPECIFIER\n#  define Q_FUNC_INFO __FUNCSIG__\n#  define Q_ASSUME_IMPL(expr) __assume(expr)\n#  define Q_UNREACHABLE_IMPL() __assume(0)\n#  define Q_DECL_EXPORT __declspec(dllexport)\n#  define Q_DECL_IMPORT __declspec(dllimport)\n#  if _MSC_VER &lt; 1938 // stdext is deprecated since VS 2022 17.8\n#    define QT_MAKE_CHECKED_ARRAY_ITERATOR(x, N) stdext::make_checked_array_iterator(x, size_t(N)) // Since _MSC_VER &gt;= 1500\n#  endif\n#  ifdef Q_CC_MSVC_ONLY\n#    define Q_COMPILER_COMPLAINS_ABOUT_RETURN_AFTER_UNREACHABLE\n#  endif\n\n#elif defined(__BORLANDC__) || defined(__TURBOC__)\n#  define Q_CC_BOR\n#  define Q_INLINE_TEMPLATE\n#  if __BORLANDC__ &lt; 0x502\n#    error &quot;Compiler not supported&quot;\n#  endif\n\n#elif defined(__WATCOMC__)\n#  define Q_CC_WAT\n\n/* ARM Realview Compiler Suite\n   RVCT compiler also defines __EDG__ and __GNUC__ (if --gnu flag is given),\n   so check for it before that */\n#elif defined(__ARMCC__) || defined(__CC_ARM)\n#  define Q_CC_RVCT\n/* work-around for missing compiler intrinsics */\n#  define __is_empty(X) false\n#  define __is_pod(X) false\n#  define Q_DECL_DEPRECATED __attribute__ ((__deprecated__))\n#  ifdef Q_OS_LINUX\n#    define Q_DECL_EXPORT     __attribute__((visibility(&quot;default&quot;)))\n#    define Q_DECL_IMPORT     __attribute__((visibility(&quot;default&quot;)))\n#    define Q_DECL_HIDDEN     __attribute__((visibility(&quot;hidden&quot;)))\n#  else\n#    define Q_DECL_EXPORT     __declspec(dllexport)\n#    define Q_DECL_IMPORT     __declspec(dllimport)\n#  endif\n\n#elif defined(__GNUC__)\n#  define Q_CC_GNU          (__GNUC__ * 100 + __GNUC_MINOR__)\n#  if defined(__MINGW32__)\n#    define Q_CC_MINGW\n#  endif\n#  if defined(__clang__)\n/* Clang also masquerades as GCC */\n#    if defined(__apple_build_version__)\n      // The Clang version reported by Apple Clang in __clang_major__\n      // and __clang_minor__ does _not_ reflect the actual upstream\n      // version of the compiler. To allow consumers to use a single\n      // define to verify the Clang version we hard-code the versions\n      // based on the best available info we have about the actual\n      // version: http://en.wikipedia.org/wiki/Xcode#Toolchain_Versions\n#      if __apple_build_version__   &gt;= 14030022 // Xcode 14.3\n#        define Q_CC_CLANG 1500\n#      elif __apple_build_version__ &gt;= 14000029 // Xcode 14.0\n#        define Q_CC_CLANG 1400\n#      elif __apple_build_version__ &gt;= 13160021 // Xcode 13.3\n#        define Q_CC_CLANG 1300\n#      elif __apple_build_version__ &gt;= 13000029 // Xcode 13.0\n#        define Q_CC_CLANG 1200\n#      elif __apple_build_version__ &gt;= 12050022 // Xcode 12.5\n#        define Q_CC_CLANG 1110\n#      elif __apple_build_version__ &gt;= 12000032 // Xcode 12.0\n#        define Q_CC_CLANG 1000\n#      elif __apple_build_version__ &gt;= 11030032 // Xcode 11.4\n#        define Q_CC_CLANG 900\n#      elif __apple_build_version__ &gt;= 11000033 // Xcode 11.0\n#        define Q_CC_CLANG 800\n#      else\n#        error &quot;Unsupported Apple Clang version&quot;\n#      endif\n#    else\n       // Non-Apple Clang, so we trust the versions reported\n#      define Q_CC_CLANG ((__clang_major__ * 100) + __clang_minor__)\n#    endif\n#    define Q_CC_CLANG_ONLY Q_CC_CLANG\n#    if __has_builtin(__builtin_assume)\n#      define Q_ASSUME_IMPL(expr)   __builtin_assume(expr)\n#    else\n#      define Q_ASSUME_IMPL(expr)  if (expr){} else __builtin_unreachable()\n#    endif\n#    define Q_UNREACHABLE_IMPL() __builtin_unreachable()\n#    if !defined(__has_extension)\n#      /* Compatibility with older Clang versions */\n#      define __has_extension __has_feature\n#    endif\n#    if defined(__APPLE__)\n     /* Apple/clang specific features */\n#      define Q_DECL_CF_RETURNS_RETAINED __attribute__((cf_returns_retained))\n#      ifdef __OBJC__\n#        define Q_DECL_NS_RETURNS_AUTORELEASED __attribute__((ns_returns_autoreleased))\n#      endif\n#    endif\n#    ifdef __EMSCRIPTEN__\n#      define Q_CC_EMSCRIPTEN\n#    endif\n#  else\n/* Plain GCC */\n#    define Q_CC_GNU_ONLY Q_CC_GNU\n#    if Q_CC_GNU &gt;= 405\n#      define Q_ASSUME_IMPL(expr)  if (expr){} else __builtin_unreachable()\n#      define Q_UNREACHABLE_IMPL() __builtin_unreachable()\n#      define Q_DECL_DEPRECATED_X(text) __attribute__ ((__deprecated__(text)))\n#    endif\n#  endif\n\n#  ifdef Q_OS_WIN\n#    define Q_DECL_EXPORT     __declspec(dllexport)\n#    define Q_DECL_IMPORT     __declspec(dllimport)\n#  else\n#    define Q_DECL_EXPORT_OVERRIDABLE __attribute__((visibility(&quot;default&quot;), weak))\n#    ifdef QT_USE_PROTECTED_VISIBILITY\n#      define Q_DECL_EXPORT     __attribute__((visibility(&quot;protected&quot;)))\n#    else\n#      define Q_DECL_EXPORT     __attribute__((visibility(&quot;default&quot;)))\n#    endif\n#    define Q_DECL_IMPORT     __attribute__((visibility(&quot;default&quot;)))\n#    define Q_DECL_HIDDEN     __attribute__((visibility(&quot;hidden&quot;)))\n#  endif\n\n#  define Q_FUNC_INFO       __PRETTY_FUNCTION__\n#  define Q_TYPEOF(expr)    __typeof__(expr)\n#  define Q_DECL_DEPRECATED __attribute__ ((__deprecated__))\n#  define Q_DECL_UNUSED     __attribute__((__unused__))\n#  define Q_LIKELY(expr)    __builtin_expect(!!(expr), true)\n#  define Q_UNLIKELY(expr)  __builtin_expect(!!(expr), false)\n#  define Q_NORETURN        __attribute__((__noreturn__))\n#  define Q_REQUIRED_RESULT __attribute__ ((__warn_unused_result__))\n#  define Q_DECL_PURE_FUNCTION __attribute__((pure))\n#  define Q_DECL_CONST_FUNCTION __attribute__((const))\n#  define Q_DECL_COLD_FUNCTION __attribute__((cold))\n#  define Q_PACKED __attribute__ ((__packed__))\n#  ifndef __ARM_EABI__\n#    define QT_NO_ARM_EABI\n#  endif\n#  if Q_CC_GNU &gt;= 403 &amp;&amp; !defined(Q_CC_CLANG)\n#      define Q_ALLOC_SIZE(x) __attribute__((alloc_size(x)))\n#  endif\n\n/* IBM compiler versions are a bit messy. There are actually two products:\n   the C product, and the C++ product. The C++ compiler is always packaged\n   with the latest version of the C compiler. Version numbers do not always\n   match. This little table (I&#x27;m not sure it&#x27;s accurate) should be helpful:\n\n   C++ product                C product\n\n   C Set 3.1                  C Compiler 3.0\n   ...                        ...\n   C++ Compiler 3.6.6         C Compiler 4.3\n   ...                        ...\n   Visual Age C++ 4.0         ...\n   ...                        ...\n   Visual Age C++ 5.0         C Compiler 5.0\n   ...                        ...\n   Visual Age C++ 6.0         C Compiler 6.0\n\n   Now:\n   __xlC__    is the version of the C compiler in hexadecimal notation\n              is only an approximation of the C++ compiler version\n   __IBMCPP__ is the version of the C++ compiler in decimal notation\n              but it is not defined on older compilers like C Set 3.1 */\n#elif defined(__xlC__)\n#  define Q_CC_XLC\n#  if __xlC__ &lt; 0x400\n#    error &quot;Compiler not supported&quot;\n#  elif __xlC__ &gt;= 0x0600\n#    define Q_TYPEOF(expr)      __typeof__(expr)\n#    define Q_PACKED            __attribute__((__packed__))\n#  endif\n\n/* Older versions of DEC C++ do not define __EDG__ or __EDG - observed\n   on DEC C++ V5.5-004. New versions do define  __EDG__ - observed on\n   Compaq C++ V6.3-002.\n   This compiler is different enough from other EDG compilers to handle\n   it separately anyway. */\n#elif defined(__DECCXX) || defined(__DECC)\n#  define Q_CC_DEC\n/* Compaq C++ V6 compilers are EDG-based but I&#x27;m not sure about older\n   DEC C++ V5 compilers. */\n#  if defined(__EDG__)\n#    define Q_CC_EDG\n#  endif\n/* Compaq has disabled EDG&#x27;s _BOOL macro and uses _BOOL_EXISTS instead\n   - observed on Compaq C++ V6.3-002.\n   In any case versions prior to Compaq C++ V6.0-005 do not have bool. */\n#  if !defined(_BOOL_EXISTS)\n#    error &quot;Compiler not supported&quot;\n#  endif\n/* Spurious (?) error messages observed on Compaq C++ V6.5-014. */\n/* Apply to all versions prior to Compaq C++ V6.0-000 - observed on\n   DEC C++ V5.5-004. */\n#  if __DECCXX_VER &lt; 60060000\n#    define Q_BROKEN_TEMPLATE_SPECIALIZATION\n#  endif\n/* avoid undefined symbol problems with out-of-line template members */\n#  define Q_OUTOFLINE_TEMPLATE inline\n\n/* The Portland Group C++ compiler is based on EDG and does define __EDG__\n   but the C compiler does not */\n#elif defined(__PGI)\n#  define Q_CC_PGI\n#  if defined(__EDG__)\n#    define Q_CC_EDG\n#  endif\n\n/* Compilers with EDG front end are similar. To detect them we test:\n   __EDG documented by SGI, observed on MIPSpro 7.3.1.1 and KAI C++ 4.0b\n   __EDG__ documented in EDG online docs, observed on Compaq C++ V6.3-002\n   and PGI C++ 5.2-4 */\n#elif !defined(Q_OS_HPUX) &amp;&amp; (defined(__EDG) || defined(__EDG__))\n#  define Q_CC_EDG\n/* From the EDG documentation (does not seem to apply to Compaq C++ or GHS C):\n   _BOOL\n        Defined in C++ mode when bool is a keyword. The name of this\n        predefined macro is specified by a configuration flag. _BOOL\n        is the default.\n   __BOOL_DEFINED\n        Defined in Microsoft C++ mode when bool is a keyword. */\n#  if !defined(_BOOL) &amp;&amp; !defined(__BOOL_DEFINED) &amp;&amp; !defined(__ghs)\n#    error &quot;Compiler not supported&quot;\n#  endif\n\n/* The Comeau compiler is based on EDG and does define __EDG__ */\n#  if defined(__COMO__)\n#    define Q_CC_COMEAU\n\n/* The `using&#x27; keyword was introduced to avoid KAI C++ warnings\n   but it&#x27;s now causing KAI C++ errors instead. The standard is\n   unclear about the use of this keyword, and in practice every\n   compiler is using its own set of rules. Forget it. */\n#  elif defined(__KCC)\n#    define Q_CC_KAI\n\n/* Uses CFront, make sure to read the manual how to tweak templates. */\n#  elif defined(__ghs)\n#    define Q_CC_GHS\n#    define Q_DECL_DEPRECATED __attribute__ ((__deprecated__))\n#    define Q_PACKED __attribute__ ((__packed__))\n#    define Q_FUNC_INFO       __PRETTY_FUNCTION__\n#    define Q_TYPEOF(expr)      __typeof__(expr)\n#    define Q_UNREACHABLE_IMPL()\n#    if defined(__cplusplus)\n#      define Q_COMPILER_AUTO_TYPE\n#      define Q_COMPILER_STATIC_ASSERT\n#      define Q_COMPILER_RANGE_FOR\n#      if __GHS_VERSION_NUMBER &gt;= 201505\n#        define Q_COMPILER_ALIGNAS\n#        define Q_COMPILER_ALIGNOF\n#        define Q_COMPILER_ATOMICS\n#        define Q_COMPILER_ATTRIBUTES\n#        define Q_COMPILER_AUTO_FUNCTION\n#        define Q_COMPILER_CLASS_ENUM\n#        define Q_COMPILER_DECLTYPE\n#        define Q_COMPILER_DEFAULT_MEMBERS\n#        define Q_COMPILER_DELETE_MEMBERS\n#        define Q_COMPILER_DELEGATING_CONSTRUCTORS\n#        define Q_COMPILER_EXPLICIT_CONVERSIONS\n#        define Q_COMPILER_EXPLICIT_OVERRIDES\n#        define Q_COMPILER_EXTERN_TEMPLATES\n#        define Q_COMPILER_INHERITING_CONSTRUCTORS\n#        define Q_COMPILER_INITIALIZER_LISTS\n#        define Q_COMPILER_LAMBDA\n#        define Q_COMPILER_NONSTATIC_MEMBER_INIT\n#        define Q_COMPILER_NOEXCEPT\n#        define Q_COMPILER_NULLPTR\n#        define Q_COMPILER_RANGE_FOR\n#        define Q_COMPILER_RAW_STRINGS\n#        define Q_COMPILER_REF_QUALIFIERS\n#        define Q_COMPILER_RVALUE_REFS\n#        define Q_COMPILER_STATIC_ASSERT\n#        define Q_COMPILER_TEMPLATE_ALIAS\n#        define Q_COMPILER_THREAD_LOCAL\n#        define Q_COMPILER_UDL\n#        define Q_COMPILER_UNICODE_STRINGS\n#        define Q_COMPILER_UNIFORM_INIT\n#        define Q_COMPILER_UNRESTRICTED_UNIONS\n#        define Q_COMPILER_VARIADIC_MACROS\n#        define Q_COMPILER_VARIADIC_TEMPLATES\n#      endif\n#    endif //__cplusplus\n\n#  elif defined(__DCC__)\n#    define Q_CC_DIAB\n#    if !defined(__bool)\n#      error &quot;Compiler not supported&quot;\n#    endif\n\n/* The UnixWare 7 UDK compiler is based on EDG and does define __EDG__ */\n#  elif defined(__USLC__) &amp;&amp; defined(__SCO_VERSION__)\n#    define Q_CC_USLC\n/* The latest UDK 7.1.1b does not need this, but previous versions do */\n#    if !defined(__SCO_VERSION__) || (__SCO_VERSION__ &lt; 302200010)\n#      define Q_OUTOFLINE_TEMPLATE inline\n#    endif\n\n/* Never tested! */\n#  elif defined(CENTERLINE_CLPP) || defined(OBJECTCENTER)\n#    define Q_CC_OC\n\n/* CDS++ defines __EDG__ although this is not documented in the Reliant\n   documentation. It also follows conventions like _BOOL and this documented */\n#  elif defined(sinix)\n#    define Q_CC_CDS\n#  endif\n\n/* VxWorks&#x27; DIAB toolchain has an additional EDG type C++ compiler\n   (see __DCC__ above). This one is for C mode files (__EDG is not defined) */\n#elif defined(_DIAB_TOOL)\n#  define Q_CC_DIAB\n#  define Q_FUNC_INFO       __PRETTY_FUNCTION__\n\n/* Never tested! */\n#elif defined(__HIGHC__)\n#  define Q_CC_HIGHC\n\n#elif defined(__SUNPRO_CC) || defined(__SUNPRO_C)\n#  define Q_CC_SUN\n#  define Q_COMPILER_MANGLES_RETURN_TYPE\n/* 5.0 compiler or better\n    &#x27;bool&#x27; is enabled by default but can be disabled using -features=nobool\n    in which case _BOOL is not defined\n        this is the default in 4.2 compatibility mode triggered by -compat=4 */\n#  if __SUNPRO_CC &gt;= 0x500\n#    define QT_NO_TEMPLATE_TEMPLATE_PARAMETERS\n   /* see http://developers.sun.com/sunstudio/support/Ccompare.html */\n#    if __SUNPRO_CC &gt;= 0x590\n#      define Q_TYPEOF(expr)    __typeof__(expr)\n#    endif\n#    if __SUNPRO_CC &gt;= 0x550\n#      define Q_DECL_EXPORT     __global\n#    endif\n#    if !defined(_BOOL)\n#      error &quot;Compiler not supported&quot;\n#    endif\n/* 4.2 compiler or older */\n#  else\n#    error &quot;Compiler not supported&quot;\n#  endif\n\n/* CDS++ does not seem to define __EDG__ or __EDG according to Reliant\n   documentation but nevertheless uses EDG conventions like _BOOL */\n#elif defined(sinix)\n#  define Q_CC_EDG\n#  define Q_CC_CDS\n#  if !defined(_BOOL)\n#    error &quot;Compiler not supported&quot;\n#  endif\n#  define Q_BROKEN_TEMPLATE_SPECIALIZATION\n\n#else\n#  error &quot;Qt has not been tested with this compiler - see http://www.qt-project.org/&quot;\n#endif\n\n/*\n * SG10&#x27;s SD-6 feature detection and some useful extensions from Clang and GCC\n * https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations\n * http://clang.llvm.org/docs/LanguageExtensions.html#feature-checking-macros\n * Not using wrapper macros, per http://eel.is/c++draft/cpp.cond#7.sentence-2\n */\n#ifndef __has_builtin\n#  define __has_builtin(x)             0\n#endif\n#ifndef __has_feature\n#  define __has_feature(x)             0\n#endif\n#ifndef __has_attribute\n#  define __has_attribute(x)           0\n#endif\n#ifndef __has_c_attribute\n#  define __has_c_attribute(x)         0\n#endif\n#ifndef __has_cpp_attribute\n#  define __has_cpp_attribute(x)       0\n#endif\n#ifndef __has_include\n#  define __has_include(x)             0\n#endif\n#ifndef __has_include_next\n#  define __has_include_next(x)        0\n#endif\n\n/*\n   detecting ASAN can be helpful to disable slow tests\n   clang uses feature, gcc  defines __SANITIZE_ADDRESS__\n   unconditionally check both in case other compilers mirror\n   either of those options\n */\n#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n#  define QT_ASAN_ENABLED\n#endif\n\n/*\n * C++11 support\n *\n *  Paper           Macro                               SD-6 macro\n *  N2341           Q_COMPILER_ALIGNAS\n *  N2341           Q_COMPILER_ALIGNOF\n *  N2427           Q_COMPILER_ATOMICS\n *  N2761           Q_COMPILER_ATTRIBUTES               __cpp_attributes = 200809\n *  N2541           Q_COMPILER_AUTO_FUNCTION\n *  N1984 N2546     Q_COMPILER_AUTO_TYPE\n *  N2437           Q_COMPILER_CLASS_ENUM\n *  N2235           Q_COMPILER_CONSTEXPR                __cpp_constexpr = 200704\n *  N2343 N3276     Q_COMPILER_DECLTYPE                 __cpp_decltype = 200707\n *  N2346           Q_COMPILER_DEFAULT_MEMBERS\n *  N2346           Q_COMPILER_DELETE_MEMBERS\n *  N1986           Q_COMPILER_DELEGATING_CONSTRUCTORS\n *  N2437           Q_COMPILER_EXPLICIT_CONVERSIONS\n *  N3206 N3272     Q_COMPILER_EXPLICIT_OVERRIDES\n *  N1987           Q_COMPILER_EXTERN_TEMPLATES\n *  N2540           Q_COMPILER_INHERITING_CONSTRUCTORS\n *  N2672           Q_COMPILER_INITIALIZER_LISTS\n *  N2658 N2927     Q_COMPILER_LAMBDA                   __cpp_lambdas = 200907\n *  N2756           Q_COMPILER_NONSTATIC_MEMBER_INIT\n *  N2855 N3050     Q_COMPILER_NOEXCEPT\n *  N2431           Q_COMPILER_NULLPTR\n *  N2930           Q_COMPILER_RANGE_FOR\n *  N2442           Q_COMPILER_RAW_STRINGS              __cpp_raw_strings = 200710\n *  N2439           Q_COMPILER_REF_QUALIFIERS\n *  N2118 N2844 N3053 Q_COMPILER_RVALUE_REFS            __cpp_rvalue_references = 200610\n *  N1720           Q_COMPILER_STATIC_ASSERT            __cpp_static_assert = 200410\n *  N2258           Q_COMPILER_TEMPLATE_ALIAS\n *  N2659           Q_COMPILER_THREAD_LOCAL\n *  N2660           Q_COMPILER_THREADSAFE_STATICS\n *  N2765           Q_COMPILER_UDL                      __cpp_user_defined_literals = 200809\n *  N2442           Q_COMPILER_UNICODE_STRINGS          __cpp_unicode_literals = 200710\n *  N2640           Q_COMPILER_UNIFORM_INIT\n *  N2544           Q_COMPILER_UNRESTRICTED_UNIONS\n *  N1653           Q_COMPILER_VARIADIC_MACROS\n *  N2242 N2555     Q_COMPILER_VARIADIC_TEMPLATES       __cpp_variadic_templates = 200704\n *\n *\n * For the C++ standards C++14 and C++17, we use only the SD-6 macro.\n *\n * For any future version of the C++ standard, we use only the C++20 feature test macro.\n * For library features, we assume &lt;version&gt; is present (this header includes it).\n *\n * For a full listing of feature test macros, see\n *  https://en.cppreference.com/w/cpp/feature_test\n * Exceptions:\n *  Q_DECL_CONSTEXPR_DTOR           constexpr in C++20 for explicit destructors __cpp_constexpr &gt;= 201907L\n *  Q_CONSTEXPR_DTOR                constexpr in C++20 for variables __cpp_constexpr &gt;= 201907L otherwise const\n *  Q_DECL_EQ_DELETE_X(message)     = delete(&quot;reason&quot;), __cpp_deleted_function &gt;= 202403L\n *\n * C++ extensions:\n *  Q_COMPILER_RESTRICTED_VLA       variable-length arrays, prior to __cpp_runtime_arrays\n */\n\n/*\n * Now that we require C++17, we unconditionally expect threadsafe statics mandated since C++11\n */\n#define Q_COMPILER_THREADSAFE_STATICS\n\n#if defined(Q_CC_CLANG)\n/* General C++ features */\n#  define Q_COMPILER_RESTRICTED_VLA\n#  if __has_feature(attribute_deprecated_with_message)\n#    define Q_DECL_DEPRECATED_X(text) __attribute__ ((__deprecated__(text)))\n#  endif\n\n// Clang supports binary literals in C, C++98 and C++11 modes\n// It&#x27;s been supported &quot;since the dawn of time itself&quot; (cf. commit 179883)\n#  if __has_extension(cxx_binary_literals)\n#    define Q_COMPILER_BINARY_LITERALS\n#  endif\n\n// Variadic macros are supported for gnu++98, c++11, c99 ... since 2.9\n#  if Q_CC_CLANG &gt;= 209\n#    if !defined(__STRICT_ANSI__) || defined(__GXX_EXPERIMENTAL_CXX0X__) \\\n      || (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)) \\\n      || (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L))\n#      define Q_COMPILER_VARIADIC_MACROS\n#    endif\n#  endif\n\n/* C++11 features, see http://clang.llvm.org/cxx_status.html */\n#  if (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L) \\\n      || defined(__GXX_EXPERIMENTAL_CXX0X__)\n    /* Detect C++ features using __has_feature(), see http://clang.llvm.org/docs/LanguageExtensions.html#cxx11 */\n#    if __has_feature(cxx_alignas)\n#      define Q_COMPILER_ALIGNAS\n#      define Q_COMPILER_ALIGNOF\n#    endif\n#    if __has_feature(cxx_atomic) &amp;&amp; __has_include(&lt;atomic&gt;)\n#     define Q_COMPILER_ATOMICS\n#    endif\n#    if __has_feature(cxx_attributes)\n#      define Q_COMPILER_ATTRIBUTES\n#    endif\n#    if __has_feature(cxx_auto_type)\n#      define Q_COMPILER_AUTO_FUNCTION\n#      define Q_COMPILER_AUTO_TYPE\n#    endif\n#    if __has_feature(cxx_strong_enums)\n#      define Q_COMPILER_CLASS_ENUM\n#    endif\n#    if __has_feature(cxx_constexpr) &amp;&amp; Q_CC_CLANG &gt; 302 /* CLANG 3.2 has bad/partial support */\n#      define Q_COMPILER_CONSTEXPR\n#    endif\n#    if __has_feature(cxx_decltype) /* &amp;&amp; __has_feature(cxx_decltype_incomplete_return_types) */\n#      define Q_COMPILER_DECLTYPE\n#    endif\n#    if __has_feature(cxx_defaulted_functions)\n#      define Q_COMPILER_DEFAULT_MEMBERS\n#    endif\n#    if __has_feature(cxx_deleted_functions)\n#      define Q_COMPILER_DELETE_MEMBERS\n#    endif\n#    if __has_feature(cxx_delegating_constructors)\n#      define Q_COMPILER_DELEGATING_CONSTRUCTORS\n#    endif\n#    if __has_feature(cxx_explicit_conversions)\n#      define Q_COMPILER_EXPLICIT_CONVERSIONS\n#    endif\n#    if __has_feature(cxx_override_control)\n#      define Q_COMPILER_EXPLICIT_OVERRIDES\n#    endif\n#    if __has_feature(cxx_inheriting_constructors)\n#      define Q_COMPILER_INHERITING_CONSTRUCTORS\n#    endif\n#    if __has_feature(cxx_generalized_initializers)\n#      define Q_COMPILER_INITIALIZER_LISTS\n#      define Q_COMPILER_UNIFORM_INIT /* both covered by this feature macro, according to docs */\n#    endif\n#    if __has_feature(cxx_lambdas)\n#      define Q_COMPILER_LAMBDA\n#    endif\n#    if __has_feature(cxx_noexcept)\n#      define Q_COMPILER_NOEXCEPT\n#    endif\n#    if __has_feature(cxx_nonstatic_member_init)\n#      define Q_COMPILER_NONSTATIC_MEMBER_INIT\n#    endif\n#    if __has_feature(cxx_nullptr)\n#      define Q_COMPILER_NULLPTR\n#    endif\n#    if __has_feature(cxx_range_for)\n#      define Q_COMPILER_RANGE_FOR\n#    endif\n#    if __has_feature(cxx_raw_string_literals)\n#      define Q_COMPILER_RAW_STRINGS\n#    endif\n#    if __has_feature(cxx_reference_qualified_functions)\n#      define Q_COMPILER_REF_QUALIFIERS\n#    endif\n#    if __has_feature(cxx_rvalue_references)\n#      define Q_COMPILER_RVALUE_REFS\n#    endif\n#    if __has_feature(cxx_static_assert)\n#      define Q_COMPILER_STATIC_ASSERT\n#    endif\n#    if __has_feature(cxx_alias_templates)\n#      define Q_COMPILER_TEMPLATE_ALIAS\n#    endif\n#    if __has_feature(cxx_thread_local)\n#      if !defined(__FreeBSD__) /* FreeBSD clang fails on __cxa_thread_atexit */\n#        define Q_COMPILER_THREAD_LOCAL\n#      endif\n#    endif\n#    if __has_feature(cxx_user_literals)\n#      define Q_COMPILER_UDL\n#    endif\n#    if __has_feature(cxx_unicode_literals)\n#      define Q_COMPILER_UNICODE_STRINGS\n#    endif\n#    if __has_feature(cxx_unrestricted_unions)\n#      define Q_COMPILER_UNRESTRICTED_UNIONS\n#    endif\n#    if __has_feature(cxx_variadic_templates)\n#      define Q_COMPILER_VARIADIC_TEMPLATES\n#    endif\n    /* Features that have no __has_feature() check */\n#    if Q_CC_CLANG &gt;= 209 /* since clang 2.9 */\n#      define Q_COMPILER_EXTERN_TEMPLATES\n#    endif\n#  endif // (defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L) || defined(__GXX_EXPERIMENTAL_CXX0X__)\n\n/* C++1y features, deprecated macros. Do not update this list. */\n#  if defined(__cplusplus) &amp;&amp; __cplusplus &gt; 201103L\n//#    if __has_feature(cxx_binary_literals)\n//#      define Q_COMPILER_BINARY_LITERALS  // see above\n//#    endif\n#    if __has_feature(cxx_generic_lambda)\n#      define Q_COMPILER_GENERIC_LAMBDA\n#    endif\n#    if __has_feature(cxx_init_capture)\n#      define Q_COMPILER_LAMBDA_CAPTURES\n#    endif\n#    if __has_feature(cxx_relaxed_constexpr)\n#      define Q_COMPILER_RELAXED_CONSTEXPR_FUNCTIONS\n#    endif\n#    if __has_feature(cxx_decltype_auto) &amp;&amp; __has_feature(cxx_return_type_deduction)\n#      define Q_COMPILER_RETURN_TYPE_DEDUCTION\n#    endif\n#    if __has_feature(cxx_variable_templates)\n#      define Q_COMPILER_VARIABLE_TEMPLATES\n#    endif\n#    if __has_feature(cxx_runtime_array)\n#      define Q_COMPILER_VLA\n#    endif\n#  endif // if defined(__cplusplus) &amp;&amp; __cplusplus &gt; 201103L\n\n#  if defined(__STDC_VERSION__)\n#    if __has_feature(c_static_assert)\n#      define Q_COMPILER_STATIC_ASSERT\n#    endif\n#    if __has_feature(c_thread_local) &amp;&amp; __has_include(&lt;threads.h&gt;)\n#      if !defined(__FreeBSD__) /* FreeBSD clang fails on __cxa_thread_atexit */\n#        define Q_COMPILER_THREAD_LOCAL\n#      endif\n#    endif\n#  endif\n\n#  ifndef Q_DECL_UNUSED\n#    define Q_DECL_UNUSED __attribute__((__unused__))\n#  endif\n#  define Q_DECL_UNUSED_MEMBER Q_DECL_UNUSED\n#endif //  defined(Q_CC_CLANG)\n\n#if defined(Q_CC_GNU_ONLY)\n#  define Q_COMPILER_RESTRICTED_VLA\n#  if Q_CC_GNU &gt;= 403\n//   GCC supports binary literals in C, C++98 and C++11 modes\n#    define Q_COMPILER_BINARY_LITERALS\n#  endif\n#  if !defined(__STRICT_ANSI__) || defined(__GXX_EXPERIMENTAL_CXX0X__) \\\n    || (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)) \\\n    || (defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901L))\n     // Variadic macros are supported for gnu++98, c++11, C99 ... since forever (gcc 2.97)\n#    define Q_COMPILER_VARIADIC_MACROS\n#  endif\n#  if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus &gt;= 201103L\n#    if Q_CC_GNU &gt;= 403\n       /* C++11 features supported in GCC 4.3: */\n#      define Q_COMPILER_DECLTYPE\n#      define Q_COMPILER_RVALUE_REFS\n#      define Q_COMPILER_STATIC_ASSERT\n#    endif\n#    if Q_CC_GNU &gt;= 404\n       /* C++11 features supported in GCC 4.4: */\n#      define Q_COMPILER_AUTO_FUNCTION\n#      define Q_COMPILER_AUTO_TYPE\n#      define Q_COMPILER_EXTERN_TEMPLATES\n#      define Q_COMPILER_UNIFORM_INIT\n#      define Q_COMPILER_UNICODE_STRINGS\n#      define Q_COMPILER_VARIADIC_TEMPLATES\n#    endif\n#    if Q_CC_GNU &gt;= 405\n       /* C++11 features supported in GCC 4.5: */\n#      define Q_COMPILER_EXPLICIT_CONVERSIONS\n       /* GCC 4.4 implements initializer_list but does not define typedefs required\n        * by the standard. */\n#      define Q_COMPILER_INITIALIZER_LISTS\n#      define Q_COMPILER_LAMBDA\n#      define Q_COMPILER_RAW_STRINGS\n#      define Q_COMPILER_CLASS_ENUM\n#    endif\n#    if Q_CC_GNU &gt;= 406\n       /* Pre-4.6 compilers implement a non-final snapshot of N2346, hence default and delete\n        * functions are supported only if they are public. Starting from 4.6, GCC handles\n        * final version - the access modifier is not relevant. */\n#      define Q_COMPILER_DEFAULT_MEMBERS\n#      define Q_COMPILER_DELETE_MEMBERS\n       /* C++11 features supported in GCC 4.6: */\n#      define Q_COMPILER_NULLPTR\n#      define Q_COMPILER_UNRESTRICTED_UNIONS\n#      define Q_COMPILER_RANGE_FOR\n#    endif\n#    if Q_CC_GNU &gt;= 407\n       /* GCC 4.4 implemented &lt;atomic&gt; and std::atomic using its old intrinsics.\n        * However, the implementation is incomplete for most platforms until GCC 4.7:\n        * instead, std::atomic would use an external lock. Since we need an std::atomic\n        * that is behavior-compatible with QBasicAtomic, we only enable it here */\n#      define Q_COMPILER_ATOMICS\n       /* GCC 4.6.x has problems dealing with noexcept expressions,\n        * so turn the feature on for 4.7 and above, only */\n#      define Q_COMPILER_NOEXCEPT\n       /* C++11 features supported in GCC 4.7: */\n#      define Q_COMPILER_NONSTATIC_MEMBER_INIT\n#      define Q_COMPILER_DELEGATING_CONSTRUCTORS\n#      define Q_COMPILER_EXPLICIT_OVERRIDES\n#      define Q_COMPILER_TEMPLATE_ALIAS\n#      define Q_COMPILER_UDL\n#    endif\n#    if Q_CC_GNU &gt;= 408\n#      define Q_COMPILER_ATTRIBUTES\n#      define Q_COMPILER_ALIGNAS\n#      define Q_COMPILER_ALIGNOF\n#      define Q_COMPILER_INHERITING_CONSTRUCTORS\n#      define Q_COMPILER_THREAD_LOCAL\n#      if Q_CC_GNU &gt; 408 || __GNUC_PATCHLEVEL__ &gt;= 1\n#         define Q_COMPILER_REF_QUALIFIERS\n#      endif\n#    endif\n#    if Q_CC_GNU &gt;= 500\n       /* GCC 4.6 introduces constexpr, but it&#x27;s bugged (at least) in the whole\n        * 4.x series, see e.g. https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57694 */\n#      define Q_COMPILER_CONSTEXPR\n#    endif\n#  endif\n#  if __cplusplus &gt; 201103L\n#    if Q_CC_GNU &gt;= 409\n     /* C++1y features in GCC 4.9 - deprecated, do not update this list */\n//#    define Q_COMPILER_BINARY_LITERALS   // already supported since GCC 4.3 as an extension\n#      define Q_COMPILER_LAMBDA_CAPTURES\n#      define Q_COMPILER_RETURN_TYPE_DEDUCTION\n#    endif\n#  endif\n#  if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt; 199901L\n#    if Q_CC_GNU &gt;= 407\n       /* C11 features supported in GCC 4.7: */\n#      define Q_COMPILER_STATIC_ASSERT\n#    endif\n#    if Q_CC_GNU &gt;= 409 &amp;&amp; defined(__has_include)\n       /* C11 features supported in GCC 4.9: */\n#      if __has_include(&lt;threads.h&gt;)\n#        define Q_COMPILER_THREAD_LOCAL\n#      endif\n#    endif\n#  endif\n#endif\n\n#if defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n#  if defined(__cplusplus)\n       /* C++11 features supported in VC8 = VC2005: */\n#      define Q_COMPILER_VARIADIC_MACROS\n\n       /* 2005 supports the override and final contextual keywords, in\n        the same positions as the C++11 variants, but &#x27;final&#x27; is\n        called &#x27;sealed&#x27; instead:\n        http://msdn.microsoft.com/en-us/library/0w2w91tf%28v=vs.80%29.aspx\n        The behavior is slightly different in C++/CLI, which requires the\n        &quot;virtual&quot; keyword to be present too, so don&#x27;t define for that.\n        So don&#x27;t define Q_COMPILER_EXPLICIT_OVERRIDES (since it&#x27;s not\n        the same as the C++11 version), but define the Q_DECL_* flags\n        accordingly. */\n       /* C++11 features supported in VC10 = VC2010: */\n#      define Q_COMPILER_AUTO_FUNCTION\n#      define Q_COMPILER_AUTO_TYPE\n#      define Q_COMPILER_DECLTYPE\n#      define Q_COMPILER_EXTERN_TEMPLATES\n#      define Q_COMPILER_LAMBDA\n#      define Q_COMPILER_NULLPTR\n#      define Q_COMPILER_RVALUE_REFS\n#      define Q_COMPILER_STATIC_ASSERT\n       /* C++11 features supported in VC11 = VC2012: */\n#      define Q_COMPILER_EXPLICIT_OVERRIDES /* ...and use std C++11 now   */\n#      define Q_COMPILER_CLASS_ENUM\n#      define Q_COMPILER_ATOMICS\n       /* C++11 features in VC12 = VC2013 */\n#      define Q_COMPILER_DELETE_MEMBERS\n#      define Q_COMPILER_DELEGATING_CONSTRUCTORS\n#      define Q_COMPILER_EXPLICIT_CONVERSIONS\n#      define Q_COMPILER_NONSTATIC_MEMBER_INIT\n#      define Q_COMPILER_RAW_STRINGS\n#      define Q_COMPILER_TEMPLATE_ALIAS\n#      define Q_COMPILER_VARIADIC_TEMPLATES\n#      define Q_COMPILER_INITIALIZER_LISTS // VC 12 SP 2 RC\n       /* C++11 features in VC14 = VC2015 */\n#      define Q_COMPILER_DEFAULT_MEMBERS\n#      define Q_COMPILER_ALIGNAS\n#      define Q_COMPILER_ALIGNOF\n#      define Q_COMPILER_INHERITING_CONSTRUCTORS\n#      define Q_COMPILER_NOEXCEPT\n#      define Q_COMPILER_RANGE_FOR\n#      define Q_COMPILER_REF_QUALIFIERS\n#      define Q_COMPILER_THREAD_LOCAL\n#      define Q_COMPILER_UDL\n#      define Q_COMPILER_UNICODE_STRINGS\n#      define Q_COMPILER_UNRESTRICTED_UNIONS\n#    if _MSC_FULL_VER &gt;= 190023419\n#      define Q_COMPILER_ATTRIBUTES\n// Almost working, see https://connect.microsoft.com/VisualStudio/feedback/details/2011648\n//#      define Q_COMPILER_CONSTEXPR\n#      define Q_COMPILER_UNIFORM_INIT\n#    endif\n#    if _MSC_VER &gt;= 1910\n#      define Q_COMPILER_CONSTEXPR\n#    endif\n// MSVC versions before 19.36 have a bug in C++20 comparison implementation.\n// This leads to ambiguities when resolving comparison operator overloads in\n// certain scenarios (the buggy MSVC versions were checked using our CI and\n// compiler explorer).\n#    if _MSC_VER &lt; 1936\n#      define Q_COMPILER_LACKS_THREE_WAY_COMPARE_SYMMETRY\n#    endif\n// QTBUG-124376: MSVC is slow at compiling qstrnlen()\n#    define Q_COMPILER_SLOW_QSTRNLEN_COMPILATION\n#  endif /* __cplusplus */\n#endif // defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n\n#ifdef Q_COMPILER_UNICODE_STRINGS\n#  define Q_STDLIB_UNICODE_STRINGS\n#elif defined(__cplusplus)\n#  error &quot;Qt6 requires Unicode string support in both the compiler and the standard library&quot;\n#endif\n\n#ifdef __cplusplus\n# include &lt;utility&gt;\n# if defined(Q_OS_QNX)\n// By default, QNX 7.0 uses libc++ (from LLVM) and\n// QNX 6.X uses Dinkumware&#x27;s libcpp. In all versions,\n// it is also possible to use GNU libstdc++.\n\n// For Dinkumware, some features must be disabled\n// (mostly because of library problems).\n// Dinkumware is assumed when __GLIBCXX__ (GNU libstdc++)\n// and _LIBCPP_VERSION (LLVM libc++) are both absent.\n#  if !defined(__GLIBCXX__) &amp;&amp; !defined(_LIBCPP_VERSION)\n\n// Older versions of libcpp (QNX 650) do not support C++11 features\n// _HAS_* macros are set to 1 by toolchains that actually include\n// Dinkum C++11 libcpp.\n\n#   if !defined(_HAS_CPP0X) || !_HAS_CPP0X\n// Disable C++11 features that depend on library support\n#    undef Q_COMPILER_INITIALIZER_LISTS\n#    undef Q_COMPILER_RVALUE_REFS\n#    undef Q_COMPILER_REF_QUALIFIERS\n#    undef Q_COMPILER_NOEXCEPT\n// Disable C++11 library features:\n#    undef Q_STDLIB_UNICODE_STRINGS\n#   endif // !_HAS_CPP0X\n#   if !defined(_HAS_NULLPTR_T) || !_HAS_NULLPTR_T\n#    undef Q_COMPILER_NULLPTR\n#   endif //!_HAS_NULLPTR_T\n#   if !defined(_HAS_CONSTEXPR) || !_HAS_CONSTEXPR\n// The libcpp is missing constexpr keywords on important functions like std::numeric_limits&lt;&gt;::min()\n// Disable constexpr support on QNX even if the compiler supports it\n#    undef Q_COMPILER_CONSTEXPR\n#   endif // !_HAS_CONSTEXPR\n#  endif // !__GLIBCXX__ &amp;&amp; !_LIBCPP_VERSION\n# endif // Q_OS_QNX\n# if defined(Q_CC_CLANG) &amp;&amp; defined(Q_OS_DARWIN)\n#  if defined(__GNUC_LIBSTD__) &amp;&amp; ((__GNUC_LIBSTD__-0) * 100 + __GNUC_LIBSTD_MINOR__-0 &lt;= 402)\n// Apple has not updated libstdc++ since 2007, which means it does not have\n// &lt;initializer_list&gt; or std::move. Let&#x27;s disable these features\n#   undef Q_COMPILER_INITIALIZER_LISTS\n#   undef Q_COMPILER_RVALUE_REFS\n#   undef Q_COMPILER_REF_QUALIFIERS\n// Also disable &lt;atomic&gt;, since it&#x27;s clearly not there\n#   undef Q_COMPILER_ATOMICS\n#  endif\n#  if defined(__cpp_lib_memory_resource) \\\n    &amp;&amp; ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED)  &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED  &lt; 140000) \\\n     || (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 170000))\n#   undef __cpp_lib_memory_resource // Only supported on macOS 14 and iOS 17\n#  endif\n# endif // defined(Q_CC_CLANG) &amp;&amp; defined(Q_OS_DARWIN)\n#endif\n\n// Don&#x27;t break code that is already using Q_COMPILER_DEFAULT_DELETE_MEMBERS\n#if defined(Q_COMPILER_DEFAULT_MEMBERS) &amp;&amp; defined(Q_COMPILER_DELETE_MEMBERS)\n#  define Q_COMPILER_DEFAULT_DELETE_MEMBERS\n#endif\n\n/*\n * Compatibility macros for C++11/14 keywords and expressions.\n * Don&#x27;t use in new code and port away whenever you have a chance.\n */\n#define Q_ALIGNOF(x)                alignof(x)\n#define Q_DECL_ALIGN(n)             alignas(n)\n#define Q_DECL_NOTHROW              Q_DECL_NOEXCEPT\n#ifdef __cplusplus\n# define Q_CONSTEXPR                constexpr\n# define Q_DECL_CONSTEXPR           constexpr\n# define Q_DECL_EQ_DEFAULT          = default\n# define Q_DECL_EQ_DELETE           = delete\n# define Q_DECL_FINAL               final\n# define Q_DECL_NOEXCEPT            noexcept\n# define Q_DECL_NOEXCEPT_EXPR(x)    noexcept(x)\n# define Q_DECL_OVERRIDE            override\n# define Q_DECL_RELAXED_CONSTEXPR   constexpr\n# define Q_NULLPTR                  nullptr\n# define Q_RELAXED_CONSTEXPR        constexpr\n#else\n# define Q_CONSTEXPR                const\n# define Q_DECL_CONSTEXPR\n# define Q_DECL_RELAXED_CONSTEXPR\n# define Q_NULLPTR                  NULL\n# define Q_RELAXED_CONSTEXPR        const\n# ifdef Q_CC_GNU\n#  define Q_DECL_NOEXCEPT           __attribute__((__nothrow__))\n# else\n#  define Q_DECL_NOEXCEPT\n# endif\n#endif\n\n#if (defined(__cplusplus) &amp;&amp; __has_cpp_attribute(nodiscard) /* P0188R1 */) || \\\n    (!defined(__cplusplus) &amp;&amp; __has_c_attribute(nodiscard) /* N2267 */)\n#  undef Q_REQUIRED_RESULT\n#  define Q_REQUIRED_RESULT [[nodiscard]]\n#endif\n\n#if (defined(__cplusplus) &amp;&amp; __has_cpp_attribute(nodiscard) &gt;= 201907L /* used for both P1771 and P1301... */) \\\n    || (!defined(__cplusplus) &amp;&amp; __has_c_attribute(nodiscard) /* N2448 */)\n// [[nodiscard]] constructor (P1771)\n#  ifndef Q_NODISCARD_CTOR\n#    define Q_NODISCARD_CTOR [[nodiscard]]\n#  endif\n// [[nodiscard(&quot;reason&quot;)]] (P1301, N2448 for C)\n#  ifndef Q_NODISCARD_X\n#    define Q_NODISCARD_X(message) [[nodiscard(message)]]\n#  endif\n#  ifndef Q_NODISCARD_CTOR_X\n#    define Q_NODISCARD_CTOR_X(message) [[nodiscard(message)]]\n#  endif\n#endif\n\n#if (defined(__cplusplus) &amp;&amp; __has_cpp_attribute(maybe_unused)) || \\\n    (!defined(__cplusplus) &amp;&amp; __has_c_attribute(maybe_unused))\n#  undef Q_DECL_UNUSED\n#  define Q_DECL_UNUSED [[maybe_unused]]\n#endif\n\n#if (defined(__cplusplus) &amp;&amp; __has_cpp_attribute(noreturn)) || \\\n    (!defined(__cplusplus) &amp;&amp; __has_c_attribute(noreturn))\n#  undef Q_NORETURN\n#  define Q_NORETURN [[noreturn]]\n#endif\n\n#if (defined(__cplusplus) &amp;&amp; __has_cpp_attribute(deprecated)) || \\\n    (!defined(__cplusplus) &amp;&amp; __has_c_attribute(deprecated))\n#  ifdef Q_DECL_DEPRECATED\n#    undef Q_DECL_DEPRECATED\n#  endif\n#  ifdef Q_DECL_DEPRECATED_X\n#    undef Q_DECL_DEPRECATED_X\n#  endif\n#  define Q_DECL_DEPRECATED [[deprecated]]\n#  define Q_DECL_DEPRECATED_X(x) [[deprecated(x)]]\n#endif\n\n#define Q_DECL_ENUMERATOR_DEPRECATED Q_DECL_DEPRECATED\n#define Q_DECL_ENUMERATOR_DEPRECATED_X(x) Q_DECL_DEPRECATED_X(x)\n\n#ifndef Q_DECL_CONSTEXPR_DTOR\n#  if __cpp_constexpr &gt;= 201907L\n#    define Q_DECL_CONSTEXPR_DTOR constexpr\n#  else\n#    define Q_DECL_CONSTEXPR_DTOR inline\n#  endif\n#endif\n\n#ifndef Q_CONSTEXPR_DTOR\n#  if __cpp_constexpr &gt;= 201907L\n#    define Q_CONSTEXPR_DTOR constexpr\n#  else\n#    define Q_CONSTEXPR_DTOR const\n#  endif\n#endif\n\n#ifndef Q_DECL_EQ_DELETE_X\n// Clang &lt; 20 advertises the feature-testing macro but issues a warning\n// if one isn&#x27;t also using C++26,\n// https://github.com/llvm/llvm-project/issues/109311\n#  if defined(__cpp_deleted_function) &amp;&amp; __cpp_deleted_function &gt;= 202403L \\\n    &amp;&amp; (!defined(Q_CC_CLANG_ONLY) || Q_CC_CLANG_ONLY &gt;= 2000 || __cplusplus &gt; 202302L) // C++26\n#    define Q_DECL_EQ_DELETE_X(reason) = delete(reason)\n#  else\n#    define Q_DECL_EQ_DELETE_X(reason) = delete\n#  endif\n#endif\n\n#ifndef Q_LIKELY_BRANCH\n#  if __has_cpp_attribute(likely)\n#    define Q_LIKELY_BRANCH [[likely]]\n#    define Q_UNLIKELY_BRANCH [[unlikely]]\n#  else\n#    define Q_LIKELY_BRANCH\n#    define Q_UNLIKELY_BRANCH\n#  endif\n#endif\n\n/*\n * Fallback macros to certain compiler features\n */\n\n#ifndef Q_NORETURN\n# define Q_NORETURN\n#endif\n#ifndef Q_LIKELY\n#  define Q_LIKELY(x) (x)\n#endif\n#ifndef Q_UNLIKELY\n#  define Q_UNLIKELY(x) (x)\n#endif\n#ifndef Q_ASSUME_IMPL\n#  define Q_ASSUME_IMPL(expr) qt_noop()\n#endif\n#ifndef Q_UNREACHABLE_IMPL\n#  define Q_UNREACHABLE_IMPL() qt_noop()\n#endif\n#ifndef Q_ALLOC_SIZE\n#  define Q_ALLOC_SIZE(x)\n#endif\n#ifndef Q_REQUIRED_RESULT\n#  define Q_REQUIRED_RESULT\n#endif\n#ifndef Q_NODISCARD_X\n#  define Q_NODISCARD_X(message) Q_REQUIRED_RESULT\n#endif\n#ifndef Q_NODISCARD_CTOR\n#  define Q_NODISCARD_CTOR\n#endif\n#ifndef Q_NODISCARD_CTOR_X\n#  define Q_NODISCARD_CTOR_X(message) Q_NODISCARD_CTOR\n#endif\n#ifndef Q_DECL_DEPRECATED\n#  define Q_DECL_DEPRECATED\n#endif\n#ifndef Q_DECL_VARIABLE_DEPRECATED\n#  define Q_DECL_VARIABLE_DEPRECATED Q_DECL_DEPRECATED\n#endif\n#ifndef Q_DECL_DEPRECATED_X\n#  define Q_DECL_DEPRECATED_X(text) Q_DECL_DEPRECATED\n#endif\n#ifndef Q_DECL_EXPORT\n#  define Q_DECL_EXPORT\n#endif\n#ifndef Q_DECL_EXPORT_OVERRIDABLE\n#  define Q_DECL_EXPORT_OVERRIDABLE Q_DECL_EXPORT\n#endif\n#ifndef Q_DECL_IMPORT\n#  define Q_DECL_IMPORT\n#endif\n#ifndef Q_DECL_HIDDEN\n#  define Q_DECL_HIDDEN\n#endif\n#ifndef Q_DECL_UNUSED\n#  define Q_DECL_UNUSED\n#endif\n#ifndef Q_DECL_UNUSED_MEMBER\n#  define Q_DECL_UNUSED_MEMBER\n#endif\n#ifndef Q_FUNC_INFO\n#  if defined(Q_OS_SOLARIS) || defined(Q_CC_XLC)\n#    define Q_FUNC_INFO __FILE__ &quot;(line number unavailable)&quot;\n#  else\n#    define Q_FUNC_INFO __FILE__ &quot;:&quot; QT_STRINGIFY(__LINE__)\n#  endif\n#endif\n#ifndef Q_DECL_CF_RETURNS_RETAINED\n#  define Q_DECL_CF_RETURNS_RETAINED\n#endif\n#ifndef Q_DECL_NS_RETURNS_AUTORELEASED\n#  define Q_DECL_NS_RETURNS_AUTORELEASED\n#endif\n#ifndef Q_DECL_PURE_FUNCTION\n#  define Q_DECL_PURE_FUNCTION\n#endif\n#ifndef Q_DECL_CONST_FUNCTION\n#  define Q_DECL_CONST_FUNCTION Q_DECL_PURE_FUNCTION\n#endif\n#ifndef Q_DECL_COLD_FUNCTION\n#  define Q_DECL_COLD_FUNCTION\n#endif\n#ifndef QT_MAKE_UNCHECKED_ARRAY_ITERATOR\n#  define QT_MAKE_UNCHECKED_ARRAY_ITERATOR(x) (x)\n#endif\n#ifndef QT_MAKE_CHECKED_ARRAY_ITERATOR\n#  define QT_MAKE_CHECKED_ARRAY_ITERATOR(x, N) (x)\n#endif\n\n/*\n * &quot;Weak overloads&quot; - makes an otherwise confliciting overload weaker\n * (by making it a template)\n */\n#ifndef Q_QDOC\n#  define Q_WEAK_OVERLOAD template &lt;typename = void&gt;\n#else\n#  define Q_WEAK_OVERLOAD\n#endif\n\n/*\n * If one wants to add functions that use post-C++17 APIs, one needs to:\n *\n * 1) make them fully inline; and\n * 2) guard them using the necessary feature-testing macros.\n *\n * This decouples the C++ version used to build Qt with the one used by\n * end-user applications; Qt and the application can either choose any C++\n * version.\n *\n * A problem arises on MSVC for member functions of exported classes. Client\n * code that tries to use such a function will see it as exported, and simply\n * try to consume the function&#x27;s *symbol*. However, if Qt has been built in\n * C++17, it won&#x27;t have such a symbol, and linking will fail.\n *\n * The workaround: declare such functions as function templates.\n * (Obviously a function template does not need this marker.)\n*/\n#ifndef Q_QDOC\n#  define QT_POST_CXX17_API_IN_EXPORTED_CLASS template &lt;typename = void&gt;\n#else\n#  define QT_POST_CXX17_API_IN_EXPORTED_CLASS\n#endif\n\n/*\n * Warning/diagnostic handling\n */\n\n#define QT_DO_PRAGMA(text)                      _Pragma(#text)\n#if defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n#  undef QT_DO_PRAGMA                           /* not needed */\n#  define QT_WARNING_PUSH                       __pragma(warning(push))\n#  define QT_WARNING_POP                        __pragma(warning(pop))\n#  define QT_WARNING_DISABLE_MSVC(number)       __pragma(warning(disable: number))\n#  define QT_WARNING_DISABLE_INTEL(number)\n#  define QT_WARNING_DISABLE_CLANG(text)\n#  define QT_WARNING_DISABLE_GCC(text)\n#  define QT_WARNING_DISABLE_DEPRECATED         QT_WARNING_DISABLE_MSVC(4996)\n#  define QT_WARNING_DISABLE_FLOAT_COMPARE\n#  define QT_WARNING_DISABLE_INVALID_OFFSETOF\n#elif defined(Q_CC_CLANG)\n#  define QT_WARNING_PUSH                       QT_DO_PRAGMA(clang diagnostic push)\n#  define QT_WARNING_POP                        QT_DO_PRAGMA(clang diagnostic pop)\n#  define QT_WARNING_DISABLE_CLANG(text)        QT_DO_PRAGMA(clang diagnostic ignored text)\n#  define QT_WARNING_DISABLE_GCC(text)\n#  define QT_WARNING_DISABLE_INTEL(number)\n#  define QT_WARNING_DISABLE_MSVC(number)\n#  define QT_WARNING_DISABLE_DEPRECATED         QT_WARNING_DISABLE_CLANG(&quot;-Wdeprecated-declarations&quot;)\n#  define QT_WARNING_DISABLE_FLOAT_COMPARE      QT_WARNING_DISABLE_CLANG(&quot;-Wfloat-equal&quot;)\n#  define QT_WARNING_DISABLE_INVALID_OFFSETOF   QT_WARNING_DISABLE_CLANG(&quot;-Winvalid-offsetof&quot;)\n#elif defined(Q_CC_GNU) &amp;&amp; (__GNUC__ * 100 + __GNUC_MINOR__ &gt;= 406)\n#  define QT_WARNING_PUSH                       QT_DO_PRAGMA(GCC diagnostic push)\n#  define QT_WARNING_POP                        QT_DO_PRAGMA(GCC diagnostic pop)\n#  define QT_WARNING_DISABLE_GCC(text)          QT_DO_PRAGMA(GCC diagnostic ignored text)\n#  define QT_WARNING_DISABLE_CLANG(text)\n#  define QT_WARNING_DISABLE_INTEL(number)\n#  define QT_WARNING_DISABLE_MSVC(number)\n#  define QT_WARNING_DISABLE_DEPRECATED         QT_WARNING_DISABLE_GCC(&quot;-Wdeprecated-declarations&quot;)\n#  define QT_WARNING_DISABLE_FLOAT_COMPARE      QT_WARNING_DISABLE_GCC(&quot;-Wfloat-equal&quot;)\n#  define QT_WARNING_DISABLE_INVALID_OFFSETOF   QT_WARNING_DISABLE_GCC(&quot;-Winvalid-offsetof&quot;)\n#else       // All other compilers, GCC &lt; 4.6 and MSVC &lt; 2008\n#  define QT_WARNING_DISABLE_GCC(text)\n#  define QT_WARNING_PUSH\n#  define QT_WARNING_POP\n#  define QT_WARNING_DISABLE_INTEL(number)\n#  define QT_WARNING_DISABLE_MSVC(number)\n#  define QT_WARNING_DISABLE_CLANG(text)\n#  define QT_WARNING_DISABLE_GCC(text)\n#  define QT_WARNING_DISABLE_DEPRECATED\n#  define QT_WARNING_DISABLE_FLOAT_COMPARE\n#  define QT_WARNING_DISABLE_INVALID_OFFSETOF\n#endif\n\n#ifndef QT_IGNORE_DEPRECATIONS\n#define QT_IGNORE_DEPRECATIONS(statement) \\\n    QT_WARNING_PUSH \\\n    QT_WARNING_DISABLE_DEPRECATED \\\n    statement \\\n    QT_WARNING_POP\n#endif\n\n// The body must be a statement:\n#define Q_CAST_IGNORE_ALIGN(body) QT_WARNING_PUSH QT_WARNING_DISABLE_GCC(&quot;-Wcast-align&quot;) body QT_WARNING_POP\n\n// This macro can be used to calculate member offsets for types with a non standard layout.\n// It uses the fact that offsetof() is allowed to support those types since C++17 as an optional\n// feature. All our compilers do support this, but some issue a warning, so we wrap the offsetof()\n// call in a macro that disables the compiler warning.\n#define Q_OFFSETOF(Class, member) \\\n    []() -&gt; size_t { \\\n        QT_WARNING_PUSH QT_WARNING_DISABLE_INVALID_OFFSETOF \\\n        return offsetof(Class, member); \\\n        QT_WARNING_POP \\\n    }()\n\n/*\n   Proper for-scoping in MIPSpro CC\n*/\n#ifndef QT_NO_KEYWORDS\n#  if defined(Q_CC_MIPS) || (defined(Q_CC_HPACC) &amp;&amp; defined(__ia64))\n#    define for if (0) {} else for\n#  endif\n#endif\n\n#ifdef Q_COMPILER_RVALUE_REFS\n#define qMove(x) std::move(x)\n#else\n#define qMove(x) (x)\n#endif\n\n#if defined(__cplusplus)\n#if __has_cpp_attribute(clang::fallthrough)\n#    define Q_FALLTHROUGH() [[clang::fallthrough]]\n#elif __has_cpp_attribute(gnu::fallthrough)\n#    define Q_FALLTHROUGH() [[gnu::fallthrough]]\n#elif __has_cpp_attribute(fallthrough)\n#  define Q_FALLTHROUGH() [[fallthrough]]\n#endif\n#else // !defined(__cplusplus)\n#  if __has_c_attribute(fallthrough)\n#    define Q_FALLTHROUGH() [[fallthrough]]\n#  endif\n#endif // !defined(__cplusplus)\n#ifndef Q_FALLTHROUGH\n#  ifdef Q_CC_GNU\n#    define Q_FALLTHROUGH() __attribute__((fallthrough))\n#  else\n#    define Q_FALLTHROUGH() (void)0\n#  endif\n#endif\n\n#if defined(__has_attribute) &amp;&amp; __has_attribute(uninitialized)\n#  define Q_DECL_UNINITIALIZED __attribute__((uninitialized))\n#else\n#  define Q_DECL_UNINITIALIZED\n#endif\n\n\n/*\n    Sanitize compiler feature availability\n*/\n#if !defined(Q_PROCESSOR_X86)\n#  undef QT_COMPILER_SUPPORTS_SSE2\n#  undef QT_COMPILER_SUPPORTS_SSE3\n#  undef QT_COMPILER_SUPPORTS_SSSE3\n#  undef QT_COMPILER_SUPPORTS_SSE4_1\n#  undef QT_COMPILER_SUPPORTS_SSE4_2\n#  undef QT_COMPILER_SUPPORTS_AVX\n#  undef QT_COMPILER_SUPPORTS_AVX2\n#  undef QT_COMPILER_SUPPORTS_F16C\n#endif\n#if !defined(Q_PROCESSOR_ARM)\n#  undef QT_COMPILER_SUPPORTS_NEON\n#endif\n#if !defined(Q_PROCESSOR_MIPS)\n#  undef QT_COMPILER_SUPPORTS_MIPS_DSP\n#  undef QT_COMPILER_SUPPORTS_MIPS_DSPR2\n#endif\n\n// Compiler version check\n#if defined(__cplusplus) &amp;&amp; (__cplusplus &lt; 201703L)\n#  ifdef Q_CC_MSVC\n#    error &quot;Qt requires a C++17 compiler, and a suitable value for __cplusplus. On MSVC, you must pass the /Zc:__cplusplus option to the compiler.&quot;\n#  else\n#    error &quot;Qt requires a C++17 compiler&quot;\n#  endif\n#endif // __cplusplus\n\n#if defined(__cplusplus) &amp;&amp; defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n#  if Q_CC_MSVC &lt; 1927\n     // Check below only works with 16.7 or newer\n#    error &quot;Qt requires at least Visual Studio 2019 version 16.7 (VC++ version 14.27). Please upgrade.&quot;\n#  endif\n\n// On MSVC we require /permissive- set by user code. Check that we are\n// under its rules -- for instance, check that std::nullptr_t-&gt;bool is\n// not an implicit conversion, as per\n// https://docs.microsoft.com/en-us/cpp/overview/cpp-conformance-improvements?view=msvc-160#nullptr_t-is-only-convertible-to-bool-as-a-direct-initialization\nstatic_assert(!std::is_convertible_v&lt;std::nullptr_t, bool&gt;,\n              &quot;On MSVC you must pass the /permissive- option to the compiler.&quot;);\n#endif\n\n#if defined(QT_BOOTSTRAPPED) || defined(QT_USE_PROTECTED_VISIBILITY) || !defined(__ELF__) || defined(__PIC__)\n// this is fine\n#elif defined(__PIE__)\n#  error &quot;-fPIE is not sufficient if Qt was configured with the -DFEATURE_reduce_relocations=ON &quot;\\\n         &quot;CMake option. Compile your code with -fPIC and without -fPIE or compile Qt with &quot;\\\n         &quot;-DFEATURE_no_direct_extern_access=ON.&quot;\n#elif defined(QT_REDUCE_RELOCATIONS)\n#  error &quot;You must build your code with position independent code if Qt was configured with the &quot;\\\n         &quot;-DFEATURE_reduce_relocations=ON CMake option. Compile your code with -fPIC and &quot;\\\n         &quot;without -fPIE or compile Qt with -DFEATURE_no_direct_extern_access=ON.&quot;\n#endif\n\n#ifdef Q_PROCESSOR_X86_32\n#  if defined(Q_CC_GNU)\n#    define QT_FASTCALL __attribute__((regparm(3)))\n#  elif defined(Q_CC_MSVC)\n#    define QT_FASTCALL __fastcall\n#  else\n#    define QT_FASTCALL\n#  endif\n#else\n#  define QT_FASTCALL\n#endif\n\n// enable gcc warnings for printf-style functions\n#if defined(Q_CC_GNU) &amp;&amp; !defined(__INSURE__)\n#  if defined(Q_CC_MINGW) &amp;&amp; !defined(Q_CC_CLANG)\n#    define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \\\n         __attribute__((format(gnu_printf, (A), (B))))\n#  else\n#    define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \\\n         __attribute__((format(printf, (A), (B))))\n#  endif\n#else\n#  define Q_ATTRIBUTE_FORMAT_PRINTF(A, B)\n#endif\n\n#ifdef Q_CC_MSVC\n#  define Q_NEVER_INLINE __declspec(noinline)\n#  define Q_ALWAYS_INLINE __forceinline\n#elif defined(Q_CC_GNU)\n#  define Q_NEVER_INLINE __attribute__((noinline))\n#  define Q_ALWAYS_INLINE inline __attribute__((always_inline))\n#else\n#  define Q_NEVER_INLINE\n#  define Q_ALWAYS_INLINE inline\n#endif\n\n//defines the type for the WNDPROC on windows\n//the alignment needs to be forced for sse2 to not crash with mingw\n#if defined(Q_OS_WIN)\n#  if defined(Q_CC_MINGW) &amp;&amp; defined(Q_PROCESSOR_X86_32)\n#    define QT_ENSURE_STACK_ALIGNED_FOR_SSE __attribute__ ((force_align_arg_pointer))\n#  else\n#    define QT_ENSURE_STACK_ALIGNED_FOR_SSE\n#  endif\n#  define QT_WIN_CALLBACK CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE\n#endif\n\n#ifdef __cpp_conditional_explicit\n#define Q_IMPLICIT explicit(false)\n#else\n#define Q_IMPLICIT\n#endif\n\n#if defined(__cplusplus)\n\n#ifdef __cpp_constinit\n# if defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n   // https://developercommunity.visualstudio.com/t/C:-constinit-for-an-optional-fails-if-/1406069\n#  define Q_CONSTINIT\n# else\n#  define Q_CONSTINIT constinit\n# endif\n#elif defined(__has_cpp_attribute) &amp;&amp; __has_cpp_attribute(clang::require_constant_initialization)\n# define Q_CONSTINIT [[clang::require_constant_initialization]]\n#elif defined(Q_CC_GNU_ONLY) &amp;&amp; Q_CC_GNU &gt;= 1000\n# define Q_CONSTINIT __constinit\n#else\n# define Q_CONSTINIT\n#endif\n\n#ifndef Q_OUTOFLINE_TEMPLATE\n#  define Q_OUTOFLINE_TEMPLATE\n#endif\n#ifndef Q_INLINE_TEMPLATE\n#  define Q_INLINE_TEMPLATE inline\n#endif\n\n/*\n   Avoid some particularly useless warnings from some stupid compilers.\n   To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out\n   the line &quot;#define QT_NO_WARNINGS&quot;. See also QTBUG-26877.\n*/\n#if !defined(QT_CC_WARNINGS)\n#  define QT_NO_WARNINGS\n#endif\n#if defined(QT_NO_WARNINGS)\n#  if defined(Q_CC_MSVC)\nQT_WARNING_DISABLE_MSVC(4251) /* class &#x27;type&#x27; needs to have dll-interface to be used by clients of class &#x27;type2&#x27; */\nQT_WARNING_DISABLE_MSVC(4244) /* conversion from &#x27;type1&#x27; to &#x27;type2&#x27;, possible loss of data */\nQT_WARNING_DISABLE_MSVC(4275) /* non - DLL-interface classkey &#x27;identifier&#x27; used as base for DLL-interface classkey &#x27;identifier&#x27; */\nQT_WARNING_DISABLE_MSVC(4514) /* unreferenced inline function has been removed */\nQT_WARNING_DISABLE_MSVC(4800) /* &#x27;type&#x27; : forcing value to bool &#x27;true&#x27; or &#x27;false&#x27; (performance warning) */\nQT_WARNING_DISABLE_MSVC(4097) /* typedef-name &#x27;identifier1&#x27; used as synonym for class-name &#x27;identifier2&#x27; */\nQT_WARNING_DISABLE_MSVC(4706) /* assignment within conditional expression */\nQT_WARNING_DISABLE_MSVC(4355) /* &#x27;this&#x27; : used in base member initializer list */\nQT_WARNING_DISABLE_MSVC(4710) /* function not inlined */\nQT_WARNING_DISABLE_MSVC(4530) /* C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc */\n#  elif defined(Q_CC_BOR)\n#    pragma option -w-inl\n#    pragma option -w-aus\n#    pragma warn -inl\n#    pragma warn -pia\n#    pragma warn -ccc\n#    pragma warn -rch\n#    pragma warn -sig\n#  endif\n#endif\n\n#if !defined(QT_NO_EXCEPTIONS)\n#  if !defined(Q_MOC_RUN)\n#    if defined(Q_CC_GNU) &amp;&amp; !defined(__cpp_exceptions)\n#      define QT_NO_EXCEPTIONS\n#    endif\n#  elif defined(QT_BOOTSTRAPPED)\n#    define QT_NO_EXCEPTIONS\n#  endif\n#endif\n\n// libstdc++ shipped with gcc &lt; 11 does not have a fix for defect LWG 3346\n#if __cplusplus &gt;= 202002L &amp;&amp; (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE &gt;= 11)\n#  define QT_COMPILER_HAS_LWG3346\n#endif\n\n#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 202002L // P0846 doesn&#x27;t have a feature macro :/\n# if !defined(Q_CC_MSVC_ONLY) || Q_CC_MSVC &gt;= 1939 // claims C++20 support but lacks P0846\n                                                   // 1939 is known to work\n                                                   // 1936 is known to fail\n#  define QT_COMPILER_HAS_P0846\n# endif\n#endif\n\n#ifdef QT_COMPILER_HAS_P0846\n#   define QT_ENABLE_P0846_SEMANTICS_FOR(func)\n#else\n    class QT_CLASS_JUST_FOR_P0846_SIMULATION;\n#   define QT_ENABLE_P0846_SEMANTICS_FOR(func) \\\n        template &lt;typename T&gt; \\\n        void func (QT_CLASS_JUST_FOR_P0846_SIMULATION *); \\\n        /* end */\n#endif // !P0846\n\n#endif // __cplusplus\n\n#endif // QCOMPILERDETECTION_H\n"}, "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qmetatype.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qmetatype.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qmetatype.h", "content": "// Copyright (C) 2021 The Qt Company Ltd.\n// Copyright (C) 2018 Intel Corporation.\n// Copyright (C) 2014 Olivier Goffart &lt;ogoffart@woboq.com&gt;\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#ifndef QMETATYPE_H\n#define QMETATYPE_H\n\n#include &lt;QtCore/qglobal.h&gt;\n#include &lt;QtCore/qatomic.h&gt;\n#include &lt;QtCore/qbytearray.h&gt;\n#include &lt;QtCore/qcompare.h&gt;\n#include &lt;QtCore/qdatastream.h&gt;\n#include &lt;QtCore/qflags.h&gt;\n#include &lt;QtCore/qfloat16.h&gt;\n#include &lt;QtCore/qhashfunctions.h&gt;\n#include &lt;QtCore/qiterable.h&gt;\n#ifndef QT_NO_QOBJECT\n#include &lt;QtCore/qobjectdefs.h&gt;\n#endif\n#include &lt;QtCore/qscopeguard.h&gt;\n#include &lt;QtCore/qttypetraits.h&gt;\n\n#include &lt;array&gt;\n#include &lt;new&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;functional&gt;\n#include &lt;optional&gt;\n#include &lt;QtCore/qxptype_traits.h&gt;\n\n#ifdef Bool\n#error qmetatype.h must be included before any header file that defines Bool\n#endif\n\nQT_BEGIN_NAMESPACE\n\n// from qcborcommon.h\nenum class QCborSimpleType : quint8;\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeId2;\n\ntemplate &lt;typename T&gt;\ninline constexpr int qMetaTypeId();\n\n// F is a tuple: (QMetaType::TypeName, QMetaType::TypeNameID, RealType)\n#define QT_FOR_EACH_STATIC_PRIMITIVE_NON_VOID_TYPE(F)\\\n    F(Bool, 1, bool) \\\n    F(Int, 2, int) \\\n    F(UInt, 3, uint) \\\n    F(LongLong, 4, qlonglong) \\\n    F(ULongLong, 5, qulonglong) \\\n    F(Double, 6, double) \\\n    F(Long, 32, long) \\\n    F(Short, 33, short) \\\n    F(Char, 34, char) \\\n    F(Char16, 56, char16_t) \\\n    F(Char32, 57, char32_t) \\\n    F(ULong, 35, ulong) \\\n    F(UShort, 36, ushort) \\\n    F(UChar, 37, uchar) \\\n    F(Float, 38, float) \\\n    F(SChar, 40, signed char) \\\n    F(Nullptr, 51, std::nullptr_t) \\\n    F(QCborSimpleType, 52, QCborSimpleType) \\\n\n#define QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(F)        \\\n    QT_FOR_EACH_STATIC_PRIMITIVE_NON_VOID_TYPE(F)   \\\n    F(Void, 43, void) \\\n\n#define QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(F)     \\\n    F(VoidStar, 31, void*) \\\n\n#if QT_CONFIG(easingcurve)\n#define QT_FOR_EACH_STATIC_EASINGCURVE(F)\\\n    F(QEasingCurve, 29, QEasingCurve)\n#else\n#define QT_FOR_EACH_STATIC_EASINGCURVE(F)\n#endif\n\n#if QT_CONFIG(itemmodel)\n#define QT_FOR_EACH_STATIC_ITEMMODEL_CLASS(F)\\\n    F(QModelIndex, 42, QModelIndex) \\\n    F(QPersistentModelIndex, 50, QPersistentModelIndex)\n#else\n#define QT_FOR_EACH_STATIC_ITEMMODEL_CLASS(F)\n#endif\n\n#if QT_CONFIG(regularexpression)\n#  define QT_FOR_EACH_STATIC_REGULAR_EXPRESSION(F) \\\n    F(QRegularExpression, 44, QRegularExpression)\n#else\n#  define QT_FOR_EACH_STATIC_REGULAR_EXPRESSION(F)\n#endif\n#ifndef QT_NO_VARIANT\n#  define QT_FOR_EACH_STATIC_QVARIANT(F) \\\n    F(QVariant, 41, QVariant)\n#else\n#  define QT_FOR_EACH_STATIC_QVARIANT(F)\n#endif\n\n#define QT_FOR_EACH_STATIC_CORE_CLASS(F)\\\n    F(QChar, 7, QChar) \\\n    F(QString, 10, QString) \\\n    F(QByteArray, 12, QByteArray) \\\n    F(QBitArray, 13, QBitArray) \\\n    F(QDate, 14, QDate) \\\n    F(QTime, 15, QTime) \\\n    F(QDateTime, 16, QDateTime) \\\n    F(QUrl, 17, QUrl) \\\n    F(QLocale, 18, QLocale) \\\n    F(QRect, 19, QRect) \\\n    F(QRectF, 20, QRectF) \\\n    F(QSize, 21, QSize) \\\n    F(QSizeF, 22, QSizeF) \\\n    F(QLine, 23, QLine) \\\n    F(QLineF, 24, QLineF) \\\n    F(QPoint, 25, QPoint) \\\n    F(QPointF, 26, QPointF) \\\n    QT_FOR_EACH_STATIC_EASINGCURVE(F) \\\n    F(QUuid, 30, QUuid) \\\n    QT_FOR_EACH_STATIC_QVARIANT(F) \\\n    QT_FOR_EACH_STATIC_REGULAR_EXPRESSION(F) \\\n    F(QJsonValue, 45, QJsonValue) \\\n    F(QJsonObject, 46, QJsonObject) \\\n    F(QJsonArray, 47, QJsonArray) \\\n    F(QJsonDocument, 48, QJsonDocument) \\\n    F(QCborValue, 53, QCborValue) \\\n    F(QCborArray, 54, QCborArray) \\\n    F(QCborMap, 55, QCborMap) \\\n    F(Float16, 63, qfloat16) \\\n    QT_FOR_EACH_STATIC_ITEMMODEL_CLASS(F)\n\n#define QT_FOR_EACH_STATIC_CORE_POINTER(F)\\\n    F(QObjectStar, 39, QObject*)\n\n#ifndef QT_NO_VARIANT\n#  define QT_FOR_EACH_STATIC_CORE_QVARIANT_TEMPLATE(F) \\\n    F(QVariantMap, 8, QVariantMap) \\\n    F(QVariantList, 9, QVariantList) \\\n    F(QVariantHash, 28, QVariantHash) \\\n    F(QVariantPair, 58, QVariantPair) \\\n    /**/\n#else\n#  define QT_FOR_EACH_STATIC_CORE_QVARIANT_TEMPLATE(F)\n#endif // QT_NO_VARIANT\n\n#define QT_FOR_EACH_STATIC_CORE_TEMPLATE(F) \\\n    QT_FOR_EACH_STATIC_CORE_QVARIANT_TEMPLATE(F) \\\n    F(QByteArrayList, 49, QByteArrayList) \\\n    F(QStringList, 11, QStringList)\n\n#if QT_CONFIG(shortcut)\n#define QT_FOR_EACH_STATIC_KEYSEQUENCE_CLASS(F)\\\n    F(QKeySequence, 0x100b, QKeySequence)\n#else\n#define QT_FOR_EACH_STATIC_KEYSEQUENCE_CLASS(F)\n#endif\n\n#define QT_FOR_EACH_STATIC_GUI_CLASS(F)\\\n    F(QFont, 0x1000, QFont) \\\n    F(QPixmap, 0x1001, QPixmap) \\\n    F(QBrush, 0x1002, QBrush) \\\n    F(QColor, 0x1003, QColor) \\\n    F(QPalette, 0x1004, QPalette) \\\n    F(QIcon, 0x1005, QIcon) \\\n    F(QImage, 0x1006, QImage) \\\n    F(QPolygon, 0x1007, QPolygon) \\\n    F(QRegion, 0x1008, QRegion) \\\n    F(QBitmap, 0x1009, QBitmap) \\\n    F(QCursor, 0x100a, QCursor) \\\n    QT_FOR_EACH_STATIC_KEYSEQUENCE_CLASS(F) \\\n    F(QPen, 0x100c, QPen) \\\n    F(QTextLength, 0x100d, QTextLength) \\\n    F(QTextFormat, 0x100e, QTextFormat) \\\n    F(QTransform, 0x1010, QTransform) \\\n    F(QMatrix4x4, 0x1011, QMatrix4x4) \\\n    F(QVector2D, 0x1012, QVector2D) \\\n    F(QVector3D, 0x1013, QVector3D) \\\n    F(QVector4D, 0x1014, QVector4D) \\\n    F(QQuaternion, 0x1015, QQuaternion) \\\n    F(QPolygonF, 0x1016, QPolygonF) \\\n    F(QColorSpace, 0x1017, QColorSpace) \\\n\n\n#define QT_FOR_EACH_STATIC_WIDGETS_CLASS(F)\\\n    F(QSizePolicy, 0x2000, QSizePolicy) \\\n\n// F is a tuple: (QMetaType::TypeName, QMetaType::TypeNameID, AliasingType, &quot;RealType&quot;)\n#define QT_FOR_EACH_STATIC_ALIAS_TYPE(F)\\\n    F(ULong, -1, ulong, &quot;unsigned long&quot;) \\\n    F(UInt, -1, uint, &quot;unsigned int&quot;) \\\n    F(UShort, -1, ushort, &quot;unsigned short&quot;) \\\n    F(UChar, -1, uchar, &quot;unsigned char&quot;) \\\n    F(LongLong, -1, qlonglong, &quot;long long&quot;) \\\n    F(ULongLong, -1, qulonglong, &quot;unsigned long long&quot;) \\\n    F(SChar, -1, signed char, &quot;qint8&quot;) \\\n    F(UChar, -1, uchar, &quot;quint8&quot;) \\\n    F(Short, -1, short, &quot;qint16&quot;) \\\n    F(UShort, -1, ushort, &quot;quint16&quot;) \\\n    F(Int, -1, int, &quot;qint32&quot;) \\\n    F(UInt, -1, uint, &quot;quint32&quot;) \\\n    F(LongLong, -1, qlonglong, &quot;qint64&quot;) \\\n    F(ULongLong, -1, qulonglong, &quot;quint64&quot;) \\\n    F(QByteArrayList, -1, QByteArrayList, &quot;QList&lt;QByteArray&gt;&quot;) \\\n    F(QStringList, -1, QStringList, &quot;QList&lt;QString&gt;&quot;) \\\n    QT_FOR_EACH_STATIC_VARIANT_ALIAS_TYPE(F)\n\n#ifndef QT_NO_VARIANT\n#define QT_FOR_EACH_STATIC_VARIANT_ALIAS_TYPE(F) \\\n    F(QVariantList, -1, QVariantList, &quot;QList&lt;QVariant&gt;&quot;) \\\n    F(QVariantMap, -1, QVariantMap, &quot;QMap&lt;QString,QVariant&gt;&quot;) \\\n    F(QVariantHash, -1, QVariantHash, &quot;QHash&lt;QString,QVariant&gt;&quot;) \\\n    F(QVariantPair, -1, QVariantPair, &quot;QPair&lt;QVariant,QVariant&gt;&quot;) \\\n    /**/\n#else\n#define QT_FOR_EACH_STATIC_VARIANT_ALIAS_TYPE(F)\n#endif\n\n#define QT_FOR_EACH_STATIC_TYPE(F)\\\n    QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(F)\\\n    QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(F)\\\n    QT_FOR_EACH_STATIC_CORE_CLASS(F)\\\n    QT_FOR_EACH_STATIC_CORE_POINTER(F)\\\n    QT_FOR_EACH_STATIC_CORE_TEMPLATE(F)\\\n    QT_FOR_EACH_STATIC_GUI_CLASS(F)\\\n    QT_FOR_EACH_STATIC_WIDGETS_CLASS(F)\\\n\n#define QT_DEFINE_METATYPE_ID(TypeName, Id, Name) \\\n    TypeName = Id,\n\n#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG(F) \\\n    F(QList) \\\n    F(QQueue) \\\n    F(QStack) \\\n    F(QSet) \\\n    /*end*/\n\n#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_2ARG(F) \\\n    F(QHash, class) \\\n    F(QMap, class)\n\n#define QT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(F) \\\n    F(QSharedPointer) \\\n    F(QWeakPointer) \\\n    F(QPointer)\n\nclass QDataStream;\nstruct QMetaObject;\n\nnamespace QtPrivate\n{\n\nclass QMetaTypeInterface;\n\n// MSVC is the only supported compiler that includes the type of a variable in\n// its mangled form, so it&#x27;s not binary-compatible to drop the const in\n// QMetaTypeInterfaceWrapper::metaType for it, which means we must keep the\n// mutable field until Qt 7.\n#if QT_VERSION &gt;= QT_VERSION_CHECK(7, 0, 0) || defined(QT_BOOTSTRAPPED) || !defined(Q_CC_MSVC)\n#  define QMTI_MUTABLE\nusing NonConstMetaTypeInterface = QMetaTypeInterface;\n#else\n#  define QMTI_MUTABLE mutable\nusing NonConstMetaTypeInterface = const QMetaTypeInterface;\n#endif\n\nclass QMetaTypeInterface\n{\npublic:\n\n    /* Revision: Can increase if new field are added, or if semantics changes\n       0: Initial Revision\n       1: the meaning of the NeedsDestruction flag changed\n    */\n    static inline constexpr ushort CurrentRevision = 1;\n\n    ushort revision;\n    ushort alignment;\n    uint size;\n    uint flags;\n    QMTI_MUTABLE QBasicAtomicInt typeId;\n\n    using MetaObjectFn = const QMetaObject *(*)(const QMetaTypeInterface *);\n    MetaObjectFn metaObjectFn;\n\n    const char *name;\n\n    using DefaultCtrFn = void (*)(const QMetaTypeInterface *, void *);\n    DefaultCtrFn defaultCtr;\n    using CopyCtrFn = void (*)(const QMetaTypeInterface *, void *, const void *);\n    CopyCtrFn copyCtr;\n    using MoveCtrFn = void (*)(const QMetaTypeInterface *, void *, void *);\n    MoveCtrFn moveCtr;\n    using DtorFn = void (*)(const QMetaTypeInterface *, void *);\n    DtorFn dtor;\n    using EqualsFn = bool (*)(const QMetaTypeInterface *, const void *, const void *);\n    EqualsFn equals;\n    using LessThanFn = bool (*)(const QMetaTypeInterface *, const void *, const void *);\n    LessThanFn lessThan;\n    using DebugStreamFn = void (*)(const QMetaTypeInterface *, QDebug &amp;, const void *);\n    DebugStreamFn debugStream;\n    using DataStreamOutFn = void (*)(const QMetaTypeInterface *, QDataStream &amp;, const void *);\n    DataStreamOutFn dataStreamOut;\n    using DataStreamInFn = void (*)(const QMetaTypeInterface *, QDataStream &amp;, void *);\n    DataStreamInFn dataStreamIn;\n\n    using LegacyRegisterOp = void (*)();\n    LegacyRegisterOp legacyRegisterOp;\n};\n#undef QMTI_MUTABLE\n\n/*!\n    This template is used for implicit conversion from type From to type To.\n    \\internal\n*/\ntemplate&lt;typename From, typename To&gt;\nTo convertImplicit(const From&amp; from)\n{\n    return from;\n}\n\n    template&lt;typename T, bool&gt;\n    struct SequentialValueTypeIsMetaType;\n    template&lt;typename T, bool&gt;\n    struct AssociativeValueTypeIsMetaType;\n    template&lt;typename T, bool&gt;\n    struct IsMetaTypePair;\n    template&lt;typename, typename&gt;\n    struct MetaTypeSmartPointerHelper;\n\n    template&lt;typename T&gt;\n    struct IsEnumOrFlags : std::disjunction&lt;std::is_enum&lt;T&gt;, IsQFlags&lt;T&gt;&gt; {};\n}  // namespace QtPrivate\n\nclass Q_CORE_EXPORT QMetaType {\npublic:\n#ifndef Q_QDOC\n    // The code that actually gets compiled.\n    enum Type {\n        // these are merged with QVariant\n        QT_FOR_EACH_STATIC_TYPE(QT_DEFINE_METATYPE_ID)\n\n        FirstCoreType = Bool,\n        LastCoreType = Float16,\n        FirstGuiType = QFont,\n        LastGuiType = QColorSpace,\n        FirstWidgetsType = QSizePolicy,\n        LastWidgetsType = QSizePolicy,\n        HighestInternalId = LastWidgetsType,\n\n        QReal = sizeof(qreal) == sizeof(double) ? Double : Float,\n\n        UnknownType = 0,\n        User = 65536\n    };\n#else\n    // If we are using QDoc it fakes the Type enum looks like this.\n    enum Type {\n        UnknownType = 0, Bool = 1, Int = 2, UInt = 3, LongLong = 4, ULongLong = 5,\n        Double = 6, Long = 32, Short = 33, Char = 34, ULong = 35, UShort = 36,\n        UChar = 37, Float = 38,\n        VoidStar = 31,\n        QChar = 7, QString = 10, QStringList = 11, QByteArray = 12,\n        QBitArray = 13, QDate = 14, QTime = 15, QDateTime = 16, QUrl = 17,\n        QLocale = 18, QRect = 19, QRectF = 20, QSize = 21, QSizeF = 22,\n        QLine = 23, QLineF = 24, QPoint = 25, QPointF = 26,\n        QEasingCurve = 29, QUuid = 30, QVariant = 41, QModelIndex = 42,\n        QPersistentModelIndex = 50, QRegularExpression = 44,\n        QJsonValue = 45, QJsonObject = 46, QJsonArray = 47, QJsonDocument = 48,\n        QByteArrayList = 49, QObjectStar = 39, SChar = 40,\n        Void = 43,\n        Nullptr = 51,\n        QVariantMap = 8, QVariantList = 9, QVariantHash = 28, QVariantPair = 58,\n        QCborSimpleType = 52, QCborValue = 53, QCborArray = 54, QCborMap = 55,\n        Char16 = 56, Char32 = 57,\n        Int128 = 59, UInt128 = 60, Float128 = 61, BFloat16 = 62, Float16 = 63,\n\n        // Gui types\n        QFont = 0x1000, QPixmap = 0x1001, QBrush = 0x1002, QColor = 0x1003, QPalette = 0x1004,\n        QIcon = 0x1005, QImage = 0x1006, QPolygon = 0x1007, QRegion = 0x1008, QBitmap = 0x1009,\n        QCursor = 0x100a, QKeySequence = 0x100b, QPen = 0x100c, QTextLength = 0x100d, QTextFormat = 0x100e,\n        QTransform = 0x1010, QMatrix4x4 = 0x1011, QVector2D = 0x1012,\n        QVector3D = 0x1013, QVector4D = 0x1014, QQuaternion = 0x1015, QPolygonF = 0x1016, QColorSpace = 0x1017,\n\n        // Widget types\n        QSizePolicy = 0x2000,\n\n        // Start-point for client-code types:\n        User = 65536\n    };\n#endif\n\n    enum TypeFlag {\n        NeedsConstruction = 0x1,\n        NeedsDestruction = 0x2,\n        RelocatableType = 0x4,\n#if QT_DEPRECATED_SINCE(6, 0)\n        MovableType Q_DECL_ENUMERATOR_DEPRECATED_X(&quot;Use RelocatableType instead.&quot;) = RelocatableType,\n#endif\n        PointerToQObject = 0x8,\n        IsEnumeration = 0x10,\n        SharedPointerToQObject = 0x20,\n        WeakPointerToQObject = 0x40,\n        TrackingPointerToQObject = 0x80,\n        IsUnsignedEnumeration = 0x100,\n        IsGadget = 0x200,\n        PointerToGadget = 0x400,\n        IsPointer = 0x800,\n        IsQmlList =0x1000, // used in the QML engine to recognize QQmlListProperty&lt;T&gt; and list&lt;T&gt;\n        IsConst = 0x2000,\n        // since 6.5:\n        NeedsCopyConstruction = 0x4000,\n        NeedsMoveConstruction = 0x8000,\n    };\n    Q_DECLARE_FLAGS(TypeFlags, TypeFlag)\n\n    static void registerNormalizedTypedef(const QT_PREPEND_NAMESPACE(QByteArray) &amp;normalizedTypeName, QMetaType type);\n\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_DEPRECATED_VERSION_6_0\n    static int type(const char *typeName)\n    { return QMetaType::fromName(typeName).id(); }\n    QT_DEPRECATED_VERSION_6_0\n    static int type(const QT_PREPEND_NAMESPACE(QByteArray) &amp;typeName)\n    { return QMetaType::fromName(typeName).id(); }\n    QT_DEPRECATED_VERSION_6_0\n    static const char *typeName(int type)\n    { return QMetaType(type).name(); }\n    QT_DEPRECATED_VERSION_6_0\n    static int sizeOf(int type)\n    { return int(QMetaType(type).sizeOf()); }\n    QT_DEPRECATED_VERSION_6_0\n    static TypeFlags typeFlags(int type)\n    { return QMetaType(type).flags(); }\n    QT_DEPRECATED_VERSION_6_0\n    static const QMetaObject *metaObjectForType(int type)\n    { return QMetaType(type).metaObject(); }\n    QT_DEPRECATED_VERSION_6_0\n    static void *create(int type, const void *copy = nullptr)\n    { return QMetaType(type).create(copy); }\n    QT_DEPRECATED_VERSION_6_0\n    static void destroy(int type, void *data)\n    { return QMetaType(type).destroy(data); }\n    QT_DEPRECATED_VERSION_6_0\n    static void *construct(int type, void *where, const void *copy)\n    { return QMetaType(type).construct(where, copy); }\n    QT_DEPRECATED_VERSION_6_0\n    static void destruct(int type, void *where)\n    { return QMetaType(type).destruct(where); }\n#endif\n    static bool isRegistered(int type);\n\n    explicit QMetaType(int type);\n    explicit constexpr QMetaType(const QtPrivate::QMetaTypeInterface *d) : d_ptr(d) {}\n    constexpr QMetaType() = default;\n\n#if QT_CORE_REMOVED_SINCE(6, 9)\n    bool isValid() const;\n    bool isRegistered() const;\n#endif\n    constexpr bool isValid(QT6_DECL_NEW_OVERLOAD) const noexcept;\n    inline bool isRegistered(QT6_DECL_NEW_OVERLOAD) const noexcept;\n    void registerType() const\n    {\n        // &quot;register&quot; is a reserved keyword\n        registerHelper();\n    }\n#if QT_CORE_REMOVED_SINCE(6, 1) || defined(Q_QDOC)\n    int id() const;\n#else\n    // ### Qt 7: Remove traces of out of line version\n    // unused int parameter is used to avoid ODR violation\n    int id(int = 0) const\n    {\n        return registerHelper();\n    }\n#endif\n    constexpr qsizetype sizeOf() const;\n    constexpr qsizetype alignOf() const;\n    constexpr TypeFlags flags() const;\n    constexpr const QMetaObject *metaObject() const;\n    constexpr const char *name() const;\n\n    void *create(const void *copy = nullptr) const;\n    void destroy(void *data) const;\n    void *construct(void *where, const void *copy = nullptr) const;\n    void destruct(void *data) const;\n    QPartialOrdering compare(const void *lhs, const void *rhs) const;\n    bool equals(const void *lhs, const void *rhs) const;\n\n    bool isDefaultConstructible() const noexcept { return d_ptr &amp;&amp; isDefaultConstructible(d_ptr); }\n    bool isCopyConstructible() const noexcept { return d_ptr &amp;&amp; isCopyConstructible(d_ptr); }\n    bool isMoveConstructible() const noexcept { return d_ptr &amp;&amp; isMoveConstructible(d_ptr); }\n    bool isDestructible() const noexcept { return d_ptr &amp;&amp; isDestructible(d_ptr); }\n    bool isEqualityComparable() const;\n    bool isOrdered() const;\n\n#ifndef QT_NO_DATASTREAM\n    bool save(QDataStream &amp;stream, const void *data) const;\n    bool load(QDataStream &amp;stream, void *data) const;\n    bool hasRegisteredDataStreamOperators() const;\n\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_DEPRECATED_VERSION_6_0\n    static bool save(QDataStream &amp;stream, int type, const void *data)\n    { return QMetaType(type).save(stream, data); }\n    QT_DEPRECATED_VERSION_6_0\n    static bool load(QDataStream &amp;stream, int type, void *data)\n    { return QMetaType(type).load(stream, data); }\n#endif\n#endif\n\n    QMetaType underlyingType() const;\n\n    template&lt;typename T&gt;\n    constexpr static QMetaType fromType();\n    static QMetaType fromName(QByteArrayView name);\nprivate:\n    friend bool comparesEqual(const QMetaType &amp;lhs,\n                              const QMetaType &amp;rhs)\n    {\n        if (lhs.d_ptr == rhs.d_ptr)\n            return true;\n        if (!lhs.d_ptr || !rhs.d_ptr)\n            return false; // one type is undefined, the other is defined\n        // avoid id call if we already have the id\n        const int aId = lhs.id();\n        const int bId = rhs.id();\n        return aId == bId;\n    }\n    Q_DECLARE_EQUALITY_COMPARABLE_NON_NOEXCEPT(QMetaType)\n#ifndef QT_NO_DEBUG_STREAM\nprivate:\n    friend Q_CORE_EXPORT QDebug operator&lt;&lt;(QDebug d, QMetaType m);\npublic:\n    bool debugStream(QDebug&amp; dbg, const void *rhs);\n    bool hasRegisteredDebugStreamOperator() const;\n\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_DEPRECATED_VERSION_6_0\n    static bool debugStream(QDebug&amp; dbg, const void *rhs, int typeId)\n    { return QMetaType(typeId).debugStream(dbg, rhs); }\n    template&lt;typename T&gt;\n    QT_DEPRECATED_VERSION_6_0\n    static bool hasRegisteredDebugStreamOperator()\n    { return QMetaType::fromType&lt;T&gt;().hasRegisteredDebugStreamOperator(); }\n    QT_DEPRECATED_VERSION_6_0\n    static bool hasRegisteredDebugStreamOperator(int typeId)\n    { return QMetaType(typeId).hasRegisteredDebugStreamOperator(); }\n#endif\n#endif\n\n    // type erased converter function\n    using ConverterFunction = std::function&lt;bool(const void *src, void *target)&gt;;\n\n    // type erased mutable view, primarily for containers\n    using MutableViewFunction = std::function&lt;bool(void *src, void *target)&gt;;\n\n    // implicit conversion supported like double -&gt; float\n    template&lt;typename From, typename To&gt;\n    static bool registerConverter()\n    {\n        return registerConverter&lt;From, To&gt;(QtPrivate::convertImplicit&lt;From, To&gt;);\n    }\n\n    // member function as in &quot;QString QFont::toString() const&quot;\n    template&lt;typename From, typename To&gt;\n    static bool registerConverter(To(From::*function)() const)\n    {\n        static_assert((!QMetaTypeId2&lt;To&gt;::IsBuiltIn || !QMetaTypeId2&lt;From&gt;::IsBuiltIn),\n            &quot;QMetaType::registerConverter: At least one of the types must be a custom type.&quot;);\n\n        const QMetaType fromType = QMetaType::fromType&lt;From&gt;();\n        const QMetaType toType = QMetaType::fromType&lt;To&gt;();\n        auto converter = [function](const void *from, void *to) -&gt; bool {\n            const From *f = static_cast&lt;const From *&gt;(from);\n            To *t = static_cast&lt;To *&gt;(to);\n            *t = (f-&gt;*function)();\n            return true;\n        };\n        return registerConverterImpl&lt;From, To&gt;(converter, fromType, toType);\n    }\n\n    // member function\n    template&lt;typename From, typename To&gt;\n    static bool registerMutableView(To(From::*function)())\n    {\n        static_assert((!QMetaTypeId2&lt;To&gt;::IsBuiltIn || !QMetaTypeId2&lt;From&gt;::IsBuiltIn),\n            &quot;QMetaType::registerMutableView: At least one of the types must be a custom type.&quot;);\n\n        const QMetaType fromType = QMetaType::fromType&lt;From&gt;();\n        const QMetaType toType = QMetaType::fromType&lt;To&gt;();\n        auto view = [function](void *from, void *to) -&gt; bool {\n            From *f = static_cast&lt;From *&gt;(from);\n            To *t = static_cast&lt;To *&gt;(to);\n            *t = (f-&gt;*function)();\n            return true;\n        };\n        return registerMutableViewImpl&lt;From, To&gt;(view, fromType, toType);\n    }\n\n    // member function as in &quot;double QString::toDouble(bool *ok = nullptr) const&quot;\n    template&lt;typename From, typename To&gt;\n    static bool registerConverter(To(From::*function)(bool*) const)\n    {\n        static_assert((!QMetaTypeId2&lt;To&gt;::IsBuiltIn || !QMetaTypeId2&lt;From&gt;::IsBuiltIn),\n            &quot;QMetaType::registerConverter: At least one of the types must be a custom type.&quot;);\n\n        const QMetaType fromType = QMetaType::fromType&lt;From&gt;();\n        const QMetaType toType = QMetaType::fromType&lt;To&gt;();\n        auto converter = [function](const void *from, void *to) -&gt; bool {\n            const From *f = static_cast&lt;const From *&gt;(from);\n            To *t = static_cast&lt;To *&gt;(to);\n            bool result = true;\n            *t = (f-&gt;*function)(&amp;result);\n            if (!result)\n                *t = To();\n            return result;\n        };\n        return registerConverterImpl&lt;From, To&gt;(converter, fromType, toType);\n    }\n\n    // functor or function pointer\n    template&lt;typename From, typename To, typename UnaryFunction&gt;\n    static bool registerConverter(UnaryFunction function)\n    {\n        static_assert((!QMetaTypeId2&lt;To&gt;::IsBuiltIn || !QMetaTypeId2&lt;From&gt;::IsBuiltIn),\n            &quot;QMetaType::registerConverter: At least one of the types must be a custom type.&quot;);\n\n        const QMetaType fromType = QMetaType::fromType&lt;From&gt;();\n        const QMetaType toType = QMetaType::fromType&lt;To&gt;();\n        auto converter = [function = std::move(function)](const void *from, void *to) -&gt; bool {\n            const From *f = static_cast&lt;const From *&gt;(from);\n            To *t = static_cast&lt;To *&gt;(to);\n            auto &amp;&amp;r = function(*f);\n            if constexpr (std::is_same_v&lt;q20::remove_cvref_t&lt;decltype(r)&gt;, std::optional&lt;To&gt;&gt;) {\n                if (!r)\n                    return false;\n                *t = *std::forward&lt;decltype(r)&gt;(r);\n            } else {\n                *t = std::forward&lt;decltype(r)&gt;(r);\n            }\n            return true;\n        };\n        return registerConverterImpl&lt;From, To&gt;(std::move(converter), fromType, toType);\n    }\n\n    // functor or function pointer\n    template&lt;typename From, typename To, typename UnaryFunction&gt;\n    static bool registerMutableView(UnaryFunction function)\n    {\n        static_assert((!QMetaTypeId2&lt;To&gt;::IsBuiltIn || !QMetaTypeId2&lt;From&gt;::IsBuiltIn),\n            &quot;QMetaType::registerMutableView: At least one of the types must be a custom type.&quot;);\n\n        const QMetaType fromType = QMetaType::fromType&lt;From&gt;();\n        const QMetaType toType = QMetaType::fromType&lt;To&gt;();\n        auto view = [function = std::move(function)](void *from, void *to) -&gt; bool {\n            From *f = static_cast&lt;From *&gt;(from);\n            To *t = static_cast&lt;To *&gt;(to);\n            *t = function(*f);\n            return true;\n        };\n        return registerMutableViewImpl&lt;From, To&gt;(std::move(view), fromType, toType);\n    }\n\nprivate:\n    template&lt;typename From, typename To&gt;\n    static bool registerConverterImpl(ConverterFunction converter, QMetaType fromType, QMetaType toType)\n    {\n        if (registerConverterFunction(std::move(converter), fromType, toType)) {\n            static const auto unregister = qScopeGuard([=] {\n                unregisterConverterFunction(fromType, toType);\n            });\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    template&lt;typename From, typename To&gt;\n    static bool registerMutableViewImpl(MutableViewFunction view, QMetaType fromType, QMetaType toType)\n    {\n        if (registerMutableViewFunction(std::move(view), fromType, toType)) {\n            static const auto unregister = qScopeGuard([=] {\n               unregisterMutableViewFunction(fromType, toType);\n            });\n            return true;\n        } else {\n            return false;\n        }\n    }\npublic:\n\n    static bool convert(QMetaType fromType, const void *from, QMetaType toType, void *to);\n    static bool canConvert(QMetaType fromType, QMetaType toType);\n\n    static bool view(QMetaType fromType, void *from, QMetaType toType, void *to);\n    static bool canView(QMetaType fromType, QMetaType toType);\n#if QT_DEPRECATED_SINCE(6, 0)\n    QT_DEPRECATED_VERSION_6_0\n    static bool convert(const void *from, int fromTypeId, void *to, int toTypeId)\n    { return convert(QMetaType(fromTypeId), from, QMetaType(toTypeId), to); }\n    QT_DEPRECATED_VERSION_6_0\n    static bool compare(const void *lhs, const void *rhs, int typeId, int *result)\n    {\n        QMetaType t(typeId);\n        auto c = t.compare(lhs, rhs);\n        if (c == QPartialOrdering::Unordered) {\n            *result = 0;\n            return false;\n        } else if (c == QPartialOrdering::Less) {\n            *result = -1;\n            return true;\n        } else if (c == QPartialOrdering::Equivalent) {\n            *result = 0;\n            return true;\n        } else {\n            *result = 1;\n            return true;\n        }\n    }\n    QT_DEPRECATED_VERSION_6_0\n    static bool equals(const void *lhs, const void *rhs, int typeId, int *result)\n    {\n        QMetaType t(typeId);\n        if (!t.isEqualityComparable())\n            return false;\n        *result = t.equals(lhs, rhs) ? 0 : -1;\n        return true;\n    }\n#endif\n\n    template&lt;typename From, typename To&gt;\n    static bool hasRegisteredConverterFunction()\n    {\n        return hasRegisteredConverterFunction(\n                    QMetaType::fromType&lt;From&gt;(), QMetaType::fromType&lt;To&gt;());\n    }\n\n    static bool hasRegisteredConverterFunction(QMetaType fromType, QMetaType toType);\n\n    template&lt;typename From, typename To&gt;\n    static bool hasRegisteredMutableViewFunction()\n    {\n        return hasRegisteredMutableViewFunction(\n                    QMetaType::fromType&lt;From&gt;(), QMetaType::fromType&lt;To&gt;());\n    }\n\n    static bool hasRegisteredMutableViewFunction(QMetaType fromType, QMetaType toType);\n\n#ifndef Q_QDOC\n    template&lt;typename, bool&gt; friend struct QtPrivate::SequentialValueTypeIsMetaType;\n    template&lt;typename, bool&gt; friend struct QtPrivate::AssociativeValueTypeIsMetaType;\n    template&lt;typename, bool&gt; friend struct QtPrivate::IsMetaTypePair;\n    template&lt;typename, typename&gt; friend struct QtPrivate::MetaTypeSmartPointerHelper;\n#endif\n    static bool registerConverterFunction(const ConverterFunction &amp;f, QMetaType from, QMetaType to);\n    static void unregisterConverterFunction(QMetaType from, QMetaType to);\n\n    static bool registerMutableViewFunction(const MutableViewFunction &amp;f, QMetaType from, QMetaType to);\n    static void unregisterMutableViewFunction(QMetaType from, QMetaType to);\n\n    static void unregisterMetaType(QMetaType type);\n\n#if QT_VERSION &lt; QT_VERSION_CHECK(7, 0, 0)\n    constexpr const QtPrivate::QMetaTypeInterface *iface() { return d_ptr; }\n#endif\n    constexpr const QtPrivate::QMetaTypeInterface *iface() const { return d_ptr; }\n\nprivate:\n    static bool isDefaultConstructible(const QtPrivate::QMetaTypeInterface *) noexcept Q_DECL_PURE_FUNCTION;\n    static bool isCopyConstructible(const QtPrivate::QMetaTypeInterface *) noexcept Q_DECL_PURE_FUNCTION;\n    static bool isMoveConstructible(const QtPrivate::QMetaTypeInterface *) noexcept Q_DECL_PURE_FUNCTION;\n    static bool isDestructible(const QtPrivate::QMetaTypeInterface *) noexcept Q_DECL_PURE_FUNCTION;\n\n#if QT_CORE_REMOVED_SINCE(6, 5)\n    int idHelper() const;\n#endif\n    static int registerHelper(const QtPrivate::QMetaTypeInterface *iface);\n    int registerHelper() const\n    {\n        if (d_ptr) {\n            if (int id = d_ptr-&gt;typeId.loadRelaxed())\n                return id;\n            return registerHelper(d_ptr);\n        }\n        return 0;\n    }\n\n    friend int qRegisterMetaType(QMetaType meta);\n\n    friend class QVariant;\n    const QtPrivate::QMetaTypeInterface *d_ptr = nullptr;\n};\n\n#undef QT_DEFINE_METATYPE_ID\n\nQ_DECLARE_OPERATORS_FOR_FLAGS(QMetaType::TypeFlags)\n\n#define QT_METATYPE_PRIVATE_DECLARE_TYPEINFO(C, F)  \\\n    }                                               \\\n    Q_DECLARE_TYPEINFO(QtMetaTypePrivate:: C, (F)); \\\n    namespace QtMetaTypePrivate {\n\n\nnamespace QtMetaTypePrivate {\n\nclass QPairVariantInterfaceImpl\n{\npublic:\n    const void *_pair;\n    QMetaType _metaType_first;\n    QMetaType _metaType_second;\n\n    typedef void (*getFunc)(const void * const *p, void *);\n\n    getFunc _getFirst;\n    getFunc _getSecond;\n\n    template&lt;class T&gt;\n    static void getFirstImpl(const void * const *pair, void *dataPtr)\n    { *static_cast&lt;typename T::first_type *&gt;(dataPtr) = static_cast&lt;const T*&gt;(*pair)-&gt;first; }\n    template&lt;class T&gt;\n    static void getSecondImpl(const void * const *pair, void *dataPtr)\n    { *static_cast&lt;typename T::second_type *&gt;(dataPtr) = static_cast&lt;const T*&gt;(*pair)-&gt;second; }\n\npublic:\n    template&lt;class T&gt; QPairVariantInterfaceImpl(const T*p)\n      : _pair(p)\n      , _metaType_first(QMetaType::fromType&lt;typename T::first_type&gt;())\n      , _metaType_second(QMetaType::fromType&lt;typename T::second_type&gt;())\n      , _getFirst(getFirstImpl&lt;T&gt;)\n      , _getSecond(getSecondImpl&lt;T&gt;)\n    {\n    }\n\n    constexpr QPairVariantInterfaceImpl()\n      : _pair(nullptr)\n      , _getFirst(nullptr)\n      , _getSecond(nullptr)\n    {\n    }\n\n    inline void first(void *dataPtr) const { _getFirst(&amp;_pair, dataPtr); }\n    inline void second(void *dataPtr) const { _getSecond(&amp;_pair, dataPtr); }\n};\nQT_METATYPE_PRIVATE_DECLARE_TYPEINFO(QPairVariantInterfaceImpl, Q_RELOCATABLE_TYPE)\n\ntemplate&lt;typename From&gt;\nstruct QPairVariantInterfaceConvertFunctor;\n\ntemplate&lt;typename T, typename U&gt;\nstruct QPairVariantInterfaceConvertFunctor&lt;std::pair&lt;T, U&gt; &gt;\n{\n    QPairVariantInterfaceImpl operator()(const std::pair&lt;T, U&gt;&amp; f) const\n    {\n        return QPairVariantInterfaceImpl(&amp;f);\n    }\n};\n\n}\n\nclass QObject;\n\n#define QT_FORWARD_DECLARE_SHARED_POINTER_TYPES_ITER(Name) \\\n    template &lt;class T&gt; class Name; \\\n\nQT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(QT_FORWARD_DECLARE_SHARED_POINTER_TYPES_ITER)\n\nnamespace QtPrivate\n{\n    namespace detail {\n    template&lt;typename T, typename ODR_VIOLATION_PREVENTER&gt;\n    struct is_complete_helper\n    {\n        template&lt;typename U&gt;\n        static auto check(U *) -&gt; std::integral_constant&lt;bool, sizeof(U) != 0&gt;;\n        static auto check(...) -&gt; std::false_type;\n        using type = decltype(check(static_cast&lt;T *&gt;(nullptr)));\n    };\n    } // namespace detail\n\n    template &lt;typename T, typename ODR_VIOLATION_PREVENTER&gt;\n    struct is_complete : detail::is_complete_helper&lt;std::remove_reference_t&lt;T&gt;, ODR_VIOLATION_PREVENTER&gt;::type {};\n\n    template &lt;typename T&gt; struct MetatypeDecay              { using type = T; };\n    template &lt;typename T&gt; struct MetatypeDecay&lt;const T&gt;     { using type = T; };\n    template &lt;typename T&gt; struct MetatypeDecay&lt;const T &amp;&gt;   { using type = T; };\n\n    template &lt;typename T&gt; struct IsPointerDeclaredOpaque  :\n            std::disjunction&lt;std::is_member_pointer&lt;T&gt;,\n                             std::is_function&lt;std::remove_pointer_t&lt;T&gt;&gt;&gt;\n    {};\n    template &lt;&gt; struct IsPointerDeclaredOpaque&lt;void *&gt;      : std::true_type {};\n    template &lt;&gt; struct IsPointerDeclaredOpaque&lt;const void *&gt; : std::true_type {};\n\n    // Note: this does not check that T = U* isn&#x27;t pointing to a\n    // forward-declared type. You may want to combine with\n    // checkTypeIsSuitableForMetaType().\n    template&lt;typename T&gt;\n    struct IsPointerToTypeDerivedFromQObject\n    {\n        enum { Value = false };\n    };\n\n    // Specialize to avoid sizeof(void) warning\n    template&lt;&gt;\n    struct IsPointerToTypeDerivedFromQObject&lt;void*&gt;\n    {\n        enum { Value = false };\n    };\n    template&lt;&gt;\n    struct IsPointerToTypeDerivedFromQObject&lt;const void*&gt;\n    {\n        enum { Value = false };\n    };\n    template&lt;&gt;\n    struct IsPointerToTypeDerivedFromQObject&lt;QObject*&gt;\n    {\n        enum { Value = true };\n    };\n\n    template&lt;typename T&gt;\n    struct IsPointerToTypeDerivedFromQObject&lt;T*&gt;\n    {\n        typedef qint8 yes_type;\n        typedef qint64 no_type;\n\n#ifndef QT_NO_QOBJECT\n        static yes_type checkType(QObject* );\n        static yes_type checkType(const QObject* );\n#endif\n        static no_type checkType(...);\n        enum { Value = sizeof(checkType(static_cast&lt;T*&gt;(nullptr))) == sizeof(yes_type) };\n    };\n\n    template&lt;typename T, typename Enable = void&gt;\n    struct IsGadgetHelper { enum { IsRealGadget = false, IsGadgetOrDerivedFrom = false }; };\n\n    template&lt;typename T&gt;\n    struct IsGadgetHelper&lt;T, typename T::QtGadgetHelper&gt;\n    {\n        template &lt;typename X&gt;\n        static char checkType(void (X::*)());\n        static void *checkType(void (T::*)());\n        enum {\n            IsRealGadget = sizeof(checkType(&amp;T::qt_check_for_QGADGET_macro)) == sizeof(void *),\n            IsGadgetOrDerivedFrom = true\n        };\n    };\n\n    template &lt;typename T&gt;\n    using IsRealGadget = std::bool_constant&lt;IsGadgetHelper&lt;T&gt;::IsRealGadget&gt;;\n\n    template&lt;typename T, typename Enable = void&gt;\n    struct IsPointerToGadgetHelper { enum { IsRealGadget = false, IsGadgetOrDerivedFrom = false }; };\n\n    template&lt;typename T&gt;\n    struct IsPointerToGadgetHelper&lt;T*, typename T::QtGadgetHelper&gt;\n    {\n        using BaseType = T;\n        template &lt;typename X&gt;\n        static char checkType(void (X::*)());\n        static void *checkType(void (T::*)());\n        enum {\n            IsRealGadget = !IsPointerToTypeDerivedFromQObject&lt;T*&gt;::Value &amp;&amp; sizeof(checkType(&amp;T::qt_check_for_QGADGET_macro)) == sizeof(void *),\n            IsGadgetOrDerivedFrom = !IsPointerToTypeDerivedFromQObject&lt;T*&gt;::Value\n        };\n    };\n\n\n    template&lt;typename T&gt; char qt_getEnumMetaObject(const T&amp;);\n\n    template&lt;typename T&gt;\n    struct IsQEnumHelper {\n        static const T &amp;declval();\n        // If the type was declared with Q_ENUM, the friend qt_getEnumMetaObject() declared in the\n        // Q_ENUM macro will be chosen by ADL, and the return type will be QMetaObject*.\n        // Otherwise the chosen overload will be the catch all template function\n        // qt_getEnumMetaObject(T) which returns &#x27;char&#x27;\n        enum { Value = sizeof(qt_getEnumMetaObject(declval())) == sizeof(QMetaObject*) };\n    };\n    template&lt;&gt; struct IsQEnumHelper&lt;void&gt; { enum { Value = false }; };\n\n    template&lt;typename T, typename Enable = void&gt;\n    struct MetaObjectForType\n    {\n        static constexpr const QMetaObject *value() { return nullptr; }\n        using MetaObjectFn = const QMetaObject *(*)(const QMetaTypeInterface *);\n        static constexpr MetaObjectFn metaObjectFunction = nullptr;\n    };\n#ifndef QT_NO_QOBJECT\n    template&lt;typename T&gt;\n    struct MetaObjectForType&lt;T*, typename std::enable_if&lt;IsPointerToTypeDerivedFromQObject&lt;T*&gt;::Value&gt;::type&gt;\n    {\n        static constexpr const QMetaObject *value() { return &amp;T::staticMetaObject; }\n        static constexpr const QMetaObject *metaObjectFunction(const QMetaTypeInterface *) { return &amp;T::staticMetaObject; }\n    };\n    template&lt;typename T&gt;\n    struct MetaObjectForType&lt;T, std::enable_if_t&lt;\n        std::disjunction_v&lt;\n            std::bool_constant&lt;IsGadgetHelper&lt;T&gt;::IsGadgetOrDerivedFrom&gt;,\n            std::is_base_of&lt;QObject, T&gt;\n        &gt;\n    &gt;&gt;\n    {\n        static constexpr const QMetaObject *value() { return &amp;T::staticMetaObject; }\n        static constexpr const QMetaObject *metaObjectFunction(const QMetaTypeInterface *) { return &amp;T::staticMetaObject; }\n    };\n    template&lt;typename T&gt;\n    struct MetaObjectForType&lt;T, typename std::enable_if&lt;IsPointerToGadgetHelper&lt;T&gt;::IsGadgetOrDerivedFrom&gt;::type&gt;\n    {\n        static constexpr const QMetaObject *value()\n        {\n            return &amp;IsPointerToGadgetHelper&lt;T&gt;::BaseType::staticMetaObject;\n        }\n        static constexpr const QMetaObject *metaObjectFunction(const QMetaTypeInterface *) { return value(); }\n    };\n    template&lt;typename T&gt;\n    struct MetaObjectForType&lt;T, typename std::enable_if&lt;IsQEnumHelper&lt;T&gt;::Value&gt;::type &gt;\n    {\n        static constexpr const QMetaObject *value() { return qt_getEnumMetaObject(T()); }\n        static constexpr const QMetaObject *metaObjectFunction(const QMetaTypeInterface *) { return value(); }\n    };\n#endif\n\n    template&lt;typename T&gt;\n    struct IsSharedPointerToTypeDerivedFromQObject\n    {\n        enum { Value = false };\n    };\n\n    template&lt;typename T&gt;\n    struct IsSharedPointerToTypeDerivedFromQObject&lt;QSharedPointer&lt;T&gt; &gt; : IsPointerToTypeDerivedFromQObject&lt;T*&gt;\n    {\n    };\n\n    template&lt;typename T&gt;\n    struct IsWeakPointerToTypeDerivedFromQObject\n    {\n        enum { Value = false };\n    };\n\n    template&lt;typename T&gt;\n    struct IsWeakPointerToTypeDerivedFromQObject&lt;QWeakPointer&lt;T&gt; &gt; : IsPointerToTypeDerivedFromQObject&lt;T*&gt;\n    {\n    };\n\n    template&lt;typename T&gt;\n    struct IsTrackingPointerToTypeDerivedFromQObject\n    {\n        enum { Value = false };\n    };\n\n    template&lt;typename T&gt;\n    struct IsTrackingPointerToTypeDerivedFromQObject&lt;QPointer&lt;T&gt; &gt;\n    {\n        enum { Value = true };\n    };\n\n    template&lt;typename T&gt;\n    struct IsSequentialContainer\n    {\n        enum { Value = false };\n    };\n\n    template&lt;typename T&gt;\n    struct IsAssociativeContainer\n    {\n        enum { Value = false };\n    };\n\n    template&lt;typename T, bool = QtPrivate::IsSequentialContainer&lt;T&gt;::Value&gt;\n    struct SequentialContainerTransformationHelper\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n\n        static bool registerMutableView()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T, bool = QMetaTypeId2&lt;typename T::value_type&gt;::Defined&gt;\n    struct SequentialValueTypeIsMetaType\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n\n        static bool registerMutableView()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T&gt;\n    struct SequentialContainerTransformationHelper&lt;T, true&gt; : SequentialValueTypeIsMetaType&lt;T&gt;\n    {\n    };\n\n    template&lt;typename T, bool = QtPrivate::IsAssociativeContainer&lt;T&gt;::Value&gt;\n    struct AssociativeContainerTransformationHelper\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n\n        static bool registerMutableView()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T, bool = QMetaTypeId2&lt;typename T::key_type&gt;::Defined&gt;\n    struct AssociativeKeyTypeIsMetaType\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n\n        static bool registerMutableView()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T, bool = QMetaTypeId2&lt;typename T::mapped_type&gt;::Defined&gt;\n    struct AssociativeMappedTypeIsMetaType\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n\n        static bool registerMutableView()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T&gt;\n    struct AssociativeContainerTransformationHelper&lt;T, true&gt; : AssociativeKeyTypeIsMetaType&lt;T&gt;\n    {\n    };\n\n    template&lt;typename T, bool = QMetaTypeId2&lt;typename T::first_type&gt;::Defined\n                                &amp;&amp; QMetaTypeId2&lt;typename T::second_type&gt;::Defined&gt;\n    struct IsMetaTypePair\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n    };\n\n    template&lt;typename T&gt;\n    struct IsMetaTypePair&lt;T, true&gt;\n    {\n        inline static bool registerConverter();\n    };\n\n    template&lt;typename T&gt;\n    struct IsPair\n    {\n        static bool registerConverter()\n        {\n            return false;\n        }\n    };\n    template&lt;typename T, typename U&gt;\n    struct IsPair&lt;std::pair&lt;T, U&gt; &gt; : IsMetaTypePair&lt;std::pair&lt;T, U&gt; &gt; {};\n\n    template&lt;typename T&gt;\n    struct MetaTypePairHelper : IsPair&lt;T&gt; {};\n\n    template&lt;typename T, typename = void&gt;\n    struct MetaTypeSmartPointerHelper\n    {\n        static bool registerConverter() { return false; }\n    };\n\n#if QT_CONFIG(future)\n    template&lt;typename T&gt;\n    struct MetaTypeQFutureHelper\n    {\n        static bool registerConverter() { return false; }\n    };\n#endif\n\n    template &lt;typename X&gt; static constexpr bool checkTypeIsSuitableForMetaType()\n    {\n        using T = typename MetatypeDecay&lt;X&gt;::type;\n        static_assert(is_complete&lt;T, void&gt;::value || std::is_void_v&lt;T&gt;,\n                &quot;Meta Types must be fully defined&quot;);\n        static_assert(!std::is_reference_v&lt;T&gt;,\n                &quot;Meta Types cannot be non-const references or rvalue references.&quot;);\n        if constexpr (std::is_pointer_v&lt;T&gt; &amp;&amp; !IsPointerDeclaredOpaque&lt;T&gt;::value) {\n            using Pointed = std::remove_pointer_t&lt;T&gt;;\n            static_assert(is_complete&lt;Pointed, void&gt;::value,\n                    &quot;Pointer Meta Types must either point to fully-defined types &quot;\n                    &quot;or be declared with Q_DECLARE_OPAQUE_POINTER(T *)&quot;);\n        }\n        return true;\n    }\n\n    Q_CORE_EXPORT bool isBuiltinType(const QByteArray &amp;type);\n} // namespace QtPrivate\n\ntemplate &lt;typename T, int =\n    QtPrivate::IsPointerToTypeDerivedFromQObject&lt;T&gt;::Value ? QMetaType::PointerToQObject :\n    QtPrivate::IsRealGadget&lt;T&gt;::value                      ? QMetaType::IsGadget :\n    QtPrivate::IsPointerToGadgetHelper&lt;T&gt;::IsRealGadget    ? QMetaType::PointerToGadget :\n    QtPrivate::IsQEnumHelper&lt;T&gt;::Value                     ? QMetaType::IsEnumeration : 0&gt;\nstruct QMetaTypeIdQObject\n{\n    enum {\n        Defined = 0\n    };\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeId : public QMetaTypeIdQObject&lt;T&gt;\n{\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeId2\n{\n    using NameAsArrayType = void;\n    enum { Defined = QMetaTypeId&lt;T&gt;::Defined, IsBuiltIn=false };\n    static inline constexpr int qt_metatype_id() { return QMetaTypeId&lt;T&gt;::qt_metatype_id(); }\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeId2&lt;const T&amp;&gt; : QMetaTypeId2&lt;T&gt; {};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeId2&lt;T&amp;&gt;\n{\n    using NameAsArrayType = void;\n    enum { Defined = false, IsBuiltIn = false };\n    static inline constexpr int qt_metatype_id() { return 0; }\n};\n\nnamespace QtPrivate {\n    template &lt;typename T, bool Defined = QMetaTypeId2&lt;T&gt;::Defined&gt;\n    struct QMetaTypeIdHelper {\n        static inline constexpr int qt_metatype_id()\n        { return QMetaTypeId2&lt;T&gt;::qt_metatype_id(); }\n    };\n    template &lt;typename T&gt; struct QMetaTypeIdHelper&lt;T, false&gt; {\n        static inline constexpr int qt_metatype_id()\n        { return -1; }\n    };\n\n    // Function pointers don&#x27;t derive from QObject\n    template &lt;typename Result, typename... Args&gt;\n    struct IsPointerToTypeDerivedFromQObject&lt;Result(*)(Args...)&gt; { enum { Value = false }; };\n\n    template&lt;typename T&gt;\n    inline constexpr bool IsQmlListType = false;\n\n    template&lt;typename T, bool = std::is_enum&lt;T&gt;::value&gt;\n    constexpr bool IsUnsignedEnum = false;\n    template&lt;typename T&gt;\n    constexpr bool IsUnsignedEnum&lt;T, true&gt; = !std::is_signed_v&lt;std::underlying_type_t&lt;T&gt;&gt;;\n\n    template&lt;typename T, bool defined&gt;\n    struct MetaTypeDefinedHelper\n    {\n        enum DefinedType { Defined = defined };\n    };\n\n    template&lt;typename SmartPointer&gt;\n    struct QSmartPointerConvertFunctor\n    {\n        QObject* operator()(const SmartPointer &amp;p) const\n        {\n            return p.operator-&gt;();\n        }\n    };\n\n    // hack to delay name lookup to instantiation time by making\n    // EnableInternalData a dependent name:\n    template &lt;typename T&gt;\n    struct EnableInternalDataWrap;\n\n    template&lt;typename T&gt;\n    struct QSmartPointerConvertFunctor&lt;QWeakPointer&lt;T&gt; &gt;\n    {\n        QObject* operator()(const QWeakPointer&lt;T&gt; &amp;p) const\n        {\n            return QtPrivate::EnableInternalDataWrap&lt;T&gt;::internalData(p);\n        }\n    };\n}\n\ntemplate &lt;typename T&gt;\nint qRegisterNormalizedMetaTypeImplementation(const QT_PREPEND_NAMESPACE(QByteArray) &amp;normalizedTypeName)\n{\n#ifndef QT_NO_QOBJECT\n    Q_ASSERT_X(normalizedTypeName == QMetaObject::normalizedType(normalizedTypeName.constData()),\n               &quot;qRegisterNormalizedMetaType&quot;,\n               &quot;qRegisterNormalizedMetaType was called with a not normalized type name, &quot;\n               &quot;please call qRegisterMetaType instead.&quot;);\n#endif\n\n    const QMetaType metaType = QMetaType::fromType&lt;T&gt;();\n    const int id = metaType.id();\n\n    QtPrivate::SequentialContainerTransformationHelper&lt;T&gt;::registerConverter();\n    QtPrivate::SequentialContainerTransformationHelper&lt;T&gt;::registerMutableView();\n    QtPrivate::AssociativeContainerTransformationHelper&lt;T&gt;::registerConverter();\n    QtPrivate::AssociativeContainerTransformationHelper&lt;T&gt;::registerMutableView();\n    QtPrivate::MetaTypePairHelper&lt;T&gt;::registerConverter();\n    QtPrivate::MetaTypeSmartPointerHelper&lt;T&gt;::registerConverter();\n#if QT_CONFIG(future)\n    QtPrivate::MetaTypeQFutureHelper&lt;T&gt;::registerConverter();\n#endif\n\n    if (normalizedTypeName != metaType.name())\n        QMetaType::registerNormalizedTypedef(normalizedTypeName, metaType);\n\n    return id;\n}\n\n// This primary template calls the -Implementation, like all other specialisations should.\n// But the split allows to\n// - in a header:\n//   - define a specialization of this template calling an out-of-line function\n//     (QT_DECL_METATYPE_EXTERN{,_TAGGED})\n// - in the .cpp file:\n//   - define the out-of-line wrapper to call the -Implementation\n//     (QT_IMPL_METATYPE_EXTERN{,_TAGGED})\n// The _TAGGED variants let you choose a tag (must be a C identifier) to disambiguate\n// the out-of-line function; the non-_TAGGED variants use the passed class name as tag.\ntemplate &lt;typename T&gt;\nint qRegisterNormalizedMetaType(const QT_PREPEND_NAMESPACE(QByteArray) &amp;normalizedTypeName)\n{\n    return qRegisterNormalizedMetaTypeImplementation&lt;T&gt;(normalizedTypeName);\n}\n\n#define QT_DECL_METATYPE_EXTERN_TAGGED(TYPE, TAG, EXPORT) \\\n    QT_BEGIN_NAMESPACE \\\n    EXPORT int qRegisterNormalizedMetaType_ ## TAG (const QByteArray &amp;); \\\n    template &lt;&gt; inline int qRegisterNormalizedMetaType&lt; TYPE &gt;(const QByteArray &amp;name) \\\n    { return qRegisterNormalizedMetaType_ ## TAG (name); } \\\n    QT_END_NAMESPACE \\\n    Q_DECLARE_METATYPE(TYPE) \\\n    /* end */\n#define QT_IMPL_METATYPE_EXTERN_TAGGED(TYPE, TAG) \\\n    int qRegisterNormalizedMetaType_ ## TAG (const QByteArray &amp;name) \\\n    { return qRegisterNormalizedMetaTypeImplementation&lt; TYPE &gt;(name); } \\\n    /* end */\n#define QT_DECL_METATYPE_EXTERN(TYPE, EXPORT) \\\n    QT_DECL_METATYPE_EXTERN_TAGGED(TYPE, TYPE, EXPORT)\n#define QT_IMPL_METATYPE_EXTERN(TYPE) \\\n    QT_IMPL_METATYPE_EXTERN_TAGGED(TYPE, TYPE)\n\ntemplate &lt;typename T&gt;\nint qRegisterMetaType(const char *typeName)\n{\n#ifdef QT_NO_QOBJECT\n    QT_PREPEND_NAMESPACE(QByteArray) normalizedTypeName = typeName;\n#else\n    QT_PREPEND_NAMESPACE(QByteArray) normalizedTypeName = QMetaObject::normalizedType(typeName);\n#endif\n    return qRegisterNormalizedMetaType&lt;T&gt;(normalizedTypeName);\n}\n\ntemplate &lt;typename T&gt;\ninline constexpr int qMetaTypeId()\n{\n    if constexpr (bool(QMetaTypeId2&lt;T&gt;::IsBuiltIn)) {\n        // this has the same result as the below code, but avoids asking the\n        // compiler to load a global variable whose value we know at compile\n        // time\n        return QMetaTypeId2&lt;T&gt;::MetaType;\n    } else {\n        return QMetaType::fromType&lt;T&gt;().id();\n    }\n}\n\ntemplate &lt;typename T&gt;\ninline constexpr int qRegisterMetaType()\n{\n    int id = qMetaTypeId&lt;T&gt;();\n    return id;\n}\n\ninline int qRegisterMetaType(QMetaType meta)\n{\n    return meta.registerHelper();\n}\n\n#ifndef QT_NO_QOBJECT\ntemplate &lt;typename T&gt;\nstruct QMetaTypeIdQObject&lt;T*, QMetaType::PointerToQObject&gt;\n{\n    enum {\n        Defined = 1\n    };\n\n    static int qt_metatype_id()\n    {\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);\n        if (const int id = metatype_id.loadAcquire())\n            return id;\n        const char *const cName = T::staticMetaObject.className();\n        QByteArray typeName;\n        typeName.reserve(strlen(cName) + 1);\n        typeName.append(cName).append(&#x27;*&#x27;);\n        const int newId = qRegisterNormalizedMetaType&lt;T *&gt;(typeName);\n        metatype_id.storeRelease(newId);\n        return newId;\n    }\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeIdQObject&lt;T, QMetaType::IsGadget&gt;\n{\n    enum {\n        Defined = std::is_default_constructible&lt;T&gt;::value\n    };\n\n    static int qt_metatype_id()\n    {\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);\n        if (const int id = metatype_id.loadAcquire())\n            return id;\n        const char *const cName = T::staticMetaObject.className();\n        const int newId = qRegisterNormalizedMetaType&lt;T&gt;(cName);\n        metatype_id.storeRelease(newId);\n        return newId;\n    }\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeIdQObject&lt;T*, QMetaType::PointerToGadget&gt;\n{\n    enum {\n        Defined = 1\n    };\n\n    static int qt_metatype_id()\n    {\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);\n        if (const int id = metatype_id.loadAcquire())\n            return id;\n        const char *const cName = T::staticMetaObject.className();\n        QByteArray typeName;\n        typeName.reserve(strlen(cName) + 1);\n        typeName.append(cName).append(&#x27;*&#x27;);\n        const int newId = qRegisterNormalizedMetaType&lt;T *&gt;(typeName);\n        metatype_id.storeRelease(newId);\n        return newId;\n    }\n};\n\ntemplate &lt;typename T&gt;\nstruct QMetaTypeIdQObject&lt;T, QMetaType::IsEnumeration&gt;\n{\n    enum {\n        Defined = 1\n    };\n\n    static int qt_metatype_id()\n    {\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);\n        if (const int id = metatype_id.loadAcquire())\n            return id;\n        const char *eName = qt_getEnumName(T());\n        const char *cName = qt_getEnumMetaObject(T())-&gt;className();\n        QByteArray typeName;\n        typeName.reserve(strlen(cName) + 2 + strlen(eName));\n        typeName.append(cName).append(&quot;::&quot;).append(eName);\n        const int newId = qRegisterNormalizedMetaType&lt;T&gt;(typeName);\n        metatype_id.storeRelease(newId);\n        return newId;\n    }\n};\n#endif\n\n#define Q_DECLARE_OPAQUE_POINTER(POINTER)                               \\\n    QT_BEGIN_NAMESPACE namespace QtPrivate {                            \\\n    template &lt;&gt; struct IsPointerDeclaredOpaque&lt;POINTER&gt;                 \\\n        : std::true_type {};                                            \\\n    } QT_END_NAMESPACE                                                  \\\n    /**/\n\n#ifndef Q_MOC_RUN\n#define Q_DECLARE_METATYPE(TYPE) Q_DECLARE_METATYPE_IMPL(TYPE)\n#define Q_DECLARE_METATYPE_IMPL(TYPE)                                   \\\n    QT_BEGIN_NAMESPACE                                                  \\\n    template &lt;&gt;                                                         \\\n    struct QMetaTypeId&lt; TYPE &gt;                                          \\\n    {                                                                   \\\n        enum { Defined = 1 };                                           \\\n        static_assert(QtPrivate::checkTypeIsSuitableForMetaType&lt;TYPE&gt;());   \\\n        static int qt_metatype_id()                                     \\\n            {                                                           \\\n                Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \\\n                if (const int id = metatype_id.loadAcquire())           \\\n                    return id;                                          \\\n                constexpr auto arr = QtPrivate::typenameHelper&lt;TYPE&gt;(); \\\n                auto name = arr.data();                                 \\\n                if (QByteArrayView(name) == (#TYPE)) {                  \\\n                    const int id = qRegisterNormalizedMetaType&lt;TYPE&gt;(name); \\\n                    metatype_id.storeRelease(id);                       \\\n                    return id;                                          \\\n                }                                                       \\\n                const int newId = qRegisterMetaType&lt; TYPE &gt;(#TYPE);     \\\n                metatype_id.storeRelease(newId);                        \\\n                return newId;                                           \\\n            }                                                           \\\n    };                                                                  \\\n    QT_END_NAMESPACE\n#endif // Q_MOC_RUN\n\n#define Q_DECLARE_BUILTIN_METATYPE(TYPE, METATYPEID, NAME) \\\n    QT_BEGIN_NAMESPACE \\\n    template&lt;&gt; struct QMetaTypeId2&lt;NAME&gt; \\\n    { \\\n        using NameAsArrayType = std::array&lt;char, sizeof(#NAME)&gt;; \\\n        enum { Defined = 1, IsBuiltIn = true, MetaType = METATYPEID };   \\\n        static inline constexpr int qt_metatype_id() { return METATYPEID; } \\\n        static constexpr NameAsArrayType nameAsArray = { #NAME }; \\\n    }; \\\n    QT_END_NAMESPACE\n\n#define QT_FORWARD_DECLARE_STATIC_TYPES_ITER(TypeName, TypeId, Name) \\\n    class Name;\n\nQT_FOR_EACH_STATIC_CORE_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)\nQT_FOR_EACH_STATIC_GUI_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)\nQT_FOR_EACH_STATIC_WIDGETS_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)\n\n#undef QT_FORWARD_DECLARE_STATIC_TYPES_ITER\n\n#define Q_DECLARE_METATYPE_TEMPLATE_1ARG(SINGLE_ARG_TEMPLATE) \\\nQT_BEGIN_NAMESPACE \\\ntemplate &lt;typename T&gt; \\\nstruct QMetaTypeId&lt; SINGLE_ARG_TEMPLATE&lt;T&gt; &gt; \\\n{ \\\n    enum { \\\n        Defined = QMetaTypeId2&lt;T&gt;::Defined \\\n    }; \\\n    static int qt_metatype_id() \\\n    { \\\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \\\n        if (const int id = metatype_id.loadRelaxed()) \\\n            return id; \\\n        const char *tName = QMetaType::fromType&lt;T&gt;().name(); \\\n        Q_ASSERT(tName); \\\n        const size_t tNameLen = qstrlen(tName); \\\n        QByteArray typeName; \\\n        typeName.reserve(sizeof(#SINGLE_ARG_TEMPLATE) + 1 + tNameLen + 1 + 1); \\\n        typeName.append(#SINGLE_ARG_TEMPLATE, int(sizeof(#SINGLE_ARG_TEMPLATE)) - 1) \\\n            .append(&#x27;&lt;&#x27;).append(tName, tNameLen); \\\n        typeName.append(&#x27;&gt;&#x27;); \\\n        const int newId = qRegisterNormalizedMetaType&lt; SINGLE_ARG_TEMPLATE&lt;T&gt; &gt;(typeName); \\\n        metatype_id.storeRelease(newId); \\\n        return newId; \\\n    } \\\n}; \\\nQT_END_NAMESPACE\n\n#define Q_DECLARE_METATYPE_TEMPLATE_2ARG(DOUBLE_ARG_TEMPLATE) \\\nQT_BEGIN_NAMESPACE \\\ntemplate&lt;typename T, typename U&gt; \\\nstruct QMetaTypeId&lt; DOUBLE_ARG_TEMPLATE&lt;T, U&gt; &gt; \\\n{ \\\n    enum { \\\n        Defined = QMetaTypeId2&lt;T&gt;::Defined &amp;&amp; QMetaTypeId2&lt;U&gt;::Defined \\\n    }; \\\n    static int qt_metatype_id() \\\n    { \\\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \\\n        if (const int id = metatype_id.loadAcquire()) \\\n            return id; \\\n        const char *tName = QMetaType::fromType&lt;T&gt;().name(); \\\n        const char *uName = QMetaType::fromType&lt;U&gt;().name(); \\\n        Q_ASSERT(tName); \\\n        Q_ASSERT(uName); \\\n        const size_t tNameLen = qstrlen(tName); \\\n        const size_t uNameLen = qstrlen(uName); \\\n        QByteArray typeName; \\\n        typeName.reserve(sizeof(#DOUBLE_ARG_TEMPLATE) + 1 + tNameLen + 1 + uNameLen + 1 + 1); \\\n        typeName.append(#DOUBLE_ARG_TEMPLATE, int(sizeof(#DOUBLE_ARG_TEMPLATE)) - 1) \\\n            .append(&#x27;&lt;&#x27;).append(tName, tNameLen).append(&#x27;,&#x27;).append(uName, uNameLen); \\\n        typeName.append(&#x27;&gt;&#x27;); \\\n        const int newId = qRegisterNormalizedMetaType&lt; DOUBLE_ARG_TEMPLATE&lt;T, U&gt; &gt;(typeName); \\\n        metatype_id.storeRelease(newId); \\\n        return newId; \\\n    } \\\n}; \\\nQT_END_NAMESPACE\n\nnamespace QtPrivate {\n\ntemplate&lt;typename T, bool /* isSharedPointerToQObjectDerived */ = false&gt;\nstruct SharedPointerMetaTypeIdHelper\n{\n    enum {\n        Defined = 0\n    };\n    static int qt_metatype_id()\n    {\n        return -1;\n    }\n};\n\n}\n\n#define Q_DECLARE_SMART_POINTER_METATYPE(SMART_POINTER) \\\nQT_BEGIN_NAMESPACE \\\nnamespace QtPrivate { \\\ntemplate&lt;typename T&gt; \\\nstruct SharedPointerMetaTypeIdHelper&lt;SMART_POINTER&lt;T&gt;, true&gt; \\\n{ \\\n    enum { \\\n        Defined = 1 \\\n    }; \\\n    static int qt_metatype_id() \\\n    { \\\n        Q_CONSTINIT static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0); \\\n        if (const int id = metatype_id.loadAcquire()) \\\n            return id; \\\n        const char * const cName = T::staticMetaObject.className(); \\\n        QByteArray typeName; \\\n        typeName.reserve(sizeof(#SMART_POINTER) + 1 + strlen(cName) + 1); \\\n        typeName.append(#SMART_POINTER, int(sizeof(#SMART_POINTER)) - 1) \\\n            .append(&#x27;&lt;&#x27;).append(cName).append(&#x27;&gt;&#x27;); \\\n        const int newId = qRegisterNormalizedMetaType&lt; SMART_POINTER&lt;T&gt; &gt;(typeName); \\\n        metatype_id.storeRelease(newId); \\\n        return newId; \\\n    } \\\n}; \\\ntemplate&lt;typename T&gt; \\\nstruct MetaTypeSmartPointerHelper&lt;SMART_POINTER&lt;T&gt; , \\\n        typename std::enable_if&lt;IsPointerToTypeDerivedFromQObject&lt;T*&gt;::Value &amp;&amp; !std::is_const_v&lt;T&gt;&gt;::type&gt; \\\n{ \\\n    static bool registerConverter() \\\n    { \\\n        const QMetaType to = QMetaType(QMetaType::QObjectStar); \\\n        if (!QMetaType::hasRegisteredConverterFunction(QMetaType::fromType&lt;SMART_POINTER&lt;T&gt;&gt;(), to)) { \\\n            QtPrivate::QSmartPointerConvertFunctor&lt;SMART_POINTER&lt;T&gt; &gt; o; \\\n            return QMetaType::registerConverter&lt;SMART_POINTER&lt;T&gt;, QObject*&gt;(o); \\\n        } \\\n        return true; \\\n    } \\\n}; \\\n} \\\ntemplate &lt;typename T&gt; \\\nstruct QMetaTypeId&lt; SMART_POINTER&lt;T&gt; &gt; \\\n    : QtPrivate::SharedPointerMetaTypeIdHelper&lt; SMART_POINTER&lt;T&gt;, \\\n                                                QtPrivate::IsPointerToTypeDerivedFromQObject&lt;T*&gt;::Value&gt; \\\n{ \\\n};\\\nQT_END_NAMESPACE\n\n#define Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(SINGLE_ARG_TEMPLATE) \\\n    QT_BEGIN_NAMESPACE \\\n    namespace QtPrivate { \\\n    template&lt;typename T&gt; \\\n    struct IsSequentialContainer&lt;SINGLE_ARG_TEMPLATE&lt;T&gt; &gt; \\\n    { \\\n        enum { Value = true }; \\\n    }; \\\n    } \\\n    QT_END_NAMESPACE \\\n    Q_DECLARE_METATYPE_TEMPLATE_1ARG(SINGLE_ARG_TEMPLATE)\n\n#define Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER(TEMPLATENAME) \\\n    Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(TEMPLATENAME)\n\nQT_END_NAMESPACE\n\nQT_FOR_EACH_AUTOMATIC_TEMPLATE_1ARG(Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER)\n\n#undef Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE_ITER\n\nQ_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::vector)\nQ_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(std::list)\n\n#define Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(TEMPLATENAME) \\\n    QT_BEGIN_NAMESPACE \\\n    namespace QtPrivate { \\\n    template&lt;typename T, typename U&gt; \\\n    struct IsAssociativeContainer&lt;TEMPLATENAME&lt;T, U&gt; &gt; \\\n    { \\\n        enum { Value = true }; \\\n    }; \\\n    } \\\n    QT_END_NAMESPACE \\\n    Q_DECLARE_METATYPE_TEMPLATE_2ARG(TEMPLATENAME)\n\nQ_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(QHash)\nQ_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(QMap)\nQ_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(std::map)\n\nQ_DECLARE_METATYPE_TEMPLATE_2ARG(std::pair)\n\n#define Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER(TEMPLATENAME) \\\n    Q_DECLARE_SMART_POINTER_METATYPE(TEMPLATENAME)\n\nQT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER)\n\nQT_BEGIN_NAMESPACE\n\n#undef Q_DECLARE_METATYPE_TEMPLATE_SMART_POINTER_ITER\n\nQT_END_NAMESPACE\n\nQT_FOR_EACH_STATIC_TYPE(Q_DECLARE_BUILTIN_METATYPE)\n\n\nQT_BEGIN_NAMESPACE\n\nnamespace QtPrivate {\n// out-of-line helpers to reduce template code bloat (&quot;SCARY&quot;) and improve compile times:\nQ_CORE_EXPORT bool hasRegisteredConverterFunctionToPairVariantInterface(QMetaType m);\nQ_CORE_EXPORT bool hasRegisteredConverterFunctionToIterableMetaSequence(QMetaType m);\nQ_CORE_EXPORT bool hasRegisteredMutableViewFunctionToIterableMetaSequence(QMetaType m);\nQ_CORE_EXPORT bool hasRegisteredConverterFunctionToIterableMetaAssociation(QMetaType m);\nQ_CORE_EXPORT bool hasRegisteredMutableViewFunctionToIterableMetaAssociation(QMetaType m);\n}\n\ntemplate &lt;typename T&gt;\ninline bool QtPrivate::IsMetaTypePair&lt;T, true&gt;::registerConverter()\n{\n    if (!QtPrivate::hasRegisteredConverterFunctionToPairVariantInterface(QMetaType::fromType&lt;T&gt;())) {\n        QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor&lt;T&gt; o;\n        return QMetaType::registerConverter&lt;T, QtMetaTypePrivate::QPairVariantInterfaceImpl&gt;(o);\n    }\n    return true;\n}\n\nnamespace QtPrivate {\n\ntemplate&lt;typename From&gt;\nstruct QSequentialIterableConvertFunctor\n{\n    QIterable&lt;QMetaSequence&gt; operator()(const From &amp;f) const\n    {\n        return QIterable&lt;QMetaSequence&gt;(QMetaSequence::fromContainer&lt;From&gt;(), &amp;f);\n    }\n};\n\ntemplate&lt;typename From&gt;\nstruct QSequentialIterableMutableViewFunctor\n{\n    QIterable&lt;QMetaSequence&gt; operator()(From &amp;f) const\n    {\n        return QIterable&lt;QMetaSequence&gt;(QMetaSequence::fromContainer&lt;From&gt;(), &amp;f);\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct SequentialValueTypeIsMetaType&lt;T, true&gt;\n{\n    static bool registerConverter()\n    {\n        if (!QtPrivate::hasRegisteredConverterFunctionToIterableMetaSequence(QMetaType::fromType&lt;T&gt;())) {\n            QSequentialIterableConvertFunctor&lt;T&gt; o;\n            return QMetaType::registerConverter&lt;T, QIterable&lt;QMetaSequence&gt;&gt;(o);\n        }\n        return true;\n    }\n\n    static bool registerMutableView()\n    {\n        if (!QtPrivate::hasRegisteredMutableViewFunctionToIterableMetaSequence(QMetaType::fromType&lt;T&gt;())) {\n            QSequentialIterableMutableViewFunctor&lt;T&gt; o;\n            return QMetaType::registerMutableView&lt;T, QIterable&lt;QMetaSequence&gt;&gt;(o);\n        }\n        return true;\n    }\n};\n\ntemplate&lt;typename From&gt;\nstruct QAssociativeIterableConvertFunctor\n{\n    QIterable&lt;QMetaAssociation&gt; operator()(const From &amp;f) const\n    {\n        return QIterable&lt;QMetaAssociation&gt;(QMetaAssociation::fromContainer&lt;From&gt;(), &amp;f);\n    }\n};\n\ntemplate&lt;typename From&gt;\nstruct QAssociativeIterableMutableViewFunctor\n{\n    QIterable&lt;QMetaAssociation&gt; operator()(From &amp;f) const\n    {\n        return QIterable&lt;QMetaAssociation&gt;(QMetaAssociation::fromContainer&lt;From&gt;(), &amp;f);\n    }\n};\n\n// Mapped type can be omitted, for example in case of a set.\n// However, if it is available, we want to instantiate the metatype here.\ntemplate&lt;typename T&gt;\nstruct AssociativeKeyTypeIsMetaType&lt;T, true&gt; : AssociativeMappedTypeIsMetaType&lt;T&gt;\n{\n    static bool registerConverter()\n    {\n        if (!QtPrivate::hasRegisteredConverterFunctionToIterableMetaAssociation(QMetaType::fromType&lt;T&gt;())) {\n            QAssociativeIterableConvertFunctor&lt;T&gt; o;\n            return QMetaType::registerConverter&lt;T, QIterable&lt;QMetaAssociation&gt;&gt;(o);\n        }\n        return true;\n    }\n\n    static bool registerMutableView()\n    {\n        if (!QtPrivate::hasRegisteredMutableViewFunctionToIterableMetaAssociation(QMetaType::fromType&lt;T&gt;())) {\n            QAssociativeIterableMutableViewFunctor&lt;T&gt; o;\n            return QMetaType::registerMutableView&lt;T, QIterable&lt;QMetaAssociation&gt;&gt;(o);\n        }\n        return true;\n    }\n};\n\nstruct QTypeNormalizer\n{\n    char *output;\n    int len = 0;\n    char last = 0;\n\nprivate:\n    static constexpr bool is_ident_char(char s)\n    {\n        return ((s &gt;= &#x27;a&#x27; &amp;&amp; s &lt;= &#x27;z&#x27;) || (s &gt;= &#x27;A&#x27; &amp;&amp; s &lt;= &#x27;Z&#x27;) || (s &gt;= &#x27;0&#x27; &amp;&amp; s &lt;= &#x27;9&#x27;)\n                || s == &#x27;_&#x27;);\n    }\n    static constexpr bool is_space(char s) { return (s == &#x27; &#x27; || s == &#x27;\\t&#x27; || s == &#x27;\\n&#x27;); }\n    static constexpr bool is_number(char s) { return s &gt;= &#x27;0&#x27; &amp;&amp; s &lt;= &#x27;9&#x27;; }\n    static constexpr bool starts_with_token(const char *b, const char *e, const char *token,\n                                            bool msvcKw = false)\n    {\n        while (b != e &amp;&amp; *token &amp;&amp; *b == *token) {\n            b++;\n            token++;\n        }\n        if (*token)\n            return false;\n#ifdef Q_CC_MSVC\n        /// On MSVC, keywords like class or struct are not separated with spaces in constexpr\n        /// context\n        if (msvcKw &amp;&amp; !is_ident_char(*b))\n            return true;\n#endif\n        Q_UNUSED(msvcKw);\n        return b == e || !is_ident_char(*b);\n    }\n    static constexpr bool starts_with_prefix(const char *b, const char *e, const char *prefix)\n    {\n        while (b != e &amp;&amp; *prefix &amp;&amp; *b == *prefix) {\n            b++;\n            prefix++;\n        }\n        return !*prefix &amp;&amp; b != e &amp;&amp; is_ident_char(*b);\n    }\n    static constexpr bool skipToken(const char *&amp;x, const char *e, const char *token,\n                                    bool msvcKw = false)\n    {\n        if (!starts_with_token(x, e, token, msvcKw))\n            return false;\n        while (*token++)\n            x++;\n        while (x != e &amp;&amp; is_space(*x))\n            x++;\n        return true;\n    }\n    static constexpr bool skipNamespacePrefix(const char *&amp;x, const char *e, const char *prefix)\n    {\n        if (!starts_with_prefix(x, e, prefix))\n            return false;\n        while (*prefix++)\n            x++;\n        while (x != e &amp;&amp; is_ident_char(*x))\n            x++;\n        return true;\n    }\n    static constexpr const char *skipString(const char *x, const char *e)\n    {\n        char delim = *x;\n        x++;\n        while (x != e &amp;&amp; *x != delim) {\n            if (*x == &#x27;\\\\&#x27;) {\n                x++;\n                if (x == e)\n                    return e;\n            }\n            x++;\n        }\n        if (x != e)\n            x++;\n        return x;\n    }\n    static constexpr const char *skipTemplate(const char *x, const char *e, bool stopAtComa = false)\n    {\n        int scopeDepth = 0;\n        int templateDepth = 0;\n        while (x != e) {\n            switch (*x) {\n            case &#x27;&lt;&#x27;:\n                if (!scopeDepth)\n                    templateDepth++;\n                break;\n            case &#x27;,&#x27;:\n                if (stopAtComa &amp;&amp; !scopeDepth &amp;&amp; !templateDepth)\n                    return x;\n                break;\n            case &#x27;&gt;&#x27;:\n                if (!scopeDepth)\n                    if (--templateDepth &lt; 0)\n                        return x;\n                break;\n            case &#x27;(&#x27;:\n            case &#x27;[&#x27;:\n            case &#x27;{&#x27;:\n                scopeDepth++;\n                break;\n            case &#x27;}&#x27;:\n            case &#x27;]&#x27;:\n            case &#x27;)&#x27;:\n                scopeDepth--;\n                break;\n            case &#x27;\\&#x27;&#x27;:\n                if (is_number(x[-1]))\n                    break;\n                Q_FALLTHROUGH();\n            case &#x27;\\&quot;&#x27;:\n                x = skipString(x, e);\n                continue;\n            }\n            x++;\n        }\n        return x;\n    }\n\n    constexpr void append(char x)\n    {\n        last = x;\n        len++;\n        if (output)\n            *output++ = x;\n    }\n\n    constexpr void replaceLast(char x)\n    {\n        last = x;\n        if (output)\n            *(output - 1) = x;\n    }\n\n    constexpr void appendStr(const char *x)\n    {\n        while (*x)\n            append(*x++);\n    }\n\n    constexpr void normalizeIntegerTypes(const char *&amp;begin, const char *end)\n    {\n        int numLong = 0;\n        int numSigned = 0;\n        int numUnsigned = 0;\n        int numInt = 0;\n        int numShort = 0;\n        int numChar = 0;\n        while (begin &lt; end) {\n            if (skipToken(begin, end, &quot;long&quot;)) {\n                numLong++;\n                continue;\n            }\n            if (skipToken(begin, end, &quot;int&quot;)) {\n                numInt++;\n                continue;\n            }\n            if (skipToken(begin, end, &quot;short&quot;)) {\n                numShort++;\n                continue;\n            }\n            if (skipToken(begin, end, &quot;unsigned&quot;)) {\n                numUnsigned++;\n                continue;\n            }\n            if (skipToken(begin, end, &quot;signed&quot;)) {\n                numSigned++;\n                continue;\n            }\n            if (skipToken(begin, end, &quot;char&quot;)) {\n                numChar++;\n                continue;\n            }\n#ifdef Q_CC_MSVC\n            if (skipToken(begin, end, &quot;__int64&quot;)) {\n                numLong = 2;\n                continue;\n            }\n#endif\n            break;\n        }\n        if (numLong == 2)\n            append(&#x27;q&#x27;); // q(u)longlong\n        if (numSigned &amp;&amp; numChar)\n            appendStr(&quot;signed &quot;);\n        else if (numUnsigned)\n            appendStr(&quot;u&quot;);\n        if (numChar)\n            appendStr(&quot;char&quot;);\n        else if (numShort)\n            appendStr(&quot;short&quot;);\n        else if (numLong == 1)\n            appendStr(&quot;long&quot;);\n        else if (numLong == 2)\n            appendStr(&quot;longlong&quot;);\n        else if (numUnsigned || numSigned || numInt)\n            appendStr(&quot;int&quot;);\n    }\n\n    constexpr void skipStructClassOrEnum(const char *&amp;begin, const char *end)\n    {\n        // discard &#x27;struct&#x27;, &#x27;class&#x27;, and &#x27;enum&#x27;; they are optional\n        // and we don&#x27;t want them in the normalized signature\n        skipToken(begin, end, &quot;struct&quot;, true) || skipToken(begin, end, &quot;class&quot;, true)\n                || skipToken(begin, end, &quot;enum&quot;, true);\n    }\n\n    constexpr void skipQtNamespace(const char *&amp;begin, const char *end)\n    {\n#ifdef QT_NAMESPACE\n        const char *nsbeg = begin;\n        if (skipToken(nsbeg, end, QT_STRINGIFY(QT_NAMESPACE)) &amp;&amp; nsbeg + 2 &lt; end &amp;&amp; nsbeg[0] == &#x27;:&#x27;\n            &amp;&amp; nsbeg[1] == &#x27;:&#x27;) {\n            begin = nsbeg + 2;\n            while (begin != end &amp;&amp; is_space(*begin))\n                begin++;\n        }\n#else\n        Q_UNUSED(begin);\n        Q_UNUSED(end);\n#endif\n    }\n\npublic:\n#if defined(Q_CC_CLANG) || defined (Q_CC_GNU)\n    // this is much simpler than the full type normalization below\n    // the reason is that the signature returned by Q_FUNC_INFO is already\n    // normalized to the largest degree, and we need to do only small adjustments\n    constexpr int normalizeTypeFromSignature(const char *begin, const char *end)\n    {\n        // bail out if there is an anonymous struct\n        std::string_view name(begin, end-begin);\n#if defined (Q_CC_CLANG)\n        if (name.find(&quot;anonymous &quot;) != std::string_view::npos)\n            return normalizeType(begin, end);\n#endif\n        if (name.find(&quot;unnamed &quot;) != std::string_view::npos)\n            return normalizeType(begin, end);\n        if (name.find(&quot;std::__&quot;) != std::string_view::npos)\n            return normalizeType(begin, end);\n        while (begin &lt; end) {\n            if (*begin == &#x27; &#x27;) {\n                if (last == &#x27;,&#x27; || last == &#x27;&gt;&#x27; || last == &#x27;&lt;&#x27; || last == &#x27;*&#x27; || last == &#x27;&amp;&#x27;) {\n                    ++begin;\n                    continue;\n                }\n            }\n            if (last == &#x27; &#x27;) {\n                if (*begin == &#x27;*&#x27; || *begin == &#x27;&amp;&#x27; || *begin == &#x27;(&#x27;) {\n                    replaceLast(*begin);\n                    ++begin;\n                    continue;\n                }\n            }\n            if (!is_ident_char(last)) {\n                skipStructClassOrEnum(begin, end);\n                if (begin == end)\n                    break;\n\n                skipQtNamespace(begin, end);\n                if (begin == end)\n                    break;\n\n                normalizeIntegerTypes(begin, end);\n                if (begin == end)\n                    break;\n            }\n            append(*begin);\n            ++begin;\n        }\n        return len;\n    }\n#else\n    // MSVC needs the full normalization, as it puts the const in a different\n    // place than we expect\n    constexpr int normalizeTypeFromSignature(const char *begin, const char *end)\n    { return normalizeType(begin, end); }\n#endif\n\n    constexpr int normalizeType(const char *begin, const char *end, bool adjustConst = true)\n    {\n        // Trim spaces\n        while (begin != end &amp;&amp; is_space(*begin))\n            begin++;\n        while (begin != end &amp;&amp; is_space(*(end - 1)))\n            end--;\n\n        // Convert &#x27;char const *&#x27; into &#x27;const char *&#x27;. Start at index 1,\n        // not 0, because &#x27;const char *&#x27; is already OK.\n        const char *cst = begin + 1;\n        if (*begin == &#x27;\\&#x27;&#x27; || *begin == &#x27;&quot;&#x27;)\n            cst = skipString(begin, end);\n        bool seenStar = false;\n        bool hasMiddleConst = false;\n        while (cst &lt; end) {\n            if (*cst == &#x27;\\&quot;&#x27; || (*cst == &#x27;\\&#x27;&#x27; &amp;&amp; !is_number(cst[-1]))) {\n                cst = skipString(cst, end);\n                if (cst == end)\n                    break;\n            }\n\n            // We mustn&#x27;t convert &#x27;char * const *&#x27; into &#x27;const char **&#x27;\n            // and we must beware of &#x27;Bar&lt;const Bla&gt;&#x27;.\n            if (*cst == &#x27;&amp;&#x27; || *cst == &#x27;*&#x27; || *cst == &#x27;[&#x27;) {\n                seenStar = *cst != &#x27;&amp;&#x27; || cst != (end - 1);\n                break;\n            }\n            if (*cst == &#x27;&lt;&#x27;) {\n                cst = skipTemplate(cst + 1, end);\n                if (cst == end)\n                    break;\n            }\n            cst++;\n            const char *skipedCst = cst;\n            if (!is_ident_char(*(cst - 1)) &amp;&amp; skipToken(skipedCst, end, &quot;const&quot;)) {\n                const char *testEnd = end;\n                while (skipedCst &lt; testEnd--) {\n                    if (*testEnd == &#x27;*&#x27; || *testEnd == &#x27;[&#x27;\n                        || (*testEnd == &#x27;&amp;&#x27; &amp;&amp; testEnd != (end - 1))) {\n                        seenStar = true;\n                        break;\n                    }\n                    if (*testEnd == &#x27;&gt;&#x27;)\n                        break;\n                }\n                if (adjustConst &amp;&amp; !seenStar) {\n                    if (*(end - 1) == &#x27;&amp;&#x27;)\n                        end--;\n                } else {\n                    appendStr(&quot;const &quot;);\n                }\n                normalizeType(begin, cst, false);\n                begin = skipedCst;\n                hasMiddleConst = true;\n                break;\n            }\n        }\n        if (skipToken(begin, end, &quot;const&quot;)) {\n            if (adjustConst &amp;&amp; !seenStar) {\n                if (*(end - 1) == &#x27;&amp;&#x27;)\n                    end--;\n            } else {\n                appendStr(&quot;const &quot;);\n            }\n        }\n        if (seenStar &amp;&amp; adjustConst) {\n            const char *e = end;\n            if (*(end - 1) == &#x27;&amp;&#x27; &amp;&amp; *(end - 2) != &#x27;&amp;&#x27;)\n                e--;\n            while (begin != e &amp;&amp; is_space(*(e - 1)))\n                e--;\n            const char *token = &quot;tsnoc&quot;; // &#x27;const&#x27; reverse, to check if it ends with const\n            while (*token &amp;&amp; begin != e &amp;&amp; *(--e) == *token++)\n                ;\n            if (!*token &amp;&amp; begin != e &amp;&amp; !is_ident_char(*(e - 1))) {\n                while (begin != e &amp;&amp; is_space(*(e - 1)))\n                    e--;\n                end = e;\n            }\n        }\n\n        skipStructClassOrEnum(begin, end);\n        skipQtNamespace(begin, end);\n\n        if (skipNamespacePrefix(begin, end, &quot;std::__&quot;)) {\n            // Replace std::__n by std::\n            appendStr(&quot;std&quot;);\n        }\n\n        if (skipToken(begin, end, &quot;QVector&quot;)) {\n            // Replace QVector by QList\n            appendStr(&quot;QList&quot;);\n        }\n\n        if (skipToken(begin, end, &quot;QPair&quot;)) {\n            // replace QPair by std::pair\n            appendStr(&quot;std::pair&quot;);\n        }\n\n        if (!hasMiddleConst)\n            // Normalize the integer types\n            normalizeIntegerTypes(begin, end);\n\n        bool spaceSkiped = true;\n        while (begin != end) {\n            char c = *begin++;\n            if (is_space(c)) {\n                spaceSkiped = true;\n            } else if ((c == &#x27;\\&#x27;&#x27; &amp;&amp; !is_number(last)) || c == &#x27;\\&quot;&#x27;) {\n                begin--;\n                auto x = skipString(begin, end);\n                while (begin &lt; x)\n                    append(*begin++);\n            } else {\n                if (spaceSkiped &amp;&amp; is_ident_char(last) &amp;&amp; is_ident_char(c))\n                    append(&#x27; &#x27;);\n                append(c);\n                spaceSkiped = false;\n                if (c == &#x27;&lt;&#x27;) {\n                    do {\n                        // template recursion\n                        const char *tpl = skipTemplate(begin, end, true);\n                        normalizeType(begin, tpl, false);\n                        if (tpl == end)\n                            return len;\n                        append(*tpl);\n                        begin = tpl;\n                    } while (*begin++ == &#x27;,&#x27;);\n                }\n            }\n        }\n        return len;\n    }\n};\n\n// Normalize the type between begin and end, and store the data in the output. Returns the length.\n// The idea is to first run this function with nullptr as output to allocate the output with the\n// size\nconstexpr int qNormalizeType(const char *begin, const char *end, char *output)\n{\n    return QTypeNormalizer { output }.normalizeType(begin, end);\n}\n\ntemplate&lt;typename T&gt;\nstruct is_std_pair : std::false_type {};\n\ntemplate &lt;typename T1_, typename T2_&gt;\nstruct is_std_pair&lt;std::pair&lt;T1_, T2_&gt;&gt; : std::true_type {\n    using T1 = T1_;\n    using T2 = T2_;\n};\n\nnamespace TypeNameHelper {\ntemplate&lt;typename T&gt;\nconstexpr auto typenameHelper()\n{\n    if constexpr (is_std_pair&lt;T&gt;::value) {\n        using T1 = typename is_std_pair&lt;T&gt;::T1;\n        using T2 = typename is_std_pair&lt;T&gt;::T2;\n        std::remove_const_t&lt;std::conditional_t&lt;bool (QMetaTypeId2&lt;T1&gt;::IsBuiltIn), typename QMetaTypeId2&lt;T1&gt;::NameAsArrayType, decltype(typenameHelper&lt;T1&gt;())&gt;&gt; t1Name {};\n        std::remove_const_t&lt;std::conditional_t&lt;bool (QMetaTypeId2&lt;T2&gt;::IsBuiltIn), typename QMetaTypeId2&lt;T2&gt;::NameAsArrayType, decltype(typenameHelper&lt;T2&gt;())&gt;&gt; t2Name {};\n        if constexpr (bool (QMetaTypeId2&lt;T1&gt;::IsBuiltIn) ) {\n            t1Name = QMetaTypeId2&lt;T1&gt;::nameAsArray;\n        } else {\n            t1Name = typenameHelper&lt;T1&gt;();\n        }\n        if constexpr (bool(QMetaTypeId2&lt;T2&gt;::IsBuiltIn)) {\n            t2Name = QMetaTypeId2&lt;T2&gt;::nameAsArray;\n        } else {\n            t2Name = typenameHelper&lt;T2&gt;();\n        }\n        constexpr auto nonTypeDependentLen = sizeof(&quot;std::pair&lt;,&gt;&quot;);\n        constexpr auto t1Len = t1Name.size() - 1;\n        constexpr auto t2Len = t2Name.size() - 1;\n        constexpr auto length = nonTypeDependentLen + t1Len + t2Len;\n        std::array&lt;char, length + 1&gt; result {};\n        constexpr auto prefix = &quot;std::pair&lt;&quot;;\n        int currentLength = 0;\n        for (; currentLength &lt; int(sizeof(&quot;std::pair&lt;&quot;) - 1); ++currentLength)\n            result[currentLength] = prefix[currentLength];\n        for (int i = 0; i &lt; int(t1Len); ++currentLength, ++i)\n            result[currentLength] = t1Name[i];\n        result[currentLength++] = &#x27;,&#x27;;\n        for (int i = 0; i &lt; int(t2Len); ++currentLength, ++i)\n            result[currentLength] = t2Name[i];\n        result[currentLength++] = &#x27;&gt;&#x27;;\n        result[currentLength++] = &#x27;\\0&#x27;;\n        return result;\n    } else {\n        constexpr auto prefix = sizeof(\n#ifdef QT_NAMESPACE\n            QT_STRINGIFY(QT_NAMESPACE) &quot;::&quot;\n#endif\n#if defined(Q_CC_MSVC) &amp;&amp; defined(Q_CC_CLANG)\n            &quot;auto __cdecl QtPrivate::TypeNameHelper::typenameHelper(void) [T = &quot;\n#elif defined(Q_CC_MSVC)\n            &quot;auto __cdecl QtPrivate::TypeNameHelper::typenameHelper&lt;&quot;\n#elif defined(Q_CC_CLANG)\n            &quot;auto QtPrivate::TypeNameHelper::typenameHelper() [T = &quot;\n#elif defined(Q_CC_GHS)\n            &quot;auto QtPrivate::TypeNameHelper::typenameHelper&lt;T&gt;()[with T=&quot;\n#else\n            &quot;constexpr auto QtPrivate::TypeNameHelper::typenameHelper() [with T = &quot;\n#endif\n            ) - 1;\n#if defined(Q_CC_MSVC) &amp;&amp; !defined(Q_CC_CLANG)\n        constexpr int suffix = sizeof(&quot;&gt;(void)&quot;);\n#else\n        constexpr int suffix = sizeof(&quot;]&quot;);\n#endif\n\n#if defined(Q_CC_GNU_ONLY) &amp;&amp; Q_CC_GNU_ONLY &lt; 804\n        auto func = Q_FUNC_INFO;\n        const char *begin = func + prefix;\n        const char *end = func + sizeof(Q_FUNC_INFO) - suffix;\n        // This is an upper bound of the size since the normalized signature should always be smaller\n        constexpr int len = sizeof(Q_FUNC_INFO) - suffix - prefix;\n#else\n        constexpr auto func = Q_FUNC_INFO;\n        constexpr const char *begin = func + prefix;\n        constexpr const char *end = func + sizeof(Q_FUNC_INFO) - suffix;\n        constexpr int len = QTypeNormalizer{ nullptr }.normalizeTypeFromSignature(begin, end);\n#endif\n        std::array&lt;char, len + 1&gt; result {};\n        QTypeNormalizer{ result.data() }.normalizeTypeFromSignature(begin, end);\n        return result;\n    }\n}\n} // namespace TypeNameHelper\nusing TypeNameHelper::typenameHelper;\n\ntemplate&lt;typename T, typename = void&gt;\nstruct BuiltinMetaType : std::integral_constant&lt;int, 0&gt;\n{\n};\ntemplate&lt;typename T&gt;\nstruct BuiltinMetaType&lt;T, std::enable_if_t&lt;QMetaTypeId2&lt;T&gt;::IsBuiltIn&gt;&gt;\n    : std::integral_constant&lt;int, QMetaTypeId2&lt;T&gt;::MetaType&gt;\n{\n};\n\ntemplate&lt;typename T, bool = (QTypeTraits::has_operator_equal_v&lt;T&gt; &amp;&amp; !std::is_pointer_v&lt;T&gt;)&gt;\nstruct QEqualityOperatorForType\n{\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_FLOAT_COMPARE\n    static bool equals(const QMetaTypeInterface *, const void *a, const void *b)\n    { return *reinterpret_cast&lt;const T *&gt;(a) == *reinterpret_cast&lt;const T *&gt;(b); }\nQT_WARNING_POP\n};\n\ntemplate&lt;typename T&gt;\nstruct QEqualityOperatorForType &lt;T, false&gt;\n{\n    static constexpr QMetaTypeInterface::EqualsFn equals = nullptr;\n};\n\ntemplate&lt;typename T, bool = (QTypeTraits::has_operator_less_than_v&lt;T&gt; &amp;&amp; !std::is_pointer_v&lt;T&gt;)&gt;\nstruct QLessThanOperatorForType\n{\n    static bool lessThan(const QMetaTypeInterface *, const void *a, const void *b)\n    { return *reinterpret_cast&lt;const T *&gt;(a) &lt; *reinterpret_cast&lt;const T *&gt;(b); }\n};\n\ntemplate&lt;typename T&gt;\nstruct QLessThanOperatorForType &lt;T, false&gt;\n{\n    static constexpr QMetaTypeInterface::LessThanFn lessThan = nullptr;\n};\n\ntemplate&lt;typename T, bool = (QTypeTraits::has_ostream_operator_v&lt;QDebug, T&gt; &amp;&amp; !std::is_pointer_v&lt;T&gt;)&gt;\nstruct QDebugStreamOperatorForType\n{\n    static void debugStream(const QMetaTypeInterface *, QDebug &amp;dbg, const void *a)\n    { dbg &lt;&lt; *reinterpret_cast&lt;const T *&gt;(a); }\n};\n\ntemplate&lt;typename T&gt;\nstruct QDebugStreamOperatorForType &lt;T, false&gt;\n{\n    static constexpr QMetaTypeInterface::DebugStreamFn debugStream = nullptr;\n};\n\ntemplate&lt;typename T, bool = QTypeTraits::has_stream_operator_v&lt;QDataStream, T&gt;&gt;\nstruct QDataStreamOperatorForType\n{\n    static constexpr QMetaTypeInterface::DataStreamOutFn dataStreamOut = nullptr;\n    static constexpr QMetaTypeInterface::DataStreamInFn dataStreamIn = nullptr;\n};\n\n#ifndef QT_NO_DATASTREAM\ntemplate&lt;typename T&gt;\nstruct QDataStreamOperatorForType &lt;T, true&gt;\n{\n    static void dataStreamOut(const QMetaTypeInterface *, QDataStream &amp;ds, const void *a)\n    { ds &lt;&lt; *reinterpret_cast&lt;const T *&gt;(a); }\n    static void dataStreamIn(const QMetaTypeInterface *, QDataStream &amp;ds, void *a)\n    { ds &gt;&gt; *reinterpret_cast&lt;T *&gt;(a); }\n};\n#endif\n\n// Performance optimization:\n//\n// Don&#x27;t add all these symbols to the dynamic symbol tables on ELF systems and\n// on Darwin. Each library is going to have a copy anyway and QMetaType already\n// copes with some of these being &quot;hidden&quot; (see QMetaType::idHelper()). We may\n// as well let the linker know it can always use the local copy.\n//\n// This is currently not enabled for GCC due to\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106023\n\n#if !defined(Q_OS_WIN) &amp;&amp; defined(Q_CC_CLANG)\n#  pragma GCC visibility push(hidden)\n#endif\n\n// ### Qt 7: consider removing this infrastructure if nothing uses it\n// (see also getCopyCtr())\nnamespace QMetaTypeCopyTraits\n{\n    // Hack to suppress deprecation warnings from types\n    // with deprecated copy operations, cf. QTBUG-132752\n    template &lt;typename T&gt;\n    using HasDeprecatedCopyConstructorTest = typename T::_q_hasDeprecatedCopyConstructor;\n\n#if !defined(QT_BOOTSTRAPPED)\n    Q_CORE_EXPORT void warnAboutDeprecatedCopy(const char *name);\n#endif\n} // namespace QMetaTypeCopyTraits\n\ntemplate&lt;typename S&gt;\nclass QMetaTypeForType\n{\npublic:\n    static constexpr decltype(typenameHelper&lt;S&gt;()) name = typenameHelper&lt;S&gt;();\n\n    static constexpr unsigned flags()\n    {\n        uint flags = 0;\n        if constexpr (QTypeInfo&lt;S&gt;::isRelocatable)\n            flags |= QMetaType::RelocatableType;\n        if constexpr (!std::is_default_constructible_v&lt;S&gt; || !QTypeInfo&lt;S&gt;::isValueInitializationBitwiseZero)\n            flags |= QMetaType::NeedsConstruction;\n        if constexpr (!std::is_trivially_destructible_v&lt;S&gt;)\n            flags |= QMetaType::NeedsDestruction;\n        if constexpr (!std::is_trivially_copy_constructible_v&lt;S&gt;)\n            flags |= QMetaType::NeedsCopyConstruction;\n        if constexpr (!std::is_trivially_move_constructible_v&lt;S&gt;)\n            flags |= QMetaType::NeedsMoveConstruction;\n        if constexpr (IsPointerToTypeDerivedFromQObject&lt;S&gt;::Value)\n            flags |= QMetaType::PointerToQObject;\n        if constexpr (IsSharedPointerToTypeDerivedFromQObject&lt;S&gt;::Value)\n            flags |= QMetaType::SharedPointerToQObject;\n        if constexpr (IsWeakPointerToTypeDerivedFromQObject&lt;S&gt;::Value)\n            flags |= QMetaType::WeakPointerToQObject;\n        if constexpr (IsTrackingPointerToTypeDerivedFromQObject&lt;S&gt;::Value)\n            flags |= QMetaType::TrackingPointerToQObject;\n        if constexpr (IsEnumOrFlags&lt;S&gt;::value)\n            flags |= QMetaType::IsEnumeration;\n        if constexpr (IsGadgetHelper&lt;S&gt;::IsGadgetOrDerivedFrom)\n            flags |= QMetaType::IsGadget;\n        if constexpr (IsPointerToGadgetHelper&lt;S&gt;::IsGadgetOrDerivedFrom)\n            flags |= QMetaType::PointerToGadget;\n        if constexpr (std::is_pointer_v&lt;S&gt;)\n            flags |= QMetaType::IsPointer;\n        if constexpr (IsUnsignedEnum&lt;S&gt;)\n            flags |= QMetaType::IsUnsignedEnumeration;\n        if constexpr (IsQmlListType&lt;S&gt;)\n            flags |= QMetaType::IsQmlList;\n        if constexpr (std::is_const_v&lt;std::remove_pointer_t&lt;S&gt;&gt;)\n            flags |= QMetaType::IsConst;\n        return flags;\n    }\n\n    static constexpr QMetaTypeInterface::DefaultCtrFn getDefaultCtr()\n    {\n        if constexpr (std::is_default_constructible_v&lt;S&gt; &amp;&amp; !QTypeInfo&lt;S&gt;::isValueInitializationBitwiseZero) {\n            return [](const QMetaTypeInterface *, void *addr) { new (addr) S(); };\n        } else {\n            return nullptr;\n        }\n    }\n\n    static constexpr QMetaTypeInterface::CopyCtrFn getCopyCtr()\n    {\n        if constexpr (std::is_copy_constructible_v&lt;S&gt; &amp;&amp; !std::is_trivially_copy_constructible_v&lt;S&gt;) {\n            return [](const QMetaTypeInterface *, void *addr, const void *other) {\n                if constexpr (qxp::is_detected_v&lt;QMetaTypeCopyTraits::HasDeprecatedCopyConstructorTest, S&gt;) {\n#if !defined(QT_BOOTSTRAPPED)\n                    QMetaTypeCopyTraits::warnAboutDeprecatedCopy(getName());\n#endif\n                    QT_IGNORE_DEPRECATIONS(new (addr) S(*reinterpret_cast&lt;const S *&gt;(other));)\n                } else {\n                    new (addr) S(*reinterpret_cast&lt;const S *&gt;(other));\n                }\n            };\n        } else {\n            return nullptr;\n        }\n    }\n\n    static constexpr QMetaTypeInterface::MoveCtrFn getMoveCtr()\n    {\n        if constexpr (std::is_move_constructible_v&lt;S&gt; &amp;&amp; !std::is_trivially_move_constructible_v&lt;S&gt;) {\n            return [](const QMetaTypeInterface *, void *addr, void *other) {\n                new (addr) S(std::move(*reinterpret_cast&lt;S *&gt;(other)));\n            };\n        } else {\n            return nullptr;\n        }\n    }\n\n    static constexpr QMetaTypeInterface::DtorFn getDtor()\n    {\n        if constexpr (std::is_destructible_v&lt;S&gt; &amp;&amp; !std::is_trivially_destructible_v&lt;S&gt;)\n            return [](const QMetaTypeInterface *, void *addr) {\n                reinterpret_cast&lt;S *&gt;(addr)-&gt;~S();\n            };\n        else\n            return nullptr;\n    }\n\n    static constexpr QMetaTypeInterface::LegacyRegisterOp getLegacyRegister()\n    {\n        if constexpr (QMetaTypeId2&lt;S&gt;::Defined &amp;&amp; !QMetaTypeId2&lt;S&gt;::IsBuiltIn) {\n            return []() { QMetaTypeId2&lt;S&gt;::qt_metatype_id(); };\n        } else {\n            return nullptr;\n        }\n    }\n\n    static constexpr const char *getName()\n    {\n        if constexpr (bool(QMetaTypeId2&lt;S&gt;::IsBuiltIn)) {\n            return QMetaTypeId2&lt;S&gt;::nameAsArray.data();\n        } else {\n            return name.data();\n        }\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct QMetaTypeInterfaceWrapper\n{\n    // if the type ID for T is known at compile-time, then we can declare\n    // the QMetaTypeInterface object const; otherwise, we declare it as\n    // non-const and the .typeId is updated by QMetaType::idHelper().\n    static constexpr bool IsConstMetaTypeInterface = !!BuiltinMetaType&lt;T&gt;::value;\n    using InterfaceType = std::conditional_t&lt;IsConstMetaTypeInterface, const QMetaTypeInterface, NonConstMetaTypeInterface&gt;;\n\n    static inline InterfaceType metaType = {\n        /*.revision=*/ QMetaTypeInterface::CurrentRevision,\n        /*.alignment=*/ alignof(T),\n        /*.size=*/ sizeof(T),\n        /*.flags=*/ QMetaTypeForType&lt;T&gt;::flags(),\n        /*.typeId=*/ BuiltinMetaType&lt;T&gt;::value,\n        /*.metaObjectFn=*/ MetaObjectForType&lt;T&gt;::metaObjectFunction,\n        /*.name=*/ QMetaTypeForType&lt;T&gt;::getName(),\n        /*.defaultCtr=*/ QMetaTypeForType&lt;T&gt;::getDefaultCtr(),\n        /*.copyCtr=*/ QMetaTypeForType&lt;T&gt;::getCopyCtr(),\n        /*.moveCtr=*/ QMetaTypeForType&lt;T&gt;::getMoveCtr(),\n        /*.dtor=*/ QMetaTypeForType&lt;T&gt;::getDtor(),\n        /*.equals=*/ QEqualityOperatorForType&lt;T&gt;::equals,\n        /*.lessThan=*/ QLessThanOperatorForType&lt;T&gt;::lessThan,\n        /*.debugStream=*/ QDebugStreamOperatorForType&lt;T&gt;::debugStream,\n        /*.dataStreamOut=*/ QDataStreamOperatorForType&lt;T&gt;::dataStreamOut,\n        /*.dataStreamIn=*/ QDataStreamOperatorForType&lt;T&gt;::dataStreamIn,\n        /*.legacyRegisterOp=*/ QMetaTypeForType&lt;T&gt;::getLegacyRegister()\n    };\n};\ntemplate&lt;typename T&gt; struct QMetaTypeInterfaceWrapper&lt;T &amp;&gt; {};\n\n\n#if !defined(Q_OS_WIN) &amp;&amp; defined(Q_CC_CLANG)\n#  pragma GCC visibility pop\n#endif\n\ntemplate&lt;&gt;\nclass QMetaTypeInterfaceWrapper&lt;void&gt;\n{\npublic:\n    static constexpr QMetaTypeInterface metaType =\n    {\n        /*.revision=*/ 0,\n        /*.alignment=*/ 0,\n        /*.size=*/ 0,\n        /*.flags=*/ 0,\n        /*.typeId=*/ BuiltinMetaType&lt;void&gt;::value,\n        /*.metaObjectFn=*/ nullptr,\n        /*.name=*/ &quot;void&quot;,\n        /*.defaultCtr=*/ nullptr,\n        /*.copyCtr=*/ nullptr,\n        /*.moveCtr=*/ nullptr,\n        /*.dtor=*/ nullptr,\n        /*.equals=*/ nullptr,\n        /*.lessThan=*/ nullptr,\n        /*.debugStream=*/ nullptr,\n        /*.dataStreamOut=*/ nullptr,\n        /*.dataStreamIn=*/ nullptr,\n        /*.legacyRegisterOp=*/ nullptr\n    };\n};\n\n/*\n MSVC instantiates extern templates\n(https://developercommunity.visualstudio.com/t/c11-extern-templates-doesnt-work-for-class-templat/157868)\n\n The INTEGRITY compiler apparently does too.\n\n On Windows (with other compilers or whenever MSVC is fixed), we can&#x27;t declare\n QMetaTypeInterfaceWrapper with __declspec(dllimport) because taking its\n address is not a core constant expression.\n */\n#if !defined(QT_BOOTSTRAPPED) &amp;&amp; !defined(Q_CC_MSVC) &amp;&amp; !defined(Q_OS_INTEGRITY)\n\n#ifdef QT_NO_DATA_RELOCATION\n#  define QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER(TypeName, Id, Name)          \\\n    extern template class Q_CORE_EXPORT QMetaTypeForType&lt;Name&gt;;\n#else\n#  define QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER(TypeName, Id, Name)          \\\n    extern template class Q_CORE_EXPORT QMetaTypeForType&lt;Name&gt;;                 \\\n    extern template struct Q_CORE_EXPORT QMetaTypeInterfaceWrapper&lt;Name&gt;;\n#endif\n\nQT_FOR_EACH_STATIC_PRIMITIVE_NON_VOID_TYPE(QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER)\nQT_FOR_EACH_STATIC_PRIMITIVE_POINTER(QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER)\nQT_FOR_EACH_STATIC_CORE_CLASS(QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER)\nQT_FOR_EACH_STATIC_CORE_POINTER(QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER)\nQT_FOR_EACH_STATIC_CORE_TEMPLATE(QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER)\n#undef QT_METATYPE_DECLARE_EXTERN_TEMPLATE_ITER\n#endif\n\ntemplate&lt;typename T&gt;\nstruct QRemovePointerLike\n{\n    using type = std::remove_pointer_t&lt;T&gt;;\n};\n\n#define Q_REMOVE_POINTER_LIKE_IMPL(Pointer) \\\ntemplate &lt;typename T&gt; \\\nstruct QRemovePointerLike&lt;Pointer&lt;T&gt;&gt; \\\n{ \\\n    using type = T; \\\n};\n\nQT_FOR_EACH_AUTOMATIC_TEMPLATE_SMART_POINTER(Q_REMOVE_POINTER_LIKE_IMPL)\n#undef Q_REMOVE_POINTER_LIKE_IMPL\n\ntemplate&lt;typename T&gt;\nconstexpr const QMetaTypeInterface *qMetaTypeInterfaceForType()\n{\n    // don&#x27;t check the type is suitable here\n    using Ty = typename MetatypeDecay&lt;T&gt;::type;\n    return &amp;QMetaTypeInterfaceWrapper&lt;Ty&gt;::metaType;\n}\n\n// Relaxed vesion of the above, used by moc-generated code to create the\n// metatype array without requiring types to be complete and allowing\n// references. Unique is passed to is_complete and must be a different unique\n// type; if it is void, this function is equal to qMetaTypeInterfaceForType()\n// above.\ntemplate&lt;typename Unique, typename T&gt;\nconstexpr const QMetaTypeInterface *qTryMetaTypeInterfaceForType()\n{\n    using Ty = typename MetatypeDecay&lt;T&gt;::type;\n    using Tz = typename QRemovePointerLike&lt;Ty&gt;::type;\n\n    if constexpr (std::is_void_v&lt;Tz&gt;) {\n        // early out to avoid expanding the rest of the templates\n        return &amp;QMetaTypeInterfaceWrapper&lt;Ty&gt;::metaType;\n    } else if constexpr (std::is_void_v&lt;Unique&gt;) {\n        checkTypeIsSuitableForMetaType&lt;Ty&gt;();\n        return &amp;QMetaTypeInterfaceWrapper&lt;Ty&gt;::metaType;\n    } else if constexpr (std::is_reference_v&lt;Tz&gt;) {\n        return nullptr;\n    } else if constexpr (!is_complete&lt;Tz, Unique&gt;::value) {\n        return nullptr;\n    } else {\n        // don&#x27;t check the type is suitable here\n        return &amp;QMetaTypeInterfaceWrapper&lt;Ty&gt;::metaType;\n    }\n}\n\n} // namespace QtPrivate\n\ntemplate&lt;typename T&gt;\nconstexpr QMetaType QMetaType::fromType()\n{\n    QtPrivate::checkTypeIsSuitableForMetaType&lt;T&gt;();\n    return QMetaType(QtPrivate::qMetaTypeInterfaceForType&lt;T&gt;());\n}\n\nconstexpr bool QMetaType::isValid(QT6_IMPL_NEW_OVERLOAD) const noexcept\n{\n    return d_ptr;\n}\n\nbool QMetaType::isRegistered(QT6_IMPL_NEW_OVERLOAD) const noexcept\n{\n    return d_ptr &amp;&amp; d_ptr-&gt;typeId.loadRelaxed();\n}\n\nconstexpr qsizetype QMetaType::sizeOf() const\n{\n    return d_ptr ? d_ptr-&gt;size : 0;\n}\n\nconstexpr qsizetype QMetaType::alignOf() const\n{\n    return d_ptr ? d_ptr-&gt;alignment : 0;\n}\n\nconstexpr QMetaType::TypeFlags QMetaType::flags() const\n{\n    return d_ptr ? TypeFlags(d_ptr-&gt;flags) : TypeFlags{};\n}\n\nconstexpr const QMetaObject *QMetaType::metaObject() const\n{\n    return d_ptr &amp;&amp; d_ptr-&gt;metaObjectFn ? d_ptr-&gt;metaObjectFn(d_ptr) : nullptr;\n}\n\nconstexpr const char *QMetaType::name() const\n{\n    return d_ptr ? d_ptr-&gt;name : nullptr;\n}\n\ninline size_t qHash(QMetaType type, size_t seed = 0)\n{\n    // We cannot use d_ptr here since the same type in different DLLs\n    // might result in different pointers!\n    return qHash(type.id(), seed);\n}\n\nQT_END_NAMESPACE\n\nQT_DECL_METATYPE_EXTERN_TAGGED(QtMetaTypePrivate::QPairVariantInterfaceImpl,\n                               QPairVariantInterfaceImpl, Q_CORE_EXPORT)\n\n#endif // QMETATYPE_H\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "f234abf2997d8ed93f186b59f7b1f69b", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 35, "column": 31, "message": "'canConvert' is deprecated", "events": [{"message": "'canConvert' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "line": 352, "column": 5}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 142, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 27, "column": 25}, {"message": "expanded from macro 'Q_DECL_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1004, "column": 31}, {"message": "'canConvert' is deprecated", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 35, "column": 31}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "a62ea9da502a7b5606133c25c742e539", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 35, "column": 64, "message": "'Type' is deprecated: Use QMetaType::Type instead.", "events": [{"message": "'Type' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "line": 142, "column": 10}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_X_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 141, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED_X'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 29, "column": 33}, {"message": "expanded from macro 'Q_DECL_DEPRECATED_X'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1005, "column": 36}, {"message": "'Type' is deprecated: Use QMetaType::Type instead.", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 35, "column": 64}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "92882cf5430a5336e3c2ff93fb184ec4", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 36, "column": 32, "message": "'convert' is deprecated", "events": [{"message": "'convert' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "line": 355, "column": 5}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 142, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 27, "column": 25}, {"message": "expanded from macro 'Q_DECL_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1004, "column": 31}, {"message": "'convert' is deprecated", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 36, "column": 32}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "f6c851e3f04ef5eb8ed6721128414e0f", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 36, "column": 62, "message": "'Type' is deprecated: Use QMetaType::Type instead.", "events": [{"message": "'Type' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "line": 142, "column": 10}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_X_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 141, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED_X'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 29, "column": 33}, {"message": "expanded from macro 'Q_DECL_DEPRECATED_X'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1005, "column": 36}, {"message": "'Type' is deprecated: Use QMetaType::Type instead.", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 36, "column": 62}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "3d67e8994209449521c3804fe5f80f3e", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 226, "column": 35, "message": "'convert' is deprecated", "events": [{"message": "'convert' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qvariant.h", "line": 355, "column": 5}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 142, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 27, "column": 25}, {"message": "expanded from macro 'Q_DECL_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1004, "column": 31}, {"message": "'convert' is deprecated", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 226, "column": 35}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "reportHash": "7a7c8c839f5fde82e78d9311342526c9", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 233, "column": 42, "message": "'typeName' is deprecated", "events": [{"message": "'typeName' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qmetatype.h", "line": 429, "column": 5}, {"message": "expanded from macro 'QT_DEPRECATED_VERSION_6_0'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 142, "column": 44}, {"message": "expanded from macro 'QT_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qtdeprecationmarkers.h", "line": 27, "column": 25}, {"message": "expanded from macro 'Q_DECL_DEPRECATED'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/qt/6.9.1/_/_/package/4c0d1d9bdb73e0b0172780e7dcf12370fceaa99d/include/QtCore/qcompilerdetection.h", "line": 1004, "column": 31}, {"message": "'typeName' is deprecated", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/utils/common/command_line_parser.cpp", "line": 233, "column": 42}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
