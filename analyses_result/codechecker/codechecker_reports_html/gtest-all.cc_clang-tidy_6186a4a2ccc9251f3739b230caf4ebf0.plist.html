<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-assertion-result.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-assertion-result.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-assertion-result.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This file implements the AssertionResult type.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251                                   \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\nnamespace testing {\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn&#x27;t successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() &lt;&lt; n &lt;&lt; &quot; is even&quot;;\n//     else\n//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         &lt;&lt; &quot;Expected: &quot; &lt;&lt; expr &lt;&lt; &quot; is even\\n  Actual: it&#x27;s &quot; &lt;&lt; n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it&#x27;s 5\n\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult&amp; other);\n\n// C4800 is a level 3 warning in Visual Studio 2015 and earlier.\n// This warning is not emitted in Visual Studio 2017.\n// This warning is off by default starting in Visual Studio 2019 but can be\n// enabled with command-line options.\n#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1910 || _MSC_VER &gt;= 1920)\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n#endif\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult&#x27;s copy constructor to be used.\n  template &lt;typename T&gt;\n  explicit AssertionResult(\n      const T&amp; success,\n      typename std::enable_if&lt;\n          !std::is_convertible&lt;T, AssertionResult&gt;::value&gt;::type*\n      /*enabler*/\n      = nullptr)\n      : success_(success) {}\n\n#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1910 || _MSC_VER &gt;= 1920)\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n  // Assignment operator.\n  AssertionResult&amp; operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true if and only if the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion&#x27;s negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate&#x27;s outcome doesn&#x27;t match the\n  // assertion&#x27;s expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_ != nullptr ? message_-&gt;c_str() : &quot;&quot;;\n  }\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template &lt;typename T&gt;\n  AssertionResult&amp; operator&lt;&lt;(const T&amp; value) {\n    AppendMessage(Message() &lt;&lt; value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult&amp; operator&lt;&lt;(\n      ::std::ostream&amp; (*basic_manipulator)(::std::ostream&amp; stream)) {\n    AppendMessage(Message() &lt;&lt; basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message&amp; a_message) {\n    if (message_ == nullptr) message_ = ::std::make_unique&lt;::std::string&gt;();\n    message_-&gt;append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult&amp; other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate&#x27;s outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  std::unique_ptr&lt; ::std::string&gt; message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() &lt;&lt; msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message&amp; msg);\n\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_ASSERTION_RESULT_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-death-test.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-death-test.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-death-test.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines the public API for death tests.  It is\n// #included by gtest.h so a user doesn&#x27;t need to include this\n// directly.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n\n#include &quot;gtest/internal/gtest-death-test-internal.h&quot;\n\n// This flag controls the style of death tests.  Valid values are &quot;threadsafe&quot;,\n// meaning that the death test child process will re-execute the test binary\n// from the start, running only a single death test, or &quot;fast&quot;,\n// meaning that the child process will execute the test logic immediately\n// after forking.\nGTEST_DECLARE_string_(death_test_style);\n\nnamespace testing {\n\n#ifdef GTEST_HAS_DEATH_TEST\n\nnamespace internal {\n\n// Returns a Boolean value indicating whether the caller is currently\n// executing in the context of the death test child process.  Tools such as\n// Valgrind heap checkers may need this to modify their behavior in death\n// tests.  IMPORTANT: This is an internal utility.  Using it may break the\n// implementation of death tests.  User code MUST NOT use it.\nGTEST_API_ bool InDeathTestChild();\n\n}  // namespace internal\n\n// The following macros are useful for writing death tests.\n\n// Here&#x27;s what happens when an ASSERT_DEATH* or EXPECT_DEATH* is\n// executed:\n//\n//   1. It generates a warning if there is more than one active\n//   thread.  This is because it&#x27;s safe to fork() or clone() only\n//   when there is a single thread.\n//\n//   2. The parent process clone()s a sub-process and runs the death\n//   test in it; the sub-process exits with code 0 at the end of the\n//   death test, if it hasn&#x27;t exited already.\n//\n//   3. The parent process waits for the sub-process to terminate.\n//\n//   4. The parent process checks the exit code and error message of\n//   the sub-process.\n//\n// Examples:\n//\n//   ASSERT_DEATH(server.SendMessage(56, &quot;Hello&quot;), &quot;Invalid port number&quot;);\n//   for (int i = 0; i &lt; 5; i++) {\n//     EXPECT_DEATH(server.ProcessRequest(i),\n//                  &quot;Invalid request .* in ProcessRequest()&quot;)\n//                  &lt;&lt; &quot;Failed to die on request &quot; &lt;&lt; i;\n//   }\n//\n//   ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), &quot;Exiting&quot;);\n//\n//   bool KilledBySIGHUP(int exit_code) {\n//     return WIFSIGNALED(exit_code) &amp;&amp; WTERMSIG(exit_code) == SIGHUP;\n//   }\n//\n//   ASSERT_EXIT(client.HangUpServer(), KilledBySIGHUP, &quot;Hanging up!&quot;);\n//\n// The final parameter to each of these macros is a matcher applied to any data\n// the sub-process wrote to stderr.  For compatibility with existing tests, a\n// bare string is interpreted as a regular expression matcher.\n//\n// On the regular expressions used in death tests:\n//\n//   On POSIX-compliant systems (*nix), we use the &lt;regex.h&gt; library,\n//   which uses the POSIX extended regex syntax.\n//\n//   On other platforms (e.g. Windows or Mac), we only support a simple regex\n//   syntax implemented as part of Google Test.  This limited\n//   implementation should be enough most of the time when writing\n//   death tests; though it lacks many features you can find in PCRE\n//   or POSIX extended regex syntax.  For example, we don&#x27;t support\n//   union (&quot;x|y&quot;), grouping (&quot;(xy)&quot;), brackets (&quot;[xy]&quot;), and\n//   repetition count (&quot;x{5,7}&quot;), among others.\n//\n//   Below is the syntax that we do support.  We chose it to be a\n//   subset of both PCRE and POSIX extended regex, so it&#x27;s easy to\n//   learn wherever you come from.  In the following: &#x27;A&#x27; denotes a\n//   literal character, period (.), or a single \\\\ escape sequence;\n//   &#x27;x&#x27; and &#x27;y&#x27; denote regular expressions; &#x27;m&#x27; and &#x27;n&#x27; are for\n//   natural numbers.\n//\n//     c     matches any literal character c\n//     \\\\d   matches any decimal digit\n//     \\\\D   matches any character that&#x27;s not a decimal digit\n//     \\\\f   matches \\f\n//     \\\\n   matches \\n\n//     \\\\r   matches \\r\n//     \\\\s   matches any ASCII whitespace, including \\n\n//     \\\\S   matches any character that&#x27;s not a whitespace\n//     \\\\t   matches \\t\n//     \\\\v   matches \\v\n//     \\\\w   matches any letter, _, or decimal digit\n//     \\\\W   matches any character that \\\\w doesn&#x27;t match\n//     \\\\c   matches any literal character c, which must be a punctuation\n//     .     matches any single character except \\n\n//     A?    matches 0 or 1 occurrences of A\n//     A*    matches 0 or many occurrences of A\n//     A+    matches 1 or many occurrences of A\n//     ^     matches the beginning of a string (not that of each line)\n//     $     matches the end of a string (not that of each line)\n//     xy    matches x followed by y\n//\n//   If you accidentally use PCRE or POSIX extended regex features\n//   not implemented by us, you will get a run-time failure.  In that\n//   case, please try to rewrite your regular expression within the\n//   above syntax.\n//\n//   This implementation is *not* meant to be as highly tuned or robust\n//   as a compiled regex library, but should perform well enough for a\n//   death test, which already incurs significant overhead by launching\n//   a child process.\n//\n// Known caveats:\n//\n//   A &quot;threadsafe&quot; style death test obtains the path to the test\n//   program from argv[0] and re-executes it in the sub-process.  For\n//   simplicity, the current implementation doesn&#x27;t search the PATH\n//   when launching the sub-process.  This means that the user must\n//   invoke the test program via a path that contains at least one\n//   path separator (e.g. path/to/foo_test and\n//   /absolute/path/to/bar_test are fine, but foo_test is not).  This\n//   is rarely a problem as people usually don&#x27;t put the test binary\n//   directory in PATH.\n//\n\n// Asserts that a given `statement` causes the program to exit, with an\n// integer exit status that satisfies `predicate`, and emitting error output\n// that matches `matcher`.\n#define ASSERT_EXIT(statement, predicate, matcher) \\\n  GTEST_DEATH_TEST_(statement, predicate, matcher, GTEST_FATAL_FAILURE_)\n\n// Like `ASSERT_EXIT`, but continues on to successive tests in the\n// test suite, if any:\n#define EXPECT_EXIT(statement, predicate, matcher) \\\n  GTEST_DEATH_TEST_(statement, predicate, matcher, GTEST_NONFATAL_FAILURE_)\n\n// Asserts that a given `statement` causes the program to exit, either by\n// explicitly exiting with a nonzero exit code or being killed by a\n// signal, and emitting error output that matches `matcher`.\n#define ASSERT_DEATH(statement, matcher) \\\n  ASSERT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, matcher)\n\n// Like `ASSERT_DEATH`, but continues on to successive tests in the\n// test suite, if any:\n#define EXPECT_DEATH(statement, matcher) \\\n  EXPECT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, matcher)\n\n// Two predicate classes that can be used in {ASSERT,EXPECT}_EXIT*:\n\n// Tests that an exit code describes a normal exit with a given exit code.\nclass GTEST_API_ ExitedWithCode {\n public:\n  explicit ExitedWithCode(int exit_code);\n  ExitedWithCode(const ExitedWithCode&amp;) = default;\n  void operator=(const ExitedWithCode&amp; other) = delete;\n  bool operator()(int exit_status) const;\n\n private:\n  const int exit_code_;\n};\n\n#if !defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_FUCHSIA)\n// Tests that an exit code describes an exit due to termination by a\n// given signal.\nclass GTEST_API_ KilledBySignal {\n public:\n  explicit KilledBySignal(int signum);\n  bool operator()(int exit_status) const;\n\n private:\n  const int signum_;\n};\n#endif  // !GTEST_OS_WINDOWS\n\n// EXPECT_DEBUG_DEATH asserts that the given statements die in debug mode.\n// The death testing framework causes this to have interesting semantics,\n// since the sideeffects of the call are only visible in opt mode, and not\n// in debug mode.\n//\n// In practice, this can be used to test functions that utilize the\n// LOG(DFATAL) macro using the following style:\n//\n// int DieInDebugOr12(int* sideeffect) {\n//   if (sideeffect) {\n//     *sideeffect = 12;\n//   }\n//   LOG(DFATAL) &lt;&lt; &quot;death&quot;;\n//   return 12;\n// }\n//\n// TEST(TestSuite, TestDieOr12WorksInDgbAndOpt) {\n//   int sideeffect = 0;\n//   // Only asserts in dbg.\n//   EXPECT_DEBUG_DEATH(DieInDebugOr12(&amp;sideeffect), &quot;death&quot;);\n//\n// #ifdef NDEBUG\n//   // opt-mode has sideeffect visible.\n//   EXPECT_EQ(12, sideeffect);\n// #else\n//   // dbg-mode no visible sideeffect.\n//   EXPECT_EQ(0, sideeffect);\n// #endif\n// }\n//\n// This will assert that DieInDebugReturn12InOpt() crashes in debug\n// mode, usually due to a DCHECK or LOG(DFATAL), but returns the\n// appropriate fallback value (12 in this case) in opt mode. If you\n// need to test that a function has appropriate side-effects in opt\n// mode, include assertions against the side-effects.  A general\n// pattern for this is:\n//\n// EXPECT_DEBUG_DEATH({\n//   // Side-effects here will have an effect after this statement in\n//   // opt mode, but none in debug mode.\n//   EXPECT_EQ(12, DieInDebugOr12(&amp;sideeffect));\n// }, &quot;death&quot;);\n//\n#ifdef NDEBUG\n\n#define EXPECT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n#define ASSERT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n#else\n\n#define EXPECT_DEBUG_DEATH(statement, regex) EXPECT_DEATH(statement, regex)\n\n#define ASSERT_DEBUG_DEATH(statement, regex) ASSERT_DEATH(statement, regex)\n\n#endif  // NDEBUG for EXPECT_DEBUG_DEATH\n#endif  // GTEST_HAS_DEATH_TEST\n\n// This macro is used for implementing macros such as\n// EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where\n// death tests are not supported. Those macros must compile on such systems\n// if and only if EXPECT_DEATH and ASSERT_DEATH compile with the same parameters\n// on systems that support death tests. This allows one to write such a macro on\n// a system that does not support death tests and be sure that it will compile\n// on a death-test supporting system. It is exposed publicly so that systems\n// that have death-tests with stricter requirements than GTEST_HAS_DEATH_TEST\n// can write their own equivalent of EXPECT_DEATH_IF_SUPPORTED and\n// ASSERT_DEATH_IF_SUPPORTED.\n//\n// Parameters:\n//   statement -  A statement that a macro such as EXPECT_DEATH would test\n//                for program termination. This macro has to make sure this\n//                statement is compiled but not executed, to ensure that\n//                EXPECT_DEATH_IF_SUPPORTED compiles with a certain\n//                parameter if and only if EXPECT_DEATH compiles with it.\n//   regex_or_matcher -  A regex that a macro such as EXPECT_DEATH would use\n//                to test the output of statement.  This parameter has to be\n//                compiled but not evaluated by this macro, to ensure that\n//                this macro only accepts expressions that a macro such as\n//                EXPECT_DEATH would accept.\n//   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED\n//                and a return statement for ASSERT_DEATH_IF_SUPPORTED.\n//                This ensures that ASSERT_DEATH_IF_SUPPORTED will not\n//                compile inside functions where ASSERT_DEATH doesn&#x27;t\n//                compile.\n//\n//  The branch that has an always false condition is used to ensure that\n//  statement and regex are compiled (and thus syntactically correct) but\n//  never executed. The unreachable code macro protects the terminator\n//  statement from generating an &#x27;unreachable code&#x27; warning in case\n//  statement unconditionally returns or throws. The Message constructor at\n//  the end allows the syntax of streaming additional messages into the\n//  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.\n#define GTEST_UNSUPPORTED_DEATH_TEST(statement, regex_or_matcher, terminator)  \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                                \\\n  if (::testing::internal::AlwaysTrue()) {                                     \\\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;Death tests are not supported on this platform.\\n&quot; \\\n                        &lt;&lt; &quot;Statement &#x27;&quot; #statement &quot;&#x27; cannot be verified.&quot;;   \\\n  } else if (::testing::internal::AlwaysFalse()) {                             \\\n    ::testing::internal::MakeDeathTestMatcher(regex_or_matcher);               \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);                 \\\n    terminator;                                                                \\\n  } else                                                                       \\\n    ::testing::Message()\n\n// EXPECT_DEATH_IF_SUPPORTED(statement, regex) and\n// ASSERT_DEATH_IF_SUPPORTED(statement, regex) expand to real death tests if\n// death tests are supported; otherwise they just issue a warning.  This is\n// useful when you are combining death test assertions with normal test\n// assertions in one test.\n#ifdef GTEST_HAS_DEATH_TEST\n#define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n  EXPECT_DEATH(statement, regex)\n#define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n  ASSERT_DEATH(statement, regex)\n#else\n#define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n  GTEST_UNSUPPORTED_DEATH_TEST(statement, regex, )\n#define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n  GTEST_UNSUPPORTED_DEATH_TEST(statement, regex, return)\n#endif\n\n}  // namespace testing\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This file implements just enough of the matcher interface to allow\n// EXPECT_DEATH and friends to accept a matcher argument.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n\n#include &lt;atomic&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include &quot;gtest/gtest-printers.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n// MSVC warning C5046 is new as of VS2017 version 15.8.\n#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1915\n#define GTEST_MAYBE_5046_ 5046\n#else\n#define GTEST_MAYBE_5046_\n#endif\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(\n    4251 GTEST_MAYBE_5046_ /* class A needs to have dll-interface to be used by\n                              clients of class B */\n    /* Symbol involving type with internal linkage not defined */)\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherMatcher that implements the matcher interface:\n//     using is_gtest_matcher = void;\n//     bool MatchAndExplain(const T&amp;, std::ostream*);\n//       (MatchResultListener* can also be used instead of std::ostream*)\n//     void DescribeTo(std::ostream*);\n//     void DescribeNegationTo(std::ostream*);\n//\n//   2. a factory function that creates a Matcher&lt;T&gt; object from a\n//      FooMatcherMatcher.\n\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template &lt;typename T&gt;\n  MatchResultListener&amp; operator&lt;&lt;(const T&amp; x) {\n    if (stream_ != nullptr) *stream_ &lt;&lt; x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true if and only if the listener is interested in an explanation\n  // of the match result.  A matcher&#x27;s MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != nullptr; }\n\n private:\n  ::std::ostream* const stream_;\n\n  MatchResultListener(const MatchResultListener&amp;) = delete;\n  MatchResultListener&amp; operator=(const MatchResultListener&amp;) = delete;\n};\n\ninline MatchResultListener::~MatchResultListener() = default;\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass GTEST_API_ MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() = default;\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints &quot;is greater than 7&quot;.\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is &quot;is greater than\n  // 7&quot;, the negated description could be &quot;is not greater than 7&quot;.\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;not (&quot;;\n    DescribeTo(os);\n    *os &lt;&lt; &quot;)&quot;;\n  }\n};\n\n// The implementation of a matcher.\ntemplate &lt;typename T&gt;\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true if and only if the matcher matches x; also explains the\n  // match result to &#x27;listener&#x27; if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (&quot;which ...&quot;,\n  // &quot;whose ...&quot;, etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like &quot;which points to ...&quot;.\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that&#x27;s not already present (or not obvious) in the\n  // print-out of x and the matcher&#x27;s description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a &quot;has at least 10 elements&quot; matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // &quot;is empty&quot; matcher probably only needs to explain what the actual\n  // size is when the match fails, as it&#x27;s redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It&#x27;s the responsibility of the caller (Google Test) to guarantee\n  // that &#x27;listener&#x27; is not NULL.  This helps to simplify a matcher&#x27;s\n  // implementation when it doesn&#x27;t care about the performance, as it\n  // can talk to &#x27;listener&#x27; without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener-&gt;stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\nnamespace internal {\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(nullptr) {}\n\n private:\n  DummyMatchResultListener(const DummyMatchResultListener&amp;) = delete;\n  DummyMatchResultListener&amp; operator=(const DummyMatchResultListener&amp;) = delete;\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  StreamMatchResultListener(const StreamMatchResultListener&amp;) = delete;\n  StreamMatchResultListener&amp; operator=(const StreamMatchResultListener&amp;) =\n      delete;\n};\n\nstruct SharedPayloadBase {\n  std::atomic&lt;int&gt; ref{1};\n  void Ref() { ref.fetch_add(1, std::memory_order_relaxed); }\n  bool Unref() { return ref.fetch_sub(1, std::memory_order_acq_rel) == 1; }\n};\n\ntemplate &lt;typename T&gt;\nstruct SharedPayload : SharedPayloadBase {\n  explicit SharedPayload(const T&amp; v) : value(v) {}\n  explicit SharedPayload(T&amp;&amp; v) : value(std::move(v)) {}\n\n  static void Destroy(SharedPayloadBase* shared) {\n    delete static_cast&lt;SharedPayload*&gt;(shared);\n  }\n\n  T value;\n};\n\n// An internal class for implementing Matcher&lt;T&gt;, which will derive\n// from it.  We put functionalities common to all Matcher&lt;T&gt;\n// specializations here to avoid code duplication.\ntemplate &lt;typename T&gt;\nclass MatcherBase : private MatcherDescriberInterface {\n public:\n  // Returns true if and only if the matcher matches x; also explains the\n  // match result to &#x27;listener&#x27;.\n  bool MatchAndExplain(const T&amp; x, MatchResultListener* listener) const {\n    GTEST_CHECK_(vtable_ != nullptr);\n    return vtable_-&gt;match_and_explain(*this, x, listener);\n  }\n\n  // Returns true if and only if this matcher matches x.\n  bool Matches(const T&amp; x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &amp;dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const final {\n    GTEST_CHECK_(vtable_ != nullptr);\n    vtable_-&gt;describe(*this, os, false);\n  }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const final {\n    GTEST_CHECK_(vtable_ != nullptr);\n    vtable_-&gt;describe(*this, os, true);\n  }\n\n  // Explains why x matches, or doesn&#x27;t match, the matcher.\n  void ExplainMatchResultTo(const T&amp; x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &amp;listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    if (vtable_ == nullptr) return nullptr;\n    return vtable_-&gt;get_describer(*this);\n  }\n\n protected:\n  MatcherBase() : vtable_(nullptr), buffer_() {}\n\n  // Constructs a matcher from its implementation.\n  template &lt;typename U&gt;\n  explicit MatcherBase(const MatcherInterface&lt;U&gt;* impl)\n      : vtable_(nullptr), buffer_() {\n    Init(impl);\n  }\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  MatcherBase(M&amp;&amp; m) : vtable_(nullptr), buffer_() {  // NOLINT\n    Init(std::forward&lt;M&gt;(m));\n  }\n\n  MatcherBase(const MatcherBase&amp; other)\n      : vtable_(other.vtable_), buffer_(other.buffer_) {\n    if (IsShared()) buffer_.shared-&gt;Ref();\n  }\n\n  MatcherBase&amp; operator=(const MatcherBase&amp; other) {\n    if (this == &amp;other) return *this;\n    Destroy();\n    vtable_ = other.vtable_;\n    buffer_ = other.buffer_;\n    if (IsShared()) buffer_.shared-&gt;Ref();\n    return *this;\n  }\n\n  MatcherBase(MatcherBase&amp;&amp; other) noexcept\n      : vtable_(other.vtable_), buffer_(other.buffer_) {\n    other.vtable_ = nullptr;\n  }\n\n  MatcherBase&amp; operator=(MatcherBase&amp;&amp; other) {\n    if (this == &amp;other) return *this;\n    Destroy();\n    vtable_ = other.vtable_;\n    buffer_ = other.buffer_;\n    other.vtable_ = nullptr;\n    return *this;\n  }\n\n  ~MatcherBase() override { Destroy(); }\n\n private:\n  struct VTable {\n    bool (*match_and_explain)(const MatcherBase&amp;, const T&amp;,\n                              MatchResultListener*);\n    void (*describe)(const MatcherBase&amp;, std::ostream*, bool negation);\n    // Returns the captured object if it implements the interface, otherwise\n    // returns the MatcherBase itself.\n    const MatcherDescriberInterface* (*get_describer)(const MatcherBase&amp;);\n    // Called on shared instances when the reference count reaches 0.\n    void (*shared_destroy)(SharedPayloadBase*);\n  };\n\n  bool IsShared() const {\n    return vtable_ != nullptr &amp;&amp; vtable_-&gt;shared_destroy != nullptr;\n  }\n\n  // If the implementation uses a listener, call that.\n  template &lt;typename P&gt;\n  static auto MatchAndExplainImpl(const MatcherBase&amp; m, const T&amp; value,\n                                  MatchResultListener* listener)\n      -&gt; decltype(P::Get(m).MatchAndExplain(value, listener-&gt;stream())) {\n    return P::Get(m).MatchAndExplain(value, listener-&gt;stream());\n  }\n\n  template &lt;typename P&gt;\n  static auto MatchAndExplainImpl(const MatcherBase&amp; m, const T&amp; value,\n                                  MatchResultListener* listener)\n      -&gt; decltype(P::Get(m).MatchAndExplain(value, listener)) {\n    return P::Get(m).MatchAndExplain(value, listener);\n  }\n\n  template &lt;typename P&gt;\n  static void DescribeImpl(const MatcherBase&amp; m, std::ostream* os,\n                           bool negation) {\n    if (negation) {\n      P::Get(m).DescribeNegationTo(os);\n    } else {\n      P::Get(m).DescribeTo(os);\n    }\n  }\n\n  template &lt;typename P&gt;\n  static const MatcherDescriberInterface* GetDescriberImpl(\n      const MatcherBase&amp; m) {\n    // If the impl is a MatcherDescriberInterface, then return it.\n    // Otherwise use MatcherBase itself.\n    // This allows us to implement the GetDescriber() function without support\n    // from the impl, but some users really want to get their impl back when\n    // they call GetDescriber().\n    // We use std::get on a tuple as a workaround of not having `if constexpr`.\n    return std::get&lt;(\n        std::is_convertible&lt;decltype(&amp;P::Get(m)),\n                            const MatcherDescriberInterface*&gt;::value\n            ? 1\n            : 0)&gt;(std::make_tuple(&amp;m, &amp;P::Get(m)));\n  }\n\n  template &lt;typename P&gt;\n  const VTable* GetVTable() {\n    static constexpr VTable kVTable = {&amp;MatchAndExplainImpl&lt;P&gt;,\n                                       &amp;DescribeImpl&lt;P&gt;, &amp;GetDescriberImpl&lt;P&gt;,\n                                       P::shared_destroy};\n    return &amp;kVTable;\n  }\n\n  union Buffer {\n    // Add some types to give Buffer some common alignment/size use cases.\n    void* ptr;\n    double d;\n    int64_t i;\n    // And add one for the out-of-line cases.\n    SharedPayloadBase* shared;\n  };\n\n  void Destroy() {\n    if (IsShared() &amp;&amp; buffer_.shared-&gt;Unref()) {\n      vtable_-&gt;shared_destroy(buffer_.shared);\n    }\n  }\n\n  template &lt;typename M&gt;\n  static constexpr bool IsInlined() {\n    return sizeof(M) &lt;= sizeof(Buffer) &amp;&amp; alignof(M) &lt;= alignof(Buffer) &amp;&amp;\n           std::is_trivially_copy_constructible&lt;M&gt;::value &amp;&amp;\n           std::is_trivially_destructible&lt;M&gt;::value;\n  }\n\n  template &lt;typename M, bool = MatcherBase::IsInlined&lt;M&gt;()&gt;\n  struct ValuePolicy {\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      // When inlined along with Init, need to be explicit to avoid violating\n      // strict aliasing rules.\n      const M* ptr =\n          static_cast&lt;const M*&gt;(static_cast&lt;const void*&gt;(&amp;m.buffer_));\n      return *ptr;\n    }\n    static void Init(MatcherBase&amp; m, M impl) {\n      ::new (static_cast&lt;void*&gt;(&amp;m.buffer_)) M(impl);\n    }\n    static constexpr auto shared_destroy = nullptr;\n  };\n\n  template &lt;typename M&gt;\n  struct ValuePolicy&lt;M, false&gt; {\n    using Shared = SharedPayload&lt;M&gt;;\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      return static_cast&lt;Shared*&gt;(m.buffer_.shared)-&gt;value;\n    }\n    template &lt;typename Arg&gt;\n    static void Init(MatcherBase&amp; m, Arg&amp;&amp; arg) {\n      m.buffer_.shared = new Shared(std::forward&lt;Arg&gt;(arg));\n    }\n    static constexpr auto shared_destroy = &amp;Shared::Destroy;\n  };\n\n  template &lt;typename U, bool B&gt;\n  struct ValuePolicy&lt;const MatcherInterface&lt;U&gt;*, B&gt; {\n    using M = const MatcherInterface&lt;U&gt;;\n    using Shared = SharedPayload&lt;std::unique_ptr&lt;M&gt;&gt;;\n    static const M&amp; Get(const MatcherBase&amp; m) {\n      return *static_cast&lt;Shared*&gt;(m.buffer_.shared)-&gt;value;\n    }\n    static void Init(MatcherBase&amp; m, M* impl) {\n      m.buffer_.shared = new Shared(std::unique_ptr&lt;M&gt;(impl));\n    }\n\n    static constexpr auto shared_destroy = &amp;Shared::Destroy;\n  };\n\n  template &lt;typename M&gt;\n  void Init(M&amp;&amp; m) {\n    using MM = typename std::decay&lt;M&gt;::type;\n    using Policy = ValuePolicy&lt;MM&gt;;\n    vtable_ = GetVTable&lt;Policy&gt;();\n    Policy::Init(*this, std::forward&lt;M&gt;(m));\n  }\n\n  const VTable* vtable_;\n  Buffer buffer_;\n};\n\n}  // namespace internal\n\n// A Matcher&lt;T&gt; is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher&lt;T&gt; is just a std::shared_ptr to const\n// MatcherInterface&lt;T&gt;.  Don&#x27;t inherit from Matcher!\ntemplate &lt;typename T&gt;\nclass Matcher : public internal::MatcherBase&lt;T&gt; {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface&lt;const T&amp;&gt;* impl)\n      : internal::MatcherBase&lt;T&gt;(impl) {}\n\n  template &lt;typename U&gt;\n  explicit Matcher(\n      const MatcherInterface&lt;U&gt;* impl,\n      typename std::enable_if&lt;!std::is_same&lt;U, const U&amp;&gt;::value&gt;::type* =\n          nullptr)\n      : internal::MatcherBase&lt;T&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m) : internal::MatcherBase&lt;T&gt;(std::forward&lt;M&gt;(m)) {}  // NOLINT\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a std::string\n// matcher is expected.\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;const std::string&amp;&gt;\n    : public internal::MatcherBase&lt;const std::string&amp;&gt; {\n public:\n  Matcher() = default;\n\n  explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)\n      : internal::MatcherBase&lt;const std::string&amp;&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;const std::string&amp;&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;std::string&gt;\n    : public internal::MatcherBase&lt;std::string&gt; {\n public:\n  Matcher() = default;\n\n  explicit Matcher(const MatcherInterface&lt;const std::string&amp;&gt;* impl)\n      : internal::MatcherBase&lt;std::string&gt;(impl) {}\n  explicit Matcher(const MatcherInterface&lt;std::string&gt;* impl)\n      : internal::MatcherBase&lt;std::string&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;std::string&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n// The following two specializations allow the user to write str\n// instead of Eq(str) and &quot;foo&quot; instead of Eq(&quot;foo&quot;) when a absl::string_view\n// matcher is expected.\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;const internal::StringView&amp;&gt;\n    : public internal::MatcherBase&lt;const internal::StringView&amp;&gt; {\n public:\n  Matcher() = default;\n\n  explicit Matcher(const MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)\n      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;const internal::StringView&amp;&gt;(std::forward&lt;M&gt;(m)) {\n  }\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass absl::string_views or std::string_views directly.\n  Matcher(internal::StringView s);  // NOLINT\n};\n\ntemplate &lt;&gt;\nclass GTEST_API_ Matcher&lt;internal::StringView&gt;\n    : public internal::MatcherBase&lt;internal::StringView&gt; {\n public:\n  Matcher() = default;\n\n  explicit Matcher(const MatcherInterface&lt;const internal::StringView&amp;&gt;* impl)\n      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}\n  explicit Matcher(const MatcherInterface&lt;internal::StringView&gt;* impl)\n      : internal::MatcherBase&lt;internal::StringView&gt;(impl) {}\n\n  template &lt;typename M, typename = typename std::remove_reference&lt;\n                            M&gt;::type::is_gtest_matcher&gt;\n  Matcher(M&amp;&amp; m)  // NOLINT\n      : internal::MatcherBase&lt;internal::StringView&gt;(std::forward&lt;M&gt;(m)) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a std::string object.\n  Matcher(const std::string&amp; s);  // NOLINT\n\n  // Allows the user to write &quot;foo&quot; instead of Eq(&quot;foo&quot;) sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass absl::string_views or std::string_views directly.\n  Matcher(internal::StringView s);  // NOLINT\n};\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n// Prints a matcher in a human-readable format.\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matcher&lt;T&gt;&amp; matcher) {\n  matcher.DescribeTo(&amp;os);\n  return os;\n}\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value&amp; value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate &lt;class Impl&gt;\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl&amp; an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl&amp; mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl&amp; impl() const { return impl_; }\n\n  template &lt;typename T&gt;\n  operator Matcher&lt;T&gt;() const {\n    return Matcher&lt;T&gt;(new MonomorphicImpl&lt;const T&amp;&gt;(impl_));\n  }\n\n private:\n  template &lt;typename T&gt;\n  class MonomorphicImpl : public MatcherInterface&lt;T&gt; {\n   public:\n    explicit MonomorphicImpl(const Impl&amp; impl) : impl_(impl) {}\n\n    void DescribeTo(::std::ostream* os) const override { impl_.DescribeTo(os); }\n\n    void DescribeNegationTo(::std::ostream* os) const override {\n      impl_.DescribeNegationTo(os);\n    }\n\n    bool MatchAndExplain(T x, MatchResultListener* listener) const override {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n  };\n\n  Impl impl_;\n};\n\n// Creates a matcher from its implementation.\n// DEPRECATED: Especially in the generic code, prefer:\n//   Matcher&lt;T&gt;(new MyMatcherImpl&lt;const T&amp;&gt;(...));\n//\n// MakeMatcher may create a Matcher that accepts its argument by value, which\n// leads to unnecessary copies &amp; lack of support for non-copyable types.\ntemplate &lt;typename T&gt;\ninline Matcher&lt;T&gt; MakeMatcher(const MatcherInterface&lt;T&gt;* impl) {\n  return Matcher&lt;T&gt;(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher&lt;Impl&gt; constructor as it\n// doesn&#x27;t require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher&lt;TypeOfFoo&gt;(foo);\ntemplate &lt;class Impl&gt;\ninline PolymorphicMatcher&lt;Impl&gt; MakePolymorphicMatcher(const Impl&amp; impl) {\n  return PolymorphicMatcher&lt;Impl&gt;(impl);\n}\n\nnamespace internal {\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, &lt;=, &lt;, etc, operators.  The\n// two values being compared don&#x27;t have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a &quot;bare&quot; type (i.e. neither &#x27;const T&#x27; nor &#x27;T&amp;&#x27;).\ntemplate &lt;typename D, typename Rhs, typename Op&gt;\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs&amp; rhs) : rhs_(rhs) {}\n\n  using is_gtest_matcher = void;\n\n  template &lt;typename Lhs&gt;\n  bool MatchAndExplain(const Lhs&amp; lhs, std::ostream*) const {\n    return Op()(lhs, Unwrap(rhs_));\n  }\n  void DescribeTo(std::ostream* os) const {\n    *os &lt;&lt; D::Desc() &lt;&lt; &quot; &quot;;\n    UniversalPrint(Unwrap(rhs_), os);\n  }\n  void DescribeNegationTo(std::ostream* os) const {\n    *os &lt;&lt; D::NegatedDesc() &lt;&lt; &quot; &quot;;\n    UniversalPrint(Unwrap(rhs_), os);\n  }\n\n private:\n  template &lt;typename T&gt;\n  static const T&amp; Unwrap(const T&amp; v) {\n    return v;\n  }\n  template &lt;typename T&gt;\n  static const T&amp; Unwrap(std::reference_wrapper&lt;T&gt; v) {\n    return v;\n  }\n\n  Rhs rhs_;\n};\n\ntemplate &lt;typename Rhs&gt;\nclass EqMatcher : public ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, std::equal_to&lt;&gt;&gt; {\n public:\n  explicit EqMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;EqMatcher&lt;Rhs&gt;, Rhs, std::equal_to&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;is equal to&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t equal to&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass NeMatcher\n    : public ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, std::not_equal_to&lt;&gt;&gt; {\n public:\n  explicit NeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;NeMatcher&lt;Rhs&gt;, Rhs, std::not_equal_to&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;isn&#x27;t equal to&quot;; }\n  static const char* NegatedDesc() { return &quot;is equal to&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass LtMatcher : public ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, std::less&lt;&gt;&gt; {\n public:\n  explicit LtMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;LtMatcher&lt;Rhs&gt;, Rhs, std::less&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &lt;&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &lt;&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass GtMatcher : public ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, std::greater&lt;&gt;&gt; {\n public:\n  explicit GtMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;GtMatcher&lt;Rhs&gt;, Rhs, std::greater&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &gt;&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &gt;&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass LeMatcher\n    : public ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, std::less_equal&lt;&gt;&gt; {\n public:\n  explicit LeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;LeMatcher&lt;Rhs&gt;, Rhs, std::less_equal&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &lt;=&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &lt;=&quot;; }\n};\ntemplate &lt;typename Rhs&gt;\nclass GeMatcher\n    : public ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, std::greater_equal&lt;&gt;&gt; {\n public:\n  explicit GeMatcher(const Rhs&amp; rhs)\n      : ComparisonBase&lt;GeMatcher&lt;Rhs&gt;, Rhs, std::greater_equal&lt;&gt;&gt;(rhs) {}\n  static const char* Desc() { return &quot;is &gt;=&quot;; }\n  static const char* NegatedDesc() { return &quot;isn&#x27;t &gt;=&quot;; }\n};\n\ntemplate &lt;typename T, typename = typename std::enable_if&lt;\n                          std::is_constructible&lt;std::string, T&gt;::value&gt;::type&gt;\nusing StringLike = T;\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher&lt;T&gt; as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  bool MatchAndExplain(const internal::StringView&amp; s,\n                       MatchResultListener* listener) const {\n    return MatchAndExplain(std::string(s), listener);\n  }\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template &lt;typename CharType&gt;\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != nullptr &amp;&amp; MatchAndExplain(std::string(s), listener);\n  }\n\n  // Matches anything that can convert to std::string.\n  //\n  // This is a template, not just a plain function with const std::string&amp;,\n  // because absl::string_view has some interfering non-explicit constructors.\n  template &lt;class MatcheeStringType&gt;\n  bool MatchAndExplain(const MatcheeStringType&amp; s,\n                       MatchResultListener* /* listener */) const {\n    const std::string s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_)\n                       : RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os &lt;&lt; (full_match_ ? &quot;matches&quot; : &quot;contains&quot;) &lt;&lt; &quot; regular expression &quot;;\n    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os &lt;&lt; &quot;doesn&#x27;t &quot; &lt;&lt; (full_match_ ? &quot;match&quot; : &quot;contain&quot;)\n        &lt;&lt; &quot; regular expression &quot;;\n    UniversalPrinter&lt;std::string&gt;::Print(regex_-&gt;pattern(), os);\n  }\n\n private:\n  const std::shared_ptr&lt;const RE&gt; regex_;\n  const bool full_match_;\n};\n}  // namespace internal\n\n// Matches a string that fully matches regular expression &#x27;regex&#x27;.\n// The matcher takes ownership of &#x27;regex&#x27;.\ninline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; MatchesRegex(\n    const internal::StringLike&lt;T&gt;&amp; regex) {\n  return MatchesRegex(new internal::RE(std::string(regex)));\n}\n\n// Matches a string that contains regular expression &#x27;regex&#x27;.\n// The matcher takes ownership of &#x27;regex&#x27;.\ninline PolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ntemplate &lt;typename T = std::string&gt;\nPolymorphicMatcher&lt;internal::MatchesRegexMatcher&gt; ContainsRegex(\n    const internal::StringLike&lt;T&gt;&amp; regex) {\n  return ContainsRegex(new internal::RE(std::string(regex)));\n}\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&amp;, Eq(&quot;foo&quot;)\n// wouldn&#x27;t compile.\ntemplate &lt;typename T&gt;\ninline internal::EqMatcher&lt;T&gt; Eq(T x) {\n  return internal::EqMatcher&lt;T&gt;(x);\n}\n\n// Constructs a Matcher&lt;T&gt; from a &#x27;value&#x27; of type T.  The constructed\n// matcher matches any value that&#x27;s equal to &#x27;value&#x27;.\ntemplate &lt;typename T&gt;\nMatcher&lt;T&gt;::Matcher(T value) {\n  *this = Eq(value);\n}\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq&lt;T&gt;(x) is just a convenient short-hand for Matcher&lt;T&gt;(Eq(x))\n// or Matcher&lt;T&gt;(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher&lt;T&gt;(Lt(5)) to be explicit about the type,\n// for example.\ntemplate &lt;typename Lhs, typename Rhs&gt;\ninline Matcher&lt;Lhs&gt; TypedEq(const Rhs&amp; rhs) {\n  return Eq(rhs);\n}\n\n// Creates a polymorphic matcher that matches anything &gt;= x.\ntemplate &lt;typename Rhs&gt;\ninline internal::GeMatcher&lt;Rhs&gt; Ge(Rhs x) {\n  return internal::GeMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &gt; x.\ntemplate &lt;typename Rhs&gt;\ninline internal::GtMatcher&lt;Rhs&gt; Gt(Rhs x) {\n  return internal::GtMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &lt;= x.\ntemplate &lt;typename Rhs&gt;\ninline internal::LeMatcher&lt;Rhs&gt; Le(Rhs x) {\n  return internal::LeMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything &lt; x.\ntemplate &lt;typename Rhs&gt;\ninline internal::LtMatcher&lt;Rhs&gt; Lt(Rhs x) {\n  return internal::LtMatcher&lt;Rhs&gt;(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate &lt;typename Rhs&gt;\ninline internal::NeMatcher&lt;Rhs&gt; Ne(Rhs x) {\n  return internal::NeMatcher&lt;Rhs&gt;(x);\n}\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251 5046\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_MATCHERS_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines the Message class.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#ifdef GTEST_HAS_ABSL\n#include &lt;type_traits&gt;\n\n#include &quot;absl/strings/has_absl_stringify.h&quot;\n#include &quot;absl/strings/str_cat.h&quot;\n#endif  // GTEST_HAS_ABSL\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Ensures that there is at least one operator&lt;&lt; in the global namespace.\n// See Message&amp; operator&lt;&lt;(...) below for why.\nvoid operator&lt;&lt;(const testing::internal::Secret&amp;, int);\n\nnamespace testing {\n\n// The Message class works like an ostream repeater.\n//\n// Typical usage:\n//\n//   1. You stream a bunch of values to a Message object.\n//      It will remember the text in a stringstream.\n//   2. Then you stream the Message object to an ostream.\n//      This causes the text in the Message to be streamed\n//      to the ostream.\n//\n// For example;\n//\n//   testing::Message foo;\n//   foo &lt;&lt; 1 &lt;&lt; &quot; != &quot; &lt;&lt; 2;\n//   std::cout &lt;&lt; foo;\n//\n// will print &quot;1 != 2&quot;.\n//\n// Message is not intended to be inherited from.  In particular, its\n// destructor is not virtual.\n//\n// Note that stringstream behaves differently in gcc and in MSVC.  You\n// can stream a NULL char pointer to it in the former, but not in the\n// latter (it causes an access violation if you do).  The Message\n// class hides this difference by treating a NULL char pointer as\n// &quot;(null)&quot;.\nclass GTEST_API_ Message {\n private:\n  // The type of basic IO manipulators (endl, ends, and flush) for\n  // narrow streams.\n  typedef std::ostream&amp; (*BasicNarrowIoManip)(std::ostream&amp;);\n\n public:\n  // Constructs an empty Message.\n  Message();\n\n  // Copy constructor.\n  Message(const Message&amp; msg) : ss_(new ::std::stringstream) {  // NOLINT\n    *ss_ &lt;&lt; msg.GetString();\n  }\n\n  // Constructs a Message from a C-string.\n  explicit Message(const char* str) : ss_(new ::std::stringstream) {\n    *ss_ &lt;&lt; str;\n  }\n\n  // Streams a non-pointer value to this object. If building a version of\n  // GoogleTest with ABSL, this overload is only enabled if the value does not\n  // have an AbslStringify definition.\n  template &lt;\n      typename T\n#ifdef GTEST_HAS_ABSL\n      ,\n      typename std::enable_if&lt;!absl::HasAbslStringify&lt;T&gt;::value,  // NOLINT\n                              int&gt;::type = 0\n#endif  // GTEST_HAS_ABSL\n      &gt;\n  inline Message&amp; operator&lt;&lt;(const T&amp; val) {\n        // Some libraries overload &lt;&lt; for STL containers.  These\n    // overloads are defined in the global namespace instead of ::std.\n    //\n    // C++&#x27;s symbol lookup rule (i.e. Koenig lookup) says that these\n    // overloads are visible in either the std namespace or the global\n    // namespace, but not other namespaces, including the testing\n    // namespace which Google Test&#x27;s Message class is in.\n    //\n    // To allow STL containers (and other types that has a &lt;&lt; operator\n    // defined in the global namespace) to be used in Google Test\n    // assertions, testing::Message must access the custom &lt;&lt; operator\n    // from the global namespace.  With this using declaration,\n    // overloads of &lt;&lt; defined in the global namespace and those\n    // visible via Koenig lookup are both exposed in this function.\n    using ::operator&lt;&lt;;\n    *ss_ &lt;&lt; val;\n    return *this;\n  }\n\n#ifdef GTEST_HAS_ABSL\n  // Streams a non-pointer value with an AbslStringify definition to this\n  // object.\n  template &lt;typename T,\n            typename std::enable_if&lt;absl::HasAbslStringify&lt;T&gt;::value,  // NOLINT\n                                    int&gt;::type = 0&gt;\n  inline Message&amp; operator&lt;&lt;(const T&amp; val) {\n    // ::operator&lt;&lt; is needed here for a similar reason as with the non-Abseil\n    // version above\n    using ::operator&lt;&lt;;\n    *ss_ &lt;&lt; absl::StrCat(val);\n    return *this;\n  }\n#endif  // GTEST_HAS_ABSL\n\n  // Streams a pointer value to this object.\n  //\n  // This function is an overload of the previous one.  When you\n  // stream a pointer to a Message, this definition will be used as it\n  // is more specialized.  (The C++ Standard, section\n  // [temp.func.order].)  If you stream a non-pointer, then the\n  // previous definition will be used.\n  //\n  // The reason for this overload is that streaming a NULL pointer to\n  // ostream is undefined behavior.  Depending on the compiler, you\n  // may get &quot;0&quot;, &quot;(nil)&quot;, &quot;(null)&quot;, or an access violation.  To\n  // ensure consistent result across compilers, we always treat NULL\n  // as &quot;(null)&quot;.\n  template &lt;typename T&gt;\n  inline Message&amp; operator&lt;&lt;(T* const&amp; pointer) {  // NOLINT\n    if (pointer == nullptr) {\n      *ss_ &lt;&lt; &quot;(null)&quot;;\n    } else {\n      *ss_ &lt;&lt; pointer;\n    }\n    return *this;\n  }\n\n  // Since the basic IO manipulators are overloaded for both narrow\n  // and wide streams, we have to provide this specialized definition\n  // of operator &lt;&lt;, even though its body is the same as the\n  // templatized version above.  Without this definition, streaming\n  // endl or other basic IO manipulators to Message will confuse the\n  // compiler.\n  Message&amp; operator&lt;&lt;(BasicNarrowIoManip val) {\n    *ss_ &lt;&lt; val;\n    return *this;\n  }\n\n  // Instead of 1/0, we want to see true/false for bool values.\n  Message&amp; operator&lt;&lt;(bool b) { return *this &lt;&lt; (b ? &quot;true&quot; : &quot;false&quot;); }\n\n  // These two overloads allow streaming a wide C string to a Message\n  // using the UTF-8 encoding.\n  Message&amp; operator&lt;&lt;(const wchar_t* wide_c_str);\n  Message&amp; operator&lt;&lt;(wchar_t* wide_c_str);\n\n#if GTEST_HAS_STD_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message&amp; operator&lt;&lt;(const ::std::wstring&amp; wstr);\n#endif  // GTEST_HAS_STD_WSTRING\n\n  // Gets the text streamed to this object so far as an std::string.\n  // Each &#x27;\\0&#x27; character in the buffer is replaced with &quot;\\\\0&quot;.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  std::string GetString() const;\n\n private:\n  // We&#x27;ll hold the text streamed to this object here.\n  const std::unique_ptr&lt; ::std::stringstream&gt; ss_;\n\n  // We declare (but don&#x27;t implement) this to prevent the compiler\n  // from implementing the assignment operator.\n  void operator=(const Message&amp;);\n};\n\n// Streams a Message to an ostream.\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Message&amp; sb) {\n  return os &lt;&lt; sb.GetString();\n}\n\nnamespace internal {\n\n// Converts a streamable value to an std::string.  A NULL pointer is\n// converted to &quot;(null)&quot;.  When the input value is a ::string,\n// ::std::string, ::wstring, or ::std::wstring object, each NUL\n// character in it is replaced with &quot;\\\\0&quot;.\ntemplate &lt;typename T&gt;\nstd::string StreamableToString(const T&amp; streamable) {\n  return (Message() &lt;&lt; streamable).GetString();\n}\n\n}  // namespace internal\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-printers.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-printers.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-printers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Test - The Google C++ Testing and Mocking Framework\n//\n// This file implements a universal value printer that can print a\n// value of any type T:\n//\n//   void ::testing::internal::UniversalPrinter&lt;T&gt;::Print(value, ostream_ptr);\n//\n// A user can teach this function how to print a class type T by\n// defining either operator&lt;&lt;() or PrintTo() in the namespace that\n// defines T.  More specifically, the FIRST defined function in the\n// following list will be used (assuming T is defined in namespace\n// foo):\n//\n//   1. foo::PrintTo(const T&amp;, ostream*)\n//   2. operator&lt;&lt;(ostream&amp;, const T&amp;) defined in either foo or the\n//      global namespace.\n// * Prefer AbslStringify(..) to operator&lt;&lt;(..), per https://abseil.io/tips/215.\n// * Define foo::PrintTo(..) if the type already has AbslStringify(..), but an\n//   alternative presentation in test results is of interest.\n//\n// However if T is an STL-style container then it is printed element-wise\n// unless foo::PrintTo(const T&amp;, ostream*) is defined. Note that\n// operator&lt;&lt;() is ignored for container types.\n//\n// If none of the above is defined, it will print the debug string of\n// the value if it is a protocol buffer, or print the raw bytes in the\n// value otherwise.\n//\n// To aid debugging: when T is a reference type, the address of the\n// value is also printed; when T is a (const) char pointer, both the\n// pointer value and the NUL-terminated string it points to are\n// printed.\n//\n// We also provide some convenient wrappers:\n//\n//   // Prints a value to a string.  For a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   std::string ::testing::PrintToString(const T&amp; value);\n//\n//   // Prints a value tersely: for a reference type, the referenced\n//   // value (but not the address) is printed; for a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   void ::testing::internal::UniversalTersePrint(const T&amp; value, ostream*);\n//\n//   // Prints value using the type inferred by the compiler.  The difference\n//   // from UniversalTersePrint() is that this function prints both the\n//   // pointer and the NUL-terminated string for a (const or not) char pointer.\n//   void ::testing::internal::UniversalPrint(const T&amp; value, ostream*);\n//\n//   // Prints the fields of a tuple tersely to a string vector, one\n//   // element for each field. Tuple support must be enabled in\n//   // gtest-port.h.\n//   std::vector&lt;string&gt; UniversalTersePrintTupleFieldsToStrings(\n//       const Tuple&amp; value);\n//\n// Known limitation:\n//\n// The print primitives print the elements of an STL-style container\n// using the compiler-inferred type of *iter where iter is a\n// const_iterator of the container.  When const_iterator is an input\n// iterator but not a forward iterator, this inferred type may not\n// match value_type, and the print output may be incorrect.  In\n// practice, this is rarely a problem as for most containers\n// const_iterator is a forward iterator.  We&#x27;ll fix this if there&#x27;s an\n// actual need for it.  Note that this fix cannot rely on value_type\n// being defined as many user-defined container types don&#x27;t have\n// value_type.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifdef GTEST_HAS_ABSL\n#include &quot;absl/strings/has_absl_stringify.h&quot;\n#include &quot;absl/strings/str_cat.h&quot;\n#endif  // GTEST_HAS_ABSL\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#if GTEST_INTERNAL_HAS_STD_SPAN\n#include &lt;span&gt;  // NOLINT\n#endif           // GTEST_INTERNAL_HAS_STD_SPAN\n\nnamespace testing {\n\n// Definitions in the internal* namespaces are subject to change without notice.\n// DO NOT USE THEM IN USER CODE!\nnamespace internal {\n\ntemplate &lt;typename T&gt;\nvoid UniversalPrint(const T&amp; value, ::std::ostream* os);\n\ntemplate &lt;typename T&gt;\nstruct IsStdSpan {\n  static constexpr bool value = false;\n};\n\n#if GTEST_INTERNAL_HAS_STD_SPAN\ntemplate &lt;typename E&gt;\nstruct IsStdSpan&lt;std::span&lt;E&gt;&gt; {\n  static constexpr bool value = true;\n};\n#endif  // GTEST_INTERNAL_HAS_STD_SPAN\n\n// Used to print an STL-style container when the user doesn&#x27;t define\n// a PrintTo() for it.\n//\n// NOTE: Since std::span does not have const_iterator until C++23, it would\n// fail IsContainerTest before C++23. However, IsContainerTest only uses\n// the presence of const_iterator to avoid treating iterators as containers\n// because of iterator::iterator. Which means std::span satisfies the *intended*\n// condition of IsContainerTest.\nstruct ContainerPrinter {\n  template &lt;typename T,\n            typename = typename std::enable_if&lt;\n                ((sizeof(IsContainerTest&lt;T&gt;(0)) == sizeof(IsContainer)) &amp;&amp;\n                 !IsRecursiveContainer&lt;T&gt;::value) ||\n                IsStdSpan&lt;T&gt;::value&gt;::type&gt;\n  static void PrintValue(const T&amp; container, std::ostream* os) {\n    const size_t kMaxCount = 32;  // The maximum number of elements to print.\n    *os &lt;&lt; &#x27;{&#x27;;\n    size_t count = 0;\n    for (auto&amp;&amp; elem : container) {\n      if (count &gt; 0) {\n        *os &lt;&lt; &#x27;,&#x27;;\n        if (count == kMaxCount) {  // Enough has been printed.\n          *os &lt;&lt; &quot; ...&quot;;\n          break;\n        }\n      }\n      *os &lt;&lt; &#x27; &#x27;;\n      // We cannot call PrintTo(elem, os) here as PrintTo() doesn&#x27;t\n      // handle `elem` being a native array.\n      internal::UniversalPrint(elem, os);\n      ++count;\n    }\n\n    if (count &gt; 0) {\n      *os &lt;&lt; &#x27; &#x27;;\n    }\n    *os &lt;&lt; &#x27;}&#x27;;\n  }\n};\n\n// Used to print a pointer that is neither a char pointer nor a member\n// pointer, when the user doesn&#x27;t define PrintTo() for it.  (A member\n// variable pointer or member function pointer doesn&#x27;t really point to\n// a location in the address space.  Their representation is\n// implementation-defined.  Therefore they will be printed as raw\n// bytes.)\nstruct FunctionPointerPrinter {\n  template &lt;typename T, typename = typename std::enable_if&lt;\n                            std::is_function&lt;T&gt;::value&gt;::type&gt;\n  static void PrintValue(T* p, ::std::ostream* os) {\n    if (p == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      // T is a function type, so &#x27;*os &lt;&lt; p&#x27; doesn&#x27;t do what we want\n      // (it just prints p as bool).  We want to print p as a const\n      // void*.\n      *os &lt;&lt; reinterpret_cast&lt;const void*&gt;(p);\n    }\n  }\n};\n\nstruct PointerPrinter {\n  template &lt;typename T&gt;\n  static void PrintValue(T* p, ::std::ostream* os) {\n    if (p == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      // T is not a function type.  We just call &lt;&lt; to print p,\n      // relying on ADL to pick up user-defined &lt;&lt; for their pointer\n      // types, if any.\n      *os &lt;&lt; p;\n    }\n  }\n};\n\nnamespace internal_stream_operator_without_lexical_name_lookup {\n\n// The presence of an operator&lt;&lt; here will terminate lexical scope lookup\n// straight away (even though it cannot be a match because of its argument\n// types). Thus, the two operator&lt;&lt; calls in StreamPrinter will find only ADL\n// candidates.\nstruct LookupBlocker {};\nvoid operator&lt;&lt;(LookupBlocker, LookupBlocker);\n\n// ADL bumps into preprocessor error when looking for std::chrono stream operators\n// with Xcode 15.3 because they are supported only for CMAKE_OSX_DEPLOYMENT_TARGET &gt;= 13.3\n#if __apple_build_version__ &gt;= 15000309 &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_13_3 //&lt; Build version for XCode 15.3.\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::chrono::milliseconds ms)\n{\n  return os &lt;&lt; ms.count();\n}\n\ninline std::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt; t)\n{\n  return os &lt;&lt; t.time_since_epoch().count();\n}\n\ninline std::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; os,\n  std::chrono::time_point&lt;std::chrono::system_clock&gt; t)\n{\n  return os &lt;&lt; t.time_since_epoch().count();\n}\n\n#endif\n\nstruct StreamPrinter {\n  template &lt;typename T,\n            // Don&#x27;t accept member pointers here. We&#x27;d print them via implicit\n            // conversion to bool, which isn&#x27;t useful.\n            typename = typename std::enable_if&lt;\n                !std::is_member_pointer&lt;T&gt;::value&gt;::type&gt;\n  // Only accept types for which we can find a streaming operator via\n  // ADL (possibly involving implicit conversions).\n  // (Use SFINAE via return type, because it seems GCC &lt; 12 doesn&#x27;t handle name\n  // lookup properly when we do it in the template parameter list.)\n  static auto PrintValue(const T&amp; value,\n                         ::std::ostream* os) -&gt; decltype((void)(*os &lt;&lt; value)) {\n    // Call streaming operator found by ADL, possibly with implicit conversions\n    // of the arguments.\n    *os &lt;&lt; value;\n  }\n};\n\n}  // namespace internal_stream_operator_without_lexical_name_lookup\n\nstruct ProtobufPrinter {\n  // We print a protobuf using its ShortDebugString() when the string\n  // doesn&#x27;t exceed this many characters; otherwise we print it using\n  // DebugString() for better readability.\n  static const size_t kProtobufOneLinerMaxLength = 50;\n\n  template &lt;typename T,\n            typename = typename std::enable_if&lt;\n                internal::HasDebugStringAndShortDebugString&lt;T&gt;::value&gt;::type&gt;\n  static void PrintValue(const T&amp; value, ::std::ostream* os) {\n    std::string pretty_str = value.ShortDebugString();\n    if (pretty_str.length() &gt; kProtobufOneLinerMaxLength) {\n      pretty_str = &quot;\\n&quot; + value.DebugString();\n    }\n    *os &lt;&lt; (&quot;&lt;&quot; + pretty_str + &quot;&gt;&quot;);\n  }\n};\n\nstruct ConvertibleToIntegerPrinter {\n  // Since T has no &lt;&lt; operator or PrintTo() but can be implicitly\n  // converted to BiggestInt, we print it as a BiggestInt.\n  //\n  // Most likely T is an enum type (either named or unnamed), in which\n  // case printing it as an integer is the desired behavior.  In case\n  // T is not an enum, printing it as an integer is the best we can do\n  // given that it has no user-defined printer.\n  static void PrintValue(internal::BiggestInt value, ::std::ostream* os) {\n    *os &lt;&lt; value;\n  }\n};\n\nstruct ConvertibleToStringViewPrinter {\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n  static void PrintValue(internal::StringView value, ::std::ostream* os) {\n    internal::UniversalPrint(value, os);\n  }\n#endif\n};\n\n#ifdef GTEST_HAS_ABSL\nstruct ConvertibleToAbslStringifyPrinter {\n  template &lt;typename T,\n            typename = typename std::enable_if&lt;\n                absl::HasAbslStringify&lt;T&gt;::value&gt;::type&gt;  // NOLINT\n  static void PrintValue(const T&amp; value, ::std::ostream* os) {\n    *os &lt;&lt; absl::StrCat(value);\n  }\n};\n#endif  // GTEST_HAS_ABSL\n\n// Prints the given number of bytes in the given object to the given\n// ostream.\nGTEST_API_ void PrintBytesInObjectTo(const unsigned char* obj_bytes,\n                                     size_t count, ::std::ostream* os);\nstruct RawBytesPrinter {\n  // SFINAE on `sizeof` to make sure we have a complete type.\n  template &lt;typename T, size_t = sizeof(T)&gt;\n  static void PrintValue(const T&amp; value, ::std::ostream* os) {\n    PrintBytesInObjectTo(\n        static_cast&lt;const unsigned char*&gt;(\n            // Load bearing cast to void* to support iOS\n            reinterpret_cast&lt;const void*&gt;(std::addressof(value))),\n        sizeof(value), os);\n  }\n};\n\nstruct FallbackPrinter {\n  template &lt;typename T&gt;\n  static void PrintValue(const T&amp;, ::std::ostream* os) {\n    *os &lt;&lt; &quot;(incomplete type)&quot;;\n  }\n};\n\n// Try every printer in order and return the first one that works.\ntemplate &lt;typename T, typename E, typename Printer, typename... Printers&gt;\nstruct FindFirstPrinter : FindFirstPrinter&lt;T, E, Printers...&gt; {};\n\ntemplate &lt;typename T, typename Printer, typename... Printers&gt;\nstruct FindFirstPrinter&lt;\n    T, decltype(Printer::PrintValue(std::declval&lt;const T&amp;&gt;(), nullptr)),\n    Printer, Printers...&gt; {\n  using type = Printer;\n};\n\n// Select the best printer in the following order:\n//  - Print containers (they have begin/end/etc).\n//  - Print function pointers.\n//  - Print object pointers.\n//  - Print protocol buffers.\n//  - Use the stream operator, if available.\n//  - Print types convertible to BiggestInt.\n//  - Print types convertible to StringView, if available.\n//  - Fallback to printing the raw bytes of the object.\ntemplate &lt;typename T&gt;\nvoid PrintWithFallback(const T&amp; value, ::std::ostream* os) {\n  using Printer = typename FindFirstPrinter&lt;\n      T, void, ContainerPrinter, FunctionPointerPrinter, PointerPrinter,\n      ProtobufPrinter,\n#ifdef GTEST_HAS_ABSL\n      ConvertibleToAbslStringifyPrinter,\n#endif  // GTEST_HAS_ABSL\n      internal_stream_operator_without_lexical_name_lookup::StreamPrinter,\n      ConvertibleToIntegerPrinter, ConvertibleToStringViewPrinter,\n      RawBytesPrinter, FallbackPrinter&gt;::type;\n  Printer::PrintValue(value, os);\n}\n\n// FormatForComparison&lt;ToPrint, OtherOperand&gt;::Format(value) formats a\n// value of type ToPrint that is an operand of a comparison assertion\n// (e.g. ASSERT_EQ).  OtherOperand is the type of the other operand in\n// the comparison, and is used to help determine the best way to\n// format the value.  In particular, when the value is a C string\n// (char pointer) and the other operand is an STL string object, we\n// want to format the C string as a string, since we know it is\n// compared by value with the string object.  If the value is a char\n// pointer but the other operand is not an STL string object, we don&#x27;t\n// know whether the pointer is supposed to point to a NUL-terminated\n// string, and thus want to print it as a pointer to be safe.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// The default case.\ntemplate &lt;typename ToPrint, typename OtherOperand&gt;\nclass FormatForComparison {\n public:\n  static ::std::string Format(const ToPrint&amp; value) {\n    return ::testing::PrintToString(value);\n  }\n};\n\n// Array.\ntemplate &lt;typename ToPrint, size_t N, typename OtherOperand&gt;\nclass FormatForComparison&lt;ToPrint[N], OtherOperand&gt; {\n public:\n  static ::std::string Format(const ToPrint* value) {\n    return FormatForComparison&lt;const ToPrint*, OtherOperand&gt;::Format(value);\n  }\n};\n\n// By default, print C string as pointers to be safe, as we don&#x27;t know\n// whether they actually point to a NUL-terminated string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(CharType)                \\\n  template &lt;typename OtherOperand&gt;                                      \\\n  class FormatForComparison&lt;CharType*, OtherOperand&gt; {                  \\\n   public:                                                              \\\n    static ::std::string Format(CharType* value) {                      \\\n      return ::testing::PrintToString(static_cast&lt;const void*&gt;(value)); \\\n    }                                                                   \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(wchar_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const wchar_t);\n#ifdef __cpp_lib_char8_t\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char8_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char8_t);\n#endif\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char16_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char16_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char32_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char32_t);\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\n\n// If a C string is compared with an STL string object, we know it&#x27;s meant\n// to point to a NUL-terminated string, and thus can print it as a string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(CharType, OtherStringType) \\\n  template &lt;&gt;                                                            \\\n  class FormatForComparison&lt;CharType*, OtherStringType&gt; {                \\\n   public:                                                               \\\n    static ::std::string Format(CharType* value) {                       \\\n      return ::testing::PrintToString(value);                            \\\n    }                                                                    \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::std::string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::std::string);\n#ifdef __cpp_lib_char8_t\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char8_t, ::std::u8string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char8_t, ::std::u8string);\n#endif\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char16_t, ::std::u16string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char16_t, ::std::u16string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char32_t, ::std::u32string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char32_t, ::std::u32string);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::std::wstring);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::std::wstring);\n#endif\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\n\n// Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)\n// operand to be used in a failure message.  The type (but not value)\n// of the other operand may affect the format.  This allows us to\n// print a char* as a raw pointer when it is compared against another\n// char* or void*, and print it as a C string when it is compared\n// against an std::string object, for example.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate &lt;typename T1, typename T2&gt;\nstd::string FormatForComparisonFailureMessage(const T1&amp; value,\n                                              const T2&amp; /* other_operand */) {\n  return FormatForComparison&lt;T1, T2&gt;::Format(value);\n}\n\n// UniversalPrinter&lt;T&gt;::Print(value, ostream_ptr) prints the given\n// value to the given ostream.  The caller must ensure that\n// &#x27;ostream_ptr&#x27; is not NULL, or the behavior is undefined.\n//\n// We define UniversalPrinter as a class template (as opposed to a\n// function template), as we need to partially specialize it for\n// reference types, which cannot be done with function templates.\ntemplate &lt;typename T&gt;\nclass UniversalPrinter;\n\n// Prints the given value using the &lt;&lt; operator if it has one;\n// otherwise prints the bytes in it.  This is what\n// UniversalPrinter&lt;T&gt;::Print() does when PrintTo() is not specialized\n// or overloaded for type T.\n//\n// A user can override this behavior for a class type Foo by defining\n// an overload of PrintTo() in the namespace where Foo is defined.  We\n// give the user this option as sometimes defining a &lt;&lt; operator for\n// Foo is not desirable (e.g. the coding style may prevent doing it,\n// or there is already a &lt;&lt; operator but it doesn&#x27;t do what the user\n// wants).\ntemplate &lt;typename T&gt;\nvoid PrintTo(const T&amp; value, ::std::ostream* os) {\n  internal::PrintWithFallback(value, os);\n}\n\n// The following list of PrintTo() overloads tells\n// UniversalPrinter&lt;T&gt;::Print() how to print standard types (built-in\n// types, strings, plain arrays, and pointers).\n\n// Overloads for various char types.\nGTEST_API_ void PrintTo(unsigned char c, ::std::ostream* os);\nGTEST_API_ void PrintTo(signed char c, ::std::ostream* os);\ninline void PrintTo(char c, ::std::ostream* os) {\n  // When printing a plain char, we always treat it as unsigned.  This\n  // way, the output won&#x27;t be affected by whether the compiler thinks\n  // char is signed or not.\n  PrintTo(static_cast&lt;unsigned char&gt;(c), os);\n}\n\n// Overloads for other simple built-in types.\ninline void PrintTo(bool x, ::std::ostream* os) {\n  *os &lt;&lt; (x ? &quot;true&quot; : &quot;false&quot;);\n}\n\n// Overload for wchar_t type.\n// Prints a wchar_t as a symbol if it is printable or as its internal\n// code otherwise and also as its decimal code (except for L&#x27;\\0&#x27;).\n// The L&#x27;\\0&#x27; char is printed as &quot;L&#x27;\\\\0&#x27;&quot;. The decimal code is printed\n// as signed integer when wchar_t is implemented by the compiler\n// as a signed type and is printed as an unsigned integer when wchar_t\n// is implemented as an unsigned type.\nGTEST_API_ void PrintTo(wchar_t wc, ::std::ostream* os);\n\nGTEST_API_ void PrintTo(char32_t c, ::std::ostream* os);\ninline void PrintTo(char16_t c, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;char32_t&gt;(c), os);\n}\n#ifdef __cpp_lib_char8_t\ninline void PrintTo(char8_t c, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;char32_t&gt;(c), os);\n}\n#endif\n\n// gcc/clang __{u,}int128_t\n#if defined(__SIZEOF_INT128__)\nGTEST_API_ void PrintTo(__uint128_t v, ::std::ostream* os);\nGTEST_API_ void PrintTo(__int128_t v, ::std::ostream* os);\n#endif  // __SIZEOF_INT128__\n\n// The default resolution used to print floating-point values uses only\n// 6 digits, which can be confusing if a test compares two values whose\n// difference lies in the 7th digit.  So we&#x27;d like to print out numbers\n// in full precision.\n// However if the value is something simple like 1.1, full will print a\n// long string like 1.100000001 due to floating-point numbers not using\n// a base of 10.  This routiune returns an appropriate resolution for a\n// given floating-point number, that is, 6 if it will be accurate, or a\n// max_digits10 value (full precision) if it won&#x27;t,  for values between\n// 0.0001 and one million.\n// It does this by computing what those digits would be (by multiplying\n// by an appropriate power of 10), then dividing by that power again to\n// see if gets the original value back.\n// A similar algorithm applies for values larger than one million; note\n// that for those values, we must divide to get a six-digit number, and\n// then multiply to possibly get the original value again.\ntemplate &lt;typename FloatType&gt;\nint AppropriateResolution(FloatType val) {\n  int full = std::numeric_limits&lt;FloatType&gt;::max_digits10;\n  if (val &lt; 0) val = -val;\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;\n#endif\n  if (val &lt; 1000000) {\n    FloatType mulfor6 = 1e10;\n    // Without these static casts, the template instantiation for float would\n    // fail to compile when -Wdouble-promotion is enabled, as the arithmetic and\n    // comparison logic would promote floats to doubles.\n    if (val &gt;= static_cast&lt;FloatType&gt;(100000.0)) {  // 100,000 to 999,999\n      mulfor6 = 1.0;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(10000.0)) {\n      mulfor6 = 1e1;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(1000.0)) {\n      mulfor6 = 1e2;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(100.0)) {\n      mulfor6 = 1e3;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(10.0)) {\n      mulfor6 = 1e4;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(1.0)) {\n      mulfor6 = 1e5;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(0.1)) {\n      mulfor6 = 1e6;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(0.01)) {\n      mulfor6 = 1e7;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(0.001)) {\n      mulfor6 = 1e8;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(0.0001)) {\n      mulfor6 = 1e9;\n    }\n    if (static_cast&lt;FloatType&gt;(static_cast&lt;int32_t&gt;(\n            val * mulfor6 + (static_cast&lt;FloatType&gt;(0.5)))) /\n            mulfor6 ==\n        val)\n      return 6;\n  } else if (val &lt; static_cast&lt;FloatType&gt;(1e10)) {\n    FloatType divfor6 = static_cast&lt;FloatType&gt;(1.0);\n    if (val &gt;= static_cast&lt;FloatType&gt;(1e9)) {  // 1,000,000,000 to 9,999,999,999\n      divfor6 = 10000;\n    } else if (val &gt;=\n               static_cast&lt;FloatType&gt;(1e8)) {  // 100,000,000 to 999,999,999\n      divfor6 = 1000;\n    } else if (val &gt;=\n               static_cast&lt;FloatType&gt;(1e7)) {  // 10,000,000 to 99,999,999\n      divfor6 = 100;\n    } else if (val &gt;= static_cast&lt;FloatType&gt;(1e6)) {  // 1,000,000 to 9,999,999\n      divfor6 = 10;\n    }\n    if (static_cast&lt;FloatType&gt;(static_cast&lt;int32_t&gt;(\n            val / divfor6 + (static_cast&lt;FloatType&gt;(0.5)))) *\n            divfor6 ==\n        val)\n      return 6;\n  }\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n  return full;\n}\n\ninline void PrintTo(float f, ::std::ostream* os) {\n  auto old_precision = os-&gt;precision();\n  os-&gt;precision(AppropriateResolution(f));\n  *os &lt;&lt; f;\n  os-&gt;precision(old_precision);\n}\n\ninline void PrintTo(double d, ::std::ostream* os) {\n  auto old_precision = os-&gt;precision();\n  os-&gt;precision(AppropriateResolution(d));\n  *os &lt;&lt; d;\n  os-&gt;precision(old_precision);\n}\n\n// Overloads for C strings.\nGTEST_API_ void PrintTo(const char* s, ::std::ostream* os);\ninline void PrintTo(char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const char*&gt;(s), os);\n}\n\n// signed/unsigned char is often used for representing binary data, so\n// we print pointers to it as void* to be safe.\ninline void PrintTo(const signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);\n}\ninline void PrintTo(signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);\n}\ninline void PrintTo(const unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);\n}\ninline void PrintTo(unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const void*&gt;(s), os);\n}\n#ifdef __cpp_lib_char8_t\n// Overloads for u8 strings.\nGTEST_API_ void PrintTo(const char8_t* s, ::std::ostream* os);\ninline void PrintTo(char8_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const char8_t*&gt;(s), os);\n}\n#endif\n// Overloads for u16 strings.\nGTEST_API_ void PrintTo(const char16_t* s, ::std::ostream* os);\ninline void PrintTo(char16_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const char16_t*&gt;(s), os);\n}\n// Overloads for u32 strings.\nGTEST_API_ void PrintTo(const char32_t* s, ::std::ostream* os);\ninline void PrintTo(char32_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const char32_t*&gt;(s), os);\n}\n\n// MSVC can be configured to define wchar_t as a typedef of unsigned\n// short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native\n// type.  When wchar_t is a typedef, defining an overload for const\n// wchar_t* would cause unsigned short* be printed as a wide string,\n// possibly causing invalid memory accesses.\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n// Overloads for wide C strings\nGTEST_API_ void PrintTo(const wchar_t* s, ::std::ostream* os);\ninline void PrintTo(wchar_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_&lt;const wchar_t*&gt;(s), os);\n}\n#endif\n\n// Overload for C arrays.  Multi-dimensional arrays are printed\n// properly.\n\n// Prints the given number of elements in an array, without printing\n// the curly braces.\ntemplate &lt;typename T&gt;\nvoid PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {\n  UniversalPrint(a[0], os);\n  for (size_t i = 1; i != count; i++) {\n    *os &lt;&lt; &quot;, &quot;;\n    UniversalPrint(a[i], os);\n  }\n}\n\n// Overloads for ::std::string.\nGTEST_API_ void PrintStringTo(const ::std::string&amp; s, ::std::ostream* os);\ninline void PrintTo(const ::std::string&amp; s, ::std::ostream* os) {\n  PrintStringTo(s, os);\n}\n\n// Overloads for ::std::u8string\n#ifdef __cpp_lib_char8_t\nGTEST_API_ void PrintU8StringTo(const ::std::u8string&amp; s, ::std::ostream* os);\ninline void PrintTo(const ::std::u8string&amp; s, ::std::ostream* os) {\n  PrintU8StringTo(s, os);\n}\n#endif\n\n// Overloads for ::std::u16string\nGTEST_API_ void PrintU16StringTo(const ::std::u16string&amp; s, ::std::ostream* os);\ninline void PrintTo(const ::std::u16string&amp; s, ::std::ostream* os) {\n  PrintU16StringTo(s, os);\n}\n\n// Overloads for ::std::u32string\nGTEST_API_ void PrintU32StringTo(const ::std::u32string&amp; s, ::std::ostream* os);\ninline void PrintTo(const ::std::u32string&amp; s, ::std::ostream* os) {\n  PrintU32StringTo(s, os);\n}\n\n// Overloads for ::std::wstring.\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ void PrintWideStringTo(const ::std::wstring&amp; s, ::std::ostream* os);\ninline void PrintTo(const ::std::wstring&amp; s, ::std::ostream* os) {\n  PrintWideStringTo(s, os);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n#if GTEST_INTERNAL_HAS_STRING_VIEW\n// Overload for internal::StringView.\ninline void PrintTo(internal::StringView sp, ::std::ostream* os) {\n  PrintTo(::std::string(sp), os);\n}\n#endif  // GTEST_INTERNAL_HAS_STRING_VIEW\n\ninline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os &lt;&lt; &quot;(nullptr)&quot;; }\n\n#if GTEST_HAS_RTTI\ninline void PrintTo(const std::type_info&amp; info, std::ostream* os) {\n  *os &lt;&lt; internal::GetTypeName(info);\n}\n#endif  // GTEST_HAS_RTTI\n\ntemplate &lt;typename T&gt;\nvoid PrintTo(std::reference_wrapper&lt;T&gt; ref, ::std::ostream* os) {\n  UniversalPrinter&lt;T&amp;&gt;::Print(ref.get(), os);\n}\n\ninline const void* VoidifyPointer(const void* p) { return p; }\ninline const void* VoidifyPointer(volatile const void* p) {\n  return const_cast&lt;const void*&gt;(p);\n}\n\ntemplate &lt;typename T, typename Ptr&gt;\nvoid PrintSmartPointer(const Ptr&amp; ptr, std::ostream* os, char) {\n  if (ptr == nullptr) {\n    *os &lt;&lt; &quot;(nullptr)&quot;;\n  } else {\n    // We can&#x27;t print the value. Just print the pointer..\n    *os &lt;&lt; &quot;(&quot; &lt;&lt; (VoidifyPointer)(ptr.get()) &lt;&lt; &quot;)&quot;;\n  }\n}\ntemplate &lt;typename T, typename Ptr,\n          typename = typename std::enable_if&lt;!std::is_void&lt;T&gt;::value &amp;&amp;\n                                             !std::is_array&lt;T&gt;::value&gt;::type&gt;\nvoid PrintSmartPointer(const Ptr&amp; ptr, std::ostream* os, int) {\n  if (ptr == nullptr) {\n    *os &lt;&lt; &quot;(nullptr)&quot;;\n  } else {\n    *os &lt;&lt; &quot;(ptr = &quot; &lt;&lt; (VoidifyPointer)(ptr.get()) &lt;&lt; &quot;, value = &quot;;\n    UniversalPrinter&lt;T&gt;::Print(*ptr, os);\n    *os &lt;&lt; &quot;)&quot;;\n  }\n}\n\ntemplate &lt;typename T, typename D&gt;\nvoid PrintTo(const std::unique_ptr&lt;T, D&gt;&amp; ptr, std::ostream* os) {\n  (PrintSmartPointer&lt;T&gt;)(ptr, os, 0);\n}\n\ntemplate &lt;typename T&gt;\nvoid PrintTo(const std::shared_ptr&lt;T&gt;&amp; ptr, std::ostream* os) {\n  (PrintSmartPointer&lt;T&gt;)(ptr, os, 0);\n}\n\n// Helper function for printing a tuple.  T must be instantiated with\n// a tuple type.\ntemplate &lt;typename T&gt;\nvoid PrintTupleTo(const T&amp;, std::integral_constant&lt;size_t, 0&gt;,\n                  ::std::ostream*) {}\n\ntemplate &lt;typename T, size_t I&gt;\nvoid PrintTupleTo(const T&amp; t, std::integral_constant&lt;size_t, I&gt;,\n                  ::std::ostream* os) {\n  PrintTupleTo(t, std::integral_constant&lt;size_t, I - 1&gt;(), os);\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (I &gt; 1) {\n    GTEST_INTENTIONAL_CONST_COND_POP_()\n    *os &lt;&lt; &quot;, &quot;;\n  }\n  UniversalPrinter&lt;typename std::tuple_element&lt;I - 1, T&gt;::type&gt;::Print(\n      std::get&lt;I - 1&gt;(t), os);\n}\n\ntemplate &lt;typename... Types&gt;\nvoid PrintTo(const ::std::tuple&lt;Types...&gt;&amp; t, ::std::ostream* os) {\n  *os &lt;&lt; &quot;(&quot;;\n  PrintTupleTo(t, std::integral_constant&lt;size_t, sizeof...(Types)&gt;(), os);\n  *os &lt;&lt; &quot;)&quot;;\n}\n\n// Overload for std::pair.\ntemplate &lt;typename T1, typename T2&gt;\nvoid PrintTo(const ::std::pair&lt;T1, T2&gt;&amp; value, ::std::ostream* os) {\n  *os &lt;&lt; &#x27;(&#x27;;\n  // We cannot use UniversalPrint(value.first, os) here, as T1 may be\n  // a reference type.  The same for printing value.second.\n  UniversalPrinter&lt;T1&gt;::Print(value.first, os);\n  *os &lt;&lt; &quot;, &quot;;\n  UniversalPrinter&lt;T2&gt;::Print(value.second, os);\n  *os &lt;&lt; &#x27;)&#x27;;\n}\n\n// Implements printing a non-reference type T by letting the compiler\n// pick the right overload of PrintTo() for T.\ntemplate &lt;typename T&gt;\nclass UniversalPrinter {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  // Note: we deliberately don&#x27;t call this PrintTo(), as that name\n  // conflicts with ::testing::internal::PrintTo in the body of the\n  // function.\n  static void Print(const T&amp; value, ::std::ostream* os) {\n    // By default, ::testing::internal::PrintTo() is used for printing\n    // the value.\n    //\n    // Thanks to Koenig look-up, if T is a class and has its own\n    // PrintTo() function defined in its namespace, that function will\n    // be visible here.  Since it is more specific than the generic ones\n    // in ::testing::internal, it will be picked by the compiler in the\n    // following statement - exactly what we want.\n    PrintTo(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// Remove any const-qualifiers before passing a type to UniversalPrinter.\ntemplate &lt;typename T&gt;\nclass UniversalPrinter&lt;const T&gt; : public UniversalPrinter&lt;T&gt; {};\n\n#if GTEST_INTERNAL_HAS_ANY\n\n// Printer for std::any / absl::any\n\ntemplate &lt;&gt;\nclass UniversalPrinter&lt;Any&gt; {\n public:\n  static void Print(const Any&amp; value, ::std::ostream* os) {\n    if (value.has_value()) {\n      *os &lt;&lt; &quot;value of type &quot; &lt;&lt; GetTypeName(value);\n    } else {\n      *os &lt;&lt; &quot;no value&quot;;\n    }\n  }\n\n private:\n  static std::string GetTypeName(const Any&amp; value) {\n#if GTEST_HAS_RTTI\n    return internal::GetTypeName(value.type());\n#else\n    static_cast&lt;void&gt;(value);  // possibly unused\n    return &quot;&lt;unknown_type&gt;&quot;;\n#endif  // GTEST_HAS_RTTI\n  }\n};\n\n#endif  // GTEST_INTERNAL_HAS_ANY\n\n#if GTEST_INTERNAL_HAS_OPTIONAL\n\n// Printer for std::optional / absl::optional\n\ntemplate &lt;typename T&gt;\nclass UniversalPrinter&lt;Optional&lt;T&gt;&gt; {\n public:\n  static void Print(const Optional&lt;T&gt;&amp; value, ::std::ostream* os) {\n    *os &lt;&lt; &#x27;(&#x27;;\n    if (!value) {\n      *os &lt;&lt; &quot;nullopt&quot;;\n    } else {\n      UniversalPrint(*value, os);\n    }\n    *os &lt;&lt; &#x27;)&#x27;;\n  }\n};\n\ntemplate &lt;&gt;\nclass UniversalPrinter&lt;decltype(Nullopt())&gt; {\n public:\n  static void Print(decltype(Nullopt()), ::std::ostream* os) {\n    *os &lt;&lt; &quot;(nullopt)&quot;;\n  }\n};\n\n#endif  // GTEST_INTERNAL_HAS_OPTIONAL\n\n#if GTEST_INTERNAL_HAS_VARIANT\n\n// Printer for std::variant / absl::variant\n\ntemplate &lt;typename... T&gt;\nclass UniversalPrinter&lt;Variant&lt;T...&gt;&gt; {\n public:\n  static void Print(const Variant&lt;T...&gt;&amp; value, ::std::ostream* os) {\n    *os &lt;&lt; &#x27;(&#x27;;\n#ifdef GTEST_HAS_ABSL\n    absl::visit(Visitor{os, value.index()}, value);\n#else\n    std::visit(Visitor{os, value.index()}, value);\n#endif  // GTEST_HAS_ABSL\n    *os &lt;&lt; &#x27;)&#x27;;\n  }\n\n private:\n  struct Visitor {\n    template &lt;typename U&gt;\n    void operator()(const U&amp; u) const {\n      *os &lt;&lt; &quot;&#x27;&quot; &lt;&lt; GetTypeName&lt;U&gt;() &lt;&lt; &quot;(index = &quot; &lt;&lt; index\n          &lt;&lt; &quot;)&#x27; with value &quot;;\n      UniversalPrint(u, os);\n    }\n    ::std::ostream* os;\n    std::size_t index;\n  };\n};\n\n#endif  // GTEST_INTERNAL_HAS_VARIANT\n\n// UniversalPrintArray(begin, len, os) prints an array of &#x27;len&#x27;\n// elements, starting at address &#x27;begin&#x27;.\ntemplate &lt;typename T&gt;\nvoid UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {\n  if (len == 0) {\n    *os &lt;&lt; &quot;{}&quot;;\n  } else {\n    *os &lt;&lt; &quot;{ &quot;;\n    const size_t kThreshold = 18;\n    const size_t kChunkSize = 8;\n    // If the array has more than kThreshold elements, we&#x27;ll have to\n    // omit some details by printing only the first and the last\n    // kChunkSize elements.\n    if (len &lt;= kThreshold) {\n      PrintRawArrayTo(begin, len, os);\n    } else {\n      PrintRawArrayTo(begin, kChunkSize, os);\n      *os &lt;&lt; &quot;, ..., &quot;;\n      PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\n    }\n    *os &lt;&lt; &quot; }&quot;;\n  }\n}\n// This overload prints a (const) char array compactly.\nGTEST_API_ void UniversalPrintArray(const char* begin, size_t len,\n                                    ::std::ostream* os);\n\n#ifdef __cpp_lib_char8_t\n// This overload prints a (const) char8_t array compactly.\nGTEST_API_ void UniversalPrintArray(const char8_t* begin, size_t len,\n                                    ::std::ostream* os);\n#endif\n\n// This overload prints a (const) char16_t array compactly.\nGTEST_API_ void UniversalPrintArray(const char16_t* begin, size_t len,\n                                    ::std::ostream* os);\n\n// This overload prints a (const) char32_t array compactly.\nGTEST_API_ void UniversalPrintArray(const char32_t* begin, size_t len,\n                                    ::std::ostream* os);\n\n// This overload prints a (const) wchar_t array compactly.\nGTEST_API_ void UniversalPrintArray(const wchar_t* begin, size_t len,\n                                    ::std::ostream* os);\n\n// Implements printing an array type T[N].\ntemplate &lt;typename T, size_t N&gt;\nclass UniversalPrinter&lt;T[N]&gt; {\n public:\n  // Prints the given array, omitting some elements when there are too\n  // many.\n  static void Print(const T (&amp;a)[N], ::std::ostream* os) {\n    UniversalPrintArray(a, N, os);\n  }\n};\n\n// Implements printing a reference type T&amp;.\ntemplate &lt;typename T&gt;\nclass UniversalPrinter&lt;T&amp;&gt; {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  static void Print(const T&amp; value, ::std::ostream* os) {\n    // Prints the address of the value.  We use reinterpret_cast here\n    // as static_cast doesn&#x27;t compile when T is a function type.\n    *os &lt;&lt; &quot;@&quot; &lt;&lt; reinterpret_cast&lt;const void*&gt;(&amp;value) &lt;&lt; &quot; &quot;;\n\n    // Then prints the value itself.\n    UniversalPrint(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// Prints a value tersely: for a reference type, the referenced value\n// (but not the address) is printed; for a (const) char pointer, the\n// NUL-terminated string (but not the pointer) is printed.\n\ntemplate &lt;typename T&gt;\nclass UniversalTersePrinter {\n public:\n  static void Print(const T&amp; value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate &lt;typename T&gt;\nclass UniversalTersePrinter&lt;T&amp;&gt; {\n public:\n  static void Print(const T&amp; value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate &lt;typename T&gt;\nclass UniversalTersePrinter&lt;std::reference_wrapper&lt;T&gt;&gt; {\n public:\n  static void Print(std::reference_wrapper&lt;T&gt; value, ::std::ostream* os) {\n    UniversalTersePrinter&lt;T&gt;::Print(value.get(), os);\n  }\n};\ntemplate &lt;typename T, size_t N&gt;\nclass UniversalTersePrinter&lt;T[N]&gt; {\n public:\n  static void Print(const T (&amp;value)[N], ::std::ostream* os) {\n    UniversalPrinter&lt;T[N]&gt;::Print(value, os);\n  }\n};\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;const char*&gt; {\n public:\n  static void Print(const char* str, ::std::ostream* os) {\n    if (str == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      UniversalPrint(std::string(str), os);\n    }\n  }\n};\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;char*&gt; : public UniversalTersePrinter&lt;const char*&gt; {\n};\n\n#ifdef __cpp_lib_char8_t\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;const char8_t*&gt; {\n public:\n  static void Print(const char8_t* str, ::std::ostream* os) {\n    if (str == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      UniversalPrint(::std::u8string(str), os);\n    }\n  }\n};\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;char8_t*&gt;\n    : public UniversalTersePrinter&lt;const char8_t*&gt; {};\n#endif\n\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;const char16_t*&gt; {\n public:\n  static void Print(const char16_t* str, ::std::ostream* os) {\n    if (str == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      UniversalPrint(::std::u16string(str), os);\n    }\n  }\n};\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;char16_t*&gt;\n    : public UniversalTersePrinter&lt;const char16_t*&gt; {};\n\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;const char32_t*&gt; {\n public:\n  static void Print(const char32_t* str, ::std::ostream* os) {\n    if (str == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      UniversalPrint(::std::u32string(str), os);\n    }\n  }\n};\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;char32_t*&gt;\n    : public UniversalTersePrinter&lt;const char32_t*&gt; {};\n\n#if GTEST_HAS_STD_WSTRING\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;const wchar_t*&gt; {\n public:\n  static void Print(const wchar_t* str, ::std::ostream* os) {\n    if (str == nullptr) {\n      *os &lt;&lt; &quot;NULL&quot;;\n    } else {\n      UniversalPrint(::std::wstring(str), os);\n    }\n  }\n};\n#endif\n\ntemplate &lt;&gt;\nclass UniversalTersePrinter&lt;wchar_t*&gt; {\n public:\n  static void Print(wchar_t* str, ::std::ostream* os) {\n    UniversalTersePrinter&lt;const wchar_t*&gt;::Print(str, os);\n  }\n};\n\ntemplate &lt;typename T&gt;\nvoid UniversalTersePrint(const T&amp; value, ::std::ostream* os) {\n  UniversalTersePrinter&lt;T&gt;::Print(value, os);\n}\n\n// Prints a value using the type inferred by the compiler.  The\n// difference between this and UniversalTersePrint() is that for a\n// (const) char pointer, this prints both the pointer and the\n// NUL-terminated string.\ntemplate &lt;typename T&gt;\nvoid UniversalPrint(const T&amp; value, ::std::ostream* os) {\n  // A workarond for the bug in VC++ 7.1 that prevents us from instantiating\n  // UniversalPrinter with T directly.\n  typedef T T1;\n  UniversalPrinter&lt;T1&gt;::Print(value, os);\n}\n\ntypedef ::std::vector&lt;::std::string&gt; Strings;\n\n// Tersely prints the first N fields of a tuple to a string vector,\n// one element for each field.\ntemplate &lt;typename Tuple&gt;\nvoid TersePrintPrefixToStrings(const Tuple&amp;, std::integral_constant&lt;size_t, 0&gt;,\n                               Strings*) {}\ntemplate &lt;typename Tuple, size_t I&gt;\nvoid TersePrintPrefixToStrings(const Tuple&amp; t,\n                               std::integral_constant&lt;size_t, I&gt;,\n                               Strings* strings) {\n  TersePrintPrefixToStrings(t, std::integral_constant&lt;size_t, I - 1&gt;(),\n                            strings);\n  ::std::stringstream ss;\n  UniversalTersePrint(std::get&lt;I - 1&gt;(t), &amp;ss);\n  strings-&gt;push_back(ss.str());\n}\n\n// Prints the fields of a tuple tersely to a string vector, one\n// element for each field.  See the comment before\n// UniversalTersePrint() for how we define &quot;tersely&quot;.\ntemplate &lt;typename Tuple&gt;\nStrings UniversalTersePrintTupleFieldsToStrings(const Tuple&amp; value) {\n  Strings result;\n  TersePrintPrefixToStrings(\n      value, std::integral_constant&lt;size_t, std::tuple_size&lt;Tuple&gt;::value&gt;(),\n      &amp;result);\n  return result;\n}\n\n}  // namespace internal\n\ntemplate &lt;typename T&gt;\n::std::string PrintToString(const T&amp; value) {\n  ::std::stringstream ss;\n  internal::UniversalTersePrinter&lt;T&gt;::Print(value, &amp;ss);\n  return ss.str();\n}\n\n}  // namespace testing\n\n// Include any custom printer added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include &quot;gtest/internal/custom/gtest-printers.h&quot;\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Utilities for testing Google Test itself and code that uses Google Test\n// (e.g. frameworks built on top of Google Test).\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_\n\n#include &lt;string&gt;\n\n#include &quot;gtest/gtest.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\nnamespace testing {\n\n// This helper class can be used to mock out Google Test failure reporting\n// so that we can test Google Test or code that builds on Google Test.\n//\n// An object of this class appends a TestPartResult object to the\n// TestPartResultArray object given in the constructor whenever a Google Test\n// failure is reported. It can either intercept only failures that are\n// generated in the same thread that created this object or it can intercept\n// all generated failures. The scope of this mock object can be controlled with\n// the second argument to the two arguments constructor.\nclass GTEST_API_ ScopedFakeTestPartResultReporter\n    : public TestPartResultReporterInterface {\n public:\n  // The two possible mocking modes of this object.\n  enum InterceptMode {\n    INTERCEPT_ONLY_CURRENT_THREAD,  // Intercepts only thread local failures.\n    INTERCEPT_ALL_THREADS           // Intercepts all failures.\n  };\n\n  // The c&#x27;tor sets this object as the test part result reporter used\n  // by Google Test.  The &#x27;result&#x27; parameter specifies where to report the\n  // results. This reporter will only catch failures generated in the current\n  // thread. DEPRECATED\n  explicit ScopedFakeTestPartResultReporter(TestPartResultArray* result);\n\n  // Same as above, but you can choose the interception scope of this object.\n  ScopedFakeTestPartResultReporter(InterceptMode intercept_mode,\n                                   TestPartResultArray* result);\n\n  // The d&#x27;tor restores the previous test part result reporter.\n  ~ScopedFakeTestPartResultReporter() override;\n\n  // Appends the TestPartResult object to the TestPartResultArray\n  // received in the constructor.\n  //\n  // This method is from the TestPartResultReporterInterface\n  // interface.\n  void ReportTestPartResult(const TestPartResult&amp; result) override;\n\n private:\n  void Init();\n\n  const InterceptMode intercept_mode_;\n  TestPartResultReporterInterface* old_reporter_;\n  TestPartResultArray* const result_;\n\n  ScopedFakeTestPartResultReporter(const ScopedFakeTestPartResultReporter&amp;) =\n      delete;\n  ScopedFakeTestPartResultReporter&amp; operator=(\n      const ScopedFakeTestPartResultReporter&amp;) = delete;\n};\n\nnamespace internal {\n\n// A helper class for implementing EXPECT_FATAL_FAILURE() and\n// EXPECT_NONFATAL_FAILURE().  Its destructor verifies that the given\n// TestPartResultArray contains exactly one failure that has the given\n// type and contains the given substring.  If that&#x27;s not the case, a\n// non-fatal failure will be generated.\nclass GTEST_API_ SingleFailureChecker {\n public:\n  // The constructor remembers the arguments.\n  SingleFailureChecker(const TestPartResultArray* results,\n                       TestPartResult::Type type, const std::string&amp; substr);\n  ~SingleFailureChecker();\n\n private:\n  const TestPartResultArray* const results_;\n  const TestPartResult::Type type_;\n  const std::string substr_;\n\n  SingleFailureChecker(const SingleFailureChecker&amp;) = delete;\n  SingleFailureChecker&amp; operator=(const SingleFailureChecker&amp;) = delete;\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n// A set of macros for testing Google Test assertions or code that&#x27;s expected\n// to generate Google Test fatal failures (e.g. a failure from an ASSERT_EQ, but\n// not a non-fatal failure, as from EXPECT_EQ).  It verifies that the given\n// statement will cause exactly one fatal Google Test failure with &#x27;substr&#x27;\n// being part of the failure message.\n//\n// There are two different versions of this macro. EXPECT_FATAL_FAILURE only\n// affects and considers failures generated in the current thread and\n// EXPECT_FATAL_FAILURE_ON_ALL_THREADS does the same but for all threads.\n//\n// The verification of the assertion is done correctly even when the statement\n// throws an exception or aborts the current function.\n//\n// Known restrictions:\n//   - &#x27;statement&#x27; cannot reference local non-static variables or\n//     non-static members of the current object.\n//   - &#x27;statement&#x27; cannot return a value.\n//   - You cannot stream a failure message to this macro.\n//\n// Note that even though the implementations of the following two\n// macros are much alike, we cannot refactor them to use a common\n// helper macro, due to some peculiarity in how the preprocessor\n// works.  The AcceptsMacroThatExpandsToUnprotectedComma test in\n// gtest_unittest.cc will fail to compile if we do that.\n#define EXPECT_FATAL_FAILURE(statement, substr)                               \\\n  do {                                                                        \\\n    class GTestExpectFatalFailureHelper {                                     \\\n     public:                                                                  \\\n      static void Execute() { statement; }                                    \\\n    };                                                                        \\\n    ::testing::TestPartResultArray gtest_failures;                            \\\n    ::testing::internal::SingleFailureChecker gtest_checker(                  \\\n        &amp;gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr)); \\\n    {                                                                         \\\n      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(             \\\n          ::testing::ScopedFakeTestPartResultReporter::                       \\\n              INTERCEPT_ONLY_CURRENT_THREAD,                                  \\\n          &amp;gtest_failures);                                                   \\\n      GTestExpectFatalFailureHelper::Execute();                               \\\n    }                                                                         \\\n  } while (::testing::internal::AlwaysFalse())\n\n#define EXPECT_FATAL_FAILURE_ON_ALL_THREADS(statement, substr)                \\\n  do {                                                                        \\\n    class GTestExpectFatalFailureHelper {                                     \\\n     public:                                                                  \\\n      static void Execute() { statement; }                                    \\\n    };                                                                        \\\n    ::testing::TestPartResultArray gtest_failures;                            \\\n    ::testing::internal::SingleFailureChecker gtest_checker(                  \\\n        &amp;gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr)); \\\n    {                                                                         \\\n      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(             \\\n          ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, \\\n          &amp;gtest_failures);                                                   \\\n      GTestExpectFatalFailureHelper::Execute();                               \\\n    }                                                                         \\\n  } while (::testing::internal::AlwaysFalse())\n\n// A macro for testing Google Test assertions or code that&#x27;s expected to\n// generate Google Test non-fatal failures (e.g. a failure from an EXPECT_EQ,\n// but not from an ASSERT_EQ). It asserts that the given statement will cause\n// exactly one non-fatal Google Test failure with &#x27;substr&#x27; being part of the\n// failure message.\n//\n// There are two different versions of this macro. EXPECT_NONFATAL_FAILURE only\n// affects and considers failures generated in the current thread and\n// EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS does the same but for all threads.\n//\n// &#x27;statement&#x27; is allowed to reference local variables and members of\n// the current object.\n//\n// The verification of the assertion is done correctly even when the statement\n// throws an exception or aborts the current function.\n//\n// Known restrictions:\n//   - You cannot stream a failure message to this macro.\n//\n// Note that even though the implementations of the following two\n// macros are much alike, we cannot refactor them to use a common\n// helper macro, due to some peculiarity in how the preprocessor\n// works.  If we do that, the code won&#x27;t compile when the user gives\n// EXPECT_NONFATAL_FAILURE() a statement that contains a macro that\n// expands to code containing an unprotected comma.  The\n// AcceptsMacroThatExpandsToUnprotectedComma test in gtest_unittest.cc\n// catches that.\n//\n// For the same reason, we have to write\n//   if (::testing::internal::AlwaysTrue()) { statement; }\n// instead of\n//   GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)\n// to avoid an MSVC warning on unreachable code.\n#define EXPECT_NONFATAL_FAILURE(statement, substr)                    \\\n  do {                                                                \\\n    ::testing::TestPartResultArray gtest_failures;                    \\\n    ::testing::internal::SingleFailureChecker gtest_checker(          \\\n        &amp;gtest_failures, ::testing::TestPartResult::kNonFatalFailure, \\\n        (substr));                                                    \\\n    {                                                                 \\\n      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(     \\\n          ::testing::ScopedFakeTestPartResultReporter::               \\\n              INTERCEPT_ONLY_CURRENT_THREAD,                          \\\n          &amp;gtest_failures);                                           \\\n      if (::testing::internal::AlwaysTrue()) {                        \\\n        statement;                                                    \\\n      }                                                               \\\n    }                                                                 \\\n  } while (::testing::internal::AlwaysFalse())\n\n#define EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS(statement, substr)             \\\n  do {                                                                        \\\n    ::testing::TestPartResultArray gtest_failures;                            \\\n    ::testing::internal::SingleFailureChecker gtest_checker(                  \\\n        &amp;gtest_failures, ::testing::TestPartResult::kNonFatalFailure,         \\\n        (substr));                                                            \\\n    {                                                                         \\\n      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(             \\\n          ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, \\\n          &amp;gtest_failures);                                                   \\\n      if (::testing::internal::AlwaysTrue()) {                                \\\n        statement;                                                            \\\n      }                                                                       \\\n    }                                                                         \\\n  } while (::testing::internal::AlwaysFalse())\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_SPI_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n\n#include &lt;iosfwd&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\nnamespace testing {\n\n// A copyable object representing the result of a test part (i.e. an\n// assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).\n//\n// Don&#x27;t inherit from TestPartResult as its destructor is not virtual.\nclass GTEST_API_ TestPartResult {\n public:\n  // The possible outcomes of a test part (i.e. an assertion or an\n  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).\n  enum Type {\n    kSuccess,          // Succeeded.\n    kNonFatalFailure,  // Failed but the test can continue.\n    kFatalFailure,     // Failed and the test should be terminated.\n    kSkip              // Skipped.\n  };\n\n  // C&#x27;tor.  TestPartResult does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestPartResult object.\n  TestPartResult(Type a_type, const char* a_file_name, int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == nullptr ? &quot;&quot; : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {}\n\n  // Gets the outcome of the test part.\n  Type type() const { return type_; }\n\n  // Gets the name of the source file where the test part took place, or\n  // NULL if it&#x27;s unknown.\n  const char* file_name() const {\n    return file_name_.empty() ? nullptr : file_name_.c_str();\n  }\n\n  // Gets the line in the source file where the test part took place,\n  // or -1 if it&#x27;s unknown.\n  int line_number() const { return line_number_; }\n\n  // Gets the summary of the failure message.\n  const char* summary() const { return summary_.c_str(); }\n\n  // Gets the message associated with the test part.\n  const char* message() const { return message_.c_str(); }\n\n  // Returns true if and only if the test part was skipped.\n  bool skipped() const { return type_ == kSkip; }\n\n  // Returns true if and only if the test part passed.\n  bool passed() const { return type_ == kSuccess; }\n\n  // Returns true if and only if the test part non-fatally failed.\n  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }\n\n  // Returns true if and only if the test part fatally failed.\n  bool fatally_failed() const { return type_ == kFatalFailure; }\n\n  // Returns true if and only if the test part failed.\n  bool failed() const { return fatally_failed() || nonfatally_failed(); }\n\n private:\n  Type type_;\n\n  // Gets the summary of the failure message by omitting the stack\n  // trace in it.\n  static std::string ExtractSummary(const char* message);\n\n  // The name of the source file where the test part took place, or\n  // &quot;&quot; if the source file is unknown.\n  std::string file_name_;\n  // The line in the source file where the test part took place, or -1\n  // if the line number is unknown.\n  int line_number_;\n  std::string summary_;  // The test failure summary.\n  std::string message_;  // The test failure message.\n};\n\n// Prints a TestPartResult object.\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const TestPartResult&amp; result);\n\n// An array of TestPartResult objects.\n//\n// Don&#x27;t inherit from TestPartResultArray as its destructor is not\n// virtual.\nclass GTEST_API_ TestPartResultArray {\n public:\n  TestPartResultArray() = default;\n\n  // Appends the given TestPartResult to the array.\n  void Append(const TestPartResult&amp; result);\n\n  // Returns the TestPartResult at the given index (0-based).\n  const TestPartResult&amp; GetTestPartResult(int index) const;\n\n  // Returns the number of TestPartResult objects in the array.\n  int size() const;\n\n private:\n  std::vector&lt;TestPartResult&gt; array_;\n\n  TestPartResultArray(const TestPartResultArray&amp;) = delete;\n  TestPartResultArray&amp; operator=(const TestPartResultArray&amp;) = delete;\n};\n\n// This interface knows how to report a test part result.\nclass GTEST_API_ TestPartResultReporterInterface {\n public:\n  virtual ~TestPartResultReporterInterface() = default;\n\n  virtual void ReportTestPartResult(const TestPartResult&amp; result) = 0;\n};\n\nnamespace internal {\n\n// This helper class is used by {ASSERT|EXPECT}_NO_FATAL_FAILURE to check if a\n// statement generates new fatal failures. To do so it registers itself as the\n// current test part result reporter. Besides checking if fatal failures were\n// reported, it only delegates the reporting to the former result reporter.\n// The original result reporter is restored in the destructor.\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nclass GTEST_API_ HasNewFatalFailureHelper\n    : public TestPartResultReporterInterface {\n public:\n  HasNewFatalFailureHelper();\n  ~HasNewFatalFailureHelper() override;\n  void ReportTestPartResult(const TestPartResult&amp; result) override;\n  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }\n\n private:\n  bool has_new_fatal_failure_;\n  TestPartResultReporterInterface* original_reporter_;\n\n  HasNewFatalFailureHelper(const HasNewFatalFailureHelper&amp;) = delete;\n  HasNewFatalFailureHelper&amp; operator=(const HasNewFatalFailureHelper&amp;) = delete;\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais&#x27; (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n#define GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-assertion-result.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-death-test.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-matchers.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-message.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-param-test.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-printers.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-test-part.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest-typed-test.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest_pred_impl.h&quot;  // IWYU pragma: export\n#include &quot;gtest/gtest_prod.h&quot;  // IWYU pragma: export\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// &quot;yes&quot; to enable colors, &quot;no&quot; (disable colors), or &quot;auto&quot; (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag controls whether the test runner should continue execution past\n// first failure.\nGTEST_DECLARE_bool_(fail_fast);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag controls whether Google Test installs a signal handler that dumps\n// debugging information when fatal signals are raised.\nGTEST_DECLARE_bool_(install_failure_signal_handler);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints only test failures.\nGTEST_DECLARE_bool_(brief);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flags control whether Google Test prints UTF8 characters as text.\nGTEST_DECLARE_bool_(print_utf8);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test Environments are recreated for each\n// repeat of the tests. The default value is true. If set to false the global\n// test Environment objects are only set up once, for the first iteration, and\n// only torn down once, for the last.\nGTEST_DECLARE_bool_(recreate_environments_when_repeating);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests&#x27; order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise. For use with an external test framework.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a &quot;host:port&quot; string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\nGTEST_DECLARE_string_(flagfile);\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n\nnamespace testing {\n\n// Silence C4100 (unreferenced formal parameter) and 4805\n// unsafe mix of type &#x27;const int&#x27; and type &#x27;const bool&#x27;\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4805 4100)\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass FuchsiaDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string&amp; message);\nstd::set&lt;std::string&gt;* GetIgnoredParameterizedTestSuites();\n\n// A base class that prevents subclasses from being copyable.\n// We do this instead of using &#x27;= delete&#x27; so as to avoid triggering warnings\n// inside user code regarding any of our declarations.\nclass GTestNonCopyable {\n public:\n  GTestNonCopyable() = default;\n  GTestNonCopyable(const GTestNonCopyable&amp;) = delete;\n  GTestNonCopyable&amp; operator=(const GTestNonCopyable&amp;) = delete;\n  ~GTestNonCopyable() = default;\n};\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don&#x27;t forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestSuite;\n\n// Old API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nusing TestCase = TestSuite;\n#endif\nclass TestInfo;\nclass UnitTest;\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestSuites, and\n// each TestSuite contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don&#x27;t need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used in a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // The d&#x27;tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test suite.\n  //\n  // Google Test will call Foo::SetUpTestSuite() before running the first\n  // test in test suite Foo.  Hence a sub-class can define its own\n  // SetUpTestSuite() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestSuite() {}\n\n  // Tears down the stuff shared by all tests in this test suite.\n  //\n  // Google Test will call Foo::TearDownTestSuite() after running the last\n  // test in test suite Foo.  Hence a sub-class can define its own\n  // TearDownTestSuite() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestSuite() {}\n\n  // Legacy API is deprecated but still available. Use SetUpTestSuite and\n  // TearDownTestSuite instead.\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  static void TearDownTestCase() {}\n  static void SetUpTestCase() {}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns true if and only if the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true if and only if the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true if and only if the current test was skipped.\n  static bool IsSkipped();\n\n  // Returns true if and only if the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test suite, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test suite.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the &lt;testcase&gt; element.  Properties recorded from fixture&#x27;s\n  // SetUpTestSuite or TearDownTestSuite are logged as attributes of the\n  // corresponding &lt;testsuite&gt; element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the &lt;testsuites&gt; element.\n  static void RecordProperty(const std::string&amp; key, const std::string&amp; value);\n  // We do not define a custom serialization except for values that can be\n  // converted to int64_t, but other values could be logged in this way.\n  template &lt;typename T, std::enable_if_t&lt;std::is_convertible&lt;T, int64_t&gt;::value,\n                                         bool&gt; = true&gt;\n  static void RecordProperty(const std::string&amp; key, const T&amp; value) {\n    RecordProperty(key, (Message() &lt;&lt; value).GetString());\n  }\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true if and only if the current test has the same fixture class\n  // as the first test in the current test suite.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const std::unique_ptr&lt;GTEST_FLAG_SAVER_&gt; gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user&#x27;s\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user&#x27;s test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return nullptr; }\n\n  // We disallow copying Tests.\n  Test(const Test&amp;) = delete;\n  Test&amp; operator=(const Test&amp;) = delete;\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don&#x27;t inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C&#x27;tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string&amp; a_key, const std::string&amp; a_value)\n      : key_(a_key), value_(a_value) {}\n\n  // Gets the user supplied key.\n  const char* key() const { return key_.c_str(); }\n\n  // Gets the user supplied value.\n  const char* value() const { return value_.c_str(); }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string&amp; new_value) { value_ = new_value; }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D&#x27;tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true if and only if the test passed (i.e. no test part failed).\n  bool Passed() const { return !Skipped() &amp;&amp; !Failed(); }\n\n  // Returns true if and only if the test was skipped.\n  bool Skipped() const;\n\n  // Returns true if and only if the test failed.\n  bool Failed() const;\n\n  // Returns true if and only if the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true if and only if the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Gets the time of the test case start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const { return start_timestamp_; }\n\n  // Returns the i-th test part result among all the results. i can range from 0\n  // to total_part_count() - 1. If i is not in that range, aborts the program.\n  const TestPartResult&amp; GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty&amp; GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestSuite;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n  friend class internal::FuchsiaDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector&lt;TestPartResult&gt;&amp; test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector&lt;TestProperty&gt;&amp; test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the start time.\n  void set_start_timestamp(TimeInMillis start) { start_timestamp_ = start; }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string&amp; xml_element,\n                      const TestProperty&amp; test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testsuite tags.  Returns true if the property is valid.\n  // FIXME: Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string&amp; xml_element,\n                                   const TestProperty&amp; test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult&amp; test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properties_mutex_;\n\n  // The vector of TestPartResults\n  std::vector&lt;TestPartResult&gt; test_part_results_;\n  // The vector of TestProperties\n  std::vector&lt;TestProperty&gt; test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The start time, in milliseconds since UNIX Epoch.\n  TimeInMillis start_timestamp_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  TestResult(const TestResult&amp;) = delete;\n  TestResult&amp; operator=(const TestResult&amp;) = delete;\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test suite name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don&#x27;t inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test suite name.\n  const char* test_suite_name() const { return test_suite_name_.c_str(); }\n\n// Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const char* test_case_name() const { return test_suite_name(); }\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_ != nullptr) return type_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_ != nullptr) return value_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Return true if this test should not be run because it&#x27;s in another shard.\n  bool is_in_another_shard() const { return is_in_another_shard_; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test suite Foo is defined as\n  // &quot;Foo.Bar&quot;.  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a &#x27;-&#x27; and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character &#x27;A&#x27; or starts with &quot;Foo.&quot;.\n  bool should_run() const { return should_run_; }\n\n  // Returns true if and only if this test will appear in the XML report.\n  bool is_reportable() const {\n    // The XML report includes tests matching the filter, excluding those\n    // run in other shards.\n    return matches_filter_ &amp;&amp; !is_in_another_shard_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &amp;result_; }\n\n private:\n#ifdef GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestSuite;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      std::string test_suite_name, const char* name, const char* type_param,\n      const char* value_param, internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id, internal::SetUpTestSuiteFunc set_up_tc,\n      internal::TearDownTestSuiteFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(std::string test_suite_name, std::string name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  // Skip and records the test result for this object.\n  void Skip();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info-&gt;result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_suite_name_;  // test suite name\n  const std::string name_;             // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;  // ID of the test fixture class\n  bool should_run_;           // True if and only if this test should run\n  bool is_disabled_;          // True if and only if this test is disabled\n  bool matches_filter_;       // True if this test matches the\n                              // user-specified filter.\n  bool is_in_another_shard_;  // Will be run in another shard.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  TestInfo(const TestInfo&amp;) = delete;\n  TestInfo&amp; operator=(const TestInfo&amp;) = delete;\n};\n\n// A test suite, which consists of a vector of TestInfos.\n//\n// TestSuite is not copyable.\nclass GTEST_API_ TestSuite {\n public:\n  // Creates a TestSuite with the given name.\n  //\n  // TestSuite does NOT have a default constructor.  Always use this\n  // constructor to create a TestSuite object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test suite\n  //   a_type_param: the name of the test&#x27;s type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test suite\n  //   tear_down_tc: pointer to the function that tears down the test suite\n  TestSuite(const std::string&amp; name, const char* a_type_param,\n            internal::SetUpTestSuiteFunc set_up_tc,\n            internal::TearDownTestSuiteFunc tear_down_tc);\n\n  // Destructor of TestSuite.\n  virtual ~TestSuite();\n\n  // Gets the name of the TestSuite.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test suite.\n  const char* type_param() const {\n    if (type_param_ != nullptr) return type_param_-&gt;c_str();\n    return nullptr;\n  }\n\n  // Returns true if any test in this test suite should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test suite.\n  int successful_test_count() const;\n\n  // Gets the number of skipped tests in this test suite.\n  int skipped_test_count() const;\n\n  // Gets the number of failed tests in this test suite.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test suite.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test suite that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test suite.\n  int total_test_count() const;\n\n  // Returns true if and only if the test suite passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true if and only if the test suite failed.\n  bool Failed() const {\n    return failed_test_count() &gt; 0 || ad_hoc_test_result().Failed();\n  }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Gets the time of the test suite start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const { return start_timestamp_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestSuite and TearDownTestSuite.\n  const TestResult&amp; ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestSuite.\n  std::vector&lt;TestInfo*&gt;&amp; test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestSuite.\n  const std::vector&lt;TestInfo*&gt;&amp; test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test suite.  Will delete the TestInfo upon\n  // destruction of the TestSuite object.\n  void AddTestInfo(TestInfo* test_info);\n\n  // Clears the results of all tests in this test suite.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test suite.\n  static void ClearTestSuiteResult(TestSuite* test_suite) {\n    test_suite-&gt;ClearResult();\n  }\n\n  // Runs every test in this TestSuite.\n  void Run();\n\n  // Skips the execution of tests under this TestSuite\n  void Skip();\n\n  // Runs SetUpTestSuite() for this TestSuite.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestSuite().\n  void RunSetUpTestSuite() {\n    if (set_up_tc_ != nullptr) {\n      (*set_up_tc_)();\n    }\n  }\n\n  // Runs TearDownTestSuite() for this TestSuite.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestSuite().\n  void RunTearDownTestSuite() {\n    if (tear_down_tc_ != nullptr) {\n      (*tear_down_tc_)();\n    }\n  }\n\n  // Returns true if and only if test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Passed();\n  }\n\n  // Returns true if and only if test skipped.\n  static bool TestSkipped(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Skipped();\n  }\n\n  // Returns true if and only if test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Failed();\n  }\n\n  // Returns true if and only if the test is disabled and will be reported in\n  // the XML report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info-&gt;is_reportable() &amp;&amp; test_info-&gt;is_disabled_;\n  }\n\n  // Returns true if and only if test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info-&gt;is_disabled_;\n  }\n\n  // Returns true if and only if this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info-&gt;is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info-&gt;should_run();\n  }\n\n  // Shuffles the tests in this test suite.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test suite.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const std::unique_ptr&lt;const ::std::string&gt; type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector&lt;TestInfo*&gt; test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector&lt;int&gt; test_indices_;\n  // Pointer to the function that sets up the test suite.\n  internal::SetUpTestSuiteFunc set_up_tc_;\n  // Pointer to the function that tears down the test suite.\n  internal::TearDownTestSuiteFunc tear_down_tc_;\n  // True if and only if any test in this test suite should run.\n  bool should_run_;\n  // The start time, in milliseconds since UNIX Epoch.\n  TimeInMillis start_timestamp_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestSuite and\n  // TearDownTestSuite.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestSuites.\n  TestSuite(const TestSuite&amp;) = delete;\n  TestSuite&amp; operator=(const TestSuite&amp;) = delete;\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d&#x27;tor is virtual as we need to subclass Environment.\n  virtual ~Environment() = default;\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return nullptr; }\n};\n\n#if GTEST_HAS_EXCEPTIONS\n\n// Exception which can be thrown from TestEventListener::OnTestPartResult.\nclass GTEST_API_ AssertionException\n    : public internal::GoogleTestFailureException {\n public:\n  explicit AssertionException(const TestPartResult&amp; result)\n      : GoogleTestFailureException(result) {}\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() = default;\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest&amp; unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest&amp; unit_test) = 0;\n\n  // Fired before the test suite starts.\n  virtual void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) {}\n\n  //  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  virtual void OnTestCaseStart(const TestCase&amp; /*test_case*/) {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo&amp; test_info) = 0;\n\n  // Fired when a test is disabled\n  virtual void OnTestDisabled(const TestInfo&amp; /*test_info*/) {}\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  // If you want to throw an exception from this function to skip to the next\n  // TEST, it must be AssertionException defined above, or inherited from it.\n  virtual void OnTestPartResult(const TestPartResult&amp; test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo&amp; test_info) = 0;\n\n  // Fired after the test suite ends.\n  virtual void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) {}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  virtual void OnTestCaseEnd(const TestCase&amp; /*test_case*/) {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest&amp; unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest&amp; unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; /*unit_test*/,\n                            int /*iteration*/) override {}\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override {}\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; /*test_case*/) override {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnTestStart(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestDisabled(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestPartResult(const TestPartResult&amp; /*test_part_result*/) override {}\n  void OnTestEnd(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; /*test_case*/) override {}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; /*unit_test*/,\n                          int /*iteration*/) override {}\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller&#x27;s responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  void SuppressEventForwarding(bool);\n\n private:\n  friend class TestSuite;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  TestEventListeners(const TestEventListeners&amp;) = delete;\n  TestEventListeners&amp; operator=(const TestEventListeners&amp;) = delete;\n};\n\n// A UnitTest consists of a vector of TestSuites.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestSuite object for the test that&#x27;s currently running,\n  // or NULL if no test is running.\n  const TestSuite* current_test_suite() const GTEST_LOCK_EXCLUDED_(mutex_);\n\n// Legacy API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const TestCase* current_test_case() const GTEST_LOCK_EXCLUDED_(mutex_);\n#endif\n\n  // Returns the TestInfo object for the test that&#x27;s currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n  // Returns the ParameterizedTestSuiteRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestSuiteRegistry&amp; parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Gets the number of successful test suites.\n  int successful_test_suite_count() const;\n\n  // Gets the number of failed test suites.\n  int failed_test_suite_count() const;\n\n  // Gets the number of all test suites.\n  int total_test_suite_count() const;\n\n  // Gets the number of all test suites that contain at least one test\n  // that should run.\n  int test_suite_to_run_count() const;\n\n  //  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  int successful_test_case_count() const;\n  int failed_test_case_count() const;\n  int total_test_case_count() const;\n  int test_case_to_run_count() const;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of skipped tests.\n  int skipped_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true if and only if the unit test passed (i.e. all test suites\n  // passed).\n  bool Passed() const;\n\n  // Returns true if and only if the unit test failed (i.e. some test suite\n  // failed or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  const TestSuite* GetTestSuite(int i) const;\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const TestCase* GetTestCase(int i) const;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test suites.\n  const TestResult&amp; ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners&amp; listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name, int line_number,\n                         const std::string&amp; message,\n                         const std::string&amp; os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestSuite&#x27;s ad_hoc_test_result_ when invoked\n  // from SetUpTestSuite or TearDownTestSuite, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string&amp; key, const std::string&amp; value);\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  TestSuite* GetMutableTestSuite(int i);\n\n  // Invokes OsStackTrackGetterInterface::UponLeavingGTest. UponLeavingGTest()\n  // should be called immediately before Google Test calls user code. It saves\n  // some information about the current stack that CurrentStackTrace() will use\n  // to find and hide Google Test stack frames.\n  void UponLeavingGTest();\n\n  // Sets the TestSuite object for the test that&#x27;s currently running.\n  void set_current_test_suite(TestSuite* a_current_test_suite)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Sets the TestInfo object for the test that&#x27;s currently running.\n  void set_current_test_info(TestInfo* a_current_test_info)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and functions are friends as they need to access private\n  // members of UnitTest.\n  friend class ScopedTrace;\n  friend class Test;\n  friend class TestInfo;\n  friend class TestSuite;\n  friend class internal::AssertHelper;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend std::set&lt;std::string&gt;* internal::GetIgnoredParameterizedTestSuites();\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type, const std::string&amp; message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D&#x27;tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo&amp; trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don&#x27;t mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  UnitTest(const UnitTest&amp;) = delete;\n  UnitTest&amp; operator=(const UnitTest&amp;) = delete;\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn&#x27;t guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()-&gt;AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\n// This overloaded version can be used on Arduino/embedded platforms where\n// there is no argc/argv.\nGTEST_API_ void InitGoogleTest();\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression, const T1&amp; lhs,\n                                   const T2&amp; rhs) {\n  return EqFailure(lhs_expression, rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs), false);\n}\n\n// This block of code defines operator==/!=\n// to block lexical scope lookup.\n// It prevents using invalid operator==/!= defined at namespace scope.\nstruct faketype {};\ninline bool operator==(faketype, faketype) { return true; }\ninline bool operator!=(faketype, faketype) { return false; }\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression, const T1&amp; lhs,\n                            const T2&amp; rhs) {\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template &lt;\n      typename T1, typename T2,\n      // Disable this overload for cases where one argument is a pointer\n      // and the other is the null pointer constant.\n      typename std::enable_if&lt;!std::is_integral&lt;T1&gt;::value ||\n                              !std::is_pointer&lt;T2&gt;::value&gt;::type* = nullptr&gt;\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression, const T1&amp; lhs,\n                                 const T2&amp; rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression, BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  template &lt;typename T&gt;\n  static AssertionResult Compare(\n      const char* lhs_expression, const char* rhs_expression,\n      // Handle cases where &#x27;0&#x27; is used as a null pointer literal.\n      std::nullptr_t /* lhs */, T* rhs) {\n    // We already know that &#x27;lhs&#x27; is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression, static_cast&lt;T*&gt;(nullptr),\n                       rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate &lt;typename T1, typename T2&gt;\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1&amp; val1, const T2&amp; val2,\n                                   const char* op) {\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; expr1 &lt;&lt; &quot;) &quot; &lt;&lt; op &lt;&lt; &quot; (&quot; &lt;&lt; expr2\n         &lt;&lt; &quot;), actual: &quot; &lt;&lt; FormatForComparisonFailureMessage(val1, val2)\n         &lt;&lt; &quot; vs &quot; &lt;&lt; FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)                                \\\n  template &lt;typename T1, typename T2&gt;                                      \\\n  AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                     const T1&amp; val1, const T2&amp; val2) {     \\\n    if (val1 op val2) {                                                    \\\n      return AssertionSuccess();                                           \\\n    } else {                                                               \\\n      return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);            \\\n    }                                                                      \\\n  }\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=)\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, &lt;=)\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, &lt;)\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, &gt;=)\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, &gt;)\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1, const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1, const char* s2);\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1, const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1, const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const char* needle,\n                                       const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const wchar_t* needle,\n                                       const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const char* needle,\n                                          const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const wchar_t* needle,\n                                          const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const ::std::string&amp; needle,\n                                       const ::std::string&amp; haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const ::std::string&amp; needle,\n                                          const ::std::string&amp; haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(const char* needle_expr,\n                                       const char* haystack_expr,\n                                       const ::std::wstring&amp; needle,\n                                       const ::std::wstring&amp; haystack);\nGTEST_API_ AssertionResult IsNotSubstring(const char* needle_expr,\n                                          const char* haystack_expr,\n                                          const ::std::wstring&amp; needle,\n                                          const ::std::wstring&amp; haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate &lt;typename RawType&gt;\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value, RawType rhs_value) {\n  const FloatingPoint&lt;RawType&gt; lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss.precision(std::numeric_limits&lt;RawType&gt;::digits10 + 2);\n  lhs_ss &lt;&lt; lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss.precision(std::numeric_limits&lt;RawType&gt;::digits10 + 2);\n  rhs_ss &lt;&lt; rhs_value;\n\n  return EqFailure(lhs_expression, rhs_expression,\n                   StringStreamToString(&amp;lhs_ss), StringStreamToString(&amp;rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1, double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type, const char* file, int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message&amp; message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t, const char* srcfile, int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) {}\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    AssertHelperData(const AssertHelperData&amp;) = delete;\n    AssertHelperData&amp; operator=(const AssertHelperData&amp;) = delete;\n  };\n\n  AssertHelperData* const data_;\n\n  AssertHelper(const AssertHelper&amp;) = delete;\n  AssertHelper&amp; operator=(const AssertHelper&amp;) = delete;\n};\n\n}  // namespace internal\n\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), Combine(), and ConvertGenerator&lt;T&gt;().\n//\n// class FooTest : public ::testing::TestWithParam&lt;int&gt; {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   ~FooTest() override {\n//     // Can use GetParam() here.\n//   }\n//   void SetUp() override {\n//     // Can use GetParam() here.\n//   }\n//   void TearDown override {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_SUITE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate &lt;typename T&gt;\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() = default;\n\n  // The current parameter value. Is also available in the test fixture&#x27;s\n  // constructor.\n  static const ParamType&amp; GetParam() {\n    GTEST_CHECK_(parameter_ != nullptr)\n        &lt;&lt; &quot;GetParam() can only be called inside a value-parameterized test &quot;\n        &lt;&lt; &quot;-- did you intend to write TEST_P instead of TEST_F?&quot;;\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) { parameter_ = parameter; }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface&lt;T&gt; and Test.\n  template &lt;class TestClass&gt;\n  friend class internal::ParameterizedTestFactory;\n};\n\ntemplate &lt;typename T&gt;\nconst T* WithParamInterface&lt;T&gt;::parameter_ = nullptr;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate &lt;typename T&gt;\nclass TestWithParam : public Test, public WithParamInterface&lt;T&gt; {};\n\n// Macros for indicating success/failure in test code.\n\n// Skips test in runtime.\n// Skipping test aborts current function.\n// Skipped tests are neither successful nor failed.\n#define GTEST_SKIP() GTEST_SKIP_(&quot;&quot;)\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn&#x27;t automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(&quot;Failed&quot;)\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line)        \\\n  GTEST_MESSAGE_AT_(file, line, &quot;Failed&quot;, \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(&quot;Failed&quot;)\n\n// Like GTEST_FAIL(), but at the given source file location.\n#define GTEST_FAIL_AT(file, line)                \\\n  return GTEST_MESSAGE_AT_(file, line, &quot;Failed&quot;, \\\n                           ::testing::TestPartResult::kFatalFailure)\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !(defined(GTEST_DONT_DEFINE_FAIL) &amp;&amp; GTEST_DONT_DEFINE_FAIL)\n#define FAIL() GTEST_FAIL()\n#define FAIL_AT(file, line) GTEST_FAIL_AT(file, line)\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(&quot;Succeeded&quot;)\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !(defined(GTEST_DONT_DEFINE_SUCCEED) &amp;&amp; GTEST_DONT_DEFINE_SUCCEED)\n#define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn&#x27;t throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define GTEST_EXPECT_TRUE(condition)                      \\\n  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define GTEST_EXPECT_FALSE(condition)                        \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define GTEST_ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)\n#define GTEST_ASSERT_FALSE(condition)                        \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Define these macros to 1 to omit the definition of the corresponding\n// EXPECT or ASSERT, which clashes with some users&#x27; own code.\n\n#if !(defined(GTEST_DONT_DEFINE_EXPECT_TRUE) &amp;&amp; GTEST_DONT_DEFINE_EXPECT_TRUE)\n#define EXPECT_TRUE(condition) GTEST_EXPECT_TRUE(condition)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_EXPECT_FALSE) &amp;&amp; GTEST_DONT_DEFINE_EXPECT_FALSE)\n#define EXPECT_FALSE(condition) GTEST_EXPECT_FALSE(condition)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_TRUE) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_TRUE)\n#define ASSERT_TRUE(condition) GTEST_ASSERT_TRUE(condition)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_FALSE) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_FALSE)\n#define ASSERT_FALSE(condition) GTEST_ASSERT_FALSE(condition)\n#endif\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 &lt; v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 &lt;= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 &gt; v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 &gt;= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By &quot;compatible&quot; we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(Foo(), 5);\n//   EXPECT_EQ(a_pointer, NULL);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) &lt;&lt; &quot;There is no record left.&quot;;\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users&#x27; own code.\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_EQ) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_EQ)\n#define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_NE) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_NE)\n#define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_LE) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_LE)\n#define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_LT) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_LT)\n#define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_GE) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_GE)\n#define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !(defined(GTEST_DONT_DEFINE_ASSERT_GT) &amp;&amp; GTEST_DONT_DEFINE_ASSERT_GT)\n#define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don&#x27;t depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)                                         \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)                                         \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)                                         \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)                                         \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)                                   \\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \\\n                      abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)                                   \\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \\\n                      abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n#ifdef GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n#define EXPECT_HRESULT_SUCCEEDED(expr) \\\n  EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n#define ASSERT_HRESULT_SUCCEEDED(expr) \\\n  ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n#define EXPECT_HRESULT_FAILED(expr) \\\n  EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#define ASSERT_HRESULT_FAILED(expr) \\\n  ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn&#x27;t generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) &lt;&lt; &quot;Process() failed&quot;;\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n  GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n  GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the given source file path and line number,\n// and the given message) to be included in every test failure message generated\n// by code in the scope of the lifetime of an instance of this class. The effect\n// is undone with the destruction of the instance.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// Example:\n//   testing::ScopedTrace trace(&quot;file.cc&quot;, 123, &quot;message&quot;);\n//\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c&#x27;tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n\n  // Template version. Uses Message() to convert the values into strings.\n  // Slow, but flexible.\n  template &lt;typename T&gt;\n  ScopedTrace(const char* file, int line, const T&amp; message) {\n    PushTrace(file, line, (Message() &lt;&lt; message).GetString());\n  }\n\n  // Optimize for some known types.\n  ScopedTrace(const char* file, int line, const char* message) {\n    PushTrace(file, line, message ? message : &quot;(null)&quot;);\n  }\n\n  ScopedTrace(const char* file, int line, const std::string&amp; message) {\n    PushTrace(file, line, message);\n  }\n\n  // The d&#x27;tor pops the info pushed by the c&#x27;tor.\n  //\n  // Note that the d&#x27;tor is not virtual in order to be efficient.\n  // Don&#x27;t inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  void PushTrace(const char* file, int line, std::string message);\n\n  ScopedTrace(const ScopedTrace&amp;) = delete;\n  ScopedTrace&amp; operator=(const ScopedTrace&amp;) = delete;\n};\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n//\n// Assuming that each thread maintains its own stack of traces.\n// Therefore, a SCOPED_TRACE() would (correctly) only affect the\n// assertions in its own thread.\n#define SCOPED_TRACE(message)                                               \\\n  const ::testing::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)( \\\n      __FILE__, __LINE__, (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq&lt;type1, type2&gt;() compiles if and only if type1 and type2\n// are the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq&lt;T1, T2&gt; by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq&lt;T1, T2&gt;() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template &lt;typename T&gt; class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq&lt;int, T&gt;(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo&lt;bool&gt; foo; }\n//\n// will NOT generate a compiler error, as Foo&lt;bool&gt;::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo&lt;bool&gt; foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate &lt;typename T1, typename T2&gt;\nconstexpr bool StaticAssertTypeEq() noexcept {\n  static_assert(std::is_same&lt;T1, T2&gt;::value, &quot;T1 and T2 are not the same type&quot;);\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test suite, and the second\n// parameter is the name of the test within the test suite.\n//\n// The convention is to end the test suite name with &quot;Test&quot;.  For\n// example, a test suite for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId&lt;\n// ::testing::Test&gt;() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId&lt;\n// ::testing::Test&gt;() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId&lt;&gt;() from the Google Test\n// framework.\n#define GTEST_TEST(test_suite_name, test_name)             \\\n  GTEST_TEST_(test_suite_name, test_name, ::testing::Test, \\\n              ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !(defined(GTEST_DONT_DEFINE_TEST) &amp;&amp; GTEST_DONT_DEFINE_TEST)\n#define TEST(test_suite_name, test_name) GTEST_TEST(test_suite_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test suite name.  The second parameter is the\n// name of the test within the test suite.\n//\n// A test fixture class must be declared earlier.  The user should put\n// the test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(a_.size(), 0);\n//     EXPECT_EQ(b_.size(), 1);\n//   }\n#define GTEST_TEST_F(test_fixture, test_name)        \\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId&lt;test_fixture&gt;())\n#if !(defined(GTEST_DONT_DEFINE_TEST_F) &amp;&amp; GTEST_DONT_DEFINE_TEST_F)\n#define TEST_F(test_fixture, test_name) GTEST_TEST_F(test_fixture, test_name)\n#endif\n\n// Returns a path to a temporary directory, which should be writable. It is\n// implementation-dependent whether or not the path is terminated by the\n// directory-separator character.\nGTEST_API_ std::string TempDir();\n\n// Returns a path to a directory that contains ancillary data files that might\n// be used by tests. It is implementation dependent whether or not the path is\n// terminated by the directory-separator character. The directory and the files\n// in it should be considered read-only.\nGTEST_API_ std::string SrcDir();\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4805 4100\n\n// Dynamically registers a test with the framework.\n//\n// This is an advanced API only to be used when the `TEST` macros are\n// insufficient. The macros should be preferred when possible, as they avoid\n// most of the complexity of calling this function.\n//\n// The `factory` argument is a factory callable (move-constructible) object or\n// function pointer that creates a new instance of the Test object. It\n// handles ownership to the caller. The signature of the callable is\n// `Fixture*()`, where `Fixture` is the test fixture class for the test. All\n// tests registered with the same `test_suite_name` must return the same\n// fixture type. This is checked at runtime.\n//\n// The framework will infer the fixture class from the factory and will call\n// the `SetUpTestSuite` and `TearDownTestSuite` for it.\n//\n// Must be called before `RUN_ALL_TESTS()` is invoked, otherwise behavior is\n// undefined.\n//\n// Use case example:\n//\n// class MyFixture : public ::testing::Test {\n//  public:\n//   // All of these optional, just like in regular macro usage.\n//   static void SetUpTestSuite() { ... }\n//   static void TearDownTestSuite() { ... }\n//   void SetUp() override { ... }\n//   void TearDown() override { ... }\n// };\n//\n// class MyTest : public MyFixture {\n//  public:\n//   explicit MyTest(int data) : data_(data) {}\n//   void TestBody() override { ... }\n//\n//  private:\n//   int data_;\n// };\n//\n// void RegisterMyTests(const std::vector&lt;int&gt;&amp; values) {\n//   for (int v : values) {\n//     ::testing::RegisterTest(\n//         &quot;MyFixture&quot;, (&quot;Test&quot; + std::to_string(v)).c_str(), nullptr,\n//         std::to_string(v).c_str(),\n//         __FILE__, __LINE__,\n//         // Important to use the fixture type as the return type here.\n//         [=]() -&gt; MyFixture* { return new MyTest(v); });\n//   }\n// }\n// ...\n// int main(int argc, char** argv) {\n//   ::testing::InitGoogleTest(&amp;argc, argv);\n//   std::vector&lt;int&gt; values_to_test = LoadValuesFromConfig();\n//   RegisterMyTests(values_to_test);\n//   ...\n//   return RUN_ALL_TESTS();\n// }\n//\ntemplate &lt;int&amp;... ExplicitParameterBarrier, typename Factory&gt;\nTestInfo* RegisterTest(const char* test_suite_name, const char* test_name,\n                       const char* type_param, const char* value_param,\n                       const char* file, int line, Factory factory) {\n  using TestT = typename std::remove_pointer&lt;decltype(factory())&gt;::type;\n\n  class FactoryImpl : public internal::TestFactoryBase {\n   public:\n    explicit FactoryImpl(Factory f) : factory_(std::move(f)) {}\n    Test* CreateTest() override { return factory_(); }\n\n   private:\n    Factory factory_;\n  };\n\n  return internal::MakeAndRegisterTestInfo(\n      test_suite_name, test_name, type_param, value_param,\n      internal::CodeLocation(file, line), internal::GetTypeId&lt;TestT&gt;(),\n      internal::SuiteApiResolver&lt;TestT&gt;::GetSetUpCaseOrSuite(file, line),\n      internal::SuiteApiResolver&lt;TestT&gt;::GetTearDownCaseOrSuite(file, line),\n      new FactoryImpl{std::move(factory)});\n}\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest(). RUN_ALL_TESTS will tear down and delete any\n// installed environments and should only be called once per binary.\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() { return ::testing::UnitTest::GetInstance()-&gt;Run(); }\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_GTEST_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file defines internal utilities needed for implementing\n// death tests.  They are subject to change without notice.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n\n#include &lt;stdio.h&gt;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n#include &quot;gtest/gtest-matchers.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\nGTEST_DECLARE_string_(internal_run_death_test);\n\nnamespace testing {\nnamespace internal {\n\n// Name of the flag (needed for parsing Google Test flag).\nconst char kInternalRunDeathTestFlag[] = &quot;internal_run_death_test&quot;;\n\n// A string passed to EXPECT_DEATH (etc.) is caught by one of these overloads\n// and interpreted as a regex (rather than an Eq matcher) for legacy\n// compatibility.\ninline Matcher&lt;const ::std::string&amp;&gt; MakeDeathTestMatcher(\n    ::testing::internal::RE regex) {\n  return ContainsRegex(regex.pattern());\n}\ninline Matcher&lt;const ::std::string&amp;&gt; MakeDeathTestMatcher(const char* regex) {\n  return ContainsRegex(regex);\n}\ninline Matcher&lt;const ::std::string&amp;&gt; MakeDeathTestMatcher(\n    const ::std::string&amp; regex) {\n  return ContainsRegex(regex);\n}\n\n// If a Matcher&lt;const ::std::string&amp;&gt; is passed to EXPECT_DEATH (etc.), it&#x27;s\n// used directly.\ninline Matcher&lt;const ::std::string&amp;&gt; MakeDeathTestMatcher(\n    Matcher&lt;const ::std::string&amp;&gt; matcher) {\n  return matcher;\n}\n\n#ifdef GTEST_HAS_DEATH_TEST\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// DeathTest is a class that hides much of the complexity of the\n// GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method\n// returns a concrete class that depends on the prevailing death test\n// style, as defined by the --gtest_death_test_style and/or\n// --gtest_internal_run_death_test flags.\n\n// In describing the results of death tests, these terms are used with\n// the corresponding definitions:\n//\n// exit status:  The integer exit information in the format specified\n//               by wait(2)\n// exit code:    The integer code passed to exit(3), _Exit(2), or\n//               returned from main()\nclass GTEST_API_ DeathTest {\n public:\n  // Create returns false if there was an error determining the\n  // appropriate action to take for the current death test; for example,\n  // if the gtest_death_test_style flag is set to an invalid value.\n  // The LastMessage method will return a more detailed message in that\n  // case.  Otherwise, the DeathTest pointer pointed to by the &quot;test&quot;\n  // argument is set.  If the death test should be skipped, the pointer\n  // is set to NULL; otherwise, it is set to the address of a new concrete\n  // DeathTest object that controls the execution of the current test.\n  static bool Create(const char* statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                     const char* file, int line, DeathTest** test);\n  DeathTest();\n  virtual ~DeathTest() = default;\n\n  // A helper class that aborts a death test when it&#x27;s deleted.\n  class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) {}\n    ~ReturnSentinel() { test_-&gt;Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n\n   private:\n    DeathTest* const test_;\n    ReturnSentinel(const ReturnSentinel&amp;) = delete;\n    ReturnSentinel&amp; operator=(const ReturnSentinel&amp;) = delete;\n  };\n\n  // An enumeration of possible roles that may be taken when a death\n  // test is encountered.  EXECUTE means that the death test logic should\n  // be executed immediately.  OVERSEE means that the program should prepare\n  // the appropriate environment for a child process to execute the death\n  // test, then wait for it to complete.\n  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };\n\n  // An enumeration of the three reasons that a test might be aborted.\n  enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  };\n\n  // Assumes one of the above roles.\n  virtual TestRole AssumeRole() = 0;\n\n  // Waits for the death test to finish and returns its status.\n  virtual int Wait() = 0;\n\n  // Returns true if the death test passed; that is, the test process\n  // exited during the test, its exit status matches a user-supplied\n  // predicate, and its stderr output matches a user-supplied regular\n  // expression.\n  // The user-supplied predicate may be a macro expression rather\n  // than a function pointer or functor, or else Wait and Passed could\n  // be combined.\n  virtual bool Passed(bool exit_status_ok) = 0;\n\n  // Signals that the death test did not die as expected.\n  virtual void Abort(AbortReason reason) = 0;\n\n  // Returns a human-readable outcome message regarding the outcome of\n  // the last death test.\n  static const char* LastMessage();\n\n  static void set_last_death_test_message(const std::string&amp; message);\n\n private:\n  // A string containing a description of the outcome of the last death test.\n  static std::string last_death_test_message_;\n\n  DeathTest(const DeathTest&amp;) = delete;\n  DeathTest&amp; operator=(const DeathTest&amp;) = delete;\n};\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n// Factory interface for death tests.  May be mocked out for testing.\nclass DeathTestFactory {\n public:\n  virtual ~DeathTestFactory() = default;\n  virtual bool Create(const char* statement,\n                      Matcher&lt;const std::string&amp;&gt; matcher, const char* file,\n                      int line, DeathTest** test) = 0;\n};\n\n// A concrete DeathTestFactory implementation for normal use.\nclass DefaultDeathTestFactory : public DeathTestFactory {\n public:\n  bool Create(const char* statement, Matcher&lt;const std::string&amp;&gt; matcher,\n              const char* file, int line, DeathTest** test) override;\n};\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nGTEST_API_ bool ExitedUnsuccessfully(int exit_status);\n\n// Traps C++ exceptions escaping statement and reports them as test\n// failures. Note that trapping SEH exceptions is not implemented here.\n#if GTEST_HAS_EXCEPTIONS\n#define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test)           \\\n  try {                                                                      \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);               \\\n  } catch (const ::std::exception&amp; gtest_exception) {                        \\\n    fprintf(                                                                 \\\n        stderr,                                                              \\\n        &quot;\\n%s: Caught std::exception-derived exception escaping the &quot;        \\\n        &quot;death test statement. Exception message: %s\\n&quot;,                     \\\n        ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \\\n        gtest_exception.what());                                             \\\n    fflush(stderr);                                                          \\\n    death_test-&gt;Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  } catch (...) {                                                            \\\n    death_test-&gt;Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  }\n\n#else\n#define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)\n\n#endif\n\n// This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,\n// ASSERT_EXIT*, and EXPECT_EXIT*.\n#define GTEST_DEATH_TEST_(statement, predicate, regex_or_matcher, fail)        \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                                \\\n  if (::testing::internal::AlwaysTrue()) {                                     \\\n    ::testing::internal::DeathTest* gtest_dt;                                  \\\n    if (!::testing::internal::DeathTest::Create(                               \\\n            #statement,                                                        \\\n            ::testing::internal::MakeDeathTestMatcher(regex_or_matcher),       \\\n            __FILE__, __LINE__, &amp;gtest_dt)) {                                  \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__);                        \\\n    }                                                                          \\\n    if (gtest_dt != nullptr) {                                                 \\\n      std::unique_ptr&lt; ::testing::internal::DeathTest&gt; gtest_dt_ptr(gtest_dt); \\\n      switch (gtest_dt-&gt;AssumeRole()) {                                        \\\n        case ::testing::internal::DeathTest::OVERSEE_TEST:                     \\\n          if (!gtest_dt-&gt;Passed(predicate(gtest_dt-&gt;Wait()))) {                \\\n            goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__);                  \\\n          }                                                                    \\\n          break;                                                               \\\n        case ::testing::internal::DeathTest::EXECUTE_TEST: {                   \\\n          const ::testing::internal::DeathTest::ReturnSentinel gtest_sentinel( \\\n              gtest_dt);                                                       \\\n          GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt);            \\\n          gtest_dt-&gt;Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE);   \\\n          break;                                                               \\\n        }                                                                      \\\n      }                                                                        \\\n    }                                                                          \\\n  } else                                                                       \\\n    GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__)                                \\\n        : fail(::testing::internal::DeathTest::LastMessage())\n// The symbol &quot;fail&quot; here expands to something into which a message\n// can be streamed.\n\n// This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in\n// NDEBUG mode. In this case we need the statements to be executed and the macro\n// must accept a streamed message even though the message is never printed.\n// The regex object is not evaluated, but it is used to prevent &quot;unused&quot;\n// warnings and to avoid an expression that doesn&#x27;t compile in debug mode.\n#define GTEST_EXECUTE_STATEMENT_(statement, regex_or_matcher)    \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                  \\\n  if (::testing::internal::AlwaysTrue()) {                       \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);   \\\n  } else if (!::testing::internal::AlwaysTrue()) {               \\\n    ::testing::internal::MakeDeathTestMatcher(regex_or_matcher); \\\n  } else                                                         \\\n    ::testing::Message()\n\n// A class representing the parsed contents of the\n// --gtest_internal_run_death_test flag, as it existed when\n// RUN_ALL_TESTS was called.\nclass InternalRunDeathTestFlag {\n public:\n  InternalRunDeathTestFlag(const std::string&amp; a_file, int a_line, int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index), write_fd_(a_write_fd) {}\n\n  ~InternalRunDeathTestFlag() {\n    if (write_fd_ &gt;= 0) posix::Close(write_fd_);\n  }\n\n  const std::string&amp; file() const { return file_; }\n  int line() const { return line_; }\n  int index() const { return index_; }\n  int write_fd() const { return write_fd_; }\n\n private:\n  std::string file_;\n  int line_;\n  int index_;\n  int write_fd_;\n\n  InternalRunDeathTestFlag(const InternalRunDeathTestFlag&amp;) = delete;\n  InternalRunDeathTestFlag&amp; operator=(const InternalRunDeathTestFlag&amp;) = delete;\n};\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-filepath.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-filepath.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-filepath.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Test filepath utilities\n//\n// This header file declares classes and functions used internally by\n// Google Test.  They are subject to change without notice.\n//\n// This file is #included in gtest/internal/gtest-internal.h.\n// Do not include this header file separately!\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n#if GTEST_HAS_FILE_SYSTEM\n\nnamespace testing {\nnamespace internal {\n\n// FilePath - a class for file and directory pathname manipulation which\n// handles platform-specific conventions (like the pathname separator).\n// Used for helper functions for naming files in a directory for xml output.\n// Except for Set methods, all methods are const or static, which provides an\n// &quot;immutable value object&quot; -- useful for peace of mind.\n// A FilePath with a value ending in a path separator (&quot;like/this/&quot;) represents\n// a directory, otherwise it is assumed to represent a file. In either case,\n// it may or may not represent an actual file or directory in the file system.\n// Names are NOT checked for syntax correctness -- no checking for illegal\n// characters, malformed paths, etc.\n\nclass GTEST_API_ FilePath {\n public:\n  FilePath() : pathname_(&quot;&quot;) {}\n  FilePath(const FilePath&amp; rhs) : pathname_(rhs.pathname_) {}\n  FilePath(FilePath&amp;&amp; rhs) noexcept : pathname_(std::move(rhs.pathname_)) {}\n\n  explicit FilePath(std::string pathname) : pathname_(std::move(pathname)) {\n    Normalize();\n  }\n\n  FilePath&amp; operator=(const FilePath&amp; rhs) {\n    Set(rhs);\n    return *this;\n  }\n  FilePath&amp; operator=(FilePath&amp;&amp; rhs) noexcept {\n    pathname_ = std::move(rhs.pathname_);\n    return *this;\n  }\n\n  void Set(const FilePath&amp; rhs) { pathname_ = rhs.pathname_; }\n\n  const std::string&amp; string() const { return pathname_; }\n  const char* c_str() const { return pathname_.c_str(); }\n\n  // Returns the current working directory, or &quot;&quot; if unsuccessful.\n  static FilePath GetCurrentDir();\n\n  // Given directory = &quot;dir&quot;, base_name = &quot;test&quot;, number = 0,\n  // extension = &quot;xml&quot;, returns &quot;dir/test.xml&quot;. If number is greater\n  // than zero (e.g., 12), returns &quot;dir/test_12.xml&quot;.\n  // On Windows platform, uses \\ as the separator rather than /.\n  static FilePath MakeFileName(const FilePath&amp; directory,\n                               const FilePath&amp; base_name, int number,\n                               const char* extension);\n\n  // Given directory = &quot;dir&quot;, relative_path = &quot;test.xml&quot;,\n  // returns &quot;dir/test.xml&quot;.\n  // On Windows, uses \\ as the separator rather than /.\n  static FilePath ConcatPaths(const FilePath&amp; directory,\n                              const FilePath&amp; relative_path);\n\n  // Returns a pathname for a file that does not currently exist. The pathname\n  // will be directory/base_name.extension or\n  // directory/base_name_&lt;number&gt;.extension if directory/base_name.extension\n  // already exists. The number will be incremented until a pathname is found\n  // that does not already exist.\n  // Examples: &#x27;dir/foo_test.xml&#x27; or &#x27;dir/foo_test_1.xml&#x27;.\n  // There could be a race condition if two or more processes are calling this\n  // function at the same time -- they could both pick the same filename.\n  static FilePath GenerateUniqueFileName(const FilePath&amp; directory,\n                                         const FilePath&amp; base_name,\n                                         const char* extension);\n\n  // Returns true if and only if the path is &quot;&quot;.\n  bool IsEmpty() const { return pathname_.empty(); }\n\n  // If input name has a trailing separator character, removes it and returns\n  // the name, otherwise return the name string unmodified.\n  // On Windows platform, uses \\ as the separator, other platforms use /.\n  FilePath RemoveTrailingPathSeparator() const;\n\n  // Returns a copy of the FilePath with the directory part removed.\n  // Example: FilePath(&quot;path/to/file&quot;).RemoveDirectoryName() returns\n  // FilePath(&quot;file&quot;). If there is no directory part (&quot;just_a_file&quot;), it returns\n  // the FilePath unmodified. If there is no file part (&quot;just_a_dir/&quot;) it\n  // returns an empty FilePath (&quot;&quot;).\n  // On Windows platform, &#x27;\\&#x27; is the path separator, otherwise it is &#x27;/&#x27;.\n  FilePath RemoveDirectoryName() const;\n\n  // RemoveFileName returns the directory path with the filename removed.\n  // Example: FilePath(&quot;path/to/file&quot;).RemoveFileName() returns &quot;path/to/&quot;.\n  // If the FilePath is &quot;a_file&quot; or &quot;/a_file&quot;, RemoveFileName returns\n  // FilePath(&quot;./&quot;) or, on Windows, FilePath(&quot;.\\\\&quot;). If the filepath does\n  // not have a file, like &quot;just/a/dir/&quot;, it returns the FilePath unmodified.\n  // On Windows platform, &#x27;\\&#x27; is the path separator, otherwise it is &#x27;/&#x27;.\n  FilePath RemoveFileName() const;\n\n  // Returns a copy of the FilePath with the case-insensitive extension removed.\n  // Example: FilePath(&quot;dir/file.exe&quot;).RemoveExtension(&quot;EXE&quot;) returns\n  // FilePath(&quot;dir/file&quot;). If a case-insensitive extension is not\n  // found, returns a copy of the original FilePath.\n  FilePath RemoveExtension(const char* extension) const;\n\n  // Creates directories so that path exists. Returns true if successful or if\n  // the directories already exist; returns false if unable to create\n  // directories for any reason. Will also return false if the FilePath does\n  // not represent a directory (that is, it doesn&#x27;t end with a path separator).\n  bool CreateDirectoriesRecursively() const;\n\n  // Create the directory so that path exists. Returns true if successful or\n  // if the directory already exists; returns false if unable to create the\n  // directory for any reason, including if the parent directory does not\n  // exist. Not named &quot;CreateDirectory&quot; because that&#x27;s a macro on Windows.\n  bool CreateFolder() const;\n\n  // Returns true if FilePath describes something in the file-system,\n  // either a file, directory, or whatever, and that something exists.\n  bool FileOrDirectoryExists() const;\n\n  // Returns true if pathname describes a directory in the file-system\n  // that exists.\n  bool DirectoryExists() const;\n\n  // Returns true if FilePath ends with a path separator, which indicates that\n  // it is intended to represent a directory. Returns false otherwise.\n  // This does NOT check that a directory (or file) actually exists.\n  bool IsDirectory() const;\n\n  // Returns true if pathname describes a root directory. (Windows has one\n  // root directory per disk drive.)\n  bool IsRootDirectory() const;\n\n  // Returns true if pathname describes an absolute path.\n  bool IsAbsolutePath() const;\n\n private:\n  // Replaces multiple consecutive separators with a single separator.\n  // For example, &quot;bar///foo&quot; becomes &quot;bar/foo&quot;. Does not eliminate other\n  // redundancies that might be in a pathname involving &quot;.&quot; or &quot;..&quot;.\n  //\n  // A pathname with multiple consecutive separators may occur either through\n  // user error or as a result of some scripts or APIs that generate a pathname\n  // with a trailing separator. On other platforms the same API or script\n  // may NOT generate a pathname with a trailing &quot;/&quot;. Then elsewhere that\n  // pathname may have another &quot;/&quot; and pathname components added to it,\n  // without checking for the separator already being there.\n  // The script language and operating system may allow paths like &quot;foo//bar&quot;\n  // but some of the functions in FilePath will not handle that correctly. In\n  // particular, RemoveTrailingPathSeparator() only removes one separator, and\n  // it is called in CreateDirectoriesRecursively() assuming that it will change\n  // a pathname from directory syntax (trailing separator) to filename syntax.\n  //\n  // On Windows this method also replaces the alternate path separator &#x27;/&#x27; with\n  // the primary path separator &#x27;\\\\&#x27;, so that for example &quot;bar\\\\/\\\\foo&quot; becomes\n  // &quot;bar\\\\foo&quot;.\n\n  void Normalize();\n\n  // Returns a pointer to the last occurrence of a valid path separator in\n  // the FilePath. On Windows, for example, both &#x27;/&#x27; and &#x27;\\&#x27; are valid path\n  // separators. Returns NULL if no path separator was found.\n  const char* FindLastPathSeparator() const;\n\n  // Returns the length of the path root, including the directory separator at\n  // the end of the prefix. Returns zero by definition if the path is relative.\n  // Examples:\n  // - [Windows] &quot;..\\Sibling&quot; =&gt; 0\n  // - [Windows] &quot;\\Windows&quot; =&gt; 1\n  // - [Windows] &quot;C:/Windows\\Notepad.exe&quot; =&gt; 3\n  // - [Windows] &quot;\\\\Host\\Share\\C$/Windows&quot; =&gt; 13\n  // - [UNIX] &quot;/bin&quot; =&gt; 1\n  size_t CalculateRootLength() const;\n\n  std::string pathname_;\n};  // class FilePath\n\n}  // namespace internal\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// The Google C++ Testing and Mocking Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#ifdef GTEST_OS_LINUX\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n#include &lt;stdexcept&gt;\n#endif\n\n#include &lt;ctype.h&gt;\n#include &lt;float.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;functional&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-filepath.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;gtest/internal/gtest-type-util.h&quot;\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// https://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo##bar\n\n// Stringifies its argument.\n// Work around a bug in visual studio which doesn&#x27;t accept code like this:\n//\n//   #define GTEST_STRINGIFY_(name) #name\n//   #define MACRO(a, b, c) ... GTEST_STRINGIFY_(a) ...\n//   MACRO(, x, y)\n//\n// Complaining about the argument to GTEST_STRINGIFY_ being empty.\n// This is allowed by the spec.\n#define GTEST_STRINGIFY_HELPER_(name, ...) #name\n#define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )\n\nnamespace proto2 {\nclass MessageLite;\n}\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;  // Result of an assertion.\nclass Message;          // Represents a failure message.\nclass Test;             // Represents a test.\nclass TestInfo;         // Information about a test.\nclass TestPartResult;   // Result of a test part.\nclass UnitTest;         // A collection of test suites.\n\ntemplate &lt;typename T&gt;\n::std::string PrintToString(const T&amp; value);\n\nnamespace internal {\n\nstruct TraceInfo;    // Information about a trace point.\nclass TestInfoImpl;  // Opaque implementation of TestInfo\nclass UnitTestImpl;  // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// An IgnoredValue object can be implicitly constructed from ANY value.\nclass IgnoredValue {\n  struct Sink {};\n\n public:\n  // This constructor template allows any value to be implicitly\n  // converted to IgnoredValue.  The object has no data member and\n  // doesn&#x27;t try to remember anything about the argument.  We\n  // deliberately omit the &#x27;explicit&#x27; keyword in order to allow the\n  // conversion to be implicit.\n  // Disable the conversion if T already has a magical conversion operator.\n  // Otherwise we get ambiguity.\n  template &lt;typename T,\n            typename std::enable_if&lt;!std::is_convertible&lt;T, Sink&gt;::value,\n                                    int&gt;::type = 0&gt;\n  IgnoredValue(const T&amp; /* ignored */) {}  // NOLINT(runtime/explicit)\n};\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(const std::string&amp; gtest_msg,\n                                         const Message&amp; user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(\n    4275 /* an exported class was derived from a class that was not exported */)\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult&amp; failure);\n};\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4275\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\nnamespace edit_distance {\n// Returns the optimal edits to go from &#x27;left&#x27; to &#x27;right&#x27;.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner-Fischer algorithm.\n// See https://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;size_t&gt;&amp; left, const std::vector&lt;size_t&gt;&amp; right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;std::string&gt;&amp; left,\n    const std::vector&lt;std::string&gt;&amp; right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,\n                                         const std::vector&lt;std::string&gt;&amp; right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: &quot;foo&quot;\n//   actual_expression:   &quot;bar&quot;\n//   expected_value:      &quot;5&quot;\n//   actual_value:        &quot;6&quot;\n//\n// The ignoring_case parameter is true if and only if the assertion is a\n// *_STRCASEEQ*.  When it&#x27;s true, the string &quot; (ignoring case)&quot; will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string&amp; expected_value,\n                                     const std::string&amp; actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult&amp; assertion_result, const char* expression_text,\n    const char* actual_predicate_value, const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it&#x27;s very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn&#x27;t work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   https://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate &lt;typename RawType&gt;\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize&lt;sizeof(RawType)&gt;::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8 * sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n      std::numeric_limits&lt;RawType&gt;::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast&lt;Bits&gt;(1) &lt;&lt; (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask = ~static_cast&lt;Bits&gt;(0) &gt;&gt;\n                                       (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP&#x27;s (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU&#x27;s, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const uint32_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don&#x27;t expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType&amp; x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() { return ReinterpretBits(kExponentBitMask); }\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits&amp; bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask &amp; u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask &amp; u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask &amp; u_.bits_; }\n\n  // Returns true if and only if this is NAN (not a number).\n  bool is_nan() const {\n    // It&#x27;s a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) &amp;&amp; (fraction_bits() != 0);\n  }\n\n  // Returns true if and only if this number is at most kMaxUlps ULP&#x27;s away\n  // from rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP&#x27;s apart.\n  bool AlmostEquals(const FloatingPoint&amp; rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_) &lt;=\n           kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read https://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits&amp; sam) {\n    if (kSignBitMask &amp; sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits&amp; sam1,\n                                                     const Bits&amp; sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 &gt;= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint&lt;float&gt; Float;\ntypedef FloatingPoint&lt;double&gt; Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test suite, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate &lt;typename T&gt;\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 &amp; 8.0) may try to merge\n  // TypeIdHelper&lt;T&gt;::dummy_ for different Ts as an &quot;optimization&quot;.\n  static bool dummy_;\n};\n\ntemplate &lt;typename T&gt;\nbool TypeIdHelper&lt;T&gt;::dummy_ = false;\n\n// GetTypeId&lt;T&gt;() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate &lt;typename T&gt;\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper&lt;T&gt;::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &amp;(TypeIdHelper&lt;T&gt;::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() = default;\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  TestFactoryBase(const TestFactoryBase&amp;) = delete;\n  TestFactoryBase&amp; operator=(const TestFactoryBase&amp;) = delete;\n};\n\n// This class provides implementation of TestFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate &lt;class TestClass&gt;\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  Test* CreateTest() override { return new TestClass; }\n};\n\n#ifdef GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestSuite() and TearDownTestSuite() functions.\nusing SetUpTestSuiteFunc = void (*)();\nusing TearDownTestSuiteFunc = void (*)();\n\nstruct CodeLocation {\n  CodeLocation(std::string a_file, int a_line)\n      : file(std::move(a_file)), line(a_line) {}\n\n  std::string file;\n  int line;\n};\n\n//  Helper to identify which setup function for TestCase / TestSuite to call.\n//  Only one function is allowed, either TestCase or TestSute but not both.\n\n// Utility functions to help SuiteApiResolver\nusing SetUpTearDownSuiteFuncType = void (*)();\n\ninline SetUpTearDownSuiteFuncType GetNotDefaultOrNull(\n    SetUpTearDownSuiteFuncType a, SetUpTearDownSuiteFuncType def) {\n  return a == def ? nullptr : a;\n}\n\ntemplate &lt;typename T&gt;\n//  Note that SuiteApiResolver inherits from T because\n//  SetUpTestSuite()/TearDownTestSuite() could be protected. This way\n//  SuiteApiResolver can access them.\nstruct SuiteApiResolver : T {\n  // testing::Test is only forward declared at this point. So we make it a\n  // dependent class for the compiler to be OK with it.\n  using Test =\n      typename std::conditional&lt;sizeof(T) != 0, ::testing::Test, void&gt;::type;\n\n  static SetUpTearDownSuiteFuncType GetSetUpCaseOrSuite(const char* filename,\n                                                        int line_num) {\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n    SetUpTearDownSuiteFuncType test_case_fp =\n        GetNotDefaultOrNull(&amp;T::SetUpTestCase, &amp;Test::SetUpTestCase);\n    SetUpTearDownSuiteFuncType test_suite_fp =\n        GetNotDefaultOrNull(&amp;T::SetUpTestSuite, &amp;Test::SetUpTestSuite);\n\n    GTEST_CHECK_(!test_case_fp || !test_suite_fp)\n        &lt;&lt; &quot;Test can not provide both SetUpTestSuite and SetUpTestCase, please &quot;\n           &quot;make sure there is only one present at &quot;\n        &lt;&lt; filename &lt;&lt; &quot;:&quot; &lt;&lt; line_num;\n\n    return test_case_fp != nullptr ? test_case_fp : test_suite_fp;\n#else\n    (void)(filename);\n    (void)(line_num);\n    return &amp;T::SetUpTestSuite;\n#endif\n  }\n\n  static SetUpTearDownSuiteFuncType GetTearDownCaseOrSuite(const char* filename,\n                                                           int line_num) {\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n    SetUpTearDownSuiteFuncType test_case_fp =\n        GetNotDefaultOrNull(&amp;T::TearDownTestCase, &amp;Test::TearDownTestCase);\n    SetUpTearDownSuiteFuncType test_suite_fp =\n        GetNotDefaultOrNull(&amp;T::TearDownTestSuite, &amp;Test::TearDownTestSuite);\n\n    GTEST_CHECK_(!test_case_fp || !test_suite_fp)\n        &lt;&lt; &quot;Test can not provide both TearDownTestSuite and TearDownTestCase,&quot;\n           &quot; please make sure there is only one present at&quot;\n        &lt;&lt; filename &lt;&lt; &quot;:&quot; &lt;&lt; line_num;\n\n    return test_case_fp != nullptr ? test_case_fp : test_suite_fp;\n#else\n    (void)(filename);\n    (void)(line_num);\n    return &amp;T::TearDownTestSuite;\n#endif\n  }\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_suite_name:  name of the test suite\n//   name:             name of the test\n//   type_param:       the name of the test&#x27;s type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param:      text representation of the test&#x27;s value parameter,\n//                     or NULL if this is not a value-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test suite\n//   tear_down_tc:     pointer to the function that tears down the test suite\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    std::string test_suite_name, const char* name, const char* type_param,\n    const char* value_param, CodeLocation code_location,\n    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,\n    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// State of the definition of a type-parameterized test suite.\nclass GTEST_API_ TypedTestSuitePState {\n public:\n  TypedTestSuitePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test suite hasn&#x27;t been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr,\n              &quot;%s Test %s must be defined before &quot;\n              &quot;REGISTER_TYPED_TEST_SUITE_P(%s, ...).\\n&quot;,\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.emplace(test_name, CodeLocation(file, line));\n    return true;\n  }\n\n  bool TestExists(const std::string&amp; test_name) const {\n    return registered_tests_.count(test_name) &gt; 0;\n  }\n\n  const CodeLocation&amp; GetCodeLocation(const std::string&amp; test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it-&gt;second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(const char* test_suite_name,\n                                        const char* file, int line,\n                                        const char* registered_tests);\n\n private:\n  typedef ::std::map&lt;std::string, CodeLocation, std::less&lt;&gt;&gt; RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nusing TypedTestCasePState = TypedTestSuitePState;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n// Skips to the first non-space char after the first comma in &#x27;str&#x27;;\n// returns NULL if no comma is found in &#x27;str&#x27;.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, &#x27;,&#x27;);\n  if (comma == nullptr) {\n    return nullptr;\n  }\n  while (IsSpace(*(++comma))) {\n  }\n  return comma;\n}\n\n// Returns the prefix of &#x27;str&#x27; before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, &#x27;,&#x27;);\n  return comma == nullptr ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string&amp; str, char delimiter,\n                 ::std::vector&lt;::std::string&gt;* dest);\n\n// The default argument to the template below for the case when the user does\n// not provide a name generator.\nstruct DefaultNameGenerator {\n  template &lt;typename T&gt;\n  static std::string GetName(int i) {\n    return StreamableToString(i);\n  }\n};\n\ntemplate &lt;typename Provided = DefaultNameGenerator&gt;\nstruct NameGeneratorSelector {\n  typedef Provided type;\n};\n\ntemplate &lt;typename NameGenerator&gt;\nvoid GenerateNamesRecursively(internal::None, std::vector&lt;std::string&gt;*, int) {}\n\ntemplate &lt;typename NameGenerator, typename Types&gt;\nvoid GenerateNamesRecursively(Types, std::vector&lt;std::string&gt;* result, int i) {\n  result-&gt;push_back(NameGenerator::template GetName&lt;typename Types::Head&gt;(i));\n  GenerateNamesRecursively&lt;NameGenerator&gt;(typename Types::Tail(), result,\n                                          i + 1);\n}\n\ntemplate &lt;typename NameGenerator, typename Types&gt;\nstd::vector&lt;std::string&gt; GenerateNames() {\n  std::vector&lt;std::string&gt; result;\n  GenerateNamesRecursively&lt;NameGenerator&gt;(Types(), &amp;result, 0);\n  return result;\n}\n\n// TypeParameterizedTest&lt;Fixture, TestSel, Types&gt;::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It&#x27;s defined in gtest-type-util.h.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, class TestSel, typename Types&gt;\nclass TypeParameterizedTest {\n public:\n  // &#x27;index&#x27; is the index of the test in the type list &#x27;Types&#x27;\n  // specified in INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, TestSuite,\n  // Types).  Valid values for &#x27;index&#x27; are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const char* case_name, const char* test_names, int index,\n                       const std::vector&lt;std::string&gt;&amp; type_names =\n                           GenerateNames&lt;DefaultNameGenerator, Types&gt;()) {\n    typedef typename Types::Head Type;\n    typedef Fixture&lt;Type&gt; FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == &#x27;\\0&#x27; ? &quot;&quot; : &quot;/&quot;) + case_name +\n         &quot;/&quot; + type_names[static_cast&lt;size_t&gt;(index)]),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName&lt;Type&gt;().c_str(),\n        nullptr,  // No value parameter.\n        code_location, GetTypeId&lt;FixtureClass&gt;(),\n        SuiteApiResolver&lt;TestClass&gt;::GetSetUpCaseOrSuite(\n            code_location.file.c_str(), code_location.line),\n        SuiteApiResolver&lt;TestClass&gt;::GetTearDownCaseOrSuite(\n            code_location.file.c_str(), code_location.line),\n        new TestFactoryImpl&lt;TestClass&gt;);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest&lt;Fixture, TestSel, typename Types::Tail&gt;::\n        Register(prefix, std::move(code_location), case_name, test_names,\n                 index + 1, type_names);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, class TestSel&gt;\nclass TypeParameterizedTest&lt;Fixture, TestSel, internal::None&gt; {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/,\n                       const std::vector&lt;std::string&gt;&amp; =\n                           std::vector&lt;std::string&gt;() /*type_names*/) {\n    return true;\n  }\n};\n\nGTEST_API_ void RegisterTypeParameterizedTestSuite(const char* test_suite_name,\n                                                   CodeLocation code_location);\nGTEST_API_ void RegisterTypeParameterizedTestSuiteInstantiation(\n    const char* case_name);\n\n// TypeParameterizedTestSuite&lt;Fixture, Tests, Types&gt;::Register()\n// registers *all combinations* of &#x27;Tests&#x27; and &#x27;Types&#x27; with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, typename Tests, typename Types&gt;\nclass TypeParameterizedTestSuite {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestSuitePState* state, const char* case_name,\n                       const char* test_names,\n                       const std::vector&lt;std::string&gt;&amp; type_names =\n                           GenerateNames&lt;DefaultNameGenerator, Types&gt;()) {\n    RegisterTypeParameterizedTestSuiteInstantiation(case_name);\n    std::string test_name =\n        StripTrailingSpaces(GetPrefixUntilComma(test_names));\n    if (!state-&gt;TestExists(test_name)) {\n      fprintf(stderr, &quot;Failed to get code location for test %s.%s at %s.&quot;,\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(), code_location.line)\n                  .c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation&amp; test_location = state-&gt;GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in &#x27;Test&#x27; for each type in &#x27;Types&#x27;.\n    TypeParameterizedTest&lt;Fixture, Head, Types&gt;::Register(\n        prefix, test_location, case_name, test_names, 0, type_names);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestSuite&lt;Fixture, typename Tests::Tail,\n                                      Types&gt;::Register(prefix,\n                                                       std::move(code_location),\n                                                       state, case_name,\n                                                       SkipComma(test_names),\n                                                       type_names);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate &lt;GTEST_TEMPLATE_ Fixture, typename Types&gt;\nclass TypeParameterizedTestSuite&lt;Fixture, internal::None, Types&gt; {\n public:\n  static bool Register(const char* /*prefix*/, const CodeLocation&amp;,\n                       const TypedTestSuitePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       const std::vector&lt;std::string&gt;&amp; =\n                           std::vector&lt;std::string&gt;() /*type_names*/) {\n    return true;\n  }\n};\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won&#x27;t.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// Helper for declaring std::string within &#x27;if&#x27; statement\n// in pre C++17 build environment.\nstruct TrueWithString {\n  TrueWithString() = default;\n  explicit TrueWithString(const char* str) : value(str) {}\n  explicit TrueWithString(const std::string&amp; str) : value(str) {}\n  explicit operator bool() const { return true; }\n  std::string value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn&#x27;t use global state (and therefore can&#x27;t interfere with user\n// code).  Unlike rand_r(), it&#x27;s portable.  An LCG isn&#x27;t very random,\n// but it&#x27;s good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const uint32_t kMaxRange = 1u &lt;&lt; 31;\n\n  explicit Random(uint32_t seed) : state_(seed) {}\n\n  void Reseed(uint32_t seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if &#x27;range&#x27; is\n  // 0 or greater than kMaxRange.\n  uint32_t Generate(uint32_t range);\n\n private:\n  uint32_t state_;\n  Random(const Random&amp;) = delete;\n  Random&amp; operator=(const Random&amp;) = delete;\n};\n\n// Turns const U&amp;, U&amp;, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n  typename std::remove_const&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type\n\n// HasDebugStringAndShortDebugString&lt;T&gt;::value is a compile-time bool constant\n// that&#x27;s true if and only if T has methods DebugString() and ShortDebugString()\n// that return std::string.\ntemplate &lt;typename T&gt;\nclass HasDebugStringAndShortDebugString {\n private:\n  template &lt;typename C&gt;\n  static auto CheckDebugString(C*) -&gt; typename std::is_same&lt;\n      std::string, decltype(std::declval&lt;const C&gt;().DebugString())&gt;::type;\n  template &lt;typename&gt;\n  static std::false_type CheckDebugString(...);\n\n  template &lt;typename C&gt;\n  static auto CheckShortDebugString(C*) -&gt; typename std::is_same&lt;\n      std::string, decltype(std::declval&lt;const C&gt;().ShortDebugString())&gt;::type;\n  template &lt;typename&gt;\n  static std::false_type CheckShortDebugString(...);\n\n  using HasDebugStringType = decltype(CheckDebugString&lt;T&gt;(nullptr));\n  using HasShortDebugStringType = decltype(CheckShortDebugString&lt;T&gt;(nullptr));\n\n public:\n  static constexpr bool value =\n      HasDebugStringType::value &amp;&amp; HasShortDebugStringType::value;\n};\n\n#ifdef GTEST_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL\ntemplate &lt;typename T&gt;\nconstexpr bool HasDebugStringAndShortDebugString&lt;T&gt;::value;\n#endif\n\n// When the compiler sees expression IsContainerTest&lt;C&gt;(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as &#x27;int&#x27; is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest&lt;C&gt;(0).\n// The value of the expression is insignificant.\n//\n// In C++11 mode we check the existence of a const_iterator and that an\n// iterator is properly implemented for the container.\n//\n// For pre-C++11 that we look for both C::iterator and C::const_iterator.\n// The reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// &#x27;iterator&#x27; or &#x27;iterator::iterator&#x27;).  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn&#x27;t work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate &lt;class C,\n          class Iterator = decltype(::std::declval&lt;const C&amp;&gt;().begin()),\n          class = decltype(::std::declval&lt;const C&amp;&gt;().end()),\n          class = decltype(++::std::declval&lt;Iterator&amp;&gt;()),\n          class = decltype(*::std::declval&lt;Iterator&gt;()),\n          class = typename C::const_iterator&gt;\nIsContainer IsContainerTest(int /* dummy */) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate &lt;class C&gt;\nIsNotContainer IsContainerTest(long /* dummy */) {\n  return &#x27;\\0&#x27;;\n}\n\n// Trait to detect whether a type T is a hash table.\n// The heuristic used is that the type contains an inner type `hasher` and does\n// not contain an inner type `reverse_iterator`.\n// If the container is iterable in reverse, then order might actually matter.\ntemplate &lt;typename T&gt;\nstruct IsHashTable {\n private:\n  template &lt;typename U&gt;\n  static char test(typename U::hasher*, typename U::reverse_iterator*);\n  template &lt;typename U&gt;\n  static int test(typename U::hasher*, ...);\n  template &lt;typename U&gt;\n  static char test(...);\n\n public:\n  static const bool value = sizeof(test&lt;T&gt;(nullptr, nullptr)) == sizeof(int);\n};\n\ntemplate &lt;typename T&gt;\nconst bool IsHashTable&lt;T&gt;::value;\n\ntemplate &lt;typename C,\n          bool = sizeof(IsContainerTest&lt;C&gt;(0)) == sizeof(IsContainer)&gt;\nstruct IsRecursiveContainerImpl;\n\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainerImpl&lt;C, false&gt; : public std::false_type {};\n\n// Since the IsRecursiveContainerImpl depends on the IsContainerTest we need to\n// obey the same inconsistencies as the IsContainerTest, namely check if\n// something is a container is relying on only const_iterator in C++11 and\n// is relying on both const_iterator and iterator otherwise\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainerImpl&lt;C, true&gt; {\n  using value_type = decltype(*std::declval&lt;typename C::const_iterator&gt;());\n  using type =\n      std::is_same&lt;typename std::remove_const&lt;\n                       typename std::remove_reference&lt;value_type&gt;::type&gt;::type,\n                   C&gt;;\n};\n\n// IsRecursiveContainer&lt;Type&gt; is a unary compile-time predicate that\n// evaluates whether C is a recursive container type. A recursive container\n// type is a container type whose value_type is equal to the container type\n// itself. An example for a recursive container type is\n// boost::filesystem::path, whose iterator has a value_type that is equal to\n// boost::filesystem::path.\ntemplate &lt;typename C&gt;\nstruct IsRecursiveContainer : public IsRecursiveContainerImpl&lt;C&gt;::type {};\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements&#x27; operator==, where k can be any integer &gt;= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate &lt;typename T, typename U&gt;\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate &lt;typename T, typename U&gt;\ninline bool ArrayEq(const T&amp; lhs, const U&amp; rhs) {\n  return lhs == rhs;\n}\n\n// This overload is used when k &gt;= 1.\ntemplate &lt;typename T, typename U, size_t N&gt;\ninline bool ArrayEq(const T (&amp;lhs)[N], const U (&amp;rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate &lt;typename T, typename U&gt;\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i])) return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate &lt;typename Iter, typename Element&gt;\nIter ArrayAwareFind(Iter begin, Iter end, const Element&amp; elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem)) return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements&#x27;\n// operator=, where k can be any integer &gt;= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate &lt;typename T, typename U&gt;\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate &lt;typename T, typename U&gt;\ninline void CopyArray(const T&amp; from, U* to) {\n  *to = from;\n}\n\n// This overload is used when k &gt;= 1.\ntemplate &lt;typename T, typename U, size_t N&gt;\ninline void CopyArray(const T (&amp;from)[N], U (*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate &lt;typename T, typename U&gt;\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock&#x27;s container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It&#x27;s the client&#x27;s responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate &lt;typename Element&gt;\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray&amp; rhs) {\n    (this-&gt;*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &amp;NativeArray::InitRef) delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray&amp; rhs) const {\n    return size() == rhs.size() &amp;&amp; ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  static_assert(!std::is_const&lt;Element&gt;::value, &quot;Type must not be const&quot;);\n  static_assert(!std::is_reference&lt;Element&gt;::value,\n                &quot;Type must not be a reference&quot;);\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &amp;NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &amp;NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n};\n\ntemplate &lt;size_t&gt;\nstruct Ignore {\n  Ignore(...);  // NOLINT\n};\n\ntemplate &lt;typename&gt;\nstruct ElemFromListImpl;\ntemplate &lt;size_t... I&gt;\nstruct ElemFromListImpl&lt;std::index_sequence&lt;I...&gt;&gt; {\n  // We make Ignore a template to solve a problem with MSVC.\n  // A non-template Ignore would work fine with `decltype(Ignore(I))...`, but\n  // MSVC doesn&#x27;t understand how to deal with that pack expansion.\n  // Use `0 * I` to have a single instantiation of Ignore.\n  template &lt;typename R&gt;\n  static R Apply(Ignore&lt;0 * I&gt;..., R (*)(), ...);\n};\n\ntemplate &lt;size_t N, typename... T&gt;\nstruct ElemFromList {\n  using type = decltype(ElemFromListImpl&lt;std::make_index_sequence&lt;N&gt;&gt;::Apply(\n      static_cast&lt;T (*)()&gt;(nullptr)...));\n};\n\nstruct FlatTupleConstructTag {};\n\ntemplate &lt;typename... T&gt;\nclass FlatTuple;\n\ntemplate &lt;typename Derived, size_t I&gt;\nstruct FlatTupleElemBase;\n\ntemplate &lt;typename... T, size_t I&gt;\nstruct FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt; {\n  using value_type = typename ElemFromList&lt;I, T...&gt;::type;\n  FlatTupleElemBase() = default;\n  template &lt;typename Arg&gt;\n  explicit FlatTupleElemBase(FlatTupleConstructTag, Arg&amp;&amp; t)\n      : value(std::forward&lt;Arg&gt;(t)) {}\n  value_type value;\n};\n\ntemplate &lt;typename Derived, typename Idx&gt;\nstruct FlatTupleBase;\n\ntemplate &lt;size_t... Idx, typename... T&gt;\nstruct FlatTupleBase&lt;FlatTuple&lt;T...&gt;, std::index_sequence&lt;Idx...&gt;&gt;\n    : FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, Idx&gt;... {\n  using Indices = std::index_sequence&lt;Idx...&gt;;\n  FlatTupleBase() = default;\n  template &lt;typename... Args&gt;\n  explicit FlatTupleBase(FlatTupleConstructTag, Args&amp;&amp;... args)\n      : FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, Idx&gt;(FlatTupleConstructTag{},\n                                                std::forward&lt;Args&gt;(args))... {}\n\n  template &lt;size_t I&gt;\n  const typename ElemFromList&lt;I, T...&gt;::type&amp; Get() const {\n    return FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt;::value;\n  }\n\n  template &lt;size_t I&gt;\n  typename ElemFromList&lt;I, T...&gt;::type&amp; Get() {\n    return FlatTupleElemBase&lt;FlatTuple&lt;T...&gt;, I&gt;::value;\n  }\n\n  template &lt;typename F&gt;\n  auto Apply(F&amp;&amp; f) -&gt; decltype(std::forward&lt;F&gt;(f)(this-&gt;Get&lt;Idx&gt;()...)) {\n    return std::forward&lt;F&gt;(f)(Get&lt;Idx&gt;()...);\n  }\n\n  template &lt;typename F&gt;\n  auto Apply(F&amp;&amp; f) const -&gt; decltype(std::forward&lt;F&gt;(f)(this-&gt;Get&lt;Idx&gt;()...)) {\n    return std::forward&lt;F&gt;(f)(Get&lt;Idx&gt;()...);\n  }\n};\n\n// Analog to std::tuple but with different tradeoffs.\n// This class minimizes the template instantiation depth, thus allowing more\n// elements than std::tuple would. std::tuple has been seen to require an\n// instantiation depth of more than 10x the number of elements in some\n// implementations.\n// FlatTuple and ElemFromList are not recursive and have a fixed depth\n// regardless of T...\n// std::make_index_sequence, on the other hand, it is recursive but with an\n// instantiation depth of O(ln(N)).\ntemplate &lt;typename... T&gt;\nclass FlatTuple\n    : private FlatTupleBase&lt;FlatTuple&lt;T...&gt;,\n                            std::make_index_sequence&lt;sizeof...(T)&gt;&gt; {\n  using Indices =\n      typename FlatTupleBase&lt;FlatTuple&lt;T...&gt;,\n                             std::make_index_sequence&lt;sizeof...(T)&gt;&gt;::Indices;\n\n public:\n  FlatTuple() = default;\n  template &lt;typename... Args&gt;\n  explicit FlatTuple(FlatTupleConstructTag tag, Args&amp;&amp;... args)\n      : FlatTuple::FlatTupleBase(tag, std::forward&lt;Args&gt;(args)...) {}\n\n  using FlatTuple::FlatTupleBase::Apply;\n  using FlatTuple::FlatTupleBase::Get;\n};\n\n// Utility functions to be called with static_assert to induce deprecation\n// warnings.\nGTEST_INTERNAL_DEPRECATED(\n    &quot;INSTANTIATE_TEST_CASE_P is deprecated, please use &quot;\n    &quot;INSTANTIATE_TEST_SUITE_P&quot;)\nconstexpr bool InstantiateTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;TYPED_TEST_SUITE_P&quot;)\nconstexpr bool TypedTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;TYPED_TEST_CASE is deprecated, please use &quot;\n    &quot;TYPED_TEST_SUITE&quot;)\nconstexpr bool TypedTestCaseIsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;REGISTER_TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;REGISTER_TYPED_TEST_SUITE_P&quot;)\nconstexpr bool RegisterTypedTestCase_P_IsDeprecated() { return true; }\n\nGTEST_INTERNAL_DEPRECATED(\n    &quot;INSTANTIATE_TYPED_TEST_CASE_P is deprecated, please use &quot;\n    &quot;INSTANTIATE_TYPED_TEST_SUITE_P&quot;)\nconstexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }\n\n}  // namespace internal\n}  // namespace testing\n\nnamespace std {\n// Some standard library implementations use `struct tuple_size` and some use\n// `class tuple_size`. Clang warns about the mismatch.\n// https://reviews.llvm.org/D55466\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Wmismatched-tags&quot;\n#endif\ntemplate &lt;typename... Ts&gt;\nstruct tuple_size&lt;testing::internal::FlatTuple&lt;Ts...&gt;&gt;\n    : std::integral_constant&lt;size_t, sizeof...(Ts)&gt; {};\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n}  // namespace std\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type)             \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) = \\\n      ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n#define GTEST_SKIP_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)\n\n// Suppress MSVC warning 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn&#x27;t return or throw in some\n// situations).\n// NOTE: The &quot;else&quot; is important to keep this expansion to prevent a top-level\n// &quot;else&quot; from attaching to our &quot;if&quot;.\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) {                        \\\n    statement;                                                    \\\n  } else                     /* NOLINT */                         \\\n    static_assert(true, &quot;&quot;)  // User must have a semicolon after expansion.\n\n#if GTEST_HAS_EXCEPTIONS\n\nnamespace testing {\nnamespace internal {\n\nclass NeverThrown {\n public:\n  const char* what() const noexcept {\n    return &quot;this exception should never be thrown&quot;;\n  }\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#if GTEST_HAS_RTTI\n\n#define GTEST_EXCEPTION_TYPE_(e) ::testing::internal::GetTypeName(typeid(e))\n\n#else  // GTEST_HAS_RTTI\n\n#define GTEST_EXCEPTION_TYPE_(e) \\\n  std::string { &quot;an std::exception-derived error&quot; }\n\n#endif  // GTEST_HAS_RTTI\n\n#define GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)   \\\n  catch (typename std::conditional&lt;                                            \\\n         std::is_same&lt;typename std::remove_cv&lt;typename std::remove_reference&lt;  \\\n                          expected_exception&gt;::type&gt;::type,                    \\\n                      std::exception&gt;::value,                                  \\\n         const ::testing::internal::NeverThrown&amp;, const std::exception&amp;&gt;::type \\\n             e) {                                                              \\\n    gtest_msg.value = &quot;Expected: &quot; #statement                                  \\\n                      &quot; throws an exception of type &quot; #expected_exception      \\\n                      &quot;.\\n  Actual: it throws &quot;;                               \\\n    gtest_msg.value += GTEST_EXCEPTION_TYPE_(e);                               \\\n    gtest_msg.value += &quot; with description \\&quot;&quot;;                                 \\\n    gtest_msg.value += e.what();                                               \\\n    gtest_msg.value += &quot;\\&quot;.&quot;;                                                  \\\n    goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);                \\\n  }\n\n#else  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail)              \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                             \\\n  if (::testing::internal::TrueWithString gtest_msg{}) {                    \\\n    bool gtest_caught_expected = false;                                     \\\n    try {                                                                   \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);            \\\n    } catch (expected_exception const&amp;) {                                   \\\n      gtest_caught_expected = true;                                         \\\n    }                                                                       \\\n    GTEST_TEST_THROW_CATCH_STD_EXCEPTION_(statement, expected_exception)    \\\n    catch (...) {                                                           \\\n      gtest_msg.value = &quot;Expected: &quot; #statement                             \\\n                        &quot; throws an exception of type &quot; #expected_exception \\\n                        &quot;.\\n  Actual: it throws a different type.&quot;;         \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);           \\\n    }                                                                       \\\n    if (!gtest_caught_expected) {                                           \\\n      gtest_msg.value = &quot;Expected: &quot; #statement                             \\\n                        &quot; throws an exception of type &quot; #expected_exception \\\n                        &quot;.\\n  Actual: it throws nothing.&quot;;                  \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__);           \\\n    }                                                                       \\\n  } else /*NOLINT*/                                                         \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__)                   \\\n        : fail(gtest_msg.value.c_str())\n\n#if GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()                \\\n  catch (std::exception const&amp; e) {                               \\\n    gtest_msg.value = &quot;it throws &quot;;                               \\\n    gtest_msg.value += GTEST_EXCEPTION_TYPE_(e);                  \\\n    gtest_msg.value += &quot; with description \\&quot;&quot;;                    \\\n    gtest_msg.value += e.what();                                  \\\n    gtest_msg.value += &quot;\\&quot;.&quot;;                                     \\\n    goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n  }\n\n#else  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#define GTEST_TEST_NO_THROW_(statement, fail)                            \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                          \\\n  if (::testing::internal::TrueWithString gtest_msg{}) {                 \\\n    try {                                                                \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);         \\\n    }                                                                    \\\n    GTEST_TEST_NO_THROW_CATCH_STD_EXCEPTION_()                           \\\n    catch (...) {                                                        \\\n      gtest_msg.value = &quot;it throws.&quot;;                                    \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__);      \\\n    }                                                                    \\\n  } else                                                                 \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__)              \\\n        : fail((&quot;Expected: &quot; #statement &quot; doesn&#x27;t throw an exception.\\n&quot; \\\n                &quot;  Actual: &quot; +                                           \\\n                gtest_msg.value)                                         \\\n                   .c_str())\n\n#define GTEST_TEST_ANY_THROW_(statement, fail)                       \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                      \\\n  if (::testing::internal::AlwaysTrue()) {                           \\\n    bool gtest_caught_any = false;                                   \\\n    try {                                                            \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);     \\\n    } catch (...) {                                                  \\\n      gtest_caught_any = true;                                       \\\n    }                                                                \\\n    if (!gtest_caught_any) {                                         \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    }                                                                \\\n  } else                                                             \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__)         \\\n        : fail(&quot;Expected: &quot; #statement                               \\\n               &quot; throws an exception.\\n&quot;                             \\\n               &quot;  Actual: it doesn&#x27;t.&quot;)\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// representation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                       \\\n  if (const ::testing::AssertionResult gtest_ar_ =                    \\\n          ::testing::AssertionResult(expression))                     \\\n    ;                                                                 \\\n  else                                                                \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(         \\\n             gtest_ar_, text, #actual, #expected)                     \\\n             .c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail)               \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_                                     \\\n  if (::testing::internal::AlwaysTrue()) {                          \\\n    const ::testing::internal::HasNewFatalFailureHelper             \\\n        gtest_fatal_failure_checker;                                \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement);      \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) {      \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    }                                                               \\\n  } else /* NOLINT */                                               \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__)         \\\n        : fail(&quot;Expected: &quot; #statement                              \\\n               &quot; doesn&#x27;t generate new fatal &quot;                       \\\n               &quot;failures in the current thread.\\n&quot;                  \\\n               &quot;  Actual: it does.&quot;)\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \\\n  test_suite_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_suite_name, test_name, parent_class, parent_id)       \\\n  static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) &gt; 1,                 \\\n                &quot;test_suite_name must not be empty&quot;);                          \\\n  static_assert(sizeof(GTEST_STRINGIFY_(test_name)) &gt; 1,                       \\\n                &quot;test_name must not be empty&quot;);                                \\\n  class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                     \\\n      : public parent_class {                                                  \\\n   public:                                                                     \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default;            \\\n    ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default;  \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                         \\\n    (const GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp;) = delete;     \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp; operator=(            \\\n        const GTEST_TEST_CLASS_NAME_(test_suite_name,                          \\\n                                     test_name) &amp;) = delete; /* NOLINT */      \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)                         \\\n    (GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp;&amp;) noexcept = delete; \\\n    GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) &amp; operator=(            \\\n        GTEST_TEST_CLASS_NAME_(test_suite_name,                                \\\n                               test_name) &amp;&amp;) noexcept = delete; /* NOLINT */  \\\n                                                                               \\\n   private:                                                                    \\\n    void TestBody() override;                                                  \\\n    GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED static ::testing::TestInfo* const    \\\n        test_info_;                                                            \\\n  };                                                                           \\\n                                                                               \\\n  ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name,           \\\n                                                    test_name)::test_info_ =   \\\n      ::testing::internal::MakeAndRegisterTestInfo(                            \\\n          #test_suite_name, #test_name, nullptr, nullptr,                      \\\n          ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id),  \\\n          ::testing::internal::SuiteApiResolver&lt;                               \\\n              parent_class&gt;::GetSetUpCaseOrSuite(__FILE__, __LINE__),          \\\n          ::testing::internal::SuiteApiResolver&lt;                               \\\n              parent_class&gt;::GetTearDownCaseOrSuite(__FILE__, __LINE__),       \\\n          new ::testing::internal::TestFactoryImpl&lt;GTEST_TEST_CLASS_NAME_(     \\\n              test_suite_name, test_name)&gt;);                                   \\\n  void GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)::TestBody()\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Type and function utilities for implementing parameterized tests.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n\n#include &lt;ctype.h&gt;\n\n#include &lt;cassert&gt;\n#include &lt;iterator&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-printers.h&quot;\n#include &quot;gtest/gtest-test-part.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\nnamespace testing {\n// Input to a parameterized test name generator, describing a test parameter.\n// Consists of the parameter value and the integer parameter index.\ntemplate &lt;class ParamType&gt;\nstruct TestParamInfo {\n  TestParamInfo(const ParamType&amp; a_param, size_t an_index)\n      : param(a_param), index(an_index) {}\n  ParamType param;\n  size_t index;\n};\n\n// A builtin parameterized test name generator which returns the result of\n// testing::PrintToString.\nstruct PrintToStringParamName {\n  template &lt;class ParamType&gt;\n  std::string operator()(const TestParamInfo&lt;ParamType&gt;&amp; info) const {\n    return PrintToString(info.param);\n  }\n};\n\nnamespace internal {\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// Utility Functions\n\n// Outputs a message explaining invalid registration of different\n// fixture class for the same test suite. This may happen when\n// TEST_P macro is used to define two tests with the same name\n// but in different namespaces.\nGTEST_API_ void ReportInvalidTestSuiteType(const char* test_suite_name,\n                                           const CodeLocation&amp; code_location);\n\ntemplate &lt;typename&gt;\nclass ParamGeneratorInterface;\ntemplate &lt;typename&gt;\nclass ParamGenerator;\n\n// Interface for iterating over elements provided by an implementation\n// of ParamGeneratorInterface&lt;T&gt;.\ntemplate &lt;typename T&gt;\nclass ParamIteratorInterface {\n public:\n  virtual ~ParamIteratorInterface() = default;\n  // A pointer to the base generator instance.\n  // Used only for the purposes of iterator comparison\n  // to make sure that two iterators belong to the same generator.\n  virtual const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const = 0;\n  // Advances iterator to point to the next element\n  // provided by the generator. The caller is responsible\n  // for not calling Advance() on an iterator equal to\n  // BaseGenerator()-&gt;End().\n  virtual void Advance() = 0;\n  // Clones the iterator object. Used for implementing copy semantics\n  // of ParamIterator&lt;T&gt;.\n  virtual ParamIteratorInterface* Clone() const = 0;\n  // Dereferences the current iterator and provides (read-only) access\n  // to the pointed value. It is the caller&#x27;s responsibility not to call\n  // Current() on an iterator equal to BaseGenerator()-&gt;End().\n  // Used for implementing ParamGenerator&lt;T&gt;::operator*().\n  virtual const T* Current() const = 0;\n  // Determines whether the given iterator and other point to the same\n  // element in the sequence generated by the generator.\n  // Used for implementing ParamGenerator&lt;T&gt;::operator==().\n  virtual bool Equals(const ParamIteratorInterface&amp; other) const = 0;\n};\n\n// Class iterating over elements provided by an implementation of\n// ParamGeneratorInterface&lt;T&gt;. It wraps ParamIteratorInterface&lt;T&gt;\n// and implements the const forward iterator concept.\ntemplate &lt;typename T&gt;\nclass ParamIterator {\n public:\n  typedef T value_type;\n  typedef const T&amp; reference;\n  typedef ptrdiff_t difference_type;\n\n  // ParamIterator assumes ownership of the impl_ pointer.\n  ParamIterator(const ParamIterator&amp; other) : impl_(other.impl_-&gt;Clone()) {}\n  ParamIterator&amp; operator=(const ParamIterator&amp; other) {\n    if (this != &amp;other) impl_.reset(other.impl_-&gt;Clone());\n    return *this;\n  }\n\n  const T&amp; operator*() const { return *impl_-&gt;Current(); }\n  const T* operator-&gt;() const { return impl_-&gt;Current(); }\n  // Prefix version of operator++.\n  ParamIterator&amp; operator++() {\n    impl_-&gt;Advance();\n    return *this;\n  }\n  // Postfix version of operator++.\n  ParamIterator operator++(int /*unused*/) {\n    ParamIteratorInterface&lt;T&gt;* clone = impl_-&gt;Clone();\n    impl_-&gt;Advance();\n    return ParamIterator(clone);\n  }\n  bool operator==(const ParamIterator&amp; other) const {\n    return impl_.get() == other.impl_.get() || impl_-&gt;Equals(*other.impl_);\n  }\n  bool operator!=(const ParamIterator&amp; other) const {\n    return !(*this == other);\n  }\n\n private:\n  friend class ParamGenerator&lt;T&gt;;\n  explicit ParamIterator(ParamIteratorInterface&lt;T&gt;* impl) : impl_(impl) {}\n  std::unique_ptr&lt;ParamIteratorInterface&lt;T&gt;&gt; impl_;\n};\n\n// ParamGeneratorInterface&lt;T&gt; is the binary interface to access generators\n// defined in other translation units.\ntemplate &lt;typename T&gt;\nclass ParamGeneratorInterface {\n public:\n  typedef T ParamType;\n\n  virtual ~ParamGeneratorInterface() = default;\n\n  // Generator interface definition\n  virtual ParamIteratorInterface&lt;T&gt;* Begin() const = 0;\n  virtual ParamIteratorInterface&lt;T&gt;* End() const = 0;\n};\n\n// Wraps ParamGeneratorInterface&lt;T&gt; and provides general generator syntax\n// compatible with the STL Container concept.\n// This class implements copy initialization semantics and the contained\n// ParamGeneratorInterface&lt;T&gt; instance is shared among all copies\n// of the original object. This is possible because that instance is immutable.\ntemplate &lt;typename T&gt;\nclass ParamGenerator {\n public:\n  typedef ParamIterator&lt;T&gt; iterator;\n\n  explicit ParamGenerator(ParamGeneratorInterface&lt;T&gt;* impl) : impl_(impl) {}\n  ParamGenerator(const ParamGenerator&amp; other) : impl_(other.impl_) {}\n\n  ParamGenerator&amp; operator=(const ParamGenerator&amp; other) {\n    impl_ = other.impl_;\n    return *this;\n  }\n\n  iterator begin() const { return iterator(impl_-&gt;Begin()); }\n  iterator end() const { return iterator(impl_-&gt;End()); }\n\n private:\n  std::shared_ptr&lt;const ParamGeneratorInterface&lt;T&gt;&gt; impl_;\n};\n\n// Generates values from a range of two comparable values. Can be used to\n// generate sequences of user-defined types that implement operator+() and\n// operator&lt;().\n// This class is used in the Range() function.\ntemplate &lt;typename T, typename IncrementT&gt;\nclass RangeGenerator : public ParamGeneratorInterface&lt;T&gt; {\n public:\n  RangeGenerator(T begin, T end, IncrementT step)\n      : begin_(begin),\n        end_(end),\n        step_(step),\n        end_index_(CalculateEndIndex(begin, end, step)) {}\n  ~RangeGenerator() override = default;\n\n  ParamIteratorInterface&lt;T&gt;* Begin() const override {\n    return new Iterator(this, begin_, 0, step_);\n  }\n  ParamIteratorInterface&lt;T&gt;* End() const override {\n    return new Iterator(this, end_, end_index_, step_);\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface&lt;T&gt; {\n   public:\n    Iterator(const ParamGeneratorInterface&lt;T&gt;* base, T value, int index,\n             IncrementT step)\n        : base_(base), value_(value), index_(index), step_(step) {}\n    ~Iterator() override = default;\n\n    const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const override {\n      return base_;\n    }\n    void Advance() override {\n      value_ = static_cast&lt;T&gt;(value_ + step_);\n      index_++;\n    }\n    ParamIteratorInterface&lt;T&gt;* Clone() const override {\n      return new Iterator(*this);\n    }\n    const T* Current() const override { return &amp;value_; }\n    bool Equals(const ParamIteratorInterface&lt;T&gt;&amp; other) const override {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          &lt;&lt; &quot;The program attempted to compare iterators &quot;\n          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;\n      const int other_index =\n          CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other)-&gt;index_;\n      return index_ == other_index;\n    }\n\n   private:\n    Iterator(const Iterator&amp; other)\n        : ParamIteratorInterface&lt;T&gt;(),\n          base_(other.base_),\n          value_(other.value_),\n          index_(other.index_),\n          step_(other.step_) {}\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator&amp; other);\n\n    const ParamGeneratorInterface&lt;T&gt;* const base_;\n    T value_;\n    int index_;\n    const IncrementT step_;\n  };  // class RangeGenerator::Iterator\n\n  static int CalculateEndIndex(const T&amp; begin, const T&amp; end,\n                               const IncrementT&amp; step) {\n    int end_index = 0;\n    for (T i = begin; i &lt; end; i = static_cast&lt;T&gt;(i + step)) end_index++;\n    return end_index;\n  }\n\n  // No implementation - assignment is unsupported.\n  void operator=(const RangeGenerator&amp; other);\n\n  const T begin_;\n  const T end_;\n  const IncrementT step_;\n  // The index for the end() iterator. All the elements in the generated\n  // sequence are indexed (0-based) to aid iterator comparison.\n  const int end_index_;\n};  // class RangeGenerator\n\n// Generates values from a pair of STL-style iterators. Used in the\n// ValuesIn() function. The elements are copied from the source range\n// since the source can be located on the stack, and the generator\n// is likely to persist beyond that stack frame.\ntemplate &lt;typename T&gt;\nclass ValuesInIteratorRangeGenerator : public ParamGeneratorInterface&lt;T&gt; {\n public:\n  template &lt;typename ForwardIterator&gt;\n  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)\n      : container_(begin, end) {}\n  ~ValuesInIteratorRangeGenerator() override = default;\n\n  ParamIteratorInterface&lt;T&gt;* Begin() const override {\n    return new Iterator(this, container_.begin());\n  }\n  ParamIteratorInterface&lt;T&gt;* End() const override {\n    return new Iterator(this, container_.end());\n  }\n\n private:\n  typedef typename ::std::vector&lt;T&gt; ContainerType;\n\n  class Iterator : public ParamIteratorInterface&lt;T&gt; {\n   public:\n    Iterator(const ParamGeneratorInterface&lt;T&gt;* base,\n             typename ContainerType::const_iterator iterator)\n        : base_(base), iterator_(iterator) {}\n    ~Iterator() override = default;\n\n    const ParamGeneratorInterface&lt;T&gt;* BaseGenerator() const override {\n      return base_;\n    }\n    void Advance() override {\n      ++iterator_;\n      value_.reset();\n    }\n    ParamIteratorInterface&lt;T&gt;* Clone() const override {\n      return new Iterator(*this);\n    }\n    // We need to use cached value referenced by iterator_ because *iterator_\n    // can return a temporary object (and of type other then T), so just\n    // having &quot;return &amp;*iterator_;&quot; doesn&#x27;t work.\n    // value_ is updated here and not in Advance() because Advance()\n    // can advance iterator_ beyond the end of the range, and we cannot\n    // detect that fact. The client code, on the other hand, is\n    // responsible for not calling Current() on an out-of-range iterator.\n    const T* Current() const override {\n      if (value_.get() == nullptr) value_.reset(new T(*iterator_));\n      return value_.get();\n    }\n    bool Equals(const ParamIteratorInterface&lt;T&gt;&amp; other) const override {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          &lt;&lt; &quot;The program attempted to compare iterators &quot;\n          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;\n      return iterator_ ==\n             CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other)-&gt;iterator_;\n    }\n\n   private:\n    Iterator(const Iterator&amp; other)\n        // The explicit constructor call suppresses a false warning\n        // emitted by gcc when supplied with the -Wextra option.\n        : ParamIteratorInterface&lt;T&gt;(),\n          base_(other.base_),\n          iterator_(other.iterator_) {}\n\n    const ParamGeneratorInterface&lt;T&gt;* const base_;\n    typename ContainerType::const_iterator iterator_;\n    // A cached value of *iterator_. We keep it here to allow access by\n    // pointer in the wrapping iterator&#x27;s operator-&gt;().\n    // value_ needs to be mutable to be accessed in Current().\n    // Use of std::unique_ptr helps manage cached value&#x27;s lifetime,\n    // which is bound by the lifespan of the iterator itself.\n    mutable std::unique_ptr&lt;const T&gt; value_;\n  };  // class ValuesInIteratorRangeGenerator::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const ValuesInIteratorRangeGenerator&amp; other);\n\n  const ContainerType container_;\n};  // class ValuesInIteratorRangeGenerator\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Default parameterized test name generator, returns a string containing the\n// integer test parameter index.\ntemplate &lt;class ParamType&gt;\nstd::string DefaultParamName(const TestParamInfo&lt;ParamType&gt;&amp; info) {\n  return std::to_string(info.index);\n}\n\ntemplate &lt;typename T = int&gt;\nvoid TestNotEmpty() {\n  static_assert(sizeof(T) == 0, &quot;Empty arguments are not allowed.&quot;);\n}\ntemplate &lt;typename T = int&gt;\nvoid TestNotEmpty(const T&amp;) {}\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Stores a parameter value and later creates tests parameterized with that\n// value.\ntemplate &lt;class TestClass&gt;\nclass ParameterizedTestFactory : public TestFactoryBase {\n public:\n  typedef typename TestClass::ParamType ParamType;\n  explicit ParameterizedTestFactory(ParamType parameter)\n      : parameter_(parameter) {}\n  Test* CreateTest() override {\n    TestClass::SetParam(&amp;parameter_);\n    return new TestClass();\n  }\n\n private:\n  const ParamType parameter_;\n\n  ParameterizedTestFactory(const ParameterizedTestFactory&amp;) = delete;\n  ParameterizedTestFactory&amp; operator=(const ParameterizedTestFactory&amp;) = delete;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactoryBase is a base class for meta-factories that create\n// test factories for passing into MakeAndRegisterTestInfo function.\ntemplate &lt;class ParamType&gt;\nclass TestMetaFactoryBase {\n public:\n  virtual ~TestMetaFactoryBase() = default;\n\n  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactory creates test factories for passing into\n// MakeAndRegisterTestInfo function. Since MakeAndRegisterTestInfo receives\n// ownership of test factory pointer, same factory object cannot be passed\n// into that method twice. But ParameterizedTestSuiteInfo is going to call\n// it for each Test/Parameter value combination. Thus it needs meta factory\n// creator class.\ntemplate &lt;class TestSuite&gt;\nclass TestMetaFactory\n    : public TestMetaFactoryBase&lt;typename TestSuite::ParamType&gt; {\n public:\n  using ParamType = typename TestSuite::ParamType;\n\n  TestMetaFactory() = default;\n\n  TestFactoryBase* CreateTestFactory(ParamType parameter) override {\n    return new ParameterizedTestFactory&lt;TestSuite&gt;(parameter);\n  }\n\n private:\n  TestMetaFactory(const TestMetaFactory&amp;) = delete;\n  TestMetaFactory&amp; operator=(const TestMetaFactory&amp;) = delete;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestSuiteInfoBase is a generic interface\n// to ParameterizedTestSuiteInfo classes. ParameterizedTestSuiteInfoBase\n// accumulates test information provided by TEST_P macro invocations\n// and generators provided by INSTANTIATE_TEST_SUITE_P macro invocations\n// and uses that information to register all resulting test instances\n// in RegisterTests method. The ParameterizeTestSuiteRegistry class holds\n// a collection of pointers to the ParameterizedTestSuiteInfo objects\n// and calls RegisterTests() on each of them when asked.\nclass ParameterizedTestSuiteInfoBase {\n public:\n  virtual ~ParameterizedTestSuiteInfoBase() = default;\n\n  // Base part of test suite name for display purposes.\n  virtual const std::string&amp; GetTestSuiteName() const = 0;\n  // Test suite id to verify identity.\n  virtual TypeId GetTestSuiteTypeId() const = 0;\n  // UnitTest class invokes this method to register tests in this\n  // test suite right before running them in RUN_ALL_TESTS macro.\n  // This method should not be called more than once on any single\n  // instance of a ParameterizedTestSuiteInfoBase derived class.\n  virtual void RegisterTests() = 0;\n\n protected:\n  ParameterizedTestSuiteInfoBase() {}\n\n private:\n  ParameterizedTestSuiteInfoBase(const ParameterizedTestSuiteInfoBase&amp;) =\n      delete;\n  ParameterizedTestSuiteInfoBase&amp; operator=(\n      const ParameterizedTestSuiteInfoBase&amp;) = delete;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Report a the name of a test_suit as safe to ignore\n// as the side effect of construction of this type.\nstruct GTEST_API_ MarkAsIgnored {\n  explicit MarkAsIgnored(const char* test_suite);\n};\n\nGTEST_API_ void InsertSyntheticTestCase(const std::string&amp; name,\n                                        CodeLocation location, bool has_test_p);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestSuiteInfo accumulates tests obtained from TEST_P\n// macro invocations for a particular test suite and generators\n// obtained from INSTANTIATE_TEST_SUITE_P macro invocations for that\n// test suite. It registers tests with all values generated by all\n// generators when asked.\ntemplate &lt;class TestSuite&gt;\nclass ParameterizedTestSuiteInfo : public ParameterizedTestSuiteInfoBase {\n public:\n  // ParamType and GeneratorCreationFunc are private types but are required\n  // for declarations of public methods AddTestPattern() and\n  // AddTestSuiteInstantiation().\n  using ParamType = typename TestSuite::ParamType;\n  // A function that returns an instance of appropriate generator type.\n  typedef ParamGenerator&lt;ParamType&gt;(GeneratorCreationFunc)();\n  using ParamNameGeneratorFunc = std::string(const TestParamInfo&lt;ParamType&gt;&amp;);\n\n  explicit ParameterizedTestSuiteInfo(std::string name,\n                                      CodeLocation code_location)\n      : test_suite_name_(std::move(name)),\n        code_location_(std::move(code_location)) {}\n\n  // Test suite base name for display purposes.\n  const std::string&amp; GetTestSuiteName() const override {\n    return test_suite_name_;\n  }\n  // Test suite id to verify identity.\n  TypeId GetTestSuiteTypeId() const override { return GetTypeId&lt;TestSuite&gt;(); }\n  // TEST_P macro uses AddTestPattern() to record information\n  // about a single test in a LocalTestInfo structure.\n  // test_suite_name is the base name of the test suite (without invocation\n  // prefix). test_base_name is the name of an individual test without\n  // parameter index. For the test SequenceA/FooTest.DoBar/1 FooTest is\n  // test suite base name and DoBar is test base name.\n  void AddTestPattern(const char*,\n                      const char* test_base_name,\n                      TestMetaFactoryBase&lt;ParamType&gt;* meta_factory,\n                      CodeLocation code_location) {\n    tests_.emplace_back(\n        new TestInfo(test_base_name, meta_factory, std::move(code_location)));\n  }\n  // INSTANTIATE_TEST_SUITE_P macro uses AddGenerator() to record information\n  // about a generator.\n  int AddTestSuiteInstantiation(std::string instantiation_name,\n                                GeneratorCreationFunc* func,\n                                ParamNameGeneratorFunc* name_func,\n                                const char* file, int line) {\n    instantiations_.emplace_back(std::move(instantiation_name), func, name_func,\n                                 file, line);\n    return 0;  // Return value used only to run this method in namespace scope.\n  }\n  // UnitTest class invokes this method to register tests in this test suite\n  // right before running tests in RUN_ALL_TESTS macro.\n  // This method should not be called more than once on any single\n  // instance of a ParameterizedTestSuiteInfoBase derived class.\n  // UnitTest has a guard to prevent from calling this method more than once.\n  void RegisterTests() override {\n    bool generated_instantiations = false;\n\n    std::string test_suite_name;\n    std::string test_name;\n    for (const std::shared_ptr&lt;TestInfo&gt;&amp; test_info : tests_) {\n      for (const InstantiationInfo&amp; instantiation : instantiations_) {\n        const std::string&amp; instantiation_name = instantiation.name;\n        ParamGenerator&lt;ParamType&gt; generator((*instantiation.generator)());\n        ParamNameGeneratorFunc* name_func = instantiation.name_func;\n        const char* file = instantiation.file;\n        int line = instantiation.line;\n\n        if (!instantiation_name.empty())\n          test_suite_name = instantiation_name + &quot;/&quot;;\n        else\n          test_suite_name.clear();\n        test_suite_name += test_suite_name_;\n\n        size_t i = 0;\n        std::set&lt;std::string&gt; test_param_names;\n        for (const auto&amp; param : generator) {\n          generated_instantiations = true;\n\n          test_name.clear();\n\n          std::string param_name =\n              name_func(TestParamInfo&lt;ParamType&gt;(param, i));\n\n          GTEST_CHECK_(IsValidParamName(param_name))\n              &lt;&lt; &quot;Parameterized test name &#x27;&quot; &lt;&lt; param_name\n              &lt;&lt; &quot;&#x27; is invalid (contains spaces, dashes, or any &quot;\n                 &quot;non-alphanumeric characters other than underscores), in &quot;\n              &lt;&lt; file &lt;&lt; &quot; line &quot; &lt;&lt; line &lt;&lt; &quot;&quot; &lt;&lt; std::endl;\n\n          GTEST_CHECK_(test_param_names.count(param_name) == 0)\n              &lt;&lt; &quot;Duplicate parameterized test name &#x27;&quot; &lt;&lt; param_name &lt;&lt; &quot;&#x27;, in &quot;\n              &lt;&lt; file &lt;&lt; &quot; line &quot; &lt;&lt; line &lt;&lt; std::endl;\n\n          if (!test_info-&gt;test_base_name.empty()) {\n            test_name.append(test_info-&gt;test_base_name).append(&quot;/&quot;);\n          }\n          test_name += param_name;\n\n          test_param_names.insert(std::move(param_name));\n\n          MakeAndRegisterTestInfo(\n              test_suite_name, test_name.c_str(),\n              nullptr,  // No type parameter.\n              PrintToString(param).c_str(), test_info-&gt;code_location,\n              GetTestSuiteTypeId(),\n              SuiteApiResolver&lt;TestSuite&gt;::GetSetUpCaseOrSuite(file, line),\n              SuiteApiResolver&lt;TestSuite&gt;::GetTearDownCaseOrSuite(file, line),\n              test_info-&gt;test_meta_factory-&gt;CreateTestFactory(param));\n          ++i;\n        }  // for param\n      }  // for instantiation\n    }  // for test_info\n\n    if (!generated_instantiations) {\n      // There are no generaotrs, or they all generate nothing ...\n      InsertSyntheticTestCase(GetTestSuiteName(), code_location_,\n                              !tests_.empty());\n    }\n  }  // RegisterTests\n\n private:\n  // LocalTestInfo structure keeps information about a single test registered\n  // with TEST_P macro.\n  struct TestInfo {\n    TestInfo(const char* a_test_base_name,\n             TestMetaFactoryBase&lt;ParamType&gt;* a_test_meta_factory,\n             CodeLocation a_code_location)\n        : test_base_name(a_test_base_name),\n          test_meta_factory(a_test_meta_factory),\n          code_location(std::move(a_code_location)) {}\n\n    const std::string test_base_name;\n    const std::unique_ptr&lt;TestMetaFactoryBase&lt;ParamType&gt;&gt; test_meta_factory;\n    const CodeLocation code_location;\n  };\n  using TestInfoContainer = ::std::vector&lt;std::shared_ptr&lt;TestInfo&gt;&gt;;\n  // Records data received from INSTANTIATE_TEST_SUITE_P macros:\n  //  &lt;Instantiation name, Sequence generator creation function,\n  //     Name generator function, Source file, Source line&gt;\n  struct InstantiationInfo {\n    InstantiationInfo(std::string name_in, GeneratorCreationFunc* generator_in,\n                      ParamNameGeneratorFunc* name_func_in, const char* file_in,\n                      int line_in)\n        : name(std::move(name_in)),\n          generator(generator_in),\n          name_func(name_func_in),\n          file(file_in),\n          line(line_in) {}\n\n    std::string name;\n    GeneratorCreationFunc* generator;\n    ParamNameGeneratorFunc* name_func;\n    const char* file;\n    int line;\n  };\n  typedef ::std::vector&lt;InstantiationInfo&gt; InstantiationContainer;\n\n  static bool IsValidParamName(const std::string&amp; name) {\n    // Check for empty string\n    if (name.empty()) return false;\n\n    // Check for invalid characters\n    for (std::string::size_type index = 0; index &lt; name.size(); ++index) {\n      if (!IsAlNum(name[index]) &amp;&amp; name[index] != &#x27;_&#x27;) return false;\n    }\n\n    return true;\n  }\n\n  const std::string test_suite_name_;\n  CodeLocation code_location_;\n  TestInfoContainer tests_;\n  InstantiationContainer instantiations_;\n\n  ParameterizedTestSuiteInfo(const ParameterizedTestSuiteInfo&amp;) = delete;\n  ParameterizedTestSuiteInfo&amp; operator=(const ParameterizedTestSuiteInfo&amp;) =\n      delete;\n};  // class ParameterizedTestSuiteInfo\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\ntemplate &lt;class TestCase&gt;\nusing ParameterizedTestCaseInfo = ParameterizedTestSuiteInfo&lt;TestCase&gt;;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestSuiteRegistry contains a map of\n// ParameterizedTestSuiteInfoBase classes accessed by test suite names. TEST_P\n// and INSTANTIATE_TEST_SUITE_P macros use it to locate their corresponding\n// ParameterizedTestSuiteInfo descriptors.\nclass ParameterizedTestSuiteRegistry {\n public:\n  ParameterizedTestSuiteRegistry() = default;\n  ~ParameterizedTestSuiteRegistry() {\n    for (auto&amp; test_suite_info : test_suite_infos_) {\n      delete test_suite_info;\n    }\n  }\n\n  // Looks up or creates and returns a structure containing information about\n  // tests and instantiations of a particular test suite.\n  template &lt;class TestSuite&gt;\n  ParameterizedTestSuiteInfo&lt;TestSuite&gt;* GetTestSuitePatternHolder(\n      std::string test_suite_name, CodeLocation code_location) {\n    ParameterizedTestSuiteInfo&lt;TestSuite&gt;* typed_test_info = nullptr;\n\n    auto item_it = suite_name_to_info_index_.find(test_suite_name);\n    if (item_it != suite_name_to_info_index_.end()) {\n      auto* test_suite_info = test_suite_infos_[item_it-&gt;second];\n      if (test_suite_info-&gt;GetTestSuiteTypeId() != GetTypeId&lt;TestSuite&gt;()) {\n        // Complain about incorrect usage of Google Test facilities\n        // and terminate the program since we cannot guaranty correct\n        // test suite setup and tear-down in this case.\n        ReportInvalidTestSuiteType(test_suite_name.c_str(), code_location);\n        posix::Abort();\n      } else {\n        // At this point we are sure that the object we found is of the same\n        // type we are looking for, so we downcast it to that type\n        // without further checks.\n        typed_test_info =\n            CheckedDowncastToActualType&lt;ParameterizedTestSuiteInfo&lt;TestSuite&gt;&gt;(\n                test_suite_info);\n      }\n    }\n    if (typed_test_info == nullptr) {\n      typed_test_info = new ParameterizedTestSuiteInfo&lt;TestSuite&gt;(\n          test_suite_name, std::move(code_location));\n      suite_name_to_info_index_.emplace(std::move(test_suite_name),\n                                        test_suite_infos_.size());\n      test_suite_infos_.push_back(typed_test_info);\n    }\n    return typed_test_info;\n  }\n  void RegisterTests() {\n    for (auto&amp; test_suite_info : test_suite_infos_) {\n      test_suite_info-&gt;RegisterTests();\n    }\n  }\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  template &lt;class TestCase&gt;\n  ParameterizedTestCaseInfo&lt;TestCase&gt;* GetTestCasePatternHolder(\n      std::string test_case_name, CodeLocation code_location) {\n    return GetTestSuitePatternHolder&lt;TestCase&gt;(std::move(test_case_name),\n                                               std::move(code_location));\n  }\n\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n private:\n  using TestSuiteInfoContainer = ::std::vector&lt;ParameterizedTestSuiteInfoBase*&gt;;\n\n  TestSuiteInfoContainer test_suite_infos_;\n  ::std::unordered_map&lt;std::string, size_t&gt; suite_name_to_info_index_;\n\n  ParameterizedTestSuiteRegistry(const ParameterizedTestSuiteRegistry&amp;) =\n      delete;\n  ParameterizedTestSuiteRegistry&amp; operator=(\n      const ParameterizedTestSuiteRegistry&amp;) = delete;\n};\n\n// Keep track of what type-parameterized test suite are defined and\n// where as well as which are intatiated. This allows susequently\n// identifying suits that are defined but never used.\nclass TypeParameterizedTestSuiteRegistry {\n public:\n  // Add a suite definition\n  void RegisterTestSuite(const char* test_suite_name,\n                         CodeLocation code_location);\n\n  // Add an instantiation of a suit.\n  void RegisterInstantiation(const char* test_suite_name);\n\n  // For each suit repored as defined but not reported as instantiation,\n  // emit a test that reports that fact (configurably, as an error).\n  void CheckForInstantiations();\n\n private:\n  struct TypeParameterizedTestSuiteInfo {\n    explicit TypeParameterizedTestSuiteInfo(CodeLocation c)\n        : code_location(std::move(c)), instantiated(false) {}\n\n    CodeLocation code_location;\n    bool instantiated;\n  };\n\n  std::map&lt;std::string, TypeParameterizedTestSuiteInfo&gt; suites_;\n};\n\n}  // namespace internal\n\n// Forward declarations of ValuesIn(), which is implemented in\n// include/gtest/gtest-param-test.h.\ntemplate &lt;class Container&gt;\ninternal::ParamGenerator&lt;typename Container::value_type&gt; ValuesIn(\n    const Container&amp; container);\n\nnamespace internal {\n// Used in the Values() function to provide polymorphic capabilities.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4100)\n\ntemplate &lt;typename... Ts&gt;\nclass ValueArray {\n public:\n  explicit ValueArray(Ts... v) : v_(FlatTupleConstructTag{}, std::move(v)...) {}\n\n  template &lt;typename T&gt;\n  operator ParamGenerator&lt;T&gt;() const {  // NOLINT\n    return ValuesIn(MakeVector&lt;T&gt;(std::make_index_sequence&lt;sizeof...(Ts)&gt;()));\n  }\n\n private:\n  template &lt;typename T, size_t... I&gt;\n  std::vector&lt;T&gt; MakeVector(std::index_sequence&lt;I...&gt;) const {\n    return std::vector&lt;T&gt;{static_cast&lt;T&gt;(v_.template Get&lt;I&gt;())...};\n  }\n\n  FlatTuple&lt;Ts...&gt; v_;\n};\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4100\n\ntemplate &lt;typename... T&gt;\nclass CartesianProductGenerator\n    : public ParamGeneratorInterface&lt;::std::tuple&lt;T...&gt;&gt; {\n public:\n  typedef ::std::tuple&lt;T...&gt; ParamType;\n\n  CartesianProductGenerator(const std::tuple&lt;ParamGenerator&lt;T&gt;...&gt;&amp; g)\n      : generators_(g) {}\n  ~CartesianProductGenerator() override = default;\n\n  ParamIteratorInterface&lt;ParamType&gt;* Begin() const override {\n    return new Iterator(this, generators_, false);\n  }\n  ParamIteratorInterface&lt;ParamType&gt;* End() const override {\n    return new Iterator(this, generators_, true);\n  }\n\n private:\n  template &lt;class I&gt;\n  class IteratorImpl;\n  template &lt;size_t... I&gt;\n  class IteratorImpl&lt;std::index_sequence&lt;I...&gt;&gt;\n      : public ParamIteratorInterface&lt;ParamType&gt; {\n   public:\n    IteratorImpl(const ParamGeneratorInterface&lt;ParamType&gt;* base,\n                 const std::tuple&lt;ParamGenerator&lt;T&gt;...&gt;&amp; generators,\n                 bool is_end)\n        : base_(base),\n          begin_(std::get&lt;I&gt;(generators).begin()...),\n          end_(std::get&lt;I&gt;(generators).end()...),\n          current_(is_end ? end_ : begin_) {\n      ComputeCurrentValue();\n    }\n    ~IteratorImpl() override = default;\n\n    const ParamGeneratorInterface&lt;ParamType&gt;* BaseGenerator() const override {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    void Advance() override {\n      assert(!AtEnd());\n      // Advance the last iterator.\n      ++std::get&lt;sizeof...(T) - 1&gt;(current_);\n      // if that reaches end, propagate that up.\n      AdvanceIfEnd&lt;sizeof...(T) - 1&gt;();\n      ComputeCurrentValue();\n    }\n    ParamIteratorInterface&lt;ParamType&gt;* Clone() const override {\n      return new IteratorImpl(*this);\n    }\n\n    const ParamType* Current() const override { return current_value_.get(); }\n\n    bool Equals(const ParamIteratorInterface&lt;ParamType&gt;&amp; other) const override {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          &lt;&lt; &quot;The program attempted to compare iterators &quot;\n          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;\n      const IteratorImpl* typed_other =\n          CheckedDowncastToActualType&lt;const IteratorImpl&gt;(&amp;other);\n\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      if (AtEnd() &amp;&amp; typed_other-&gt;AtEnd()) return true;\n\n      bool same = true;\n      bool dummy[] = {\n          (same = same &amp;&amp; std::get&lt;I&gt;(current_) ==\n                              std::get&lt;I&gt;(typed_other-&gt;current_))...};\n      (void)dummy;\n      return same;\n    }\n\n   private:\n    template &lt;size_t ThisI&gt;\n    void AdvanceIfEnd() {\n      if (std::get&lt;ThisI&gt;(current_) != std::get&lt;ThisI&gt;(end_)) return;\n\n      bool last = ThisI == 0;\n      if (last) {\n        // We are done. Nothing else to propagate.\n        return;\n      }\n\n      constexpr size_t NextI = ThisI - (ThisI != 0);\n      std::get&lt;ThisI&gt;(current_) = std::get&lt;ThisI&gt;(begin_);\n      ++std::get&lt;NextI&gt;(current_);\n      AdvanceIfEnd&lt;NextI&gt;();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = std::make_shared&lt;ParamType&gt;(*std::get&lt;I&gt;(current_)...);\n    }\n    bool AtEnd() const {\n      bool at_end = false;\n      bool dummy[] = {\n          (at_end = at_end || std::get&lt;I&gt;(current_) == std::get&lt;I&gt;(end_))...};\n      (void)dummy;\n      return at_end;\n    }\n\n    const ParamGeneratorInterface&lt;ParamType&gt;* const base_;\n    std::tuple&lt;typename ParamGenerator&lt;T&gt;::iterator...&gt; begin_;\n    std::tuple&lt;typename ParamGenerator&lt;T&gt;::iterator...&gt; end_;\n    std::tuple&lt;typename ParamGenerator&lt;T&gt;::iterator...&gt; current_;\n    std::shared_ptr&lt;ParamType&gt; current_value_;\n  };\n\n  using Iterator = IteratorImpl&lt;std::make_index_sequence&lt;sizeof...(T)&gt;&gt;;\n\n  std::tuple&lt;ParamGenerator&lt;T&gt;...&gt; generators_;\n};\n\ntemplate &lt;class... Gen&gt;\nclass CartesianProductHolder {\n public:\n  CartesianProductHolder(const Gen&amp;... g) : generators_(g...) {}\n  template &lt;typename... T&gt;\n  operator ParamGenerator&lt;::std::tuple&lt;T...&gt;&gt;() const {\n    return ParamGenerator&lt;::std::tuple&lt;T...&gt;&gt;(\n        new CartesianProductGenerator&lt;T...&gt;(generators_));\n  }\n\n private:\n  std::tuple&lt;Gen...&gt; generators_;\n};\n\ntemplate &lt;typename From, typename To&gt;\nclass ParamGeneratorConverter : public ParamGeneratorInterface&lt;To&gt; {\n public:\n  ParamGeneratorConverter(ParamGenerator&lt;From&gt; gen)  // NOLINT\n      : generator_(std::move(gen)) {}\n\n  ParamIteratorInterface&lt;To&gt;* Begin() const override {\n    return new Iterator(this, generator_.begin(), generator_.end());\n  }\n  ParamIteratorInterface&lt;To&gt;* End() const override {\n    return new Iterator(this, generator_.end(), generator_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface&lt;To&gt; {\n   public:\n    Iterator(const ParamGeneratorInterface&lt;To&gt;* base, ParamIterator&lt;From&gt; it,\n             ParamIterator&lt;From&gt; end)\n        : base_(base), it_(it), end_(end) {\n      if (it_ != end_) value_ = std::make_shared&lt;To&gt;(static_cast&lt;To&gt;(*it_));\n    }\n    ~Iterator() override = default;\n\n    const ParamGeneratorInterface&lt;To&gt;* BaseGenerator() const override {\n      return base_;\n    }\n    void Advance() override {\n      ++it_;\n      if (it_ != end_) value_ = std::make_shared&lt;To&gt;(static_cast&lt;To&gt;(*it_));\n    }\n    ParamIteratorInterface&lt;To&gt;* Clone() const override {\n      return new Iterator(*this);\n    }\n    const To* Current() const override { return value_.get(); }\n    bool Equals(const ParamIteratorInterface&lt;To&gt;&amp; other) const override {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          &lt;&lt; &quot;The program attempted to compare iterators &quot;\n          &lt;&lt; &quot;from different generators.&quot; &lt;&lt; std::endl;\n      const ParamIterator&lt;From&gt; other_it =\n          CheckedDowncastToActualType&lt;const Iterator&gt;(&amp;other)-&gt;it_;\n      return it_ == other_it;\n    }\n\n   private:\n    Iterator(const Iterator&amp; other) = default;\n\n    const ParamGeneratorInterface&lt;To&gt;* const base_;\n    ParamIterator&lt;From&gt; it_;\n    ParamIterator&lt;From&gt; end_;\n    std::shared_ptr&lt;To&gt; value_;\n  };  // class ParamGeneratorConverter::Iterator\n\n  ParamGenerator&lt;From&gt; generator_;\n};  // class ParamGeneratorConverter\n\ntemplate &lt;class Gen&gt;\nclass ParamConverterGenerator {\n public:\n  ParamConverterGenerator(ParamGenerator&lt;Gen&gt; g)  // NOLINT\n      : generator_(std::move(g)) {}\n\n  template &lt;typename T&gt;\n  operator ParamGenerator&lt;T&gt;() const {  // NOLINT\n    return ParamGenerator&lt;T&gt;(new ParamGeneratorConverter&lt;Gen, T&gt;(generator_));\n  }\n\n private:\n  ParamGenerator&lt;Gen&gt; generator_;\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don&#x27;t\n// end with _ are part of Google Test&#x27;s public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n// IWYU pragma: private, include &quot;gtest/gtest.h&quot;\n// IWYU pragma: friend gtest/.*\n// IWYU pragma: friend gmock/.*\n\n#ifndef GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don&#x27;t need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it&#x27;s necessary for a user to define some of the following\n// macros in the build script to override Google Test&#x27;s decisions.\n//\n// If the user doesn&#x27;t define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don&#x27;t use #ifdef or &quot;#if\n//     defined(...)&quot;, which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren&#x27;t available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that &lt;pthread.h&gt;\n//                              is/isn&#x27;t available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn&#x27;t\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn&#x27;t work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_FILE_SYSTEM    - Define it to 1/0 to indicate whether or not a\n//                              file system is/isn&#x27;t available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft&#x27;s &quot;Structured\n//                              Exception Handling&quot;.\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n//   GTEST_DEFAULT_DEATH_TEST_STYLE\n//                            - The default value of --gtest_death_test_style.\n//                              The legacy default has been &quot;fast&quot; in the open\n//                              source version since 2008. The recommended value\n//                              is &quot;threadsafe&quot;, and can be set in\n//                              custom/gtest-port.h.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_DRAGONFLY - DragonFlyBSD\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_FUCHSIA  - Fuchsia\n//   GTEST_OS_GNU_HURD - GNU/Hurd\n//   GTEST_OS_GNU_KFREEBSD - GNU/kFreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_NETBSD   - NetBSD\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_OS2      - OS/2\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Mac OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don&#x27;t have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it&#x27;s never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #ifdef\n// which controls that code.  For example:\n//\n// #ifdef GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_RE2         - the RE2 regular expression library is used\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above RE\\b(s) are mutually exclusive.\n//   GTEST_HAS_ABSL         - Google Test is compiled with Abseil.\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test&#x27;s INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_MUST_USE_RESULT_   - declares that a function&#x27;s result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//   GTEST_INTERNAL_HAS_ANY - for enabling UniversalPrinter&lt;std::any&gt; or\n//                            UniversalPrinter&lt;absl::any&gt; specializations.\n//                            Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_OPTIONAL - for enabling UniversalPrinter&lt;std::optional&gt;\n//   or\n//                                 UniversalPrinter&lt;absl::optional&gt;\n//                                 specializations. Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_STD_SPAN - for enabling UniversalPrinter&lt;std::span&gt;\n//                                 specializations. Always defined to 0 or 1\n//   GTEST_INTERNAL_HAS_STRING_VIEW - for enabling Matcher&lt;std::string_view&gt; or\n//                                    Matcher&lt;absl::string_view&gt;\n//                                    specializations. Always defined to 0 or 1.\n//   GTEST_INTERNAL_HAS_VARIANT - for enabling UniversalPrinter&lt;std::variant&gt; or\n//                                UniversalPrinter&lt;absl::variant&gt;\n//                                specializations. Always defined to 0 or 1.\n//   GTEST_USE_OWN_FLAGFILE_FLAG_ - Always defined to 0 or 1.\n//   GTEST_HAS_CXXABI_H_ - Always defined to 0 or 1.\n//   GTEST_CAN_STREAM_RESULTS_ - Always defined to 0 or 1.\n//   GTEST_HAS_ALT_PATH_SEP_ - Always defined to 0 or 1.\n//   GTEST_WIDE_STRING_USES_UTF16_ - Always defined to 0 or 1.\n//   GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ - Always defined to 0 or 1.\n//   GTEST_HAS_NOTIFICATION_- Always defined to 0 or 1.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using\n//                     1) the RE2 syntax on all platforms when built with RE2\n//                        and Abseil as dependencies\n//                     2) the POSIX Extended Regular Expression syntax on\n//                        UNIX-like platforms,\n//                     3) A reduced regular exception syntax on other platforms,\n//                        including Windows.\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   TimeInMillis   - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an int32_t environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n//\n// Deprecation warnings:\n//   GTEST_INTERNAL_DEPRECATED(message) - attribute marking a function as\n//                                        deprecated; calling a marked function\n//                                        should generate a compiler warning\n\n// The definition of GTEST_INTERNAL_CPLUSPLUS_LANG comes first because it can\n// potentially be used as an #include guard.\n#if defined(_MSVC_LANG)\n#define GTEST_INTERNAL_CPLUSPLUS_LANG _MSVC_LANG\n#elif defined(__cplusplus)\n#define GTEST_INTERNAL_CPLUSPLUS_LANG __cplusplus\n#endif\n\n#if !defined(GTEST_INTERNAL_CPLUSPLUS_LANG) || \\\n    GTEST_INTERNAL_CPLUSPLUS_LANG &lt; 201402L\n#error C++ versions less than C++14 are not supported.\n#endif\n\n// MSVC &gt;= 19.11 (VS 2017 Update 3) supports __has_include.\n#ifdef __has_include\n#define GTEST_INTERNAL_HAS_INCLUDE __has_include\n#else\n#define GTEST_INTERNAL_HAS_INCLUDE(...) 0\n#endif\n\n// Detect C++ feature test macros as gracefully as possible.\n// MSVC &gt;= 19.15, Clang &gt;= 3.4.1, and GCC &gt;= 4.1.2 support feature test macros.\n#if GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 202002L &amp;&amp; \\\n    (!defined(__has_include) || GTEST_INTERNAL_HAS_INCLUDE(&lt;version&gt;))\n#include &lt;version&gt;  // C++20 and later\n#elif (!defined(__has_include) || GTEST_INTERNAL_HAS_INCLUDE(&lt;ciso646&gt;))\n#include &lt;ciso646&gt;  // Pre-C++20\n#endif\n\n#include &lt;ctype.h&gt;   // for isspace, etc\n#include &lt;stddef.h&gt;  // for ptrdiff_t\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cerrno&gt;\n// #include &lt;condition_variable&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;locale&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n// #include &lt;mutex&gt;  // Guarded by GTEST_IS_THREADSAFE below\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#ifndef _WIN32_WCE\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n#include &lt;AvailabilityMacros.h&gt;\n#include &lt;TargetConditionals.h&gt;\n#endif\n\n#include &quot;gtest/internal/custom/gtest-port.h&quot;\n#include &quot;gtest/internal/gtest-port-arch.h&quot;\n\n#ifndef GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n#define GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ 0\n#endif\n\n#ifndef GTEST_HAS_NOTIFICATION_\n#define GTEST_HAS_NOTIFICATION_ 0\n#endif\n\n#if defined(GTEST_HAS_ABSL) &amp;&amp; !defined(GTEST_NO_ABSL_FLAGS)\n#define GTEST_INTERNAL_HAS_ABSL_FLAGS  // Used only in this file.\n#include &quot;absl/flags/declare.h&quot;\n#include &quot;absl/flags/flag.h&quot;\n#include &quot;absl/flags/reflection.h&quot;\n#endif\n\n#if !defined(GTEST_DEV_EMAIL_)\n#define GTEST_DEV_EMAIL_ &quot;googletestframework@@googlegroups.com&quot;\n#define GTEST_FLAG_PREFIX_ &quot;gtest_&quot;\n#define GTEST_FLAG_PREFIX_DASH_ &quot;gtest-&quot;\n#define GTEST_FLAG_PREFIX_UPPER_ &quot;GTEST_&quot;\n#define GTEST_NAME_ &quot;Google Test&quot;\n#define GTEST_PROJECT_URL_ &quot;https://github.com/google/googletest/&quot;\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n#define GTEST_INIT_GOOGLE_TEST_NAME_ &quot;testing::InitGoogleTest&quot;\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n#define GTEST_GCC_VER_ \\\n  (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if defined(_MSC_VER)\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n  __pragma(warning(push)) __pragma(warning(disable : warnings))\n#define GTEST_DISABLE_MSC_WARNINGS_POP_() __pragma(warning(pop))\n#else\n// Not all compilers are MSVC\n#define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n#define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Clang on Windows does not understand MSVC&#x27;s pragma warning.\n// We need clang-specific way to disable function deprecation warning.\n#ifdef __clang__\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_()                            \\\n  _Pragma(&quot;clang diagnostic push&quot;)                                      \\\n      _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-declarations\\&quot;&quot;) \\\n          _Pragma(&quot;clang diagnostic ignored \\&quot;-Wdeprecated-implementations\\&quot;&quot;)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() _Pragma(&quot;clang diagnostic pop&quot;)\n#else\n#define GTEST_DISABLE_MSC_DEPRECATED_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\n#define GTEST_DISABLE_MSC_DEPRECATED_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#ifdef GTEST_OS_WINDOWS\n#ifndef GTEST_OS_WINDOWS_MOBILE\n#include &lt;direct.h&gt;\n#include &lt;io.h&gt;\n#endif\n// In order to avoid having to include &lt;windows.h&gt;, use forward declaration\n#if defined(GTEST_OS_WINDOWS_MINGW) &amp;&amp; !defined(__MINGW64_VERSION_MAJOR)\n// MinGW defined _CRITICAL_SECTION and _RTL_CRITICAL_SECTION as two\n// separate (equivalent) structs, instead of using typedef\ntypedef struct _CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#else\n// Assume CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\ntypedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;\n#endif\n#elif defined(GTEST_OS_XTENSA)\n#include &lt;unistd.h&gt;\n// Xtensa toolchains define strcasecmp in the string.h header instead of\n// strings.h. string.h is already included.\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n#include &lt;strings.h&gt;\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#ifdef GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#include &lt;android/api-level.h&gt;  // NOLINT\n#endif\n\n// Defines this to true if and only if Google Test can use POSIX regular\n// expressions.\n#ifndef GTEST_HAS_POSIX_RE\n#ifdef GTEST_OS_LINUX_ANDROID\n// On Android, &lt;regex.h&gt; is only available starting with Gingerbread.\n#define GTEST_HAS_POSIX_RE (__ANDROID_API__ &gt;= 9)\n#else\n#if !(defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_XTENSA) || \\\n      defined(GTEST_OS_QURT))\n#define GTEST_HAS_POSIX_RE 1\n#else\n#define GTEST_HAS_POSIX_RE 0\n#endif\n#endif  // GTEST_OS_LINUX_ANDROID\n#endif\n\n// Select the regular expression implementation.\n#ifdef GTEST_HAS_ABSL\n// When using Abseil, RE2 is required.\n#include &quot;absl/strings/string_view.h&quot;\n#include &quot;re2/re2.h&quot;\n#define GTEST_USES_RE2 1\n#elif GTEST_HAS_POSIX_RE\n#include &lt;regex.h&gt;  // NOLINT\n#define GTEST_USES_POSIX_RE 1\n#else\n// Use our own simple regex implementation.\n#define GTEST_USES_SIMPLE_RE 1\n#endif\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn&#x27;t tell us whether exceptions are enabled, so we need\n// to figure it out.\n#if defined(_MSC_VER) &amp;&amp; defined(_CPPUNWIND)\n// MSVC defines _CPPUNWIND to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__BORLANDC__)\n// C++Builder&#x27;s implementation of the STL uses the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we&#x27;ll do the same.\n// Assumes that exceptions are enabled by default.\n#ifndef _HAS_EXCEPTIONS\n#define _HAS_EXCEPTIONS 1\n#endif  // _HAS_EXCEPTIONS\n#define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n#elif defined(__clang__)\n// clang defines __EXCEPTIONS if and only if exceptions are enabled before clang\n// 220714, but if and only if cleanups are enabled after that. In Obj-C++ files,\n// there can be cleanups for ObjC exceptions which also need cleanups, even if\n// C++ exceptions are disabled. clang has __has_feature(cxx_exceptions) which\n// checks for C++ exceptions starting at clang r206352, but which checked for\n// cleanups prior to that. To reliably check for C++ exception availability with\n// clang, check for\n// __EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions).\n#if defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS &amp;&amp; __has_feature(cxx_exceptions)\n#define GTEST_HAS_EXCEPTIONS 1\n#else\n#define GTEST_HAS_EXCEPTIONS 0\n#endif\n#elif defined(__GNUC__) &amp;&amp; defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__IBMCPP__) &amp;&amp; defined(__EXCEPTIONS) &amp;&amp; __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 if and only if exceptions are enabled.\n#define GTEST_HAS_EXCEPTIONS 1\n#elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#define GTEST_HAS_EXCEPTIONS 1\n#else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#define GTEST_HAS_EXCEPTIONS 0\n#endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn&#x27;t tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// Cygwin 1.7 and below doesn&#x27;t support ::std::wstring.\n// Solaris&#x27; libc++ doesn&#x27;t support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n#if (!(defined(GTEST_OS_LINUX_ANDROID) || defined(GTEST_OS_CYGWIN) || \\\n       defined(GTEST_OS_SOLARIS) || defined(GTEST_OS_HAIKU) ||        \\\n       defined(GTEST_OS_ESP32) || defined(GTEST_OS_ESP8266) ||        \\\n       defined(GTEST_OS_XTENSA) || defined(GTEST_OS_QURT) ||          \\\n       defined(GTEST_OS_NXP_QN9090) || defined(GTEST_OS_NRF52)))\n#define GTEST_HAS_STD_WSTRING 1\n#else\n#define GTEST_HAS_STD_WSTRING 0\n#endif\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_FILE_SYSTEM\n// Most platforms support a file system.\n#define GTEST_HAS_FILE_SYSTEM 1\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn&#x27;t tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n#ifdef _MSC_VER\n\n#ifdef _CPPRTTI  // MSVC defines this macro if and only if RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI if and only if RTTI is\n// enabled.\n#elif defined(__GNUC__)\n\n#ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#if defined(GTEST_OS_LINUX_ANDROID) &amp;&amp; defined(_STLPORT_MAJOR) &amp;&amp; \\\n    !defined(__EXCEPTIONS)\n#define GTEST_HAS_RTTI 0\n#else\n#define GTEST_HAS_RTTI 1\n#endif  // GTEST_OS_LINUX_ANDROID &amp;&amp; __STLPORT_MAJOR &amp;&amp; !__EXCEPTIONS\n#else\n#define GTEST_HAS_RTTI 0\n#endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n#elif defined(__clang__)\n\n#define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n#elif defined(__IBMCPP__) &amp;&amp; (__IBMCPP__ &gt;= 900)\n\n#ifdef __RTTI_ALL__\n#define GTEST_HAS_RTTI 1\n#else\n#define GTEST_HAS_RTTI 0\n#endif\n\n#else\n\n// For all other compilers, we assume RTTI is enabled.\n#define GTEST_HAS_RTTI 1\n\n#endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It&#x27;s this header&#x27;s responsibility to #include &lt;typeinfo&gt; when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n#include &lt;typeinfo&gt;\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn&#x27;t tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n#if (defined(GTEST_OS_LINUX) || defined(GTEST_OS_MAC) ||              \\\n     defined(GTEST_OS_HPUX) || defined(GTEST_OS_QNX) ||               \\\n     defined(GTEST_OS_FREEBSD) || defined(GTEST_OS_NACL) ||           \\\n     defined(GTEST_OS_NETBSD) || defined(GTEST_OS_FUCHSIA) ||         \\\n     defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n     defined(GTEST_OS_OPENBSD) || defined(GTEST_OS_HAIKU) ||          \\\n     defined(GTEST_OS_GNU_HURD) || defined(GTEST_OS_SOLARIS) ||       \\\n     defined(GTEST_OS_AIX) || defined(GTEST_OS_ZOS))\n#define GTEST_HAS_PTHREAD 1\n#else\n#define GTEST_HAS_PTHREAD 0\n#endif\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include &lt;pthread.h&gt; when GTEST_HAS_PTHREAD is\n// true.\n#include &lt;pthread.h&gt;  // NOLINT\n\n// For timespec and nanosleep, used below.\n#include &lt;time.h&gt;  // NOLINT\n#endif\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see https://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if defined(GTEST_OS_LINUX) &amp;&amp; !defined(__ia64__)\n#if defined(GTEST_OS_LINUX_ANDROID)\n// On Android, clone() became available at different API levels for each 32-bit\n// architecture.\n#if defined(__LP64__) || (defined(__arm__) &amp;&amp; __ANDROID_API__ &gt;= 9) || \\\n    (defined(__mips__) &amp;&amp; __ANDROID_API__ &gt;= 12) ||                    \\\n    (defined(__i386__) &amp;&amp; __ANDROID_API__ &gt;= 17)\n#define GTEST_HAS_CLONE 1\n#else\n#define GTEST_HAS_CLONE 0\n#endif\n#else\n#define GTEST_HAS_CLONE 1\n#endif\n#else\n#define GTEST_HAS_CLONE 0\n#endif  // GTEST_OS_LINUX &amp;&amp; !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile / embedded ones. Also, if the port doesn&#x27;t have\n// a file system, stream redirection is not supported.\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_WINDOWS_PHONE) || \\\n    defined(GTEST_OS_WINDOWS_RT) || defined(GTEST_OS_WINDOWS_GAMES) ||     \\\n    defined(GTEST_OS_ESP8266) || defined(GTEST_OS_XTENSA) ||               \\\n    defined(GTEST_OS_QURT) || !GTEST_HAS_FILE_SYSTEM\n#define GTEST_HAS_STREAM_REDIRECTION 0\n#else\n#define GTEST_HAS_STREAM_REDIRECTION 1\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (defined(GTEST_OS_LINUX) || defined(GTEST_OS_CYGWIN) ||           \\\n     defined(GTEST_OS_SOLARIS) || defined(GTEST_OS_ZOS) ||            \\\n     (defined(GTEST_OS_MAC) &amp;&amp; !defined(GTEST_OS_IOS)) ||             \\\n     (defined(GTEST_OS_WINDOWS_DESKTOP) &amp;&amp; _MSC_VER) ||               \\\n     defined(GTEST_OS_WINDOWS_MINGW) || defined(GTEST_OS_AIX) ||      \\\n     defined(GTEST_OS_HPUX) || defined(GTEST_OS_OPENBSD) ||           \\\n     defined(GTEST_OS_QNX) || defined(GTEST_OS_FREEBSD) ||            \\\n     defined(GTEST_OS_NETBSD) || defined(GTEST_OS_FUCHSIA) ||         \\\n     defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n     defined(GTEST_OS_HAIKU) || defined(GTEST_OS_GNU_HURD))\n// Death tests require a file system to work properly.\n#if GTEST_HAS_FILE_SYSTEM\n#define GTEST_HAS_DEATH_TEST 1\n#endif  // GTEST_HAS_FILE_SYSTEM\n#endif\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need &lt;typeinfo&gt; and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || defined(_MSC_VER) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n#define GTEST_HAS_TYPED_TEST 1\n#define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_CYGWIN) || \\\n    defined(GTEST_OS_AIX) || defined(GTEST_OS_OS2)\n#define GTEST_WIDE_STRING_USES_UTF16_ 1\n#else\n#define GTEST_WIDE_STRING_USES_UTF16_ 0\n#endif\n\n// Determines whether test results can be streamed to a socket.\n#if defined(GTEST_OS_LINUX) || defined(GTEST_OS_GNU_KFREEBSD) || \\\n    defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_FREEBSD) ||  \\\n    defined(GTEST_OS_NETBSD) || defined(GTEST_OS_OPENBSD) ||     \\\n    defined(GTEST_OS_GNU_HURD) || defined(GTEST_OS_MAC)\n#define GTEST_CAN_STREAM_RESULTS_ 1\n#else\n#define GTEST_CAN_STREAM_RESULTS_ 0\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested &quot;if&quot; statements are followed by\n// an &quot;else&quot; statement and braces are not used to explicitly disambiguate the\n// &quot;else&quot; binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) &lt;&lt; &quot;Some message&quot;;\n//\n// The &quot;switch (0) case 0:&quot; idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n#define GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  switch (0)                          \\\n  case 0:                             \\\n  default:  // NOLINT\n#endif\n\n// GTEST_HAVE_ATTRIBUTE_\n//\n// A function-like feature checking macro that is a wrapper around\n// `__has_attribute`, which is defined by GCC 5+ and Clang and evaluates to a\n// nonzero constant integer if the attribute is supported or 0 if not.\n//\n// It evaluates to zero if `__has_attribute` is not defined by the compiler.\n//\n// GCC: https://gcc.gnu.org/gcc-5/changes.html\n// Clang: https://clang.llvm.org/docs/LanguageExtensions.html\n#ifdef __has_attribute\n#define GTEST_HAVE_ATTRIBUTE_(x) __has_attribute(x)\n#else\n#define GTEST_HAVE_ATTRIBUTE_(x) 0\n#endif\n\n// GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE\n//\n// A function-like feature checking macro that accepts C++11 style attributes.\n// It&#x27;s a wrapper around `__has_cpp_attribute`, defined by ISO C++ SD-6\n// (https://en.cppreference.com/w/cpp/experimental/feature_test). If we don&#x27;t\n// find `__has_cpp_attribute`, will evaluate to 0.\n#if defined(__has_cpp_attribute)\n// NOTE: requiring __cplusplus above should not be necessary, but\n// works around https://bugs.llvm.org/show_bug.cgi?id=23435.\n#define GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n#define GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(x) 0\n#endif\n\n// GTEST_HAVE_FEATURE_\n//\n// A function-like feature checking macro that is a wrapper around\n// `__has_feature`.\n#ifdef __has_feature\n#define GTEST_HAVE_FEATURE_(x) __has_feature(x)\n#else\n#define GTEST_HAVE_FEATURE_(x) 0\n#endif\n\n// Use this annotation after a variable or parameter declaration to tell the\n// compiler the variable/parameter may be used.\n// Example:\n//\n//   GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED int foo = bar();\n//\n// This can be removed once we only support only C++17 or newer and\n// [[maybe_unused]] is available on all supported platforms.\n#if GTEST_INTERNAL_HAVE_CPP_ATTRIBUTE(maybe_unused)\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED [[maybe_unused]]\n#elif GTEST_HAVE_ATTRIBUTE_(unused)\n// This is inferior to [[maybe_unused]] as it can produce a\n// -Wused-but-marked-unused warning on optionally used symbols, but it is all we\n// have.\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED __attribute__((__unused__))\n#else\n#define GTEST_INTERNAL_ATTRIBUTE_MAYBE_UNUSED\n#endif\n\n// Use this annotation before a function that takes a printf format string.\n#if GTEST_HAVE_ATTRIBUTE_(format) &amp;&amp; defined(__MINGW_PRINTF_FORMAT)\n// MinGW has two different printf implementations. Ensure the format macro\n// matches the selected implementation. See\n// https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/.\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((format(__MINGW_PRINTF_FORMAT, string_index, first_to_check)))\n#elif GTEST_HAVE_ATTRIBUTE_(format)\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\\n  __attribute__((format(printf, string_index, first_to_check)))\n#else\n#define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check)\n#endif\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if GTEST_HAVE_ATTRIBUTE_(warn_unused_result)\n#define GTEST_MUST_USE_RESULT_ __attribute__((warn_unused_result))\n#else\n#define GTEST_MUST_USE_RESULT_\n#endif\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n#define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n#define GTEST_INTENTIONAL_CONST_COND_POP_() GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft&#x27;s Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn&#x27;t tell us, so we need to figure it out.\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#define GTEST_HAS_SEH 1\n#else\n// Assume no SEH.\n#define GTEST_HAS_SEH 0\n#endif\n\n#endif  // GTEST_HAS_SEH\n\n#ifndef GTEST_IS_THREADSAFE\n\n#if (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ ||                              \\\n     (defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n      !defined(GTEST_OS_WINDOWS_RT)) ||                                \\\n     GTEST_HAS_PTHREAD)\n#define GTEST_IS_THREADSAFE 1\n#endif\n\n#endif  // GTEST_IS_THREADSAFE\n\n#ifdef GTEST_IS_THREADSAFE\n// Some platforms don&#x27;t support including these threading related headers.\n#include &lt;condition_variable&gt;  // NOLINT\n#include &lt;mutex&gt;               // NOLINT\n#endif                         // GTEST_IS_THREADSAFE\n\n// GTEST_API_ qualifies all symbols that must be exported. The definitions below\n// are guarded by #ifndef to give embedders a chance to define GTEST_API_ in\n// gtest/internal/custom/gtest-port.h\n#ifndef GTEST_API_\n\n#ifdef _MSC_VER\n#if defined(GTEST_LINKED_AS_SHARED_LIBRARY) &amp;&amp; GTEST_LINKED_AS_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllimport)\n#elif defined(GTEST_CREATE_SHARED_LIBRARY) &amp;&amp; GTEST_CREATE_SHARED_LIBRARY\n#define GTEST_API_ __declspec(dllexport)\n#endif\n#elif GTEST_HAVE_ATTRIBUTE_(visibility)\n#define GTEST_API_ __attribute__((visibility(&quot;default&quot;)))\n#endif  // _MSC_VER\n\n#endif  // GTEST_API_\n\n#ifndef GTEST_API_\n#define GTEST_API_\n#endif  // GTEST_API_\n\n#ifndef GTEST_DEFAULT_DEATH_TEST_STYLE\n#define GTEST_DEFAULT_DEATH_TEST_STYLE &quot;fast&quot;\n#endif  // GTEST_DEFAULT_DEATH_TEST_STYLE\n\n#if GTEST_HAVE_ATTRIBUTE_(noinline)\n// Ask the compiler to never inline a given function.\n#define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n#define GTEST_NO_INLINE_\n#endif\n\n#if GTEST_HAVE_ATTRIBUTE_(disable_tail_calls)\n// Ask the compiler not to perform tail call optimization inside\n// the marked function.\n#define GTEST_NO_TAIL_CALL_ __attribute__((disable_tail_calls))\n#elif defined(__GNUC__) &amp;&amp; !defined(__NVCOMPILER)\n#define GTEST_NO_TAIL_CALL_ \\\n  __attribute__((optimize(&quot;no-optimize-sibling-calls&quot;)))\n#else\n#define GTEST_NO_TAIL_CALL_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if !defined(GTEST_HAS_CXXABI_H_)\n#if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) &amp;&amp; !defined(_MSC_VER))\n#define GTEST_HAS_CXXABI_H_ 1\n#else\n#define GTEST_HAS_CXXABI_H_ 0\n#endif\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_memory)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ __attribute__((no_sanitize_memory))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_address)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n  __attribute__((no_sanitize_address))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif\n\n// A function level attribute to disable HWAddressSanitizer instrumentation.\n#if GTEST_HAVE_FEATURE_(hwaddress_sanitizer) &amp;&amp; \\\n    GTEST_HAVE_ATTRIBUTE_(no_sanitize)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_ \\\n  __attribute__((no_sanitize(&quot;hwaddress&quot;)))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\n#endif\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if GTEST_HAVE_ATTRIBUTE_(no_sanitize_thread)\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ __attribute((no_sanitize_thread))\n#else\n#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif\n\nnamespace testing {\n\nclass Message;\n\n// Legacy imports for backwards compatibility.\n// New code should use std:: names directly.\nusing std::get;\nusing std::make_tuple;\nusing std::tuple;\nusing std::tuple_element;\nusing std::tuple_size;\n\nnamespace internal {\n\n// A secret type that Google Test users don&#x27;t know about.  It has no\n// accessible constructors on purpose.  Therefore it&#x27;s impossible to create a\n// Secret object, which is what we want.\nclass Secret {\n  Secret(const Secret&amp;) = delete;\n};\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns &#x27;condition&#x27;.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines RE.\n\n#ifdef GTEST_USES_RE2\n\n// This is almost `using RE = ::RE2`, except it is copy-constructible, and it\n// needs to disambiguate the `std::string`, `absl::string_view`, and `const\n// char*` constructors.\nclass GTEST_API_ RE {\n public:\n  RE(absl::string_view regex) : regex_(regex) {}                  // NOLINT\n  RE(const char* regex) : RE(absl::string_view(regex)) {}         // NOLINT\n  RE(const std::string&amp; regex) : RE(absl::string_view(regex)) {}  // NOLINT\n  RE(const RE&amp; other) : RE(other.pattern()) {}\n\n  const std::string&amp; pattern() const { return regex_.pattern(); }\n\n  static bool FullMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::FullMatch(str, re.regex_);\n  }\n  static bool PartialMatch(absl::string_view str, const RE&amp; re) {\n    return RE2::PartialMatch(str, re.regex_);\n  }\n\n private:\n  RE2 regex_;\n};\n\n#elif defined(GTEST_USES_POSIX_RE) || defined(GTEST_USES_SIMPLE_RE)\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// A simple C++ wrapper for &lt;regex.h&gt;.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE&amp; other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string&amp; regex) { Init(regex.c_str()); }  // NOLINT\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_.c_str(); }\n\n  // FullMatch(str, re) returns true if and only if regular expression re\n  // matches the entire str.\n  // PartialMatch(str, re) returns true if and only if regular expression re\n  // matches a substring of str (including str itself).\n  static bool FullMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string&amp; str, const RE&amp; re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n  static bool FullMatch(const char* str, const RE&amp; re);\n  static bool PartialMatch(const char* str, const RE&amp; re);\n\n private:\n  void Init(const char* regex);\n  std::string pattern_;\n  bool is_valid_;\n\n#ifdef GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  std::string full_pattern_;  // For FullMatch();\n\n#endif\n};\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n#endif  // ::testing::internal::RE implementation\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity { GTEST_INFO, GTEST_WARNING, GTEST_ERROR, GTEST_FATAL };\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream&amp; GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTestLog(const GTestLog&amp;) = delete;\n  GTestLog&amp; operator=(const GTestLog&amp;) = delete;\n};\n\n#if !defined(GTEST_LOG_)\n\n#define GTEST_LOG_(severity)                                           \\\n  ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                __FILE__, __LINE__)                    \\\n      .GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(nullptr); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsis:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) &lt;&lt; &quot;Additional message&quot;;\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n#define GTEST_CHECK_(condition)               \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_               \\\n  if (::testing::internal::IsTrue(condition)) \\\n    ;                                         \\\n  else                                        \\\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Condition &quot; #condition &quot; failed. &quot;\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn&#x27;t expand to a balanced &#x27;if&#x27; statement, so enclose the macro\n// in {} if you need to use it as the only statement in an &#x27;if&#x27;\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call))    \\\n  GTEST_LOG_(FATAL) &lt;&lt; #posix_call &lt;&lt; &quot;failed with error &quot; &lt;&lt; gtest_error\n\n// Transforms &quot;T&quot; into &quot;const T&amp;&quot; according to standard reference collapsing\n// rules (this is only needed as a backport for C++98 compilers that do not\n// support reference collapsing). Specifically, it transforms:\n//\n//   char         ==&gt; const char&amp;\n//   const char   ==&gt; const char&amp;\n//   char&amp;        ==&gt; char&amp;\n//   const char&amp;  ==&gt; const char&amp;\n//\n// Note that the non-const reference will not have &quot;const&quot; added. This is\n// standard, and necessary so that &quot;T&quot; can always bind to &quot;const T&amp;&quot;.\ntemplate &lt;typename T&gt;\nstruct ConstRef {\n  typedef const T&amp; type;\n};\ntemplate &lt;typename T&gt;\nstruct ConstRef&lt;T&amp;&gt; {\n  typedef T&amp; type;\n};\n\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n  typename ::testing::internal::ConstRef&lt;T&gt;::type\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertible to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_&lt;ToType&gt;(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate &lt;typename To&gt;\ninline To ImplicitCast_(To x) {\n  return x;\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate &lt;class Derived, class Base&gt;\nDerived* CheckedDowncastToActualType(Base* base) {\n  static_assert(std::is_base_of&lt;Base, Derived&gt;::value,\n                &quot;target type not derived from source type&quot;);\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(base == nullptr || dynamic_cast&lt;Derived*&gt;(base) != nullptr);\n#endif\n  return static_cast&lt;Derived*&gt;(base);\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ std::vector&lt;std::string&gt; GetArgvs();\n\n#ifdef GTEST_HAS_DEATH_TEST\n\nstd::vector&lt;std::string&gt; GetInjectableArgvs();\n// Deprecated: pass the args vector by value instead.\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;* new_argvs);\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;&amp; new_argvs);\nvoid ClearInjectableArgvs();\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#ifdef GTEST_IS_THREADSAFE\n\n#ifdef GTEST_OS_WINDOWS\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including &lt;windows.h&gt; in this header file. Including &lt;windows.h&gt; is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true if and only if the handle is a valid handle object that can be\n  // closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  AutoHandle(const AutoHandle&amp;) = delete;\n  AutoHandle&amp; operator=(const AutoHandle&amp;) = delete;\n};\n#endif\n\n#if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n#else\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test&#x27;s own constructs. Do not\n// use it in user tests, either directly or indirectly.\n// TODO(b/203539622): Replace unconditionally with absl::Notification.\nclass GTEST_API_ Notification {\n public:\n  Notification() : notified_(false) {}\n  Notification(const Notification&amp;) = delete;\n  Notification&amp; operator=(const Notification&amp;) = delete;\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    std::lock_guard&lt;std::mutex&gt; lock(mu_);\n    notified_ = true;\n    cv_.notify_all();\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    std::unique_lock&lt;std::mutex&gt; lock(mu_);\n    cv_.wait(lock, [this]() { return notified_; });\n  }\n\n private:\n  std::mutex mu_;\n  std::condition_variable cv_;\n  bool notified_;\n};\nGTEST_DISABLE_MSC_WARNINGS_POP_()  // 4251\n#endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don&#x27;t want to use MinGW&#x27;s pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n#if GTEST_HAS_PTHREAD &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() = default;\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern &quot;C&quot; inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast&lt;ThreadWithParamBase*&gt;(thread)-&gt;Run();\n  return nullptr;\n}\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam&lt;int&gt; thread(&amp;ThreadFunc, 5, &amp;thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test&#x27;s own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&amp;thread_, nullptr, &amp;ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() override { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, nullptr));\n      finished_ = true;\n    }\n  }\n\n  void Run() override {\n    if (thread_can_start_ != nullptr) thread_can_start_-&gt;WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true if and only if we know that the thread function has\n                   // finished.\n  pthread_t thread_;  // The native thread object.\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; GTEST_HAS_PTHREAD ||\n        // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n#elif defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT)\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&amp;mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per https://blogs.msdn.microsoft.com/oldnewthing/20040223-00/?p=40503,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  GTEST_CRITICAL_SECTION* critical_section_;\n\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder&lt;T&gt;.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder&lt;T&gt; object holding a default value passed to\n  // this ThreadLocal&lt;T&gt;&#x27;s constructor and returns it.  It is the caller&#x27;s\n  // responsibility not to call this when the ThreadLocal&lt;T&gt; instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  ThreadLocalBase(const ThreadLocalBase&amp;) = delete;\n  ThreadLocalBase&amp; operator=(const ThreadLocalBase&amp;) = delete;\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable* runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test&#x27;s multi-threading constructs.\ntemplate &lt;typename T&gt;\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {}\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param) : func_(func), param_(param) {}\n    virtual ~RunnableImpl() {}\n    virtual void Run() { func_(param_); }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    RunnableImpl(const RunnableImpl&amp;) = delete;\n    RunnableImpl&amp; operator=(const RunnableImpl&amp;) = delete;\n  };\n\n  ThreadWithParam(const ThreadWithParam&amp;) = delete;\n  ThreadWithParam&amp; operator=(const ThreadWithParam&amp;) = delete;\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal&lt;int&gt; tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate &lt;typename T&gt;\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() override { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  T* GetOrCreateValue() const {\n    return static_cast&lt;ValueHolder*&gt;(\n               ThreadLocalRegistry::GetValueOnCurrentThread(this))\n        -&gt;pointer();\n  }\n\n  ThreadLocalValueHolderBase* NewValueForCurrentThread() const override {\n    return default_factory_-&gt;MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&amp;mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don&#x27;t protect writing to has_owner_ here, as it&#x27;s\n    // the caller&#x27;s responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&amp;mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ &amp;&amp; pthread_equal(owner_, pthread_self()))\n        &lt;&lt; &quot;The current thread is not holding the mutex @&quot; &lt;&lt; this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there&#x27;s no\n  // guarantee that a zero&#x27;d pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n// The initialization list here does not explicitly initialize each field,\n// instead relying on default initialization for the unspecified fields. In\n// particular, the owner_ field (a pthread_t) is not explicitly initialized.\n// This allows initialization to work whether pthread_t is a scalar or struct.\n// The flag -Wmissing-field-initializers must not be specified for this to work.\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n  ::testing::internal::MutexBase mutex = {PTHREAD_MUTEX_INITIALIZER, false, 0}\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&amp;mutex_, nullptr));\n    has_owner_ = false;\n  }\n  ~Mutex() { GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&amp;mutex_)); }\n\n private:\n  Mutex(const Mutex&amp;) = delete;\n  Mutex&amp; operator=(const Mutex&amp;) = delete;\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex) : mutex_(mutex) { mutex_-&gt;Lock(); }\n\n  ~GTestMutexLock() { mutex_-&gt;Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTestMutexLock(const GTestMutexLock&amp;) = delete;\n  GTestMutexLock&amp; operator=(const GTestMutexLock&amp;) = delete;\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal&lt;T&gt;.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass GTEST_API_ ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() = default;\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern &quot;C&quot; inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast&lt;ThreadLocalValueHolderBase*&gt;(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T&amp; value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T&amp; get() const { return *pointer(); }\n  void set(const T&amp; value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T&amp; value) : value_(value) {}\n\n    T* pointer() { return &amp;value_; }\n\n   private:\n    T value_;\n    ValueHolder(const ValueHolder&amp;) = delete;\n    ValueHolder&amp; operator=(const ValueHolder&amp;) = delete;\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&amp;key, &amp;DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast&lt;ThreadLocalValueHolderBase*&gt;(pthread_getspecific(key_));\n    if (holder != nullptr) {\n      return CheckedDowncastToActualType&lt;ValueHolder&gt;(holder)-&gt;pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_-&gt;MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder-&gt;pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() = default;\n    virtual ~ValueHolderFactory() = default;\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    ValueHolderFactory(const ValueHolderFactory&amp;) = delete;\n    ValueHolderFactory&amp; operator=(const ValueHolderFactory&amp;) = delete;\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() = default;\n    ValueHolder* MakeNewHolder() const override { return new ValueHolder(); }\n\n   private:\n    DefaultValueHolderFactory(const DefaultValueHolderFactory&amp;) = delete;\n    DefaultValueHolderFactory&amp; operator=(const DefaultValueHolderFactory&amp;) =\n        delete;\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T&amp; value) : value_(value) {}\n    ValueHolder* MakeNewHolder() const override {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    InstanceValueHolderFactory(const InstanceValueHolderFactory&amp;) = delete;\n    InstanceValueHolderFactory&amp; operator=(const InstanceValueHolderFactory&amp;) =\n        delete;\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  std::unique_ptr&lt;ValueHolderFactory&gt; default_factory_;\n\n  ThreadLocal(const ThreadLocal&amp;) = delete;\n  ThreadLocal&amp; operator=(const ThreadLocal&amp;) = delete;\n};\n\n#endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n#define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n#define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like &quot;MutexLock(&amp;mu)&quot; rather than\n// &quot;MutexLock l(&amp;mu)&quot;.  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate &lt;typename T&gt;\nclass GTEST_API_ ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T&amp; value) : value_(value) {}\n  T* pointer() { return &amp;value_; }\n  const T* pointer() const { return &amp;value_; }\n  const T&amp; get() const { return value_; }\n  void set(const T&amp; value) { value_ = value; }\n\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n#ifdef GTEST_OS_WINDOWS\n#define GTEST_PATH_SEP_ &quot;\\\\&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 1\n#else\n#define GTEST_PATH_SEP_ &quot;/&quot;\n#define GTEST_HAS_ALT_PATH_SEP_ 0\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#ifdef __cpp_lib_char8_t\ninline bool IsXDigit(char8_t ch) {\n  return isxdigit(static_cast&lt;unsigned char&gt;(ch)) != 0;\n}\n#endif\ninline bool IsXDigit(char16_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(char32_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast&lt;unsigned char&gt;(ch);\n  return ch == low_byte &amp;&amp; isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast&lt;char&gt;(tolower(static_cast&lt;unsigned char&gt;(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast&lt;char&gt;(toupper(static_cast&lt;unsigned char&gt;(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() &amp;&amp; IsSpace(*--it)) it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// File system porting.\n// Note: Not every I/O-related function is related to file systems, so don&#x27;t\n// just disable all of them here. For example, fileno() and isatty(), etc. must\n// always be available in order to detect if a pipe points to a terminal.\n#ifdef GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast&lt;int&gt;(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n#else\ninline int FileNo(FILE* file) { return _fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return (_S_IFDIR &amp; st.st_mode) != 0; }\n#endif\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n#elif defined(GTEST_OS_ESP8266)\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) {\n  // stat function not implemented on ESP8266\n  return 0;\n}\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n#endif\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\n#if GTEST_HAS_FILE_SYSTEM\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\n#ifdef GTEST_OS_QURT\n// QuRT doesn&#x27;t support any directory functions, including rmdir\ninline int RmDir(const char*) { return 0; }\n#else\ninline int RmDir(const char* dir) { return rmdir(dir); }\n#endif\ninline bool IsDir(const StatStruct&amp; st) { return S_ISDIR(st.st_mode); }\n#endif\n\n#endif  // GTEST_OS_WINDOWS\n\n// Other functions with a different name on Windows.\n\n#ifdef GTEST_OS_WINDOWS\n\n#ifdef __BORLANDC__\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\n#else  // !__BORLANDC__\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_ZOS) || \\\n    defined(GTEST_OS_IOS) || defined(GTEST_OS_WINDOWS_PHONE) ||  \\\n    defined(GTEST_OS_WINDOWS_RT) || defined(ESP_PLATFORM)\ninline int DoIsATTY(int /* fd */) { return 0; }\n#else\ninline int DoIsATTY(int fd) { return _isatty(fd); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\n#endif  // __BORLANDC__\n\n#else\n\ninline int DoIsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\n\n#endif  // GTEST_OS_WINDOWS\n\ninline int IsATTY(int fd) {\n  // DoIsATTY might change errno (for example ENOTTY in case you redirect stdout\n  // to a file on Linux), which is unexpected, so save the previous value, and\n  // restore it after the call.\n  int savedErrno = errno;\n  int isAttyValue = DoIsATTY(fd);\n  errno = savedErrno;\n\n  return isAttyValue;\n}\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_DEPRECATED_PUSH_()\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren&#x27;t needed on Windows CE at this time and thus not\n// defined there.\n#if GTEST_HAS_FILE_SYSTEM\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT) &amp;&amp; !defined(GTEST_OS_WINDOWS_GAMES) &amp;&amp;     \\\n    !defined(GTEST_OS_ESP8266) &amp;&amp; !defined(GTEST_OS_XTENSA) &amp;&amp;               \\\n    !defined(GTEST_OS_QURT)\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n  struct wchar_codecvt : public std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; {};\n  std::wstring_convert&lt;wchar_codecvt&gt; converter;\n  std::wstring wide_path = converter.from_bytes(path);\n  std::wstring wide_mode = converter.from_bytes(mode);\n  return _wfopen(wide_path.c_str(), wide_mode.c_str());\n#else   // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n  return fopen(path, mode);\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW\n}\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline FILE* FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast&lt;int&gt;(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_QURT)\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif  // !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_QURT\n\ninline const char* GetEnv(const char* name) {\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_WINDOWS_PHONE) || \\\n    defined(GTEST_OS_ESP8266) || defined(GTEST_OS_XTENSA) ||               \\\n    defined(GTEST_OS_QURT)\n  // We are on an embedded platform, which has no environment variables.\n  static_cast&lt;void&gt;(name);  // To prevent &#x27;unused argument&#x27; warning.\n  return nullptr;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != nullptr &amp;&amp; env[0] != &#x27;\\0&#x27;) ? env : nullptr;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_DEPRECATED_POP_()\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\n[[noreturn]] void Abort();\n#else\n[[noreturn]] inline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC &quot;deprecates&quot; snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if defined(_MSC_VER) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE)\n// MSVC 2005 and above support variadic macros.\n#define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n  _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s\n#define GTEST_SNPRINTF_ _snprintf\n#else\n#define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The biggest signed integer type the compiler supports.\n//\n// long long is guaranteed to be at least 64-bits in C++11.\nusing BiggestInt = long long;  // NOLINT\n\n// The maximum number a BiggestInt can represent.\nconstexpr BiggestInt kMaxBiggestInt = (std::numeric_limits&lt;BiggestInt&gt;::max)();\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize&lt;4&gt;::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that&#x27;s all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate &lt;size_t size&gt;\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize&lt;N&gt; with incorrect\n  // values of N.\n  using UInt = void;\n};\n\n// The specialization for size 4.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;4&gt; {\n public:\n  using Int = std::int32_t;\n  using UInt = std::uint32_t;\n};\n\n// The specialization for size 8.\ntemplate &lt;&gt;\nclass TypeWithSize&lt;8&gt; {\n public:\n  using Int = std::int64_t;\n  using UInt = std::uint64_t;\n};\n\n// Integer types of known sizes.\nusing TimeInMillis = int64_t;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n#define GTEST_FLAG_NAME_(name) gtest_##name\n#define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n// Pick a command line flags implementation.\n#ifdef GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n  ABSL_FLAG(bool, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n  ABSL_FLAG(int32_t, GTEST_FLAG_NAME_(name), default_val, doc)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n  ABSL_FLAG(std::string, GTEST_FLAG_NAME_(name), default_val, doc)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name) \\\n  ABSL_DECLARE_FLAG(bool, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_int32_(name) \\\n  ABSL_DECLARE_FLAG(int32_t, GTEST_FLAG_NAME_(name))\n#define GTEST_DECLARE_string_(name) \\\n  ABSL_DECLARE_FLAG(std::string, GTEST_FLAG_NAME_(name))\n\n#define GTEST_FLAG_SAVER_ ::absl::FlagSaver\n\n#define GTEST_FLAG_GET(name) ::absl::GetFlag(GTEST_FLAG(name))\n#define GTEST_FLAG_SET(name, value) \\\n  (void)(::absl::SetFlag(&amp;GTEST_FLAG(name), value))\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 0\n\n#undef GTEST_INTERNAL_HAS_ABSL_FLAGS\n#else  // ndef GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc)  \\\n  namespace testing {                               \\\n  GTEST_API_ bool GTEST_FLAG(name) = (default_val); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_int32_(name, default_val, doc)         \\\n  namespace testing {                                       \\\n  GTEST_API_ std::int32_t GTEST_FLAG(name) = (default_val); \\\n  }                                                         \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DEFINE_string_(name, default_val, doc)         \\\n  namespace testing {                                        \\\n  GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val); \\\n  }                                                          \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n// Macros for declaring flags.\n#define GTEST_DECLARE_bool_(name)          \\\n  namespace testing {                      \\\n  GTEST_API_ extern bool GTEST_FLAG(name); \\\n  }                                        \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_int32_(name)                 \\\n  namespace testing {                              \\\n  GTEST_API_ extern std::int32_t GTEST_FLAG(name); \\\n  }                                                \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n#define GTEST_DECLARE_string_(name)                 \\\n  namespace testing {                               \\\n  GTEST_API_ extern ::std::string GTEST_FLAG(name); \\\n  }                                                 \\\n  static_assert(true, &quot;no-op to require trailing semicolon&quot;)\n\n#define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n#define GTEST_FLAG_GET(name) ::testing::GTEST_FLAG(name)\n#define GTEST_FLAG_SET(name, value) (void)(::testing::GTEST_FLAG(name) = value)\n#define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n\n#endif  // GTEST_INTERNAL_HAS_ABSL_FLAGS\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n#define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n#define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses &#x27;str&#x27; for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\nGTEST_API_ bool ParseInt32(const Message&amp; src_text, const char* str,\n                           int32_t* value);\n\n// Parses a bool/int32_t/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ int32_t Int32FromGTestEnv(const char* flag, int32_t default_val);\nstd::string OutputFlagAlsoCheckEnvVar();\nconst char* StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#if !defined(GTEST_INTERNAL_DEPRECATED)\n\n// Internal Macro to mark an API deprecated, for googletest usage only\n// Usage: class GTEST_INTERNAL_DEPRECATED(message) MyClass or\n// GTEST_INTERNAL_DEPRECATED(message) &lt;return_type&gt; myFunction(); Every usage of\n// a deprecated entity will trigger a warning when compiled with\n// `-Wdeprecated-declarations` option (clang, gcc, any __GNUC__ compiler).\n// For msvc /W3 option will need to be used\n// Note that for &#x27;other&#x27; compilers this macro evaluates to nothing to prevent\n// compilations errors.\n#if defined(_MSC_VER)\n#define GTEST_INTERNAL_DEPRECATED(message) __declspec(deprecated(message))\n#elif defined(__GNUC__)\n#define GTEST_INTERNAL_DEPRECATED(message) __attribute__((deprecated(message)))\n#else\n#define GTEST_INTERNAL_DEPRECATED(message)\n#endif\n\n#endif  // !defined(GTEST_INTERNAL_DEPRECATED)\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::any for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &quot;absl/types/any.h&quot;\nnamespace testing {\nnamespace internal {\nusing Any = ::absl::any;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_any) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;any&gt;) &amp;&amp;        \\\n                               GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L &amp;&amp; \\\n                               (!defined(_MSC_VER) || GTEST_HAS_RTTI))\n// Otherwise for C++17 and higher use std::any for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_ANY 1\n#include &lt;any&gt;\nnamespace testing {\nnamespace internal {\nusing Any = ::std::any;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::any is not\n// supported.\n#endif  // __cpp_lib_any\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_ANY\n#define GTEST_INTERNAL_HAS_ANY 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::optional for UniversalPrinter&lt;&gt; specializations if\n// googletest is built with absl support.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &quot;absl/types/optional.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::absl::optional&lt;T&gt;;\ninline ::absl::nullopt_t Nullopt() { return ::absl::nullopt; }\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_optional) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;optional&gt;) &amp;&amp; \\\n                                    GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::optional for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_OPTIONAL 1\n#include &lt;optional&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename T&gt;\nusing Optional = ::std::optional&lt;T&gt;;\ninline ::std::nullopt_t Nullopt() { return ::std::nullopt; }\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::optional is not\n// supported.\n#endif  // __cpp_lib_optional\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_OPTIONAL\n#define GTEST_INTERNAL_HAS_OPTIONAL 0\n#endif\n\n#if defined(__cpp_lib_span) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;span&gt;) &amp;&amp; \\\n                                GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 202002L)\n#define GTEST_INTERNAL_HAS_STD_SPAN 1\n#endif  // __cpp_lib_span\n\n#ifndef GTEST_INTERNAL_HAS_STD_SPAN\n#define GTEST_INTERNAL_HAS_STD_SPAN 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::string_view for Matcher&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &quot;absl/strings/string_view.h&quot;\nnamespace testing {\nnamespace internal {\nusing StringView = ::absl::string_view;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_string_view) ||             \\\n    (GTEST_INTERNAL_HAS_INCLUDE(&lt;string_view&gt;) &amp;&amp; \\\n     GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::string_view for Matcher&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_STRING_VIEW 1\n#include &lt;string_view&gt;\nnamespace testing {\nnamespace internal {\nusing StringView = ::std::string_view;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::string_view is not\n// supported.\n#endif  // __cpp_lib_string_view\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_STRING_VIEW\n#define GTEST_INTERNAL_HAS_STRING_VIEW 0\n#endif\n\n#ifdef GTEST_HAS_ABSL\n// Always use absl::variant for UniversalPrinter&lt;&gt; specializations if googletest\n// is built with absl support.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &quot;absl/types/variant.h&quot;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::absl::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n#else\n#if defined(__cpp_lib_variant) || (GTEST_INTERNAL_HAS_INCLUDE(&lt;variant&gt;) &amp;&amp; \\\n                                   GTEST_INTERNAL_CPLUSPLUS_LANG &gt;= 201703L)\n// Otherwise for C++17 and higher use std::variant for UniversalPrinter&lt;&gt;\n// specializations.\n#define GTEST_INTERNAL_HAS_VARIANT 1\n#include &lt;variant&gt;\nnamespace testing {\nnamespace internal {\ntemplate &lt;typename... T&gt;\nusing Variant = ::std::variant&lt;T...&gt;;\n}  // namespace internal\n}  // namespace testing\n// The case where absl is configured NOT to alias std::variant is not supported.\n#endif  // __cpp_lib_variant\n#endif  // GTEST_HAS_ABSL\n\n#ifndef GTEST_INTERNAL_HAS_VARIANT\n#define GTEST_INTERNAL_HAS_VARIANT 0\n#endif\n\n#if (defined(__cpp_constexpr) &amp;&amp; !defined(__cpp_inline_variables)) || \\\n    (defined(GTEST_INTERNAL_CPLUSPLUS_LANG) &amp;&amp;                        \\\n     GTEST_INTERNAL_CPLUSPLUS_LANG &lt; 201703L)\n#define GTEST_INTERNAL_NEED_REDUNDANT_CONSTEXPR_DECL 1\n#endif\n\n#endif  // GOOGLETEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n//\n// This file implements death tests.\n\n#include &quot;gtest/gtest-death-test.h&quot;\n\n#include &lt;stdlib.h&gt;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/internal/custom/gtest.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#ifdef GTEST_HAS_DEATH_TEST\n\n#ifdef GTEST_OS_MAC\n#include &lt;crt_externs.h&gt;\n#endif  // GTEST_OS_MAC\n\n#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;limits.h&gt;\n\n#ifdef GTEST_OS_LINUX\n#include &lt;signal.h&gt;\n#endif  // GTEST_OS_LINUX\n\n#include &lt;stdarg.h&gt;\n\n#ifdef GTEST_OS_WINDOWS\n#include &lt;windows.h&gt;\n#else\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/wait.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#ifdef GTEST_OS_QNX\n#include &lt;spawn.h&gt;\n#endif  // GTEST_OS_QNX\n\n#ifdef GTEST_OS_FUCHSIA\n#include &lt;lib/fdio/fd.h&gt;\n#include &lt;lib/fdio/io.h&gt;\n#include &lt;lib/fdio/spawn.h&gt;\n#include &lt;lib/zx/channel.h&gt;\n#include &lt;lib/zx/port.h&gt;\n#include &lt;lib/zx/process.h&gt;\n#include &lt;lib/zx/socket.h&gt;\n#include &lt;zircon/processargs.h&gt;\n#include &lt;zircon/syscalls.h&gt;\n#include &lt;zircon/syscalls/policy.h&gt;\n#include &lt;zircon/syscalls/port.h&gt;\n#endif  // GTEST_OS_FUCHSIA\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;src/gtest-internal-inl.h&quot;\n\nnamespace testing {\n\n// Constants.\n\n// The default death test style.\n//\n// This is defined in internal/gtest-port.h as &quot;fast&quot;, but can be overridden by\n// a definition in internal/custom/gtest-port.h. The recommended value, which is\n// used internally at Google, is &quot;threadsafe&quot;.\nstatic const char kDefaultDeathTestStyle[] = GTEST_DEFAULT_DEATH_TEST_STYLE;\n\n}  // namespace testing\n\nGTEST_DEFINE_string_(\n    death_test_style,\n    testing::internal::StringFromGTestEnv(&quot;death_test_style&quot;,\n                                          testing::kDefaultDeathTestStyle),\n    &quot;Indicates how to run a death test in a forked child process: &quot;\n    &quot;\\&quot;threadsafe\\&quot; (child process re-executes the test binary &quot;\n    &quot;from the beginning, running only the specific death test) or &quot;\n    &quot;\\&quot;fast\\&quot; (child process runs the death test immediately &quot;\n    &quot;after forking).&quot;);\n\nGTEST_DEFINE_bool_(\n    death_test_use_fork,\n    testing::internal::BoolFromGTestEnv(&quot;death_test_use_fork&quot;, false),\n    &quot;Instructs to use fork()/_Exit() instead of clone() in death tests. &quot;\n    &quot;Ignored and always uses fork() on POSIX systems where clone() is not &quot;\n    &quot;implemented. Useful when running under valgrind or similar tools if &quot;\n    &quot;those do not support clone(). Valgrind 3.3.1 will just fail if &quot;\n    &quot;it sees an unsupported combination of clone() flags. &quot;\n    &quot;It is not recommended to use this flag w/o valgrind though it will &quot;\n    &quot;work in 99% of the cases. Once valgrind is fixed, this flag will &quot;\n    &quot;most likely be removed.&quot;);\n\nGTEST_DEFINE_string_(\n    internal_run_death_test, &quot;&quot;,\n    &quot;Indicates the file, line number, temporal index of &quot;\n    &quot;the single death test to run, and a file descriptor to &quot;\n    &quot;which a success code may be sent, all separated by &quot;\n    &quot;the &#x27;|&#x27; characters.  This flag is specified if and only if the &quot;\n    &quot;current process is a sub-process launched for running a thread-safe &quot;\n    &quot;death test.  FOR INTERNAL USE ONLY.&quot;);\n\nnamespace testing {\n\n#ifdef GTEST_HAS_DEATH_TEST\n\nnamespace internal {\n\n// Valid only for fast death tests. Indicates the code is running in the\n// child process of a fast style death test.\n#if !defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_FUCHSIA)\nstatic bool g_in_fast_death_test_child = false;\n#endif\n\n// Returns a Boolean value indicating whether the caller is currently\n// executing in the context of the death test child process.  Tools such as\n// Valgrind heap checkers may need this to modify their behavior in death\n// tests.  IMPORTANT: This is an internal utility.  Using it may break the\n// implementation of death tests.  User code MUST NOT use it.\nbool InDeathTestChild() {\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_FUCHSIA)\n\n  // On Windows and Fuchsia, death tests are thread-safe regardless of the value\n  // of the death_test_style flag.\n  return !GTEST_FLAG_GET(internal_run_death_test).empty();\n\n#else\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot;)\n    return !GTEST_FLAG_GET(internal_run_death_test).empty();\n  else\n    return g_in_fast_death_test_child;\n#endif\n}\n\n}  // namespace internal\n\n// ExitedWithCode constructor.\nExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) {}\n\n// ExitedWithCode function-call operator.\nbool ExitedWithCode::operator()(int exit_status) const {\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_FUCHSIA)\n\n  return exit_status == exit_code_;\n\n#else\n\n  return WIFEXITED(exit_status) &amp;&amp; WEXITSTATUS(exit_status) == exit_code_;\n\n#endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n}\n\n#if !defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_FUCHSIA)\n// KilledBySignal constructor.\nKilledBySignal::KilledBySignal(int signum) : signum_(signum) {}\n\n// KilledBySignal function-call operator.\nbool KilledBySignal::operator()(int exit_status) const {\n#if defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  {\n    bool result;\n    if (GTEST_KILLED_BY_SIGNAL_OVERRIDE_(signum_, exit_status, &amp;result)) {\n      return result;\n    }\n  }\n#endif  // defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)\n  return WIFSIGNALED(exit_status) &amp;&amp; WTERMSIG(exit_status) == signum_;\n}\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n\nnamespace internal {\n\n// Utilities needed for death tests.\n\n// Generates a textual description of a given exit code, in the format\n// specified by wait(2).\nstatic std::string ExitSummary(int exit_code) {\n  Message m;\n\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_FUCHSIA)\n\n  m &lt;&lt; &quot;Exited with exit status &quot; &lt;&lt; exit_code;\n\n#else\n\n  if (WIFEXITED(exit_code)) {\n    m &lt;&lt; &quot;Exited with exit status &quot; &lt;&lt; WEXITSTATUS(exit_code);\n  } else if (WIFSIGNALED(exit_code)) {\n    m &lt;&lt; &quot;Terminated by signal &quot; &lt;&lt; WTERMSIG(exit_code);\n  }\n#ifdef WCOREDUMP\n  if (WCOREDUMP(exit_code)) {\n    m &lt;&lt; &quot; (core dumped)&quot;;\n  }\n#endif\n#endif  // GTEST_OS_WINDOWS || GTEST_OS_FUCHSIA\n\n  return m.GetString();\n}\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nbool ExitedUnsuccessfully(int exit_status) {\n  return !ExitedWithCode(0)(exit_status);\n}\n\n#if !defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_FUCHSIA)\n// Generates a textual failure message when a death test finds more than\n// one thread running, or cannot determine the number of threads, prior\n// to executing the given statement.  It is the responsibility of the\n// caller not to pass a thread_count of 1.\nstatic std::string DeathTestThreadWarning(size_t thread_count) {\n  Message msg;\n  msg &lt;&lt; &quot;Death tests use fork(), which is unsafe particularly&quot;\n      &lt;&lt; &quot; in a threaded context. For this test, &quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot; &quot;;\n  if (thread_count == 0) {\n    msg &lt;&lt; &quot;couldn&#x27;t detect the number of threads.&quot;;\n  } else {\n    msg &lt;&lt; &quot;detected &quot; &lt;&lt; thread_count &lt;&lt; &quot; threads.&quot;;\n  }\n  msg &lt;&lt; &quot; See &quot;\n         &quot;https://github.com/google/googletest/blob/main/docs/&quot;\n         &quot;advanced.md#death-tests-and-threads&quot;\n      &lt;&lt; &quot; for more explanation and suggested solutions, especially if&quot;\n      &lt;&lt; &quot; this is the last message you see before your test times out.&quot;;\n  return msg.GetString();\n}\n#endif  // !GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_FUCHSIA\n\n// Flag characters for reporting a death test that did not die.\nstatic const char kDeathTestLived = &#x27;L&#x27;;\nstatic const char kDeathTestReturned = &#x27;R&#x27;;\nstatic const char kDeathTestThrew = &#x27;T&#x27;;\nstatic const char kDeathTestInternalError = &#x27;I&#x27;;\n\n#ifdef GTEST_OS_FUCHSIA\n\n// File descriptor used for the pipe in the child process.\nstatic const int kFuchsiaReadPipeFd = 3;\n\n#endif\n\n// An enumeration describing all of the possible ways that a death test can\n// conclude.  DIED means that the process died while executing the test\n// code; LIVED means that process lived beyond the end of the test code;\n// RETURNED means that the test statement attempted to execute a return\n// statement, which is not allowed; THREW means that the test statement\n// returned control by throwing an exception.  IN_PROGRESS means the test\n// has not yet concluded.\nenum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW };\n\n// Routine for aborting the program which is safe to call from an\n// exec-style death test child process, in which case the error\n// message is propagated back to the parent process.  Otherwise, the\n// message is simply printed to stderr.  In either case, the program\n// then exits with status 1.\n[[noreturn]] static void DeathTestAbort(const std::string&amp; message) {\n  // On a POSIX system, this function may be called from a threadsafe-style\n  // death test child process, which operates on a very small stack.  Use\n  // the heap for any additional non-minuscule memory requirements.\n  const InternalRunDeathTestFlag* const flag =\n      GetUnitTestImpl()-&gt;internal_run_death_test_flag();\n  if (flag != nullptr) {\n    FILE* parent = posix::FDOpen(flag-&gt;write_fd(), &quot;w&quot;);\n    fputc(kDeathTestInternalError, parent);\n    fprintf(parent, &quot;%s&quot;, message.c_str());\n    fflush(parent);\n    _Exit(1);\n  } else {\n    fprintf(stderr, &quot;%s&quot;, message.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n}\n\n// A replacement for CHECK that calls DeathTestAbort if the assertion\n// fails.\n#define GTEST_DEATH_TEST_CHECK_(expression)                              \\\n  do {                                                                   \\\n    if (!::testing::internal::IsTrue(expression)) {                      \\\n      DeathTestAbort(::std::string(&quot;CHECK failed: File &quot;) + __FILE__ +   \\\n                     &quot;, line &quot; +                                         \\\n                     ::testing::internal::StreamableToString(__LINE__) + \\\n                     &quot;: &quot; + #expression);                                \\\n    }                                                                    \\\n  } while (::testing::internal::AlwaysFalse())\n\n// This macro is similar to GTEST_DEATH_TEST_CHECK_, but it is meant for\n// evaluating any system call that fulfills two conditions: it must return\n// -1 on failure, and set errno to EINTR when it is interrupted and\n// should be tried again.  The macro expands to a loop that repeatedly\n// evaluates the expression as long as it evaluates to -1 and sets\n// errno to EINTR.  If the expression evaluates to -1 but errno is\n// something other than EINTR, DeathTestAbort is called.\n#define GTEST_DEATH_TEST_CHECK_SYSCALL_(expression)                      \\\n  do {                                                                   \\\n    int gtest_retval;                                                    \\\n    do {                                                                 \\\n      gtest_retval = (expression);                                       \\\n    } while (gtest_retval == -1 &amp;&amp; errno == EINTR);                      \\\n    if (gtest_retval == -1) {                                            \\\n      DeathTestAbort(::std::string(&quot;CHECK failed: File &quot;) + __FILE__ +   \\\n                     &quot;, line &quot; +                                         \\\n                     ::testing::internal::StreamableToString(__LINE__) + \\\n                     &quot;: &quot; + #expression + &quot; != -1&quot;);                     \\\n    }                                                                    \\\n  } while (::testing::internal::AlwaysFalse())\n\n// Returns the message describing the last system error in errno.\nstd::string GetLastErrnoDescription() {\n  return errno == 0 ? &quot;&quot; : posix::StrError(errno);\n}\n\n// This is called from a death test parent process to read a failure\n// message from the death test child process and log it with the FATAL\n// severity. On Windows, the message is read from a pipe handle. On other\n// platforms, it is read from a file descriptor.\nstatic void FailFromInternalError(int fd) {\n  Message error;\n  char buffer[256];\n  int num_read;\n\n  do {\n    while ((num_read = posix::Read(fd, buffer, 255)) &gt; 0) {\n      buffer[num_read] = &#x27;\\0&#x27;;\n      error &lt;&lt; buffer;\n    }\n  } while (num_read == -1 &amp;&amp; errno == EINTR);\n\n  if (num_read == 0) {\n    GTEST_LOG_(FATAL) &lt;&lt; error.GetString();\n  } else {\n    const int last_error = errno;\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Error while reading death test internal: &quot;\n                      &lt;&lt; GetLastErrnoDescription() &lt;&lt; &quot; [&quot; &lt;&lt; last_error &lt;&lt; &quot;]&quot;;\n  }\n}\n\n// Death test constructor.  Increments the running death test count\n// for the current test.\nDeathTest::DeathTest() {\n  TestInfo* const info = GetUnitTestImpl()-&gt;current_test_info();\n  if (info == nullptr) {\n    DeathTestAbort(\n        &quot;Cannot run a death test outside of a TEST or &quot;\n        &quot;TEST_F construct&quot;);\n  }\n}\n\n// Creates and returns a death test by dispatching to the current\n// death test factory.\nbool DeathTest::Create(const char* statement,\n                       Matcher&lt;const std::string&amp;&gt; matcher, const char* file,\n                       int line, DeathTest** test) {\n  return GetUnitTestImpl()-&gt;death_test_factory()-&gt;Create(\n      statement, std::move(matcher), file, line, test);\n}\n\nconst char* DeathTest::LastMessage() {\n  return last_death_test_message_.c_str();\n}\n\nvoid DeathTest::set_last_death_test_message(const std::string&amp; message) {\n  last_death_test_message_ = message;\n}\n\nstd::string DeathTest::last_death_test_message_;\n\n// Provides cross platform implementation for some death functionality.\nclass DeathTestImpl : public DeathTest {\n protected:\n  DeathTestImpl(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher)\n      : statement_(a_statement),\n        matcher_(std::move(matcher)),\n        spawned_(false),\n        status_(-1),\n        outcome_(IN_PROGRESS),\n        read_fd_(-1),\n        write_fd_(-1) {}\n\n  // read_fd_ is expected to be closed and cleared by a derived class.\n  ~DeathTestImpl() override { GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); }\n\n  void Abort(AbortReason reason) override;\n  bool Passed(bool status_ok) override;\n\n  const char* statement() const { return statement_; }\n  bool spawned() const { return spawned_; }\n  void set_spawned(bool is_spawned) { spawned_ = is_spawned; }\n  int status() const { return status_; }\n  void set_status(int a_status) { status_ = a_status; }\n  DeathTestOutcome outcome() const { return outcome_; }\n  void set_outcome(DeathTestOutcome an_outcome) { outcome_ = an_outcome; }\n  int read_fd() const { return read_fd_; }\n  void set_read_fd(int fd) { read_fd_ = fd; }\n  int write_fd() const { return write_fd_; }\n  void set_write_fd(int fd) { write_fd_ = fd; }\n\n  // Called in the parent process only. Reads the result code of the death\n  // test child process via a pipe, interprets it to set the outcome_\n  // member, and closes read_fd_.  Outputs diagnostics and terminates in\n  // case of unexpected codes.\n  void ReadAndInterpretStatusByte();\n\n  // Returns stderr output from the child process.\n  virtual std::string GetErrorLogs();\n\n private:\n  // The textual content of the code this object is testing.  This class\n  // doesn&#x27;t own this string and should not attempt to delete it.\n  const char* const statement_;\n  // A matcher that&#x27;s expected to match the stderr output by the child process.\n  Matcher&lt;const std::string&amp;&gt; matcher_;\n  // True if the death test child process has been successfully spawned.\n  bool spawned_;\n  // The exit status of the child process.\n  int status_;\n  // How the death test concluded.\n  DeathTestOutcome outcome_;\n  // Descriptor to the read end of the pipe to the child process.  It is\n  // always -1 in the child process.  The child keeps its write end of the\n  // pipe in write_fd_.\n  int read_fd_;\n  // Descriptor to the child&#x27;s write end of the pipe to the parent process.\n  // It is always -1 in the parent process.  The parent keeps its end of the\n  // pipe in read_fd_.\n  int write_fd_;\n};\n\n// Called in the parent process only. Reads the result code of the death\n// test child process via a pipe, interprets it to set the outcome_\n// member, and closes read_fd_.  Outputs diagnostics and terminates in\n// case of unexpected codes.\nvoid DeathTestImpl::ReadAndInterpretStatusByte() {\n  char flag;\n  int bytes_read;\n\n  // The read() here blocks until data is available (signifying the\n  // failure of the death test) or until the pipe is closed (signifying\n  // its success), so it&#x27;s okay to call this in the parent before\n  // the child process has exited.\n  do {\n    bytes_read = posix::Read(read_fd(), &amp;flag, 1);\n  } while (bytes_read == -1 &amp;&amp; errno == EINTR);\n\n  if (bytes_read == 0) {\n    set_outcome(DIED);\n  } else if (bytes_read == 1) {\n    switch (flag) {\n      case kDeathTestReturned:\n        set_outcome(RETURNED);\n        break;\n      case kDeathTestThrew:\n        set_outcome(THREW);\n        break;\n      case kDeathTestLived:\n        set_outcome(LIVED);\n        break;\n      case kDeathTestInternalError:\n        FailFromInternalError(read_fd());  // Does not return.\n        break;\n      default:\n        GTEST_LOG_(FATAL) &lt;&lt; &quot;Death test child process reported &quot;\n                          &lt;&lt; &quot;unexpected status byte (&quot;\n                          &lt;&lt; static_cast&lt;unsigned int&gt;(flag) &lt;&lt; &quot;)&quot;;\n    }\n  } else {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Read from death test child process failed: &quot;\n                      &lt;&lt; GetLastErrnoDescription();\n  }\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));\n  set_read_fd(-1);\n}\n\nstd::string DeathTestImpl::GetErrorLogs() { return GetCapturedStderr(); }\n\n// Signals that the death test code which should have exited, didn&#x27;t.\n// Should be called only in a death test child process.\n// Writes a status byte to the child&#x27;s status file descriptor, then\n// calls _Exit(1).\nvoid DeathTestImpl::Abort(AbortReason reason) {\n  // The parent process considers the death test to be a failure if\n  // it finds any data in our pipe.  So, here we write a single flag byte\n  // to the pipe, then exit.\n  const char status_ch = reason == TEST_DID_NOT_DIE       ? kDeathTestLived\n                         : reason == TEST_THREW_EXCEPTION ? kDeathTestThrew\n                                                          : kDeathTestReturned;\n\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &amp;status_ch, 1));\n  // We are leaking the descriptor here because on some platforms (i.e.,\n  // when built as Windows DLL), destructors of global objects will still\n  // run after calling _Exit(). On such systems, write_fd_ will be\n  // indirectly closed from the destructor of UnitTestImpl, causing double\n  // close if it is also closed here. On debug configurations, double close\n  // may assert. As there are no in-process buffers to flush here, we are\n  // relying on the OS to close the descriptor after the process terminates\n  // when the destructors are not run.\n  _Exit(1);  // Exits w/o any normal exit hooks (we were supposed to crash)\n}\n\n// Returns an indented copy of stderr output for a death test.\n// This makes distinguishing death test output lines from regular log lines\n// much easier.\nstatic ::std::string FormatDeathTestOutput(const ::std::string&amp; output) {\n  ::std::string ret;\n  for (size_t at = 0;;) {\n    const size_t line_end = output.find(&#x27;\\n&#x27;, at);\n    ret += &quot;[  DEATH   ] &quot;;\n    if (line_end == ::std::string::npos) {\n      ret += output.substr(at);\n      break;\n    }\n    ret += output.substr(at, line_end + 1 - at);\n    at = line_end + 1;\n  }\n  return ret;\n}\n\n// Assesses the success or failure of a death test, using both private\n// members which have previously been set, and one argument:\n//\n// Private data members:\n//   outcome:  An enumeration describing how the death test\n//             concluded: DIED, LIVED, THREW, or RETURNED.  The death test\n//             fails in the latter three cases.\n//   status:   The exit status of the child process. On *nix, it is in the\n//             in the format specified by wait(2). On Windows, this is the\n//             value supplied to the ExitProcess() API or a numeric code\n//             of the exception that terminated the program.\n//   matcher_: A matcher that&#x27;s expected to match the stderr output by the child\n//             process.\n//\n// Argument:\n//   status_ok: true if exit_status is acceptable in the context of\n//              this particular death test, which fails if it is false\n//\n// Returns true if and only if all of the above conditions are met.  Otherwise,\n// the first failing condition, in the order given above, is the one that is\n// reported. Also sets the last death test message string.\nbool DeathTestImpl::Passed(bool status_ok) {\n  if (!spawned()) return false;\n\n  const std::string error_message = GetErrorLogs();\n\n  bool success = false;\n  Message buffer;\n\n  buffer &lt;&lt; &quot;Death test: &quot; &lt;&lt; statement() &lt;&lt; &quot;\\n&quot;;\n  switch (outcome()) {\n    case LIVED:\n      buffer &lt;&lt; &quot;    Result: failed to die.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case THREW:\n      buffer &lt;&lt; &quot;    Result: threw an exception.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case RETURNED:\n      buffer &lt;&lt; &quot;    Result: illegal return in test statement.\\n&quot;\n             &lt;&lt; &quot; Error msg:\\n&quot;\n             &lt;&lt; FormatDeathTestOutput(error_message);\n      break;\n    case DIED:\n      if (status_ok) {\n        if (matcher_.Matches(error_message)) {\n          success = true;\n        } else {\n          std::ostringstream stream;\n          matcher_.DescribeTo(&amp;stream);\n          buffer &lt;&lt; &quot;    Result: died but not with expected error.\\n&quot;\n                 &lt;&lt; &quot;  Expected: &quot; &lt;&lt; stream.str() &lt;&lt; &quot;\\n&quot;\n                 &lt;&lt; &quot;Actual msg:\\n&quot;\n                 &lt;&lt; FormatDeathTestOutput(error_message);\n        }\n      } else {\n        buffer &lt;&lt; &quot;    Result: died but not with expected exit code:\\n&quot;\n               &lt;&lt; &quot;            &quot; &lt;&lt; ExitSummary(status()) &lt;&lt; &quot;\\n&quot;\n               &lt;&lt; &quot;Actual msg:\\n&quot;\n               &lt;&lt; FormatDeathTestOutput(error_message);\n      }\n      break;\n    case IN_PROGRESS:\n    default:\n      GTEST_LOG_(FATAL)\n          &lt;&lt; &quot;DeathTest::Passed somehow called before conclusion of test&quot;;\n  }\n\n  DeathTest::set_last_death_test_message(buffer.GetString());\n  return success;\n}\n\n#ifndef GTEST_OS_WINDOWS\n// Note: The return value points into args, so the return value&#x27;s lifetime is\n// bound to that of args.\nstatic std::vector&lt;char*&gt; CreateArgvFromArgs(std::vector&lt;std::string&gt;&amp; args) {\n  std::vector&lt;char*&gt; result;\n  result.reserve(args.size() + 1);\n  for (auto&amp; arg : args) {\n    result.push_back(&amp;arg[0]);\n  }\n  result.push_back(nullptr);  // Extra null terminator.\n  return result;\n}\n#endif\n\n#ifdef GTEST_OS_WINDOWS\n// WindowsDeathTest implements death tests on Windows. Due to the\n// specifics of starting new processes on Windows, death tests there are\n// always threadsafe, and Google Test considers the\n// --gtest_death_test_style=fast setting to be equivalent to\n// --gtest_death_test_style=threadsafe there.\n//\n// A few implementation notes:  Like the Linux version, the Windows\n// implementation uses pipes for child-to-parent communication. But due to\n// the specifics of pipes on Windows, some extra steps are required:\n//\n// 1. The parent creates a communication pipe and stores handles to both\n//    ends of it.\n// 2. The parent starts the child and provides it with the information\n//    necessary to acquire the handle to the write end of the pipe.\n// 3. The child acquires the write end of the pipe and signals the parent\n//    using a Windows event.\n// 4. Now the parent can release the write end of the pipe on its side. If\n//    this is done before step 3, the object&#x27;s reference count goes down to\n//    0 and it is destroyed, preventing the child from acquiring it. The\n//    parent now has to release it, or read operations on the read end of\n//    the pipe will not return when the child terminates.\n// 5. The parent reads child&#x27;s output through the pipe (outcome code and\n//    any possible error messages) from the pipe, and its stderr and then\n//    determines whether to fail the test.\n//\n// Note: to distinguish Win32 API calls from the local method and function\n// calls, the former are explicitly resolved in the global namespace.\n//\nclass WindowsDeathTest : public DeathTestImpl {\n public:\n  WindowsDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                   const char* file, int line)\n      : DeathTestImpl(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n\n  // All of these virtual functions are inherited from DeathTest.\n  virtual int Wait();\n  virtual TestRole AssumeRole();\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n  // Handle to the write end of the pipe to the child process.\n  AutoHandle write_handle_;\n  // Child process handle.\n  AutoHandle child_handle_;\n  // Event the child process uses to signal the parent that it has\n  // acquired the handle to the write end of the pipe. After seeing this\n  // event the parent can release its own handles to make sure its\n  // ReadFile() calls return when the child terminates.\n  AutoHandle event_handle_;\n};\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint WindowsDeathTest::Wait() {\n  if (!spawned()) return 0;\n\n  // Wait until the child either signals that it has acquired the write end\n  // of the pipe or it dies.\n  const HANDLE wait_handles[2] = {child_handle_.Get(), event_handle_.Get()};\n  switch (::WaitForMultipleObjects(2, wait_handles,\n                                   FALSE,  // Waits for any of the handles.\n                                   INFINITE)) {\n    case WAIT_OBJECT_0:\n    case WAIT_OBJECT_0 + 1:\n      break;\n    default:\n      GTEST_DEATH_TEST_CHECK_(false);  // Should not get here.\n  }\n\n  // The child has acquired the write end of the pipe or exited.\n  // We release the handle on our side and continue.\n  write_handle_.Reset();\n  event_handle_.Reset();\n\n  ReadAndInterpretStatusByte();\n\n  // Waits for the child process to exit if it haven&#x27;t already. This\n  // returns immediately if the child has already exited, regardless of\n  // whether previous calls to WaitForMultipleObjects synchronized on this\n  // handle or not.\n  GTEST_DEATH_TEST_CHECK_(WAIT_OBJECT_0 ==\n                          ::WaitForSingleObject(child_handle_.Get(), INFINITE));\n  DWORD status_code;\n  GTEST_DEATH_TEST_CHECK_(\n      ::GetExitCodeProcess(child_handle_.Get(), &amp;status_code) != FALSE);\n  child_handle_.Reset();\n  set_status(static_cast&lt;int&gt;(status_code));\n  return status();\n}\n\n// The AssumeRole process for a Windows death test.  It creates a child\n// process with the same executable as the current process to run the\n// death test.  The child process is given the --gtest_filter and\n// --gtest_internal_run_death_test flags such that it knows to run the\n// current death test only.\nDeathTest::TestRole WindowsDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(flag-&gt;write_fd());\n    return EXECUTE_TEST;\n  }\n\n  // WindowsDeathTest uses an anonymous pipe to communicate results of\n  // a death test.\n  SECURITY_ATTRIBUTES handles_are_inheritable = {sizeof(SECURITY_ATTRIBUTES),\n                                                 nullptr, TRUE};\n  HANDLE read_handle, write_handle;\n  GTEST_DEATH_TEST_CHECK_(::CreatePipe(&amp;read_handle, &amp;write_handle,\n                                       &amp;handles_are_inheritable,\n                                       0)  // Default buffer size.\n                          != FALSE);\n  set_read_fd(\n      ::_open_osfhandle(reinterpret_cast&lt;intptr_t&gt;(read_handle), O_RDONLY));\n  write_handle_.Reset(write_handle);\n  event_handle_.Reset(::CreateEvent(\n      &amp;handles_are_inheritable,\n      TRUE,       // The event will automatically reset to non-signaled state.\n      FALSE,      // The initial state is non-signalled.\n      nullptr));  // The even is unnamed.\n  GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != nullptr);\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag =\n      std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n      &quot;internal_run_death_test=&quot; + file_ + &quot;|&quot; + StreamableToString(line_) +\n      &quot;|&quot; + StreamableToString(death_test_index) + &quot;|&quot; +\n      StreamableToString(static_cast&lt;unsigned int&gt;(::GetCurrentProcessId())) +\n      // size_t has the same width as pointers on both 32-bit and 64-bit\n      // Windows platforms.\n      // See https://msdn.microsoft.com/en-us/library/tcxf1dw6.aspx.\n      &quot;|&quot; + StreamableToString(reinterpret_cast&lt;size_t&gt;(write_handle)) + &quot;|&quot; +\n      StreamableToString(reinterpret_cast&lt;size_t&gt;(event_handle_.Get()));\n\n  char executable_path[_MAX_PATH + 1];  // NOLINT\n  GTEST_DEATH_TEST_CHECK_(_MAX_PATH + 1 != ::GetModuleFileNameA(nullptr,\n                                                                executable_path,\n                                                                _MAX_PATH));\n\n  std::string command_line = std::string(::GetCommandLineA()) + &quot; &quot; +\n                             filter_flag + &quot; \\&quot;&quot; + internal_flag + &quot;\\&quot;&quot;;\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n\n  CaptureStderr();\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // The child process will share the standard handles with the parent.\n  STARTUPINFOA startup_info;\n  memset(&amp;startup_info, 0, sizeof(STARTUPINFO));\n  startup_info.dwFlags = STARTF_USESTDHANDLES;\n  startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\n  startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\n  startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\n\n  PROCESS_INFORMATION process_info;\n  GTEST_DEATH_TEST_CHECK_(\n      ::CreateProcessA(\n          executable_path, const_cast&lt;char*&gt;(command_line.c_str()),\n          nullptr,  // Returned process handle is not inheritable.\n          nullptr,  // Returned thread handle is not inheritable.\n          TRUE,  // Child inherits all inheritable handles (for write_handle_).\n          0x0,   // Default creation flags.\n          nullptr,  // Inherit the parent&#x27;s environment.\n          UnitTest::GetInstance()-&gt;original_working_dir(), &amp;startup_info,\n          &amp;process_info) != FALSE);\n  child_handle_.Reset(process_info.hProcess);\n  ::CloseHandle(process_info.hThread);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\n#elif defined(GTEST_OS_FUCHSIA)\n\nclass FuchsiaDeathTest : public DeathTestImpl {\n public:\n  FuchsiaDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                   const char* file, int line)\n      : DeathTestImpl(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n\n  // All of these virtual functions are inherited from DeathTest.\n  int Wait() override;\n  TestRole AssumeRole() override;\n  std::string GetErrorLogs() override;\n\n private:\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n  // The stderr data captured by the child process.\n  std::string captured_stderr_;\n\n  zx::process child_process_;\n  zx::channel exception_channel_;\n  zx::socket stderr_socket_;\n};\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint FuchsiaDeathTest::Wait() {\n  const int kProcessKey = 0;\n  const int kSocketKey = 1;\n  const int kExceptionKey = 2;\n\n  if (!spawned()) return 0;\n\n  // Create a port to wait for socket/task/exception events.\n  zx_status_t status_zx;\n  zx::port port;\n  status_zx = zx::port::create(0, &amp;port);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for the child process to terminate.\n  status_zx =\n      child_process_.wait_async(port, kProcessKey, ZX_PROCESS_TERMINATED, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for the socket to be readable or closed.\n  status_zx = stderr_socket_.wait_async(\n      port, kSocketKey, ZX_SOCKET_READABLE | ZX_SOCKET_PEER_CLOSED, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  // Register to wait for an exception.\n  status_zx = exception_channel_.wait_async(port, kExceptionKey,\n                                            ZX_CHANNEL_READABLE, 0);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  bool process_terminated = false;\n  bool socket_closed = false;\n  do {\n    zx_port_packet_t packet = {};\n    status_zx = port.wait(zx::time::infinite(), &amp;packet);\n    GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n    if (packet.key == kExceptionKey) {\n      // Process encountered an exception. Kill it directly rather than\n      // letting other handlers process the event. We will get a kProcessKey\n      // event when the process actually terminates.\n      status_zx = child_process_.kill();\n      GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n    } else if (packet.key == kProcessKey) {\n      // Process terminated.\n      GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));\n      GTEST_DEATH_TEST_CHECK_(packet.signal.observed &amp; ZX_PROCESS_TERMINATED);\n      process_terminated = true;\n    } else if (packet.key == kSocketKey) {\n      GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));\n      if (packet.signal.observed &amp; ZX_SOCKET_READABLE) {\n        // Read data from the socket.\n        constexpr size_t kBufferSize = 1024;\n        do {\n          size_t old_length = captured_stderr_.length();\n          size_t bytes_read = 0;\n          captured_stderr_.resize(old_length + kBufferSize);\n          status_zx =\n              stderr_socket_.read(0, &amp;captured_stderr_.front() + old_length,\n                                  kBufferSize, &amp;bytes_read);\n          captured_stderr_.resize(old_length + bytes_read);\n        } while (status_zx == ZX_OK);\n        if (status_zx == ZX_ERR_PEER_CLOSED) {\n          socket_closed = true;\n        } else {\n          GTEST_DEATH_TEST_CHECK_(status_zx == ZX_ERR_SHOULD_WAIT);\n          status_zx = stderr_socket_.wait_async(\n              port, kSocketKey, ZX_SOCKET_READABLE | ZX_SOCKET_PEER_CLOSED, 0);\n          GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n        }\n      } else {\n        GTEST_DEATH_TEST_CHECK_(packet.signal.observed &amp; ZX_SOCKET_PEER_CLOSED);\n        socket_closed = true;\n      }\n    }\n  } while (!process_terminated &amp;&amp; !socket_closed);\n\n  ReadAndInterpretStatusByte();\n\n  zx_info_process_t buffer;\n  status_zx = child_process_.get_info(ZX_INFO_PROCESS, &amp;buffer, sizeof(buffer),\n                                      nullptr, nullptr);\n  GTEST_DEATH_TEST_CHECK_(status_zx == ZX_OK);\n\n  GTEST_DEATH_TEST_CHECK_(buffer.flags &amp; ZX_INFO_PROCESS_FLAG_EXITED);\n  set_status(static_cast&lt;int&gt;(buffer.return_code));\n  return status();\n}\n\n// The AssumeRole process for a Fuchsia death test.  It creates a child\n// process with the same executable as the current process to run the\n// death test.  The child process is given the --gtest_filter and\n// --gtest_internal_run_death_test flags such that it knows to run the\n// current death test only.\nDeathTest::TestRole FuchsiaDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    // ParseInternalRunDeathTestFlag() has performed all the necessary\n    // processing.\n    set_write_fd(kFuchsiaReadPipeFd);\n    return EXECUTE_TEST;\n  }\n\n  // Flush the log buffers since the log streams are shared with the child.\n  FlushInfoLog();\n\n  // Build the child process command line.\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                    kInternalRunDeathTestFlag + &quot;=&quot; + file_ +\n                                    &quot;|&quot; + StreamableToString(line_) + &quot;|&quot; +\n                                    StreamableToString(death_test_index);\n\n  std::vector&lt;std::string&gt; args = GetInjectableArgvs();\n  args.push_back(filter_flag);\n  args.push_back(internal_flag);\n\n  // Build the pipe for communication with the child.\n  zx_status_t status;\n  zx_handle_t child_pipe_handle;\n  int child_pipe_fd;\n  status = fdio_pipe_half(&amp;child_pipe_fd, &amp;child_pipe_handle);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  set_read_fd(child_pipe_fd);\n\n  // Set the pipe handle for the child.\n  fdio_spawn_action_t spawn_actions[2] = {};\n  fdio_spawn_action_t* add_handle_action = &amp;spawn_actions[0];\n  add_handle_action-&gt;action = FDIO_SPAWN_ACTION_ADD_HANDLE;\n  add_handle_action-&gt;h.id = PA_HND(PA_FD, kFuchsiaReadPipeFd);\n  add_handle_action-&gt;h.handle = child_pipe_handle;\n\n  // Create a socket pair will be used to receive the child process&#x27; stderr.\n  zx::socket stderr_producer_socket;\n  status = zx::socket::create(0, &amp;stderr_producer_socket, &amp;stderr_socket_);\n  GTEST_DEATH_TEST_CHECK_(status &gt;= 0);\n  int stderr_producer_fd = -1;\n  status =\n      fdio_fd_create(stderr_producer_socket.release(), &amp;stderr_producer_fd);\n  GTEST_DEATH_TEST_CHECK_(status &gt;= 0);\n\n  // Make the stderr socket nonblocking.\n  GTEST_DEATH_TEST_CHECK_(fcntl(stderr_producer_fd, F_SETFL, 0) == 0);\n\n  fdio_spawn_action_t* add_stderr_action = &amp;spawn_actions[1];\n  add_stderr_action-&gt;action = FDIO_SPAWN_ACTION_CLONE_FD;\n  add_stderr_action-&gt;fd.local_fd = stderr_producer_fd;\n  add_stderr_action-&gt;fd.target_fd = STDERR_FILENO;\n\n  // Create a child job.\n  zx_handle_t child_job = ZX_HANDLE_INVALID;\n  status = zx_job_create(zx_job_default(), 0, &amp;child_job);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n  zx_policy_basic_t policy;\n  policy.condition = ZX_POL_NEW_ANY;\n  policy.policy = ZX_POL_ACTION_ALLOW;\n  status = zx_job_set_policy(child_job, ZX_JOB_POL_RELATIVE, ZX_JOB_POL_BASIC,\n                             &amp;policy, 1);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  // Create an exception channel attached to the |child_job|, to allow\n  // us to suppress the system default exception handler from firing.\n  status = zx_task_create_exception_channel(\n      child_job, 0, exception_channel_.reset_and_get_address());\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  // Spawn the child process.\n  // Note: The test component must have `fuchsia.process.Launcher` declared\n  // in its manifest. (Fuchsia integration tests require creating a\n  // &quot;Fuchsia Test Component&quot; which contains a &quot;Fuchsia Component Manifest&quot;)\n  // Launching processes is a privileged operation in Fuchsia, and the\n  // declaration indicates that the ability is required for the component.\n  std::vector&lt;char*&gt; argv = CreateArgvFromArgs(args);\n  status = fdio_spawn_etc(child_job, FDIO_SPAWN_CLONE_ALL, argv[0], argv.data(),\n                          nullptr, 2, spawn_actions,\n                          child_process_.reset_and_get_address(), nullptr);\n  GTEST_DEATH_TEST_CHECK_(status == ZX_OK);\n\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\nstd::string FuchsiaDeathTest::GetErrorLogs() { return captured_stderr_; }\n\n#else  // We are neither on Windows, nor on Fuchsia.\n\n// ForkingDeathTest provides implementations for most of the abstract\n// methods of the DeathTest interface.  Only the AssumeRole method is\n// left undefined.\nclass ForkingDeathTest : public DeathTestImpl {\n public:\n  ForkingDeathTest(const char* statement, Matcher&lt;const std::string&amp;&gt; matcher);\n\n  // All of these virtual functions are inherited from DeathTest.\n  int Wait() override;\n\n protected:\n  void set_child_pid(pid_t child_pid) { child_pid_ = child_pid; }\n\n private:\n  // PID of child process during death test; 0 in the child process itself.\n  pid_t child_pid_;\n};\n\n// Constructs a ForkingDeathTest.\nForkingDeathTest::ForkingDeathTest(const char* a_statement,\n                                   Matcher&lt;const std::string&amp;&gt; matcher)\n    : DeathTestImpl(a_statement, std::move(matcher)), child_pid_(-1) {}\n\n// Waits for the child in a death test to exit, returning its exit\n// status, or 0 if no child process exists.  As a side effect, sets the\n// outcome data member.\nint ForkingDeathTest::Wait() {\n  if (!spawned()) return 0;\n\n  ReadAndInterpretStatusByte();\n\n  int status_value;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &amp;status_value, 0));\n  set_status(status_value);\n  return status_value;\n}\n\n// A concrete death test class that forks, then immediately runs the test\n// in the child process.\nclass NoExecDeathTest : public ForkingDeathTest {\n public:\n  NoExecDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher)\n      : ForkingDeathTest(a_statement, std::move(matcher)) {}\n  TestRole AssumeRole() override;\n};\n\n// The AssumeRole process for a fork-and-run death test.  It implements a\n// straightforward fork, with a simple pipe to transmit the status byte.\nDeathTest::TestRole NoExecDeathTest::AssumeRole() {\n  const size_t thread_count = GetThreadCount();\n  if (thread_count != 1) {\n    GTEST_LOG_(WARNING) &lt;&lt; DeathTestThreadWarning(thread_count);\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n  CaptureStderr();\n  // When we fork the process below, the log file buffers are copied, but the\n  // file descriptors are shared.  We flush all log files here so that closing\n  // the file descriptors in the child process doesn&#x27;t throw off the\n  // synchronization between descriptors and buffers in the parent process.\n  // This is as close to the fork as possible to avoid a race condition in case\n  // there are multiple threads running before the death test, and another\n  // thread writes to the log file.\n  FlushInfoLog();\n\n  const pid_t child_pid = fork();\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  set_child_pid(child_pid);\n  if (child_pid == 0) {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));\n    set_write_fd(pipe_fd[1]);\n    // Redirects all logging to stderr in the child process to prevent\n    // concurrent writes to the log files.  We capture stderr in the parent\n    // process and append the child process&#x27; output to a log.\n    LogToStderr();\n    // Event forwarding to the listeners of event listener API mush be shut\n    // down in death test subprocesses.\n    GetUnitTestImpl()-&gt;listeners()-&gt;SuppressEventForwarding(true);\n    g_in_fast_death_test_child = true;\n    return EXECUTE_TEST;\n  } else {\n    GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n    set_read_fd(pipe_fd[0]);\n    set_spawned(true);\n    return OVERSEE_TEST;\n  }\n}\n\n// A concrete death test class that forks and re-executes the main\n// program from the beginning, with command-line flags set that cause\n// only this specific death test to be run.\nclass ExecDeathTest : public ForkingDeathTest {\n public:\n  ExecDeathTest(const char* a_statement, Matcher&lt;const std::string&amp;&gt; matcher,\n                const char* file, int line)\n      : ForkingDeathTest(a_statement, std::move(matcher)),\n        file_(file),\n        line_(line) {}\n  TestRole AssumeRole() override;\n\n private:\n  static ::std::vector&lt;std::string&gt; GetArgvsForDeathTestChildProcess() {\n    ::std::vector&lt;std::string&gt; args = GetInjectableArgvs();\n#if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    ::std::vector&lt;std::string&gt; extra_args =\n        GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();\n    args.insert(args.end(), extra_args.begin(), extra_args.end());\n#endif  // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)\n    return args;\n  }\n  // The name of the file in which the death test is located.\n  const char* const file_;\n  // The line number on which the death test is located.\n  const int line_;\n};\n\n// A struct that encompasses the arguments to the child process of a\n// threadsafe-style death test process.\nstruct ExecDeathTestArgs {\n  char* const* argv;  // Command-line arguments for the child&#x27;s call to exec\n  int close_fd;       // File descriptor to close; the read end of a pipe\n};\n\n#ifdef GTEST_OS_QNX\nextern &quot;C&quot; char** environ;\n#else   // GTEST_OS_QNX\n// The main function for a threadsafe-style death test child process.\n// This function is called in a clone()-ed process and thus must avoid\n// any potentially unsafe operations like malloc or libc functions.\nstatic int ExecDeathTestChildMain(void* child_arg) {\n  ExecDeathTestArgs* const args = static_cast&lt;ExecDeathTestArgs*&gt;(child_arg);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args-&gt;close_fd));\n\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()-&gt;original_working_dir();\n  // We can safely call chdir() as it&#x27;s a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(&quot;chdir(\\&quot;&quot;) + original_dir +\n                   &quot;\\&quot;) failed: &quot; + GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  // We can safely call execv() as it&#x27;s almost a direct system call. We\n  // cannot use execvp() as it&#x27;s a libc function and thus potentially\n  // unsafe.  Since execv() doesn&#x27;t search the PATH, the user must\n  // invoke the test program via a valid path that contains at least\n  // one path separator.\n  execv(args-&gt;argv[0], args-&gt;argv);\n  DeathTestAbort(std::string(&quot;execv(&quot;) + args-&gt;argv[0] + &quot;, ...) in &quot; +\n                 original_dir + &quot; failed: &quot; + GetLastErrnoDescription());\n  return EXIT_FAILURE;\n}\n#endif  // GTEST_OS_QNX\n\n#if GTEST_HAS_CLONE\n// Two utility routines that together determine the direction the stack\n// grows.\n// This could be accomplished more elegantly by a single recursive\n// function, but we want to guard against the unlikely possibility of\n// a smart compiler optimizing the recursion away.\n//\n// GTEST_NO_INLINE_ is required to prevent GCC 4.6 from inlining\n// StackLowerThanAddress into StackGrowsDown, which then doesn&#x27;t give\n// correct answer.\nstatic void StackLowerThanAddress(const void* ptr,\n                                  bool* result) GTEST_NO_INLINE_;\n// Make sure sanitizers do not tamper with the stack here.\n// Ideally, we want to use `__builtin_frame_address` instead of a local variable\n// address with sanitizer disabled, but it does not work when the\n// compiler optimizes the stack frame out, which happens on PowerPC targets.\n// HWAddressSanitizer add a random tag to the MSB of the local variable address,\n// making comparison result unpredictable.\nGTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\nstatic void StackLowerThanAddress(const void* ptr, bool* result) {\n  int dummy = 0;\n  *result = std::less&lt;const void*&gt;()(&amp;dummy, ptr);\n}\n\n// Make sure AddressSanitizer does not tamper with the stack here.\nGTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\nGTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_\nstatic bool StackGrowsDown() {\n  int dummy = 0;\n  bool result;\n  StackLowerThanAddress(&amp;dummy, &amp;result);\n  return result;\n}\n#endif  // GTEST_HAS_CLONE\n\n// Spawns a child process with the same executable as the current process in\n// a thread-safe manner and instructs it to run the death test.  The\n// implementation uses fork(2) + exec.  On systems where clone(2) is\n// available, it is used instead, being slightly more thread-safe.  On QNX,\n// fork supports only single-threaded environments, so this function uses\n// spawn(2) there instead.  The function dies with an error message if\n// anything goes wrong.\nstatic pid_t ExecDeathTestSpawnChild(char* const* argv, int close_fd) {\n  ExecDeathTestArgs args = {argv, close_fd};\n  pid_t child_pid = -1;\n\n#ifdef GTEST_OS_QNX\n  // Obtains the current directory and sets it to be closed in the child\n  // process.\n  const int cwd_fd = open(&quot;.&quot;, O_RDONLY);\n  GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));\n  // We need to execute the test program in the same environment where\n  // it was originally invoked.  Therefore we change to the original\n  // working directory first.\n  const char* const original_dir =\n      UnitTest::GetInstance()-&gt;original_working_dir();\n  // We can safely call chdir() as it&#x27;s a direct system call.\n  if (chdir(original_dir) != 0) {\n    DeathTestAbort(std::string(&quot;chdir(\\&quot;&quot;) + original_dir +\n                   &quot;\\&quot;) failed: &quot; + GetLastErrnoDescription());\n    return EXIT_FAILURE;\n  }\n\n  int fd_flags;\n  // Set close_fd to be closed after spawn.\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      fcntl(close_fd, F_SETFD, fd_flags | FD_CLOEXEC));\n  struct inheritance inherit = {0};\n  // spawn is a system call.\n  child_pid = spawn(args.argv[0], 0, nullptr, &amp;inherit, args.argv, environ);\n  // Restores the current working directory.\n  GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));\n\n#else  // GTEST_OS_QNX\n#ifdef GTEST_OS_LINUX\n  // When a SIGPROF signal is received while fork() or clone() are executing,\n  // the process may hang. To avoid this, we ignore SIGPROF here and re-enable\n  // it after the call to fork()/clone() is complete.\n  struct sigaction saved_sigprof_action;\n  struct sigaction ignore_sigprof_action;\n  memset(&amp;ignore_sigprof_action, 0, sizeof(ignore_sigprof_action));\n  sigemptyset(&amp;ignore_sigprof_action.sa_mask);\n  ignore_sigprof_action.sa_handler = SIG_IGN;\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      sigaction(SIGPROF, &amp;ignore_sigprof_action, &amp;saved_sigprof_action));\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_CLONE\n  const bool use_fork = GTEST_FLAG_GET(death_test_use_fork);\n\n  if (!use_fork) {\n    static const bool stack_grows_down = StackGrowsDown();\n    const auto stack_size = static_cast&lt;size_t&gt;(getpagesize() * 2);\n    // MMAP_ANONYMOUS is not defined on Mac, so we use MAP_ANON instead.\n    void* const stack = mmap(nullptr, stack_size, PROT_READ | PROT_WRITE,\n                             MAP_ANON | MAP_PRIVATE, -1, 0);\n    GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);\n\n    // Maximum stack alignment in bytes:  For a downward-growing stack, this\n    // amount is subtracted from size of the stack space to get an address\n    // that is within the stack space and is aligned on all systems we care\n    // about.  As far as I know there is no ABI with stack alignment greater\n    // than 64.  We assume stack and stack_size already have alignment of\n    // kMaxStackAlignment.\n    const size_t kMaxStackAlignment = 64;\n    void* const stack_top =\n        static_cast&lt;char*&gt;(stack) +\n        (stack_grows_down ? stack_size - kMaxStackAlignment : 0);\n    GTEST_DEATH_TEST_CHECK_(\n        static_cast&lt;size_t&gt;(stack_size) &gt; kMaxStackAlignment &amp;&amp;\n        reinterpret_cast&lt;uintptr_t&gt;(stack_top) % kMaxStackAlignment == 0);\n\n    child_pid = clone(&amp;ExecDeathTestChildMain, stack_top, SIGCHLD, &amp;args);\n\n    GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);\n  }\n#else\n  const bool use_fork = true;\n#endif  // GTEST_HAS_CLONE\n\n  if (use_fork &amp;&amp; (child_pid = fork()) == 0) {\n    _Exit(ExecDeathTestChildMain(&amp;args));\n  }\n#endif  // GTEST_OS_QNX\n#ifdef GTEST_OS_LINUX\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(\n      sigaction(SIGPROF, &amp;saved_sigprof_action, nullptr));\n#endif  // GTEST_OS_LINUX\n\n  GTEST_DEATH_TEST_CHECK_(child_pid != -1);\n  return child_pid;\n}\n\n// The AssumeRole process for a fork-and-exec death test.  It re-executes the\n// main program from the beginning, setting the --gtest_filter\n// and --gtest_internal_run_death_test flags to cause only the current\n// death test to be re-run.\nDeathTest::TestRole ExecDeathTest::AssumeRole() {\n  const UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const TestInfo* const info = impl-&gt;current_test_info();\n  const int death_test_index = info-&gt;result()-&gt;death_test_count();\n\n  if (flag != nullptr) {\n    set_write_fd(flag-&gt;write_fd());\n    return EXECUTE_TEST;\n  }\n\n  int pipe_fd[2];\n  GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\n  // Clear the close-on-exec flag on the write end of the pipe, lest\n  // it be closed when the child process does an exec:\n  GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);\n\n  const std::string filter_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                  &quot;filter=&quot; + info-&gt;test_suite_name() + &quot;.&quot; +\n                                  info-&gt;name();\n  const std::string internal_flag = std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ +\n                                    &quot;internal_run_death_test=&quot; + file_ + &quot;|&quot; +\n                                    StreamableToString(line_) + &quot;|&quot; +\n                                    StreamableToString(death_test_index) + &quot;|&quot; +\n                                    StreamableToString(pipe_fd[1]);\n  std::vector&lt;std::string&gt; args = GetArgvsForDeathTestChildProcess();\n  args.push_back(filter_flag);\n  args.push_back(internal_flag);\n\n  DeathTest::set_last_death_test_message(&quot;&quot;);\n\n  CaptureStderr();\n  // See the comment in NoExecDeathTest::AssumeRole for why the next line\n  // is necessary.\n  FlushInfoLog();\n\n  std::vector&lt;char*&gt; argv = CreateArgvFromArgs(args);\n  const pid_t child_pid = ExecDeathTestSpawnChild(argv.data(), pipe_fd[0]);\n  GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\n  set_child_pid(child_pid);\n  set_read_fd(pipe_fd[0]);\n  set_spawned(true);\n  return OVERSEE_TEST;\n}\n\n#endif  // !GTEST_OS_WINDOWS\n\n// Creates a concrete DeathTest-derived class that depends on the\n// --gtest_death_test_style flag, and sets the pointer pointed to\n// by the &quot;test&quot; argument to its address.  If the test should be\n// skipped, sets that pointer to NULL.  Returns true, unless the\n// flag is set to an invalid value.\nbool DefaultDeathTestFactory::Create(const char* statement,\n                                     Matcher&lt;const std::string&amp;&gt; matcher,\n                                     const char* file, int line,\n                                     DeathTest** test) {\n  UnitTestImpl* const impl = GetUnitTestImpl();\n  const InternalRunDeathTestFlag* const flag =\n      impl-&gt;internal_run_death_test_flag();\n  const int death_test_index =\n      impl-&gt;current_test_info()-&gt;increment_death_test_count();\n\n  if (flag != nullptr) {\n    if (death_test_index &gt; flag-&gt;index()) {\n      DeathTest::set_last_death_test_message(\n          &quot;Death test count (&quot; + StreamableToString(death_test_index) +\n          &quot;) somehow exceeded expected maximum (&quot; +\n          StreamableToString(flag-&gt;index()) + &quot;)&quot;);\n      return false;\n    }\n\n    if (!(flag-&gt;file() == file &amp;&amp; flag-&gt;line() == line &amp;&amp;\n          flag-&gt;index() == death_test_index)) {\n      *test = nullptr;\n      return true;\n    }\n  }\n\n#ifdef GTEST_OS_WINDOWS\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot; ||\n      GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new WindowsDeathTest(statement, std::move(matcher), file, line);\n  }\n\n#elif defined(GTEST_OS_FUCHSIA)\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot; ||\n      GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new FuchsiaDeathTest(statement, std::move(matcher), file, line);\n  }\n\n#else\n\n  if (GTEST_FLAG_GET(death_test_style) == &quot;threadsafe&quot;) {\n    *test = new ExecDeathTest(statement, std::move(matcher), file, line);\n  } else if (GTEST_FLAG_GET(death_test_style) == &quot;fast&quot;) {\n    *test = new NoExecDeathTest(statement, std::move(matcher));\n  }\n\n#endif  // GTEST_OS_WINDOWS\n\n  else {  // NOLINT - this is more readable than unbalanced brackets inside #if.\n    DeathTest::set_last_death_test_message(&quot;Unknown death test style \\&quot;&quot; +\n                                           GTEST_FLAG_GET(death_test_style) +\n                                           &quot;\\&quot; encountered&quot;);\n    return false;\n  }\n\n  return true;\n}\n\n#ifdef GTEST_OS_WINDOWS\n// Recreates the pipe and event handles from the provided parameters,\n// signals the event, and returns a file descriptor wrapped around the pipe\n// handle. This function is called in the child process only.\nstatic int GetStatusFileDescriptor(unsigned int parent_process_id,\n                                   size_t write_handle_as_size_t,\n                                   size_t event_handle_as_size_t) {\n  AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,\n                                                 FALSE,  // Non-inheritable.\n                                                 parent_process_id));\n  if (parent_process_handle.Get() == INVALID_HANDLE_VALUE) {\n    DeathTestAbort(&quot;Unable to open parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  GTEST_CHECK_(sizeof(HANDLE) &lt;= sizeof(size_t));\n\n  const HANDLE write_handle = reinterpret_cast&lt;HANDLE&gt;(write_handle_as_size_t);\n  HANDLE dup_write_handle;\n\n  // The newly initialized handle is accessible only in the parent\n  // process. To obtain one accessible within the child, we need to use\n  // DuplicateHandle.\n  if (!::DuplicateHandle(parent_process_handle.Get(), write_handle,\n                         ::GetCurrentProcess(), &amp;dup_write_handle,\n                         0x0,    // Requested privileges ignored since\n                                 // DUPLICATE_SAME_ACCESS is used.\n                         FALSE,  // Request non-inheritable handler.\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(&quot;Unable to duplicate the pipe handle &quot; +\n                   StreamableToString(write_handle_as_size_t) +\n                   &quot; from the parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  const HANDLE event_handle = reinterpret_cast&lt;HANDLE&gt;(event_handle_as_size_t);\n  HANDLE dup_event_handle;\n\n  if (!::DuplicateHandle(parent_process_handle.Get(), event_handle,\n                         ::GetCurrentProcess(), &amp;dup_event_handle, 0x0, FALSE,\n                         DUPLICATE_SAME_ACCESS)) {\n    DeathTestAbort(&quot;Unable to duplicate the event handle &quot; +\n                   StreamableToString(event_handle_as_size_t) +\n                   &quot; from the parent process &quot; +\n                   StreamableToString(parent_process_id));\n  }\n\n  const int write_fd =\n      ::_open_osfhandle(reinterpret_cast&lt;intptr_t&gt;(dup_write_handle), O_APPEND);\n  if (write_fd == -1) {\n    DeathTestAbort(&quot;Unable to convert pipe handle &quot; +\n                   StreamableToString(write_handle_as_size_t) +\n                   &quot; to a file descriptor&quot;);\n  }\n\n  // Signals the parent that the write end of the pipe has been acquired\n  // so the parent can release its own write end.\n  ::SetEvent(dup_event_handle);\n\n  return write_fd;\n}\n#endif  // GTEST_OS_WINDOWS\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() {\n  if (GTEST_FLAG_GET(internal_run_death_test).empty()) return nullptr;\n\n  // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we\n  // can use it here.\n  int line = -1;\n  int index = -1;\n  ::std::vector&lt; ::std::string&gt; fields;\n  SplitString(GTEST_FLAG_GET(internal_run_death_test), &#x27;|&#x27;, &amp;fields);\n  int write_fd = -1;\n\n#ifdef GTEST_OS_WINDOWS\n\n  unsigned int parent_process_id = 0;\n  size_t write_handle_as_size_t = 0;\n  size_t event_handle_as_size_t = 0;\n\n  if (fields.size() != 6 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index) ||\n      !ParseNaturalNumber(fields[3], &amp;parent_process_id) ||\n      !ParseNaturalNumber(fields[4], &amp;write_handle_as_size_t) ||\n      !ParseNaturalNumber(fields[5], &amp;event_handle_as_size_t)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n  write_fd = GetStatusFileDescriptor(parent_process_id, write_handle_as_size_t,\n                                     event_handle_as_size_t);\n\n#elif defined(GTEST_OS_FUCHSIA)\n\n  if (fields.size() != 3 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n\n#else\n\n  if (fields.size() != 4 || !ParseNaturalNumber(fields[1], &amp;line) ||\n      !ParseNaturalNumber(fields[2], &amp;index) ||\n      !ParseNaturalNumber(fields[3], &amp;write_fd)) {\n    DeathTestAbort(&quot;Bad --gtest_internal_run_death_test flag: &quot; +\n                   GTEST_FLAG_GET(internal_run_death_test));\n  }\n\n#endif  // GTEST_OS_WINDOWS\n\n  return new InternalRunDeathTestFlag(fields[0], line, index, write_fd);\n}\n\n}  // namespace internal\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace testing\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Utility functions and classes used by the Google C++ testing framework.//\n// This file contains purely Google Test&#x27;s internal implementation.  Please\n// DO NOT #INCLUDE IT IN A USER PROGRAM.\n\n#ifndef GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_\n#define GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_\n\n#ifndef _WIN32_WCE\n#include &lt;errno.h&gt;\n#endif  // !_WIN32_WCE\n#include &lt;stddef.h&gt;\n#include &lt;stdlib.h&gt;  // For strtoll/_strtoul64/malloc/free.\n#include &lt;string.h&gt;  // For memmove.\n\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#if GTEST_CAN_STREAM_RESULTS_\n#include &lt;arpa/inet.h&gt;  // NOLINT\n#include &lt;netdb.h&gt;      // NOLINT\n#endif\n\n#ifdef GTEST_OS_WINDOWS\n#include &lt;windows.h&gt;  // NOLINT\n#endif                // GTEST_OS_WINDOWS\n\n#include &quot;gtest/gtest-spi.h&quot;\n#include &quot;gtest/gtest.h&quot;\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \\\n/* class A needs to have dll-interface to be used by clients of class B */)\n\n// Declares the flags.\n//\n// We don&#x27;t want the users to modify this flag in the code, but want\n// Google Test&#x27;s own unit tests to be able to access it. Therefore we\n// declare it here as opposed to in gtest.h.\nGTEST_DECLARE_bool_(death_test_use_fork);\n\nnamespace testing {\nnamespace internal {\n\n// The value of GetTestTypeId() as seen from within the Google Test\n// library.  This is solely for testing GetTestTypeId().\nGTEST_API_ extern const TypeId kTestTypeIdInGoogleTest;\n\n// A valid random seed must be in [1, kMaxRandomSeed].\nconst int kMaxRandomSeed = 99999;\n\n// g_help_flag is true if and only if the --help flag or an equivalent form\n// is specified on the command line.\nGTEST_API_ extern bool g_help_flag;\n\n// Returns the current time in milliseconds.\nGTEST_API_ TimeInMillis GetTimeInMillis();\n\n// Returns true if and only if Google Test should use colors in the output.\nGTEST_API_ bool ShouldUseColor(bool stdout_is_tty);\n\n// Formats the given time in milliseconds as seconds. If the input is an exact N\n// seconds, the output has a trailing decimal point (e.g., &quot;N.&quot; instead of &quot;N&quot;).\nGTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);\n\n// Converts the given time in milliseconds to a date string in the ISO 8601\n// format, without the timezone information.  N.B.: due to the use the\n// non-reentrant localtime() function, this function is not thread safe.  Do\n// not use it in any code that can be called from multiple threads.\nGTEST_API_ std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms);\n\n// Parses a string for an Int32 flag, in the form of &quot;--flag=value&quot;.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\nGTEST_API_ bool ParseFlag(const char* str, const char* flag, int32_t* value);\n\n// Returns a random seed in range [1, kMaxRandomSeed] based on the\n// given --gtest_random_seed flag value.\ninline int GetRandomSeedFromFlag(int32_t random_seed_flag) {\n  const unsigned int raw_seed =\n      (random_seed_flag == 0) ? static_cast&lt;unsigned int&gt;(GetTimeInMillis())\n                              : static_cast&lt;unsigned int&gt;(random_seed_flag);\n\n  // Normalizes the actual seed to range [1, kMaxRandomSeed] such that\n  // it&#x27;s easy to type.\n  const int normalized_seed =\n      static_cast&lt;int&gt;((raw_seed - 1U) %\n                       static_cast&lt;unsigned int&gt;(kMaxRandomSeed)) +\n      1;\n  return normalized_seed;\n}\n\n// Returns the first valid random seed after &#x27;seed&#x27;.  The behavior is\n// undefined if &#x27;seed&#x27; is invalid.  The seed after kMaxRandomSeed is\n// considered to be 1.\ninline int GetNextRandomSeed(int seed) {\n  GTEST_CHECK_(1 &lt;= seed &amp;&amp; seed &lt;= kMaxRandomSeed)\n      &lt;&lt; &quot;Invalid random seed &quot; &lt;&lt; seed &lt;&lt; &quot; - must be in [1, &quot;\n      &lt;&lt; kMaxRandomSeed &lt;&lt; &quot;].&quot;;\n  const int next_seed = seed + 1;\n  return (next_seed &gt; kMaxRandomSeed) ? 1 : next_seed;\n}\n\n// This class saves the values of all Google Test flags in its c&#x27;tor, and\n// restores them in its d&#x27;tor.\nclass GTestFlagSaver {\n public:\n  // The c&#x27;tor.\n  GTestFlagSaver() {\n    also_run_disabled_tests_ = GTEST_FLAG_GET(also_run_disabled_tests);\n    break_on_failure_ = GTEST_FLAG_GET(break_on_failure);\n    catch_exceptions_ = GTEST_FLAG_GET(catch_exceptions);\n    color_ = GTEST_FLAG_GET(color);\n    death_test_style_ = GTEST_FLAG_GET(death_test_style);\n    death_test_use_fork_ = GTEST_FLAG_GET(death_test_use_fork);\n    fail_fast_ = GTEST_FLAG_GET(fail_fast);\n    filter_ = GTEST_FLAG_GET(filter);\n    internal_run_death_test_ = GTEST_FLAG_GET(internal_run_death_test);\n    list_tests_ = GTEST_FLAG_GET(list_tests);\n    output_ = GTEST_FLAG_GET(output);\n    brief_ = GTEST_FLAG_GET(brief);\n    print_time_ = GTEST_FLAG_GET(print_time);\n    print_utf8_ = GTEST_FLAG_GET(print_utf8);\n    random_seed_ = GTEST_FLAG_GET(random_seed);\n    repeat_ = GTEST_FLAG_GET(repeat);\n    recreate_environments_when_repeating_ =\n        GTEST_FLAG_GET(recreate_environments_when_repeating);\n    shuffle_ = GTEST_FLAG_GET(shuffle);\n    stack_trace_depth_ = GTEST_FLAG_GET(stack_trace_depth);\n    stream_result_to_ = GTEST_FLAG_GET(stream_result_to);\n    throw_on_failure_ = GTEST_FLAG_GET(throw_on_failure);\n  }\n\n  // The d&#x27;tor is not virtual.  DO NOT INHERIT FROM THIS CLASS.\n  ~GTestFlagSaver() {\n    GTEST_FLAG_SET(also_run_disabled_tests, also_run_disabled_tests_);\n    GTEST_FLAG_SET(break_on_failure, break_on_failure_);\n    GTEST_FLAG_SET(catch_exceptions, catch_exceptions_);\n    GTEST_FLAG_SET(color, color_);\n    GTEST_FLAG_SET(death_test_style, death_test_style_);\n    GTEST_FLAG_SET(death_test_use_fork, death_test_use_fork_);\n    GTEST_FLAG_SET(filter, filter_);\n    GTEST_FLAG_SET(fail_fast, fail_fast_);\n    GTEST_FLAG_SET(internal_run_death_test, internal_run_death_test_);\n    GTEST_FLAG_SET(list_tests, list_tests_);\n    GTEST_FLAG_SET(output, output_);\n    GTEST_FLAG_SET(brief, brief_);\n    GTEST_FLAG_SET(print_time, print_time_);\n    GTEST_FLAG_SET(print_utf8, print_utf8_);\n    GTEST_FLAG_SET(random_seed, random_seed_);\n    GTEST_FLAG_SET(repeat, repeat_);\n    GTEST_FLAG_SET(recreate_environments_when_repeating,\n                   recreate_environments_when_repeating_);\n    GTEST_FLAG_SET(shuffle, shuffle_);\n    GTEST_FLAG_SET(stack_trace_depth, stack_trace_depth_);\n    GTEST_FLAG_SET(stream_result_to, stream_result_to_);\n    GTEST_FLAG_SET(throw_on_failure, throw_on_failure_);\n  }\n\n private:\n  // Fields for saving the original values of flags.\n  bool also_run_disabled_tests_;\n  bool break_on_failure_;\n  bool catch_exceptions_;\n  std::string color_;\n  std::string death_test_style_;\n  bool death_test_use_fork_;\n  bool fail_fast_;\n  std::string filter_;\n  std::string internal_run_death_test_;\n  bool list_tests_;\n  std::string output_;\n  bool brief_;\n  bool print_time_;\n  bool print_utf8_;\n  int32_t random_seed_;\n  int32_t repeat_;\n  bool recreate_environments_when_repeating_;\n  bool shuffle_;\n  int32_t stack_trace_depth_;\n  std::string stream_result_to_;\n  bool throw_on_failure_;\n};\n\n// Converts a Unicode code point to a narrow string in UTF-8 encoding.\n// code_point parameter is of type UInt32 because wchar_t may not be\n// wide enough to contain a code point.\n// If the code_point is not a valid Unicode code point\n// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted\n// to &quot;(Invalid Unicode 0xXXXXXXXX)&quot;.\nGTEST_API_ std::string CodePointToUtf8(uint32_t code_point);\n\n// Converts a wide string to a narrow string in UTF-8 encoding.\n// The wide string is assumed to have the following encoding:\n//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)\n//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)\n// Parameter str points to a null-terminated wide string.\n// Parameter num_chars may additionally limit the number\n// of wchar_t characters processed. -1 is used when the entire string\n// should be processed.\n// If the string contains code points that are not valid Unicode code points\n// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output\n// as &#x27;(Invalid Unicode 0xXXXXXXXX)&#x27;. If the string is in UTF16 encoding\n// and contains invalid UTF-16 surrogate pairs, values in those pairs\n// will be encoded as individual Unicode characters from Basic Normal Plane.\nGTEST_API_ std::string WideStringToUtf8(const wchar_t* str, int num_chars);\n\n// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file\n// if the variable is present. If a file already exists at this location, this\n// function will write over it. If the variable is present, but the file cannot\n// be created, prints an error and exits.\nvoid WriteToShardStatusFileIfNeeded();\n\n// Checks whether sharding is enabled by examining the relevant\n// environment variable values. If the variables are present,\n// but inconsistent (e.g., shard_index &gt;= total_shards), prints\n// an error and exits. If in_subprocess_for_death_test, sharding is\n// disabled because it must only be applied to the original test\n// process. Otherwise, we could filter out death tests we intended to execute.\nGTEST_API_ bool ShouldShard(const char* total_shards_str,\n                            const char* shard_index_str,\n                            bool in_subprocess_for_death_test);\n\n// Parses the environment variable var as a 32-bit integer. If it is unset,\n// returns default_val. If it is not a 32-bit integer, prints an error and\n// and aborts.\nGTEST_API_ int32_t Int32FromEnvOrDie(const char* env_var, int32_t default_val);\n\n// Given the total number of shards, the shard index, and the test id,\n// returns true if and only if the test should be run on this shard. The test id\n// is some arbitrary but unique non-negative integer assigned to each test\n// method. Assumes that 0 &lt;= shard_index &lt; total_shards.\nGTEST_API_ bool ShouldRunTestOnShard(int total_shards, int shard_index,\n                                     int test_id);\n\n// STL container utilities.\n\n// Returns the number of elements in the given container that satisfy\n// the given predicate.\ntemplate &lt;class Container, typename Predicate&gt;\ninline int CountIf(const Container&amp; c, Predicate predicate) {\n  // Implemented as an explicit loop since std::count_if() in libCstd on\n  // Solaris has a non-standard signature.\n  int count = 0;\n  for (auto it = c.begin(); it != c.end(); ++it) {\n    if (predicate(*it)) ++count;\n  }\n  return count;\n}\n\n// Applies a function/functor to each element in the container.\ntemplate &lt;class Container, typename Functor&gt;\nvoid ForEach(const Container&amp; c, Functor functor) {\n  std::for_each(c.begin(), c.end(), functor);\n}\n\n// Returns the i-th element of the vector, or default_value if i is not\n// in range [0, v.size()).\ntemplate &lt;typename E&gt;\ninline E GetElementOr(const std::vector&lt;E&gt;&amp; v, int i, E default_value) {\n  return (i &lt; 0 || i &gt;= static_cast&lt;int&gt;(v.size())) ? default_value\n                                                    : v[static_cast&lt;size_t&gt;(i)];\n}\n\n// Performs an in-place shuffle of a range of the vector&#x27;s elements.\n// &#x27;begin&#x27; and &#x27;end&#x27; are element indices as an STL-style range;\n// i.e. [begin, end) are shuffled, where &#x27;end&#x27; == size() means to\n// shuffle to the end of the vector.\ntemplate &lt;typename E&gt;\nvoid ShuffleRange(internal::Random* random, int begin, int end,\n                  std::vector&lt;E&gt;* v) {\n  const int size = static_cast&lt;int&gt;(v-&gt;size());\n  GTEST_CHECK_(0 &lt;= begin &amp;&amp; begin &lt;= size)\n      &lt;&lt; &quot;Invalid shuffle range start &quot; &lt;&lt; begin &lt;&lt; &quot;: must be in range [0, &quot;\n      &lt;&lt; size &lt;&lt; &quot;].&quot;;\n  GTEST_CHECK_(begin &lt;= end &amp;&amp; end &lt;= size)\n      &lt;&lt; &quot;Invalid shuffle range finish &quot; &lt;&lt; end &lt;&lt; &quot;: must be in range [&quot;\n      &lt;&lt; begin &lt;&lt; &quot;, &quot; &lt;&lt; size &lt;&lt; &quot;].&quot;;\n\n  // Fisher-Yates shuffle, from\n  // https://en.wikipedia.org/wiki/Fisher-Yates_shuffle\n  for (int range_width = end - begin; range_width &gt;= 2; range_width--) {\n    const int last_in_range = begin + range_width - 1;\n    const int selected =\n        begin +\n        static_cast&lt;int&gt;(random-&gt;Generate(static_cast&lt;uint32_t&gt;(range_width)));\n    std::swap((*v)[static_cast&lt;size_t&gt;(selected)],\n              (*v)[static_cast&lt;size_t&gt;(last_in_range)]);\n  }\n}\n\n// Performs an in-place shuffle of the vector&#x27;s elements.\ntemplate &lt;typename E&gt;\ninline void Shuffle(internal::Random* random, std::vector&lt;E&gt;* v) {\n  ShuffleRange(random, 0, static_cast&lt;int&gt;(v-&gt;size()), v);\n}\n\n// A function for deleting an object.  Handy for being used as a\n// functor.\ntemplate &lt;typename T&gt;\nstatic void Delete(T* x) {\n  delete x;\n}\n\n// A predicate that checks the key of a TestProperty against a known key.\n//\n// TestPropertyKeyIs is copyable.\nclass TestPropertyKeyIs {\n public:\n  // Constructor.\n  //\n  // TestPropertyKeyIs has NO default constructor.\n  explicit TestPropertyKeyIs(const std::string&amp; key) : key_(key) {}\n\n  // Returns true if and only if the test name of test property matches on key_.\n  bool operator()(const TestProperty&amp; test_property) const {\n    return test_property.key() == key_;\n  }\n\n private:\n  std::string key_;\n};\n\n// Class UnitTestOptions.\n//\n// This class contains functions for processing options the user\n// specifies when running the tests.  It has only static members.\n//\n// In most cases, the user can specify an option using either an\n// environment variable or a command line flag.  E.g. you can set the\n// test filter using either GTEST_FILTER or --gtest_filter.  If both\n// the variable and the flag are present, the latter overrides the\n// former.\nclass GTEST_API_ UnitTestOptions {\n public:\n  // Functions for processing the gtest_output flag.\n\n  // Returns the output format, or &quot;&quot; for normal printed output.\n  static std::string GetOutputFormat();\n\n  // Returns the absolute path of the requested output file, or the\n  // default (test_detail.xml in the original working directory) if\n  // none was explicitly specified.\n  static std::string GetAbsolutePathToOutputFile();\n\n  // Functions for processing the gtest_filter flag.\n\n  // Returns true if and only if the user-specified filter matches the test\n  // suite name and the test name.\n  static bool FilterMatchesTest(const std::string&amp; test_suite_name,\n                                const std::string&amp; test_name);\n\n#ifdef GTEST_OS_WINDOWS\n  // Function for supporting the gtest_catch_exception flag.\n\n  // Returns EXCEPTION_EXECUTE_HANDLER if given SEH exception was handled, or\n  // EXCEPTION_CONTINUE_SEARCH otherwise.\n  // This function is useful as an __except condition.\n  static int GTestProcessSEH(DWORD seh_code, const char* location);\n#endif  // GTEST_OS_WINDOWS\n\n  // Returns true if &quot;name&quot; matches the &#x27;:&#x27; separated list of glob-style\n  // filters in &quot;filter&quot;.\n  static bool MatchesFilter(const std::string&amp; name, const char* filter);\n};\n\n#if GTEST_HAS_FILE_SYSTEM\n// Returns the current application&#x27;s name, removing directory path if that\n// is present.  Used by UnitTestOptions::GetOutputFile.\nGTEST_API_ FilePath GetCurrentExecutableName();\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// The role interface for getting the OS stack trace as a string.\nclass OsStackTraceGetterInterface {\n public:\n  OsStackTraceGetterInterface() = default;\n  virtual ~OsStackTraceGetterInterface() = default;\n\n  // Returns the current OS stack trace as an std::string.  Parameters:\n  //\n  //   max_depth  - the maximum number of stack frames to be included\n  //                in the trace.\n  //   skip_count - the number of top frames to be skipped; doesn&#x27;t count\n  //                against max_depth.\n  virtual std::string CurrentStackTrace(int max_depth, int skip_count) = 0;\n\n  // UponLeavingGTest() should be called immediately before Google Test calls\n  // user code. It saves some information about the current stack that\n  // CurrentStackTrace() will use to find and hide Google Test stack frames.\n  virtual void UponLeavingGTest() = 0;\n\n  // This string is inserted in place of stack frames that are part of\n  // Google Test&#x27;s implementation.\n  static const char* const kElidedFramesMarker;\n\n private:\n  OsStackTraceGetterInterface(const OsStackTraceGetterInterface&amp;) = delete;\n  OsStackTraceGetterInterface&amp; operator=(const OsStackTraceGetterInterface&amp;) =\n      delete;\n};\n\n// A working implementation of the OsStackTraceGetterInterface interface.\nclass OsStackTraceGetter : public OsStackTraceGetterInterface {\n public:\n  OsStackTraceGetter() = default;\n\n  std::string CurrentStackTrace(int max_depth, int skip_count) override;\n  void UponLeavingGTest() override;\n\n private:\n#ifdef GTEST_HAS_ABSL\n  Mutex mutex_;  // Protects all internal state.\n\n  // We save the stack frame below the frame that calls user code.\n  // We do this because the address of the frame immediately below\n  // the user code changes between the call to UponLeavingGTest()\n  // and any calls to the stack trace code from within the user code.\n  void* caller_frame_ = nullptr;\n#endif  // GTEST_HAS_ABSL\n\n  OsStackTraceGetter(const OsStackTraceGetter&amp;) = delete;\n  OsStackTraceGetter&amp; operator=(const OsStackTraceGetter&amp;) = delete;\n};\n\n// Information about a Google Test trace point.\nstruct TraceInfo {\n  const char* file;\n  int line;\n  std::string message;\n};\n\n// This is the default global test part result reporter used in UnitTestImpl.\n// This class should only be used by UnitTestImpl.\nclass DefaultGlobalTestPartResultReporter\n    : public TestPartResultReporterInterface {\n public:\n  explicit DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);\n  // Implements the TestPartResultReporterInterface. Reports the test part\n  // result in the current test.\n  void ReportTestPartResult(const TestPartResult&amp; result) override;\n\n private:\n  UnitTestImpl* const unit_test_;\n\n  DefaultGlobalTestPartResultReporter(\n      const DefaultGlobalTestPartResultReporter&amp;) = delete;\n  DefaultGlobalTestPartResultReporter&amp; operator=(\n      const DefaultGlobalTestPartResultReporter&amp;) = delete;\n};\n\n// This is the default per thread test part result reporter used in\n// UnitTestImpl. This class should only be used by UnitTestImpl.\nclass DefaultPerThreadTestPartResultReporter\n    : public TestPartResultReporterInterface {\n public:\n  explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);\n  // Implements the TestPartResultReporterInterface. The implementation just\n  // delegates to the current global test part result reporter of *unit_test_.\n  void ReportTestPartResult(const TestPartResult&amp; result) override;\n\n private:\n  UnitTestImpl* const unit_test_;\n\n  DefaultPerThreadTestPartResultReporter(\n      const DefaultPerThreadTestPartResultReporter&amp;) = delete;\n  DefaultPerThreadTestPartResultReporter&amp; operator=(\n      const DefaultPerThreadTestPartResultReporter&amp;) = delete;\n};\n\n// The private implementation of the UnitTest class.  We don&#x27;t protect\n// the methods under a mutex, as this class is not accessible by a\n// user and the UnitTest class that delegates work to this class does\n// proper locking.\nclass GTEST_API_ UnitTestImpl {\n public:\n  explicit UnitTestImpl(UnitTest* parent);\n  virtual ~UnitTestImpl();\n\n  // There are two different ways to register your own TestPartResultReporter.\n  // You can register your own reporter to listen either only for test results\n  // from the current thread or for results from all threads.\n  // By default, each per-thread test result reporter just passes a new\n  // TestPartResult to the global test result reporter, which registers the\n  // test part result for the currently running test.\n\n  // Returns the global test part result reporter.\n  TestPartResultReporterInterface* GetGlobalTestPartResultReporter();\n\n  // Sets the global test part result reporter.\n  void SetGlobalTestPartResultReporter(\n      TestPartResultReporterInterface* reporter);\n\n  // Returns the test part result reporter for the current thread.\n  TestPartResultReporterInterface* GetTestPartResultReporterForCurrentThread();\n\n  // Sets the test part result reporter for the current thread.\n  void SetTestPartResultReporterForCurrentThread(\n      TestPartResultReporterInterface* reporter);\n\n  // Gets the number of successful test suites.\n  int successful_test_suite_count() const;\n\n  // Gets the number of failed test suites.\n  int failed_test_suite_count() const;\n\n  // Gets the number of all test suites.\n  int total_test_suite_count() const;\n\n  // Gets the number of all test suites that contain at least one test\n  // that should run.\n  int test_suite_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of skipped tests.\n  int skipped_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const { return start_timestamp_; }\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns true if and only if the unit test passed (i.e. all test suites\n  // passed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true if and only if the unit test failed (i.e. some test suite\n  // failed or something outside of all tests failed).\n  bool Failed() const {\n    return failed_test_suite_count() &gt; 0 || ad_hoc_test_result()-&gt;Failed();\n  }\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  const TestSuite* GetTestSuite(int i) const {\n    const int index = GetElementOr(test_suite_indices_, i, -1);\n    return index &lt; 0 ? nullptr : test_suites_[static_cast&lt;size_t&gt;(i)];\n  }\n\n  //  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  const TestCase* GetTestCase(int i) const { return GetTestSuite(i); }\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Gets the i-th test suite among all the test suites. i can range from 0 to\n  // total_test_suite_count() - 1. If i is not in that range, returns NULL.\n  TestSuite* GetMutableSuiteCase(int i) {\n    const int index = GetElementOr(test_suite_indices_, i, -1);\n    return index &lt; 0 ? nullptr : test_suites_[static_cast&lt;size_t&gt;(index)];\n  }\n\n  // Provides access to the event listener list.\n  TestEventListeners* listeners() { return &amp;listeners_; }\n\n  // Returns the TestResult for the test that&#x27;s currently running, or\n  // the TestResult for the ad hoc test if no test is running.\n  TestResult* current_test_result();\n\n  // Returns the TestResult for the ad hoc test.\n  const TestResult* ad_hoc_test_result() const { return &amp;ad_hoc_test_result_; }\n\n  // Sets the OS stack trace getter.\n  //\n  // Does nothing if the input and the current OS stack trace getter\n  // are the same; otherwise, deletes the old getter and makes the\n  // input the current getter.\n  void set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);\n\n  // Returns the current OS stack trace getter if it is not NULL;\n  // otherwise, creates an OsStackTraceGetter, makes it the current\n  // getter, and returns it.\n  OsStackTraceGetterInterface* os_stack_trace_getter();\n\n  // Returns the current OS stack trace as an std::string.\n  //\n  // The maximum number of stack frames to be included is specified by\n  // the gtest_stack_trace_depth flag.  The skip_count parameter\n  // specifies the number of top frames to be skipped, which doesn&#x27;t\n  // count against the number of frames to be included.\n  //\n  // For example, if Foo() calls Bar(), which in turn calls\n  // CurrentOsStackTraceExceptTop(1), Foo() will be included in the\n  // trace but Bar() and CurrentOsStackTraceExceptTop() won&#x27;t.\n  std::string CurrentOsStackTraceExceptTop(int skip_count)\n      GTEST_NO_INLINE_ GTEST_NO_TAIL_CALL_;\n\n  // Finds and returns a TestSuite with the given name.  If one doesn&#x27;t\n  // exist, creates one and returns it.\n  //\n  // Arguments:\n  //\n  //   test_suite_name: name of the test suite\n  //   type_param:      the name of the test&#x27;s type parameter, or NULL if\n  //                    this is not a typed or a type-parameterized test.\n  //   set_up_tc:       pointer to the function that sets up the test suite\n  //   tear_down_tc:    pointer to the function that tears down the test suite\n  TestSuite* GetTestSuite(const std::string&amp; test_suite_name,\n                          const char* type_param,\n                          internal::SetUpTestSuiteFunc set_up_tc,\n                          internal::TearDownTestSuiteFunc tear_down_tc);\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  TestCase* GetTestCase(const std::string&amp; test_case_name,\n                        const char* type_param,\n                        internal::SetUpTestSuiteFunc set_up_tc,\n                        internal::TearDownTestSuiteFunc tear_down_tc) {\n    return GetTestSuite(test_case_name, type_param, set_up_tc, tear_down_tc);\n  }\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  // Adds a TestInfo to the unit test.\n  //\n  // Arguments:\n  //\n  //   set_up_tc:    pointer to the function that sets up the test suite\n  //   tear_down_tc: pointer to the function that tears down the test suite\n  //   test_info:    the TestInfo object\n  void AddTestInfo(internal::SetUpTestSuiteFunc set_up_tc,\n                   internal::TearDownTestSuiteFunc tear_down_tc,\n                   TestInfo* test_info) {\n#if GTEST_HAS_FILE_SYSTEM\n    // In order to support thread-safe death tests, we need to\n    // remember the original working directory when the test program\n    // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as\n    // the user may have changed the current directory before calling\n    // RUN_ALL_TESTS().  Therefore we capture the current directory in\n    // AddTestInfo(), which is called to register a TEST or TEST_F\n    // before main() is reached.\n    if (original_working_dir_.IsEmpty()) {\n      original_working_dir_ = FilePath::GetCurrentDir();\n      GTEST_CHECK_(!original_working_dir_.IsEmpty())\n          &lt;&lt; &quot;Failed to get the current working directory.&quot;;\n    }\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n    GetTestSuite(test_info-&gt;test_suite_name_, test_info-&gt;type_param(),\n                 set_up_tc, tear_down_tc)\n        -&gt;AddTestInfo(test_info);\n  }\n\n  // Returns ParameterizedTestSuiteRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  internal::ParameterizedTestSuiteRegistry&amp; parameterized_test_registry() {\n    return parameterized_test_registry_;\n  }\n\n  std::set&lt;std::string&gt;* ignored_parameterized_test_suites() {\n    return &amp;ignored_parameterized_test_suites_;\n  }\n\n  // Returns TypeParameterizedTestSuiteRegistry object used to keep track of\n  // type-parameterized tests and instantiations of them.\n  internal::TypeParameterizedTestSuiteRegistry&amp;\n  type_parameterized_test_registry() {\n    return type_parameterized_test_registry_;\n  }\n\n  // Registers all parameterized tests defined using TEST_P and\n  // INSTANTIATE_TEST_SUITE_P, creating regular tests for each test/parameter\n  // combination. This method can be called more then once; it has guards\n  // protecting from registering the tests more then once.  If\n  // value-parameterized tests are disabled, RegisterParameterizedTests is\n  // present but does nothing.\n  void RegisterParameterizedTests();\n\n  // Runs all tests in this UnitTest object, prints the result, and\n  // returns true if all tests are successful.  If any exception is\n  // thrown during a test, this test is considered to be failed, but\n  // the rest of the tests will still be run.\n  bool RunAllTests();\n\n  // Clears the results of all tests, except the ad hoc tests.\n  void ClearNonAdHocTestResult() {\n    ForEach(test_suites_, TestSuite::ClearTestSuiteResult);\n  }\n\n  // Clears the results of ad-hoc test assertions.\n  void ClearAdHocTestResult() { ad_hoc_test_result_.Clear(); }\n\n  // Adds a TestProperty to the current TestResult object when invoked in a\n  // context of a test or a test suite, or to the global property set. If the\n  // result already contains a property with the same key, the value will be\n  // updated.\n  void RecordProperty(const TestProperty&amp; test_property);\n\n  enum ReactionToSharding { HONOR_SHARDING_PROTOCOL, IGNORE_SHARDING_PROTOCOL };\n\n  // Matches the full name of each test against the user-specified\n  // filter to decide whether the test should run, then records the\n  // result in each TestSuite and TestInfo object.\n  // If shard_tests == HONOR_SHARDING_PROTOCOL, further filters tests\n  // based on sharding variables in the environment.\n  // Returns the number of tests that should run.\n  int FilterTests(ReactionToSharding shard_tests);\n\n  // Prints the names of the tests matching the user-specified filter flag.\n  void ListTestsMatchingFilter();\n\n  const TestSuite* current_test_suite() const { return current_test_suite_; }\n  TestInfo* current_test_info() { return current_test_info_; }\n  const TestInfo* current_test_info() const { return current_test_info_; }\n\n  // Returns the vector of environments that need to be set-up/torn-down\n  // before/after the tests are run.\n  std::vector&lt;Environment*&gt;&amp; environments() { return environments_; }\n\n  // Getters for the per-thread Google Test trace stack.\n  std::vector&lt;TraceInfo&gt;&amp; gtest_trace_stack() {\n    return *(gtest_trace_stack_.pointer());\n  }\n  const std::vector&lt;TraceInfo&gt;&amp; gtest_trace_stack() const {\n    return gtest_trace_stack_.get();\n  }\n\n#ifdef GTEST_HAS_DEATH_TEST\n  void InitDeathTestSubprocessControlInfo() {\n    internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());\n  }\n  // Returns a pointer to the parsed --gtest_internal_run_death_test\n  // flag, or NULL if that flag was not specified.\n  // This information is useful only in a death test child process.\n  // Must not be called before a call to InitGoogleTest.\n  const InternalRunDeathTestFlag* internal_run_death_test_flag() const {\n    return internal_run_death_test_flag_.get();\n  }\n\n  // Returns a pointer to the current death test factory.\n  internal::DeathTestFactory* death_test_factory() {\n    return death_test_factory_.get();\n  }\n\n  void SuppressTestEventsIfInSubprocess();\n\n  friend class ReplaceDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n\n  // Initializes the event listener performing XML output as specified by\n  // UnitTestOptions. Must not be called before InitGoogleTest.\n  void ConfigureXmlOutput();\n\n#if GTEST_CAN_STREAM_RESULTS_\n  // Initializes the event listener for streaming test results to a socket.\n  // Must not be called before InitGoogleTest.\n  void ConfigureStreamingOutput();\n#endif\n\n  // Performs initialization dependent upon flag values obtained in\n  // ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to\n  // ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest\n  // this function is also called from RunAllTests.  Since this function can be\n  // called more than once, it has to be idempotent.\n  void PostFlagParsingInit();\n\n  // Gets the random seed used at the start of the current test iteration.\n  int random_seed() const { return random_seed_; }\n\n  // Gets the random number generator.\n  internal::Random* random() { return &amp;random_; }\n\n  // Shuffles all test suites, and the tests within each test suite,\n  // making sure that death tests are still run first.\n  void ShuffleTests();\n\n  // Restores the test suites and tests to their order before the first shuffle.\n  void UnshuffleTests();\n\n  // Returns the value of GTEST_FLAG(catch_exceptions) at the moment\n  // UnitTest::Run() starts.\n  bool catch_exceptions() const { return catch_exceptions_; }\n\n private:\n  struct CompareTestSuitesByPointer {\n    bool operator()(const TestSuite* lhs, const TestSuite* rhs) const {\n      return lhs-&gt;name_ &lt; rhs-&gt;name_;\n    }\n  };\n\n  friend class ::testing::UnitTest;\n\n  // Used by UnitTest::Run() to capture the state of\n  // GTEST_FLAG(catch_exceptions) at the moment it starts.\n  void set_catch_exceptions(bool value) { catch_exceptions_ = value; }\n\n  // Sets the TestSuite object for the test that&#x27;s currently running.\n  void set_current_test_suite(TestSuite* a_current_test_suite) {\n    current_test_suite_ = a_current_test_suite;\n  }\n\n  // Sets the TestInfo object for the test that&#x27;s currently running.  If\n  // current_test_info is NULL, the assertion results will be stored in\n  // ad_hoc_test_result_.\n  void set_current_test_info(TestInfo* a_current_test_info) {\n    current_test_info_ = a_current_test_info;\n  }\n\n  // The UnitTest object that owns this implementation object.\n  UnitTest* const parent_;\n\n#if GTEST_HAS_FILE_SYSTEM\n  // The working directory when the first TEST() or TEST_F() was\n  // executed.\n  internal::FilePath original_working_dir_;\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n  // The default test part result reporters.\n  DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_;\n  DefaultPerThreadTestPartResultReporter\n      default_per_thread_test_part_result_reporter_;\n\n  // Points to (but doesn&#x27;t own) the global test part result reporter.\n  TestPartResultReporterInterface* global_test_part_result_reporter_;\n\n  // Protects read and write access to global_test_part_result_reporter_.\n  internal::Mutex global_test_part_result_reporter_mutex_;\n\n  // Points to (but doesn&#x27;t own) the per-thread test part result reporter.\n  internal::ThreadLocal&lt;TestPartResultReporterInterface*&gt;\n      per_thread_test_part_result_reporter_;\n\n  // The vector of environments that need to be set-up/torn-down\n  // before/after the tests are run.\n  std::vector&lt;Environment*&gt; environments_;\n\n  // The vector of TestSuites in their original order.  It owns the\n  // elements in the vector.\n  std::vector&lt;TestSuite*&gt; test_suites_;\n\n  // The set of TestSuites by name.\n  std::unordered_map&lt;std::string, TestSuite*&gt; test_suites_by_name_;\n\n  // Provides a level of indirection for the test suite list to allow\n  // easy shuffling and restoring the test suite order.  The i-th\n  // element of this vector is the index of the i-th test suite in the\n  // shuffled order.\n  std::vector&lt;int&gt; test_suite_indices_;\n\n  // ParameterizedTestRegistry object used to register value-parameterized\n  // tests.\n  internal::ParameterizedTestSuiteRegistry parameterized_test_registry_;\n  internal::TypeParameterizedTestSuiteRegistry\n      type_parameterized_test_registry_;\n\n  // The set holding the name of parameterized\n  // test suites that may go uninstantiated.\n  std::set&lt;std::string&gt; ignored_parameterized_test_suites_;\n\n  // Indicates whether RegisterParameterizedTests() has been called already.\n  bool parameterized_tests_registered_;\n\n  // Index of the last death test suite registered.  Initially -1.\n  int last_death_test_suite_;\n\n  // This points to the TestSuite for the currently running test.  It\n  // changes as Google Test goes through one test suite after another.\n  // When no test is running, this is set to NULL and Google Test\n  // stores assertion results in ad_hoc_test_result_.  Initially NULL.\n  TestSuite* current_test_suite_;\n\n  // This points to the TestInfo for the currently running test.  It\n  // changes as Google Test goes through one test after another.  When\n  // no test is running, this is set to NULL and Google Test stores\n  // assertion results in ad_hoc_test_result_.  Initially NULL.\n  TestInfo* current_test_info_;\n\n  // Normally, a user only writes assertions inside a TEST or TEST_F,\n  // or inside a function called by a TEST or TEST_F.  Since Google\n  // Test keeps track of which test is current running, it can\n  // associate such an assertion with the test it belongs to.\n  //\n  // If an assertion is encountered when no TEST or TEST_F is running,\n  // Google Test attributes the assertion result to an imaginary &quot;ad hoc&quot;\n  // test, and records the result in ad_hoc_test_result_.\n  TestResult ad_hoc_test_result_;\n\n  // The list of event listeners that can be used to track events inside\n  // Google Test.\n  TestEventListeners listeners_;\n\n  // The OS stack trace getter.  Will be deleted when the UnitTest\n  // object is destructed.  By default, an OsStackTraceGetter is used,\n  // but the user can set this field to use a custom getter if that is\n  // desired.\n  OsStackTraceGetterInterface* os_stack_trace_getter_;\n\n  // True if and only if PostFlagParsingInit() has been called.\n  bool post_flag_parse_init_performed_;\n\n  // The random number seed used at the beginning of the test run.\n  int random_seed_;\n\n  // Our random number generator.\n  internal::Random random_;\n\n  // The time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp_;\n\n  // How long the test took to run, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n#ifdef GTEST_HAS_DEATH_TEST\n  // The decomposed components of the gtest_internal_run_death_test flag,\n  // parsed when RUN_ALL_TESTS is called.\n  std::unique_ptr&lt;InternalRunDeathTestFlag&gt; internal_run_death_test_flag_;\n  std::unique_ptr&lt;internal::DeathTestFactory&gt; death_test_factory_;\n#endif  // GTEST_HAS_DEATH_TEST\n\n  // A per-thread stack of traces created by the SCOPED_TRACE() macro.\n  internal::ThreadLocal&lt;std::vector&lt;TraceInfo&gt; &gt; gtest_trace_stack_;\n\n  // The value of GTEST_FLAG(catch_exceptions) at the moment RunAllTests()\n  // starts.\n  bool catch_exceptions_;\n\n  UnitTestImpl(const UnitTestImpl&amp;) = delete;\n  UnitTestImpl&amp; operator=(const UnitTestImpl&amp;) = delete;\n};  // class UnitTestImpl\n\n// Convenience function for accessing the global UnitTest\n// implementation object.\ninline UnitTestImpl* GetUnitTestImpl() {\n  return UnitTest::GetInstance()-&gt;impl();\n}\n\n#ifdef GTEST_USES_SIMPLE_RE\n\n// Internal helper functions for implementing the simple regular\n// expression matcher.\nGTEST_API_ bool IsInSet(char ch, const char* str);\nGTEST_API_ bool IsAsciiDigit(char ch);\nGTEST_API_ bool IsAsciiPunct(char ch);\nGTEST_API_ bool IsRepeat(char ch);\nGTEST_API_ bool IsAsciiWhiteSpace(char ch);\nGTEST_API_ bool IsAsciiWordChar(char ch);\nGTEST_API_ bool IsValidEscape(char ch);\nGTEST_API_ bool AtomMatchesChar(bool escaped, char pattern, char ch);\nGTEST_API_ bool ValidateRegex(const char* regex);\nGTEST_API_ bool MatchRegexAtHead(const char* regex, const char* str);\nGTEST_API_ bool MatchRepetitionAndRegexAtHead(bool escaped, char ch,\n                                              char repeat, const char* regex,\n                                              const char* str);\nGTEST_API_ bool MatchRegexAnywhere(const char* regex, const char* str);\n\n#endif  // GTEST_USES_SIMPLE_RE\n\n// Parses the command line for Google Test flags, without initializing\n// other parts of Google Test.\nGTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, char** argv);\nGTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);\n\n#ifdef GTEST_HAS_DEATH_TEST\n\n// Returns the message describing the last system error, regardless of the\n// platform.\nGTEST_API_ std::string GetLastErrnoDescription();\n\n// Attempts to parse a string into a positive integer pointed to by the\n// number parameter.  Returns true if that is possible.\n// GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we can use\n// it here.\ntemplate &lt;typename Integer&gt;\nbool ParseNaturalNumber(const ::std::string&amp; str, Integer* number) {\n  // Fail fast if the given string does not begin with a digit;\n  // this bypasses strtoXXX&#x27;s &quot;optional leading whitespace and plus\n  // or minus sign&quot; semantics, which are undesirable here.\n  if (str.empty() || !IsDigit(str[0])) {\n    return false;\n  }\n  errno = 0;\n\n  char* end;\n  // BiggestConvertible is the largest integer type that system-provided\n  // string-to-number conversion routines can return.\n  using BiggestConvertible = unsigned long long;  // NOLINT\n\n  const BiggestConvertible parsed = strtoull(str.c_str(), &amp;end, 10);  // NOLINT\n  const bool parse_success = *end == &#x27;\\0&#x27; &amp;&amp; errno == 0;\n\n  GTEST_CHECK_(sizeof(Integer) &lt;= sizeof(parsed));\n\n  const Integer result = static_cast&lt;Integer&gt;(parsed);\n  if (parse_success &amp;&amp; static_cast&lt;BiggestConvertible&gt;(result) == parsed) {\n    *number = result;\n    return true;\n  }\n  return false;\n}\n#endif  // GTEST_HAS_DEATH_TEST\n\n// TestResult contains some private methods that should be hidden from\n// Google Test user but are required for testing. This class allow our tests\n// to access them.\n//\n// This class is supplied only for the purpose of testing Google Test&#x27;s own\n// constructs. Do not use it in user tests, either directly or indirectly.\nclass TestResultAccessor {\n public:\n  static void RecordProperty(TestResult* test_result,\n                             const std::string&amp; xml_element,\n                             const TestProperty&amp; property) {\n    test_result-&gt;RecordProperty(xml_element, property);\n  }\n\n  static void ClearTestPartResults(TestResult* test_result) {\n    test_result-&gt;ClearTestPartResults();\n  }\n\n  static const std::vector&lt;testing::TestPartResult&gt;&amp; test_part_results(\n      const TestResult&amp; test_result) {\n    return test_result.test_part_results();\n  }\n};\n\n#if GTEST_CAN_STREAM_RESULTS_\n\n// Streams test results to the given port on the given host machine.\nclass StreamingListener : public EmptyTestEventListener {\n public:\n  // Abstract base class for writing strings to a socket.\n  class AbstractSocketWriter {\n   public:\n    virtual ~AbstractSocketWriter() = default;\n\n    // Sends a string to the socket.\n    virtual void Send(const std::string&amp; message) = 0;\n\n    // Closes the socket.\n    virtual void CloseConnection() {}\n\n    // Sends a string and a newline to the socket.\n    void SendLn(const std::string&amp; message) { Send(message + &quot;\\n&quot;); }\n  };\n\n  // Concrete class for actually writing strings to a socket.\n  class SocketWriter : public AbstractSocketWriter {\n   public:\n    SocketWriter(const std::string&amp; host, const std::string&amp; port)\n        : sockfd_(-1), host_name_(host), port_num_(port) {\n      MakeConnection();\n    }\n\n    ~SocketWriter() override {\n      if (sockfd_ != -1) CloseConnection();\n    }\n\n    // Sends a string to the socket.\n    void Send(const std::string&amp; message) override {\n      GTEST_CHECK_(sockfd_ != -1)\n          &lt;&lt; &quot;Send() can be called only when there is a connection.&quot;;\n\n      const auto len = static_cast&lt;size_t&gt;(message.length());\n      if (write(sockfd_, message.c_str(), len) != static_cast&lt;ssize_t&gt;(len)) {\n        GTEST_LOG_(WARNING) &lt;&lt; &quot;stream_result_to: failed to stream to &quot;\n                            &lt;&lt; host_name_ &lt;&lt; &quot;:&quot; &lt;&lt; port_num_;\n      }\n    }\n\n   private:\n    // Creates a client socket and connects to the server.\n    void MakeConnection();\n\n    // Closes the socket.\n    void CloseConnection() override {\n      GTEST_CHECK_(sockfd_ != -1)\n          &lt;&lt; &quot;CloseConnection() can be called only when there is a connection.&quot;;\n\n      close(sockfd_);\n      sockfd_ = -1;\n    }\n\n    int sockfd_;  // socket file descriptor\n    const std::string host_name_;\n    const std::string port_num_;\n\n    SocketWriter(const SocketWriter&amp;) = delete;\n    SocketWriter&amp; operator=(const SocketWriter&amp;) = delete;\n  };  // class SocketWriter\n\n  // Escapes &#x27;=&#x27;, &#x27;&amp;&#x27;, &#x27;%&#x27;, and &#x27;\\n&#x27; characters in str as &quot;%xx&quot;.\n  static std::string UrlEncode(const char* str);\n\n  StreamingListener(const std::string&amp; host, const std::string&amp; port)\n      : socket_writer_(new SocketWriter(host, port)) {\n    Start();\n  }\n\n  explicit StreamingListener(AbstractSocketWriter* socket_writer)\n      : socket_writer_(socket_writer) {\n    Start();\n  }\n\n  void OnTestProgramStart(const UnitTest&amp; /* unit_test */) override {\n    SendLn(&quot;event=TestProgramStart&quot;);\n  }\n\n  void OnTestProgramEnd(const UnitTest&amp; unit_test) override {\n    // Note that Google Test current only report elapsed time for each\n    // test iteration, not for the entire test program.\n    SendLn(&quot;event=TestProgramEnd&amp;passed=&quot; + FormatBool(unit_test.Passed()));\n\n    // Notify the streaming server to stop.\n    socket_writer_-&gt;CloseConnection();\n  }\n\n  void OnTestIterationStart(const UnitTest&amp; /* unit_test */,\n                            int iteration) override {\n    SendLn(&quot;event=TestIterationStart&amp;iteration=&quot; +\n           StreamableToString(iteration));\n  }\n\n  void OnTestIterationEnd(const UnitTest&amp; unit_test,\n                          int /* iteration */) override {\n    SendLn(&quot;event=TestIterationEnd&amp;passed=&quot; + FormatBool(unit_test.Passed()) +\n           &quot;&amp;elapsed_time=&quot; + StreamableToString(unit_test.elapsed_time()) +\n           &quot;ms&quot;);\n  }\n\n  // Note that &quot;event=TestCaseStart&quot; is a wire format and has to remain\n  // &quot;case&quot; for compatibility\n  void OnTestSuiteStart(const TestSuite&amp; test_suite) override {\n    SendLn(std::string(&quot;event=TestCaseStart&amp;name=&quot;) + test_suite.name());\n  }\n\n  // Note that &quot;event=TestCaseEnd&quot; is a wire format and has to remain\n  // &quot;case&quot; for compatibility\n  void OnTestSuiteEnd(const TestSuite&amp; test_suite) override {\n    SendLn(&quot;event=TestCaseEnd&amp;passed=&quot; + FormatBool(test_suite.Passed()) +\n           &quot;&amp;elapsed_time=&quot; + StreamableToString(test_suite.elapsed_time()) +\n           &quot;ms&quot;);\n  }\n\n  void OnTestStart(const TestInfo&amp; test_info) override {\n    SendLn(std::string(&quot;event=TestStart&amp;name=&quot;) + test_info.name());\n  }\n\n  void OnTestEnd(const TestInfo&amp; test_info) override {\n    SendLn(&quot;event=TestEnd&amp;passed=&quot; +\n           FormatBool((test_info.result())-&gt;Passed()) + &quot;&amp;elapsed_time=&quot; +\n           StreamableToString((test_info.result())-&gt;elapsed_time()) + &quot;ms&quot;);\n  }\n\n  void OnTestPartResult(const TestPartResult&amp; test_part_result) override {\n    const char* file_name = test_part_result.file_name();\n    if (file_name == nullptr) file_name = &quot;&quot;;\n    SendLn(&quot;event=TestPartResult&amp;file=&quot; + UrlEncode(file_name) +\n           &quot;&amp;line=&quot; + StreamableToString(test_part_result.line_number()) +\n           &quot;&amp;message=&quot; + UrlEncode(test_part_result.message()));\n  }\n\n private:\n  // Sends the given message and a newline to the socket.\n  void SendLn(const std::string&amp; message) { socket_writer_-&gt;SendLn(message); }\n\n  // Called at the start of streaming to notify the receiver what\n  // protocol we are using.\n  void Start() { SendLn(&quot;gtest_streaming_protocol_version=1.0&quot;); }\n\n  std::string FormatBool(bool value) { return value ? &quot;1&quot; : &quot;0&quot;; }\n\n  const std::unique_ptr&lt;AbstractSocketWriter&gt; socket_writer_;\n\n  StreamingListener(const StreamingListener&amp;) = delete;\n  StreamingListener&amp; operator=(const StreamingListener&amp;) = delete;\n};  // class StreamingListener\n\n#endif  // GTEST_CAN_STREAM_RESULTS_\n\n}  // namespace internal\n}  // namespace testing\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()  //  4251\n\n#endif  // GOOGLETEST_SRC_GTEST_INTERNAL_INL_H_\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;cstdint&gt;\n#include &lt;fstream&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#ifdef GTEST_OS_WINDOWS\n#include &lt;io.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;windows.h&gt;\n\n#include &lt;map&gt;  // Used in ThreadLocal.\n#ifdef _MSC_VER\n#include &lt;crtdbg.h&gt;\n#endif  // _MSC_VER\n#else\n#include &lt;unistd.h&gt;\n#endif  // GTEST_OS_WINDOWS\n\n#ifdef GTEST_OS_MAC\n#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/task.h&gt;\n#include &lt;mach/vm_map.h&gt;\n#endif  // GTEST_OS_MAC\n\n#if defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_FREEBSD) ||   \\\n    defined(GTEST_OS_GNU_KFREEBSD) || defined(GTEST_OS_NETBSD) || \\\n    defined(GTEST_OS_OPENBSD)\n#include &lt;sys/sysctl.h&gt;\n#if defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_FREEBSD) || \\\n    defined(GTEST_OS_GNU_KFREEBSD)\n#include &lt;sys/user.h&gt;\n#endif\n#endif\n\n#ifdef GTEST_OS_QNX\n#include &lt;devctl.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/procfs.h&gt;\n#endif  // GTEST_OS_QNX\n\n#ifdef GTEST_OS_AIX\n#include &lt;procinfo.h&gt;\n#include &lt;sys/types.h&gt;\n#endif  // GTEST_OS_AIX\n\n#ifdef GTEST_OS_FUCHSIA\n#include &lt;zircon/process.h&gt;\n#include &lt;zircon/syscalls.h&gt;\n#endif  // GTEST_OS_FUCHSIA\n\n#include &quot;gtest/gtest-message.h&quot;\n#include &quot;gtest/gtest-spi.h&quot;\n#include &quot;gtest/internal/gtest-internal.h&quot;\n#include &quot;gtest/internal/gtest-string.h&quot;\n#include &quot;src/gtest-internal-inl.h&quot;\n\nnamespace testing {\nnamespace internal {\n\n#if defined(GTEST_OS_LINUX) || defined(GTEST_OS_GNU_HURD)\n\nnamespace {\ntemplate &lt;typename T&gt;\nT ReadProcFileField(const std::string&amp; filename, int field) {\n  std::string dummy;\n  std::ifstream file(filename.c_str());\n  while (field-- &gt; 0) {\n    file &gt;&gt; dummy;\n  }\n  T output = 0;\n  file &gt;&gt; output;\n  return output;\n}\n}  // namespace\n\n// Returns the number of active threads, or 0 when there is an error.\nsize_t GetThreadCount() {\n  const std::string filename =\n      (Message() &lt;&lt; &quot;/proc/&quot; &lt;&lt; getpid() &lt;&lt; &quot;/stat&quot;).GetString();\n  return ReadProcFileField&lt;size_t&gt;(filename, 19);\n}\n\n#elif defined(GTEST_OS_MAC)\n\nsize_t GetThreadCount() {\n  const task_t task = mach_task_self();\n  mach_msg_type_number_t thread_count;\n  thread_act_array_t thread_list;\n  const kern_return_t status = task_threads(task, &amp;thread_list, &amp;thread_count);\n  if (status == KERN_SUCCESS) {\n    // task_threads allocates resources in thread_list and we need to free them\n    // to avoid leaks.\n    vm_deallocate(task, reinterpret_cast&lt;vm_address_t&gt;(thread_list),\n                  sizeof(thread_t) * thread_count);\n    return static_cast&lt;size_t&gt;(thread_count);\n  } else {\n    return 0;\n  }\n}\n\n#elif defined(GTEST_OS_DRAGONFLY) || defined(GTEST_OS_FREEBSD) || \\\n    defined(GTEST_OS_GNU_KFREEBSD) || defined(GTEST_OS_NETBSD)\n\n#ifdef GTEST_OS_NETBSD\n#undef KERN_PROC\n#define KERN_PROC KERN_PROC2\n#define kinfo_proc kinfo_proc2\n#endif\n\n#ifdef GTEST_OS_DRAGONFLY\n#define KP_NLWP(kp) (kp.kp_nthreads)\n#elif defined(GTEST_OS_FREEBSD) || defined(GTEST_OS_GNU_KFREEBSD)\n#define KP_NLWP(kp) (kp.ki_numthreads)\n#elif defined(GTEST_OS_NETBSD)\n#define KP_NLWP(kp) (kp.p_nlwps)\n#endif\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  int mib[] = {\n      CTL_KERN,\n      KERN_PROC,\n      KERN_PROC_PID,\n      getpid(),\n#ifdef GTEST_OS_NETBSD\n      sizeof(struct kinfo_proc),\n      1,\n#endif\n  };\n  u_int miblen = sizeof(mib) / sizeof(mib[0]);\n  struct kinfo_proc info;\n  size_t size = sizeof(info);\n  if (sysctl(mib, miblen, &amp;info, &amp;size, NULL, 0)) {\n    return 0;\n  }\n  return static_cast&lt;size_t&gt;(KP_NLWP(info));\n}\n#elif defined(GTEST_OS_OPENBSD)\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  int mib[] = {\n      CTL_KERN,\n      KERN_PROC,\n      KERN_PROC_PID | KERN_PROC_SHOW_THREADS,\n      getpid(),\n      sizeof(struct kinfo_proc),\n      0,\n  };\n  u_int miblen = sizeof(mib) / sizeof(mib[0]);\n\n  // get number of structs\n  size_t size;\n  if (sysctl(mib, miblen, NULL, &amp;size, NULL, 0)) {\n    return 0;\n  }\n\n  mib[5] = static_cast&lt;int&gt;(size / static_cast&lt;size_t&gt;(mib[4]));\n\n  // populate array of structs\n  std::vector&lt;struct kinfo_proc&gt; info(mib[5]);\n  if (sysctl(mib, miblen, info.data(), &amp;size, NULL, 0)) {\n    return 0;\n  }\n\n  // exclude empty members\n  size_t nthreads = 0;\n  for (size_t i = 0; i &lt; size / static_cast&lt;size_t&gt;(mib[4]); i++) {\n    if (info[i].p_tid != -1) nthreads++;\n  }\n  return nthreads;\n}\n\n#elif defined(GTEST_OS_QNX)\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nsize_t GetThreadCount() {\n  const int fd = open(&quot;/proc/self/as&quot;, O_RDONLY);\n  if (fd &lt; 0) {\n    return 0;\n  }\n  procfs_info process_info;\n  const int status =\n      devctl(fd, DCMD_PROC_INFO, &amp;process_info, sizeof(process_info), nullptr);\n  close(fd);\n  if (status == EOK) {\n    return static_cast&lt;size_t&gt;(process_info.num_threads);\n  } else {\n    return 0;\n  }\n}\n\n#elif defined(GTEST_OS_AIX)\n\nsize_t GetThreadCount() {\n  struct procentry64 entry;\n  pid_t pid = getpid();\n  int status = getprocs64(&amp;entry, sizeof(entry), nullptr, 0, &amp;pid, 1);\n  if (status == 1) {\n    return entry.pi_thcount;\n  } else {\n    return 0;\n  }\n}\n\n#elif defined(GTEST_OS_FUCHSIA)\n\nsize_t GetThreadCount() {\n  int dummy_buffer;\n  size_t avail;\n  zx_status_t status =\n      zx_object_get_info(zx_process_self(), ZX_INFO_PROCESS_THREADS,\n                         &amp;dummy_buffer, 0, nullptr, &amp;avail);\n  if (status == ZX_OK) {\n    return avail;\n  } else {\n    return 0;\n  }\n}\n\n#else\n\nsize_t GetThreadCount() {\n  // There&#x27;s no portable way to detect the number of threads, so we just\n  // return 0 to indicate that we cannot detect it.\n  return 0;\n}\n\n#endif  // GTEST_OS_LINUX\n\n#if defined(GTEST_IS_THREADSAFE) &amp;&amp; defined(GTEST_OS_WINDOWS)\n\nAutoHandle::AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}\n\nAutoHandle::AutoHandle(Handle handle) : handle_(handle) {}\n\nAutoHandle::~AutoHandle() { Reset(); }\n\nAutoHandle::Handle AutoHandle::Get() const { return handle_; }\n\nvoid AutoHandle::Reset() { Reset(INVALID_HANDLE_VALUE); }\n\nvoid AutoHandle::Reset(HANDLE handle) {\n  // Resetting with the same handle we already own is invalid.\n  if (handle_ != handle) {\n    if (IsCloseable()) {\n      ::CloseHandle(handle_);\n    }\n    handle_ = handle;\n  } else {\n    GTEST_CHECK_(!IsCloseable())\n        &lt;&lt; &quot;Resetting a valid handle to itself is likely a programmer error &quot;\n           &quot;and thus not allowed.&quot;;\n  }\n}\n\nbool AutoHandle::IsCloseable() const {\n  // Different Windows APIs may use either of these values to represent an\n  // invalid handle.\n  return handle_ != nullptr &amp;&amp; handle_ != INVALID_HANDLE_VALUE;\n}\n\nMutex::Mutex()\n    : owner_thread_id_(0),\n      type_(kDynamic),\n      critical_section_init_phase_(0),\n      critical_section_(new CRITICAL_SECTION) {\n  ::InitializeCriticalSection(critical_section_);\n}\n\nMutex::~Mutex() {\n  // Static mutexes are leaked intentionally. It is not thread-safe to try\n  // to clean them up.\n  if (type_ == kDynamic) {\n    ::DeleteCriticalSection(critical_section_);\n    delete critical_section_;\n    critical_section_ = nullptr;\n  }\n}\n\nvoid Mutex::Lock() {\n  ThreadSafeLazyInit();\n  ::EnterCriticalSection(critical_section_);\n  owner_thread_id_ = ::GetCurrentThreadId();\n}\n\nvoid Mutex::Unlock() {\n  ThreadSafeLazyInit();\n  // We don&#x27;t protect writing to owner_thread_id_ here, as it&#x27;s the\n  // caller&#x27;s responsibility to ensure that the current thread holds the\n  // mutex when this is called.\n  owner_thread_id_ = 0;\n  ::LeaveCriticalSection(critical_section_);\n}\n\n// Does nothing if the current thread holds the mutex. Otherwise, crashes\n// with high probability.\nvoid Mutex::AssertHeld() {\n  ThreadSafeLazyInit();\n  GTEST_CHECK_(owner_thread_id_ == ::GetCurrentThreadId())\n      &lt;&lt; &quot;The current thread is not holding the mutex @&quot; &lt;&lt; this;\n}\n\nnamespace {\n\n#ifdef _MSC_VER\n// Use the RAII idiom to flag mem allocs that are intentionally never\n// deallocated. The motivation is to silence the false positive mem leaks\n// that are reported by the debug version of MS&#x27;s CRT which can only detect\n// if an alloc is missing a matching deallocation.\n// Example:\n//    MemoryIsNotDeallocated memory_is_not_deallocated;\n//    critical_section_ = new CRITICAL_SECTION;\n//\nclass MemoryIsNotDeallocated {\n public:\n  MemoryIsNotDeallocated() : old_crtdbg_flag_(0) {\n    old_crtdbg_flag_ = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n    // Set heap allocation block type to _IGNORE_BLOCK so that MS debug CRT\n    // doesn&#x27;t report mem leak if there&#x27;s no matching deallocation.\n    (void)_CrtSetDbgFlag(old_crtdbg_flag_ &amp; ~_CRTDBG_ALLOC_MEM_DF);\n  }\n\n  ~MemoryIsNotDeallocated() {\n    // Restore the original _CRTDBG_ALLOC_MEM_DF flag\n    (void)_CrtSetDbgFlag(old_crtdbg_flag_);\n  }\n\n private:\n  int old_crtdbg_flag_;\n\n  MemoryIsNotDeallocated(const MemoryIsNotDeallocated&amp;) = delete;\n  MemoryIsNotDeallocated&amp; operator=(const MemoryIsNotDeallocated&amp;) = delete;\n};\n#endif  // _MSC_VER\n\n}  // namespace\n\n// Initializes owner_thread_id_ and critical_section_ in static mutexes.\nvoid Mutex::ThreadSafeLazyInit() {\n  // Dynamic mutexes are initialized in the constructor.\n  if (type_ == kStatic) {\n    switch (\n        ::InterlockedCompareExchange(&amp;critical_section_init_phase_, 1L, 0L)) {\n      case 0:\n        // If critical_section_init_phase_ was 0 before the exchange, we\n        // are the first to test it and need to perform the initialization.\n        owner_thread_id_ = 0;\n        {\n          // Use RAII to flag that following mem alloc is never deallocated.\n#ifdef _MSC_VER\n          MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n          critical_section_ = new CRITICAL_SECTION;\n        }\n        ::InitializeCriticalSection(critical_section_);\n        // Updates the critical_section_init_phase_ to 2 to signal\n        // initialization complete.\n        GTEST_CHECK_(::InterlockedCompareExchange(&amp;critical_section_init_phase_,\n                                                  2L, 1L) == 1L);\n        break;\n      case 1:\n        // Somebody else is already initializing the mutex; spin until they\n        // are done.\n        while (::InterlockedCompareExchange(&amp;critical_section_init_phase_, 2L,\n                                            2L) != 2L) {\n          // Possibly yields the rest of the thread&#x27;s time slice to other\n          // threads.\n          ::Sleep(0);\n        }\n        break;\n\n      case 2:\n        break;  // The mutex is already initialized and ready for use.\n\n      default:\n        GTEST_CHECK_(false)\n            &lt;&lt; &quot;Unexpected value of critical_section_init_phase_ &quot;\n            &lt;&lt; &quot;while initializing a static mutex.&quot;;\n    }\n  }\n}\n\nnamespace {\n\nclass ThreadWithParamSupport : public ThreadWithParamBase {\n public:\n  static HANDLE CreateThread(Runnable* runnable,\n                             Notification* thread_can_start) {\n    ThreadMainParam* param = new ThreadMainParam(runnable, thread_can_start);\n    DWORD thread_id;\n    HANDLE thread_handle = ::CreateThread(\n        nullptr,  // Default security.\n        0,        // Default stack size.\n        &amp;ThreadWithParamSupport::ThreadMain,\n        param,        // Parameter to ThreadMainStatic\n        0x0,          // Default creation flags.\n        &amp;thread_id);  // Need a valid pointer for the call to work under Win98.\n    GTEST_CHECK_(thread_handle != nullptr)\n        &lt;&lt; &quot;CreateThread failed with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n    if (thread_handle == nullptr) {\n      delete param;\n    }\n    return thread_handle;\n  }\n\n private:\n  struct ThreadMainParam {\n    ThreadMainParam(Runnable* runnable, Notification* thread_can_start)\n        : runnable_(runnable), thread_can_start_(thread_can_start) {}\n    std::unique_ptr&lt;Runnable&gt; runnable_;\n    // Does not own.\n    Notification* thread_can_start_;\n  };\n\n  static DWORD WINAPI ThreadMain(void* ptr) {\n    // Transfers ownership.\n    std::unique_ptr&lt;ThreadMainParam&gt; param(static_cast&lt;ThreadMainParam*&gt;(ptr));\n    if (param-&gt;thread_can_start_ != nullptr)\n      param-&gt;thread_can_start_-&gt;WaitForNotification();\n    param-&gt;runnable_-&gt;Run();\n    return 0;\n  }\n\n  // Prohibit instantiation.\n  ThreadWithParamSupport();\n\n  ThreadWithParamSupport(const ThreadWithParamSupport&amp;) = delete;\n  ThreadWithParamSupport&amp; operator=(const ThreadWithParamSupport&amp;) = delete;\n};\n\n}  // namespace\n\nThreadWithParamBase::ThreadWithParamBase(Runnable* runnable,\n                                         Notification* thread_can_start)\n    : thread_(\n          ThreadWithParamSupport::CreateThread(runnable, thread_can_start)) {}\n\nThreadWithParamBase::~ThreadWithParamBase() { Join(); }\n\nvoid ThreadWithParamBase::Join() {\n  GTEST_CHECK_(::WaitForSingleObject(thread_.Get(), INFINITE) == WAIT_OBJECT_0)\n      &lt;&lt; &quot;Failed to join the thread with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n}\n\n// Maps a thread to a set of ThreadIdToThreadLocals that have values\n// instantiated on that thread and notifies them when the thread exits.  A\n// ThreadLocal instance is expected to persist until all threads it has\n// values on have terminated.\nclass ThreadLocalRegistryImpl {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance) {\n#ifdef _MSC_VER\n    MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n    DWORD current_thread = ::GetCurrentThreadId();\n    MutexLock lock(&amp;mutex_);\n    ThreadIdToThreadLocals* const thread_to_thread_locals =\n        GetThreadLocalsMapLocked();\n    ThreadIdToThreadLocals::iterator thread_local_pos =\n        thread_to_thread_locals-&gt;find(current_thread);\n    if (thread_local_pos == thread_to_thread_locals-&gt;end()) {\n      thread_local_pos =\n          thread_to_thread_locals\n              -&gt;insert(std::make_pair(current_thread, ThreadLocalValues()))\n              .first;\n      StartWatcherThreadFor(current_thread);\n    }\n    ThreadLocalValues&amp; thread_local_values = thread_local_pos-&gt;second;\n    ThreadLocalValues::iterator value_pos =\n        thread_local_values.find(thread_local_instance);\n    if (value_pos == thread_local_values.end()) {\n      value_pos =\n          thread_local_values\n              .insert(std::make_pair(\n                  thread_local_instance,\n                  std::shared_ptr&lt;ThreadLocalValueHolderBase&gt;(\n                      thread_local_instance-&gt;NewValueForCurrentThread())))\n              .first;\n    }\n    return value_pos-&gt;second.get();\n  }\n\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance) {\n    std::vector&lt;std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt; value_holders;\n    // Clean up the ThreadLocalValues data structure while holding the lock, but\n    // defer the destruction of the ThreadLocalValueHolderBases.\n    {\n      MutexLock lock(&amp;mutex_);\n      ThreadIdToThreadLocals* const thread_to_thread_locals =\n          GetThreadLocalsMapLocked();\n      for (ThreadIdToThreadLocals::iterator it =\n               thread_to_thread_locals-&gt;begin();\n           it != thread_to_thread_locals-&gt;end(); ++it) {\n        ThreadLocalValues&amp; thread_local_values = it-&gt;second;\n        ThreadLocalValues::iterator value_pos =\n            thread_local_values.find(thread_local_instance);\n        if (value_pos != thread_local_values.end()) {\n          value_holders.push_back(value_pos-&gt;second);\n          thread_local_values.erase(value_pos);\n          // This &#x27;if&#x27; can only be successful at most once, so theoretically we\n          // could break out of the loop here, but we don&#x27;t bother doing so.\n        }\n      }\n    }\n    // Outside the lock, let the destructor for &#x27;value_holders&#x27; deallocate the\n    // ThreadLocalValueHolderBases.\n  }\n\n  static void OnThreadExit(DWORD thread_id) {\n    GTEST_CHECK_(thread_id != 0) &lt;&lt; ::GetLastError();\n    std::vector&lt;std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt; value_holders;\n    // Clean up the ThreadIdToThreadLocals data structure while holding the\n    // lock, but defer the destruction of the ThreadLocalValueHolderBases.\n    {\n      MutexLock lock(&amp;mutex_);\n      ThreadIdToThreadLocals* const thread_to_thread_locals =\n          GetThreadLocalsMapLocked();\n      ThreadIdToThreadLocals::iterator thread_local_pos =\n          thread_to_thread_locals-&gt;find(thread_id);\n      if (thread_local_pos != thread_to_thread_locals-&gt;end()) {\n        ThreadLocalValues&amp; thread_local_values = thread_local_pos-&gt;second;\n        for (ThreadLocalValues::iterator value_pos =\n                 thread_local_values.begin();\n             value_pos != thread_local_values.end(); ++value_pos) {\n          value_holders.push_back(value_pos-&gt;second);\n        }\n        thread_to_thread_locals-&gt;erase(thread_local_pos);\n      }\n    }\n    // Outside the lock, let the destructor for &#x27;value_holders&#x27; deallocate the\n    // ThreadLocalValueHolderBases.\n  }\n\n private:\n  // In a particular thread, maps a ThreadLocal object to its value.\n  typedef std::map&lt;const ThreadLocalBase*,\n                   std::shared_ptr&lt;ThreadLocalValueHolderBase&gt; &gt;\n      ThreadLocalValues;\n  // Stores all ThreadIdToThreadLocals having values in a thread, indexed by\n  // thread&#x27;s ID.\n  typedef std::map&lt;DWORD, ThreadLocalValues&gt; ThreadIdToThreadLocals;\n\n  struct WatcherThreadParams {\n    DWORD thread_id;\n    HANDLE handle;\n    Notification has_initialized;\n  };\n\n  static void StartWatcherThreadFor(DWORD thread_id) {\n    // The returned handle will be kept in thread_map and closed by\n    // watcher_thread in WatcherThreadFunc.\n    HANDLE thread =\n        ::OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION, FALSE, thread_id);\n    GTEST_CHECK_(thread != nullptr);\n\n    WatcherThreadParams* watcher_thread_params = new WatcherThreadParams;\n    watcher_thread_params-&gt;thread_id = thread_id;\n    watcher_thread_params-&gt;handle = thread;\n\n    // We need to pass a valid thread ID pointer into CreateThread for it\n    // to work correctly under Win98.\n    DWORD watcher_thread_id;\n    HANDLE watcher_thread =\n        ::CreateThread(nullptr,  // Default security.\n                       0,        // Default stack size\n                       &amp;ThreadLocalRegistryImpl::WatcherThreadFunc,\n                       reinterpret_cast&lt;LPVOID&gt;(watcher_thread_params),\n                       CREATE_SUSPENDED, &amp;watcher_thread_id);\n    GTEST_CHECK_(watcher_thread != nullptr)\n        &lt;&lt; &quot;CreateThread failed with error &quot; &lt;&lt; ::GetLastError() &lt;&lt; &quot;.&quot;;\n    // Give the watcher thread the same priority as ours to avoid being\n    // blocked by it.\n    ::SetThreadPriority(watcher_thread,\n                        ::GetThreadPriority(::GetCurrentThread()));\n    ::ResumeThread(watcher_thread);\n    ::CloseHandle(watcher_thread);\n\n    // Wait for the watcher thread to start to avoid race conditions.\n    // One specific race condition that can happen is that we have returned\n    // from main and have started to tear down, the newly spawned watcher\n    // thread may access already-freed variables, like global shared_ptrs.\n    watcher_thread_params-&gt;has_initialized.WaitForNotification();\n  }\n\n  // Monitors exit from a given thread and notifies those\n  // ThreadIdToThreadLocals about thread termination.\n  static DWORD WINAPI WatcherThreadFunc(LPVOID param) {\n    WatcherThreadParams* watcher_thread_params =\n        reinterpret_cast&lt;WatcherThreadParams*&gt;(param);\n    watcher_thread_params-&gt;has_initialized.Notify();\n    GTEST_CHECK_(::WaitForSingleObject(watcher_thread_params-&gt;handle,\n                                       INFINITE) == WAIT_OBJECT_0);\n    OnThreadExit(watcher_thread_params-&gt;thread_id);\n    ::CloseHandle(watcher_thread_params-&gt;handle);\n    delete watcher_thread_params;\n    return 0;\n  }\n\n  // Returns map of thread local instances.\n  static ThreadIdToThreadLocals* GetThreadLocalsMapLocked() {\n    mutex_.AssertHeld();\n#ifdef _MSC_VER\n    MemoryIsNotDeallocated memory_is_not_deallocated;\n#endif  // _MSC_VER\n    static ThreadIdToThreadLocals* map = new ThreadIdToThreadLocals();\n    return map;\n  }\n\n  // Protects access to GetThreadLocalsMapLocked() and its return value.\n  static Mutex mutex_;\n  // Protects access to GetThreadMapLocked() and its return value.\n  static Mutex thread_map_mutex_;\n};\n\nMutex ThreadLocalRegistryImpl::mutex_(Mutex::kStaticMutex);  // NOLINT\nMutex ThreadLocalRegistryImpl::thread_map_mutex_(\n    Mutex::kStaticMutex);  // NOLINT\n\nThreadLocalValueHolderBase* ThreadLocalRegistry::GetValueOnCurrentThread(\n    const ThreadLocalBase* thread_local_instance) {\n  return ThreadLocalRegistryImpl::GetValueOnCurrentThread(\n      thread_local_instance);\n}\n\nvoid ThreadLocalRegistry::OnThreadLocalDestroyed(\n    const ThreadLocalBase* thread_local_instance) {\n  ThreadLocalRegistryImpl::OnThreadLocalDestroyed(thread_local_instance);\n}\n\n#endif  // GTEST_IS_THREADSAFE &amp;&amp; GTEST_OS_WINDOWS\n\n#ifdef GTEST_USES_POSIX_RE\n\n// Implements RE.  Currently only needed for death tests.\n\nRE::~RE() {\n  if (is_valid_) {\n    // regfree&#x27;ing an invalid regex might crash because the content\n    // of the regex is undefined. Since the regex&#x27;s are essentially\n    // the same, one cannot be valid (or invalid) without the other\n    // being so too.\n    regfree(&amp;partial_regex_);\n    regfree(&amp;full_regex_);\n  }\n}\n\n// Returns true if and only if regular expression re matches the entire str.\nbool RE::FullMatch(const char* str, const RE&amp; re) {\n  if (!re.is_valid_) return false;\n\n  regmatch_t match;\n  return regexec(&amp;re.full_regex_, str, 1, &amp;match, 0) == 0;\n}\n\n// Returns true if and only if regular expression re matches a substring of\n// str (including str itself).\nbool RE::PartialMatch(const char* str, const RE&amp; re) {\n  if (!re.is_valid_) return false;\n\n  regmatch_t match;\n  return regexec(&amp;re.partial_regex_, str, 1, &amp;match, 0) == 0;\n}\n\n// Initializes an RE from its string representation.\nvoid RE::Init(const char* regex) {\n  pattern_ = regex;\n\n  // NetBSD (and Android, which takes its regex implemntation from NetBSD) does\n  // not include the GNU regex extensions (such as Perl style character classes\n  // like \\w) in REG_EXTENDED. REG_EXTENDED is only specified to include the\n  // [[:alpha:]] style character classes. Enable REG_GNU wherever it is defined\n  // so users can use those extensions.\n#if defined(REG_GNU)\n  constexpr int reg_flags = REG_EXTENDED | REG_GNU;\n#else\n  constexpr int reg_flags = REG_EXTENDED;\n#endif\n\n  // Reserves enough bytes to hold the regular expression used for a\n  // full match.\n  const size_t full_regex_len = strlen(regex) + 10;\n  char* const full_pattern = new char[full_regex_len];\n\n  snprintf(full_pattern, full_regex_len, &quot;^(%s)$&quot;, regex);\n  is_valid_ = regcomp(&amp;full_regex_, full_pattern, reg_flags) == 0;\n  // We want to call regcomp(&amp;partial_regex_, ...) even if the\n  // previous expression returns false.  Otherwise partial_regex_ may\n  // not be properly initialized can may cause trouble when it&#x27;s\n  // freed.\n  //\n  // Some implementation of POSIX regex (e.g. on at least some\n  // versions of Cygwin) doesn&#x27;t accept the empty string as a valid\n  // regex.  We change it to an equivalent form &quot;()&quot; to be safe.\n  if (is_valid_) {\n    const char* const partial_regex = (*regex == &#x27;\\0&#x27;) ? &quot;()&quot; : regex;\n    is_valid_ = regcomp(&amp;partial_regex_, partial_regex, reg_flags) == 0;\n  }\n  EXPECT_TRUE(is_valid_)\n      &lt;&lt; &quot;Regular expression \\&quot;&quot; &lt;&lt; regex\n      &lt;&lt; &quot;\\&quot; is not a valid POSIX Extended regular expression.&quot;;\n\n  delete[] full_pattern;\n}\n\n#elif defined(GTEST_USES_SIMPLE_RE)\n\n// Returns true if and only if ch appears anywhere in str (excluding the\n// terminating &#x27;\\0&#x27; character).\nbool IsInSet(char ch, const char* str) {\n  return ch != &#x27;\\0&#x27; &amp;&amp; strchr(str, ch) != nullptr;\n}\n\n// Returns true if and only if ch belongs to the given classification.\n// Unlike similar functions in &lt;ctype.h&gt;, these aren&#x27;t affected by the\n// current locale.\nbool IsAsciiDigit(char ch) { return &#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;; }\nbool IsAsciiPunct(char ch) {\n  return IsInSet(ch, &quot;^-!\\&quot;#$%&amp;&#x27;()*+,./:;&lt;=&gt;?@[\\\\]_`{|}~&quot;);\n}\nbool IsRepeat(char ch) { return IsInSet(ch, &quot;?*+&quot;); }\nbool IsAsciiWhiteSpace(char ch) { return IsInSet(ch, &quot; \\f\\n\\r\\t\\v&quot;); }\nbool IsAsciiWordChar(char ch) {\n  return (&#x27;a&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;z&#x27;) || (&#x27;A&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;Z&#x27;) ||\n         (&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;) || ch == &#x27;_&#x27;;\n}\n\n// Returns true if and only if &quot;\\\\c&quot; is a supported escape sequence.\nbool IsValidEscape(char c) {\n  return (IsAsciiPunct(c) || IsInSet(c, &quot;dDfnrsStvwW&quot;));\n}\n\n// Returns true if and only if the given atom (specified by escaped and\n// pattern) matches ch.  The result is undefined if the atom is invalid.\nbool AtomMatchesChar(bool escaped, char pattern_char, char ch) {\n  if (escaped) {  // &quot;\\\\p&quot; where p is pattern_char.\n    switch (pattern_char) {\n      case &#x27;d&#x27;:\n        return IsAsciiDigit(ch);\n      case &#x27;D&#x27;:\n        return !IsAsciiDigit(ch);\n      case &#x27;f&#x27;:\n        return ch == &#x27;\\f&#x27;;\n      case &#x27;n&#x27;:\n        return ch == &#x27;\\n&#x27;;\n      case &#x27;r&#x27;:\n        return ch == &#x27;\\r&#x27;;\n      case &#x27;s&#x27;:\n        return IsAsciiWhiteSpace(ch);\n      case &#x27;S&#x27;:\n        return !IsAsciiWhiteSpace(ch);\n      case &#x27;t&#x27;:\n        return ch == &#x27;\\t&#x27;;\n      case &#x27;v&#x27;:\n        return ch == &#x27;\\v&#x27;;\n      case &#x27;w&#x27;:\n        return IsAsciiWordChar(ch);\n      case &#x27;W&#x27;:\n        return !IsAsciiWordChar(ch);\n    }\n    return IsAsciiPunct(pattern_char) &amp;&amp; pattern_char == ch;\n  }\n\n  return (pattern_char == &#x27;.&#x27; &amp;&amp; ch != &#x27;\\n&#x27;) || pattern_char == ch;\n}\n\n// Helper function used by ValidateRegex() to format error messages.\nstatic std::string FormatRegexSyntaxError(const char* regex, int index) {\n  return (Message() &lt;&lt; &quot;Syntax error at index &quot; &lt;&lt; index\n                    &lt;&lt; &quot; in simple regular expression \\&quot;&quot; &lt;&lt; regex &lt;&lt; &quot;\\&quot;: &quot;)\n      .GetString();\n}\n\n// Generates non-fatal failures and returns false if regex is invalid;\n// otherwise returns true.\nbool ValidateRegex(const char* regex) {\n  if (regex == nullptr) {\n    ADD_FAILURE() &lt;&lt; &quot;NULL is not a valid simple regular expression.&quot;;\n    return false;\n  }\n\n  bool is_valid = true;\n\n  // True if and only if ?, *, or + can follow the previous atom.\n  bool prev_repeatable = false;\n  for (int i = 0; regex[i]; i++) {\n    if (regex[i] == &#x27;\\\\&#x27;) {  // An escape sequence\n      i++;\n      if (regex[i] == &#x27;\\0&#x27;) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)\n                      &lt;&lt; &quot;&#x27;\\\\&#x27; cannot appear at the end.&quot;;\n        return false;\n      }\n\n      if (!IsValidEscape(regex[i])) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i - 1)\n                      &lt;&lt; &quot;invalid escape sequence \\&quot;\\\\&quot; &lt;&lt; regex[i] &lt;&lt; &quot;\\&quot;.&quot;;\n        is_valid = false;\n      }\n      prev_repeatable = true;\n    } else {  // Not an escape sequence.\n      const char ch = regex[i];\n\n      if (ch == &#x27;^&#x27; &amp;&amp; i &gt; 0) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)\n                      &lt;&lt; &quot;&#x27;^&#x27; can only appear at the beginning.&quot;;\n        is_valid = false;\n      } else if (ch == &#x27;$&#x27; &amp;&amp; regex[i + 1] != &#x27;\\0&#x27;) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i)\n                      &lt;&lt; &quot;&#x27;$&#x27; can only appear at the end.&quot;;\n        is_valid = false;\n      } else if (IsInSet(ch, &quot;()[]{}|&quot;)) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i) &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch\n                      &lt;&lt; &quot;&#x27; is unsupported.&quot;;\n        is_valid = false;\n      } else if (IsRepeat(ch) &amp;&amp; !prev_repeatable) {\n        ADD_FAILURE() &lt;&lt; FormatRegexSyntaxError(regex, i) &lt;&lt; &quot;&#x27;&quot; &lt;&lt; ch\n                      &lt;&lt; &quot;&#x27; can only follow a repeatable token.&quot;;\n        is_valid = false;\n      }\n\n      prev_repeatable = !IsInSet(ch, &quot;^$?*+&quot;);\n    }\n  }\n\n  return is_valid;\n}\n\n// Matches a repeated regex atom followed by a valid simple regular\n// expression.  The regex atom is defined as c if escaped is false,\n// or \\c otherwise.  repeat is the repetition meta character (?, *,\n// or +).  The behavior is undefined if str contains too many\n// characters to be indexable by size_t, in which case the test will\n// probably time out anyway.  We are fine with this limitation as\n// std::string has it too.\nbool MatchRepetitionAndRegexAtHead(bool escaped, char c, char repeat,\n                                   const char* regex, const char* str) {\n  const size_t min_count = (repeat == &#x27;+&#x27;) ? 1 : 0;\n  const size_t max_count = (repeat == &#x27;?&#x27;) ? 1 : static_cast&lt;size_t&gt;(-1) - 1;\n  // We cannot call numeric_limits::max() as it conflicts with the\n  // max() macro on Windows.\n\n  for (size_t i = 0; i &lt;= max_count; ++i) {\n    // We know that the atom matches each of the first i characters in str.\n    if (i &gt;= min_count &amp;&amp; MatchRegexAtHead(regex, str + i)) {\n      // We have enough matches at the head, and the tail matches too.\n      // Since we only care about *whether* the pattern matches str\n      // (as opposed to *how* it matches), there is no need to find a\n      // greedy match.\n      return true;\n    }\n    if (str[i] == &#x27;\\0&#x27; || !AtomMatchesChar(escaped, c, str[i])) return false;\n  }\n  return false;\n}\n\n// Returns true if and only if regex matches a prefix of str. regex must\n// be a valid simple regular expression and not start with &quot;^&quot;, or the\n// result is undefined.\nbool MatchRegexAtHead(const char* regex, const char* str) {\n  if (*regex == &#x27;\\0&#x27;)  // An empty regex matches a prefix of anything.\n    return true;\n\n  // &quot;$&quot; only matches the end of a string.  Note that regex being\n  // valid guarantees that there&#x27;s nothing after &quot;$&quot; in it.\n  if (*regex == &#x27;$&#x27;) return *str == &#x27;\\0&#x27;;\n\n  // Is the first thing in regex an escape sequence?\n  const bool escaped = *regex == &#x27;\\\\&#x27;;\n  if (escaped) ++regex;\n  if (IsRepeat(regex[1])) {\n    // MatchRepetitionAndRegexAtHead() calls MatchRegexAtHead(), so\n    // here&#x27;s an indirect recursion.  It terminates as the regex gets\n    // shorter in each recursion.\n    return MatchRepetitionAndRegexAtHead(escaped, regex[0], regex[1], regex + 2,\n                                         str);\n  } else {\n    // regex isn&#x27;t empty, isn&#x27;t &quot;$&quot;, and doesn&#x27;t start with a\n    // repetition.  We match the first atom of regex with the first\n    // character of str and recurse.\n    return (*str != &#x27;\\0&#x27;) &amp;&amp; AtomMatchesChar(escaped, *regex, *str) &amp;&amp;\n           MatchRegexAtHead(regex + 1, str + 1);\n  }\n}\n\n// Returns true if and only if regex matches any substring of str.  regex must\n// be a valid simple regular expression, or the result is undefined.\n//\n// The algorithm is recursive, but the recursion depth doesn&#x27;t exceed\n// the regex length, so we won&#x27;t need to worry about running out of\n// stack space normally.  In rare cases the time complexity can be\n// exponential with respect to the regex length + the string length,\n// but usually it&#x27;s must faster (often close to linear).\nbool MatchRegexAnywhere(const char* regex, const char* str) {\n  if (regex == nullptr || str == nullptr) return false;\n\n  if (*regex == &#x27;^&#x27;) return MatchRegexAtHead(regex + 1, str);\n\n  // A successful match can be anywhere in str.\n  do {\n    if (MatchRegexAtHead(regex, str)) return true;\n  } while (*str++ != &#x27;\\0&#x27;);\n  return false;\n}\n\n// Implements the RE class.\n\nRE::~RE() = default;\n\n// Returns true if and only if regular expression re matches the entire str.\nbool RE::FullMatch(const char* str, const RE&amp; re) {\n  return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.full_pattern_.c_str(), str);\n}\n\n// Returns true if and only if regular expression re matches a substring of\n// str (including str itself).\nbool RE::PartialMatch(const char* str, const RE&amp; re) {\n  return re.is_valid_ &amp;&amp; MatchRegexAnywhere(re.pattern_.c_str(), str);\n}\n\n// Initializes an RE from its string representation.\nvoid RE::Init(const char* regex) {\n  full_pattern_.clear();\n  pattern_.clear();\n\n  if (regex != nullptr) {\n    pattern_ = regex;\n  }\n\n  is_valid_ = ValidateRegex(regex);\n  if (!is_valid_) {\n    // No need to calculate the full pattern when the regex is invalid.\n    return;\n  }\n\n  // Reserves enough bytes to hold the regular expression used for a\n  // full match: we need space to prepend a &#x27;^&#x27; and append a &#x27;$&#x27;.\n  full_pattern_.reserve(pattern_.size() + 2);\n\n  if (pattern_.empty() || pattern_.front() != &#x27;^&#x27;) {\n    full_pattern_.push_back(&#x27;^&#x27;);  // Makes sure full_pattern_ starts with &#x27;^&#x27;.\n  }\n\n  full_pattern_.append(pattern_);\n\n  if (pattern_.empty() || pattern_.back() != &#x27;$&#x27;) {\n    full_pattern_.push_back(&#x27;$&#x27;);  // Makes sure full_pattern_ ends with &#x27;$&#x27;.\n  }\n}\n\n#endif  // GTEST_USES_POSIX_RE\n\nconst char kUnknownFile[] = &quot;unknown file&quot;;\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line) {\n  const std::string file_name(file == nullptr ? kUnknownFile : file);\n\n  if (line &lt; 0) {\n    return file_name + &quot;:&quot;;\n  }\n#ifdef _MSC_VER\n  return file_name + &quot;(&quot; + StreamableToString(line) + &quot;):&quot;;\n#else\n  return file_name + &quot;:&quot; + StreamableToString(line) + &quot;:&quot;;\n#endif  // _MSC_VER\n}\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\n// Note that FormatCompilerIndependentFileLocation() does NOT append colon\n// to the file location it produces, unlike FormatFileLocation().\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line) {\n  const std::string file_name(file == nullptr ? kUnknownFile : file);\n\n  if (line &lt; 0)\n    return file_name;\n  else\n    return file_name + &quot;:&quot; + StreamableToString(line);\n}\n\nGTestLog::GTestLog(GTestLogSeverity severity, const char* file, int line)\n    : severity_(severity) {\n  const char* const marker = severity == GTEST_INFO      ? &quot;[  INFO ]&quot;\n                             : severity == GTEST_WARNING ? &quot;[WARNING]&quot;\n                             : severity == GTEST_ERROR   ? &quot;[ ERROR ]&quot;\n                                                         : &quot;[ FATAL ]&quot;;\n  GetStream() &lt;&lt; ::std::endl\n              &lt;&lt; marker &lt;&lt; &quot; &quot; &lt;&lt; FormatFileLocation(file, line).c_str()\n              &lt;&lt; &quot;: &quot;;\n}\n\n// Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\nGTestLog::~GTestLog() {\n  GetStream() &lt;&lt; ::std::endl;\n  if (severity_ == GTEST_FATAL) {\n    fflush(stderr);\n    posix::Abort();\n  }\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Disable Microsoft deprecation warnings for POSIX functions called from\n// this class (creat, dup, dup2, and close)\nGTEST_DISABLE_MSC_DEPRECATED_PUSH_()\n\nnamespace {\n\n#if defined(GTEST_OS_LINUX_ANDROID) || defined(GTEST_OS_IOS)\nbool EndsWithPathSeparator(const std::string&amp; path) {\n  return !path.empty() &amp;&amp; path.back() == GTEST_PATH_SEP_[0];\n}\n#endif\n\n}  // namespace\n\n// Object that captures an output stream (stdout/stderr).\nclass CapturedStream {\n public:\n  // The ctor redirects the stream to a temporary file.\n  explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {\n#ifdef GTEST_OS_WINDOWS\n    char temp_dir_path[MAX_PATH + 1] = {&#x27;\\0&#x27;};   // NOLINT\n    char temp_file_path[MAX_PATH + 1] = {&#x27;\\0&#x27;};  // NOLINT\n\n    ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);\n    const UINT success = ::GetTempFileNameA(temp_dir_path, &quot;gtest_redir&quot;,\n                                            0,  // Generate unique file name.\n                                            temp_file_path);\n    GTEST_CHECK_(success != 0)\n        &lt;&lt; &quot;Unable to create a temporary file in &quot; &lt;&lt; temp_dir_path;\n    const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);\n    GTEST_CHECK_(captured_fd != -1)\n        &lt;&lt; &quot;Unable to open temporary file &quot; &lt;&lt; temp_file_path;\n    filename_ = temp_file_path;\n#else\n    // There&#x27;s no guarantee that a test has write access to the current\n    // directory, so we create the temporary file in a temporary directory.\n    std::string name_template;\n\n#ifdef GTEST_OS_LINUX_ANDROID\n    // Note: Android applications are expected to call the framework&#x27;s\n    // Context.getExternalStorageDirectory() method through JNI to get\n    // the location of the world-writable SD Card directory. However,\n    // this requires a Context handle, which cannot be retrieved\n    // globally from native code. Doing so also precludes running the\n    // code as part of a regular standalone executable, which doesn&#x27;t\n    // run in a Dalvik process (e.g. when running it through &#x27;adb shell&#x27;).\n    //\n    // The location /data/local/tmp is directly accessible from native code.\n    // &#x27;/sdcard&#x27; and other variants cannot be relied on, as they are not\n    // guaranteed to be mounted, or may have a delay in mounting.\n    //\n    // However, prefer using the TMPDIR environment variable if set, as newer\n    // devices may have /data/local/tmp read-only.\n    name_template = TempDir();\n    if (!EndsWithPathSeparator(name_template))\n      name_template.push_back(GTEST_PATH_SEP_[0]);\n\n#elif defined(GTEST_OS_IOS)\n    char user_temp_dir[PATH_MAX + 1];\n\n    // Documented alternative to NSTemporaryDirectory() (for obtaining creating\n    // a temporary directory) at\n    // https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW10\n    //\n    // _CS_DARWIN_USER_TEMP_DIR (as well as _CS_DARWIN_USER_CACHE_DIR) is not\n    // documented in the confstr() man page at\n    // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/confstr.3.html#//apple_ref/doc/man/3/confstr\n    // but are still available, according to the WebKit patches at\n    // https://trac.webkit.org/changeset/262004/webkit\n    // https://trac.webkit.org/changeset/263705/webkit\n    //\n    // The confstr() implementation falls back to getenv(&quot;TMPDIR&quot;). See\n    // https://opensource.apple.com/source/Libc/Libc-1439.100.3/gen/confstr.c.auto.html\n    ::confstr(_CS_DARWIN_USER_TEMP_DIR, user_temp_dir, sizeof(user_temp_dir));\n\n    name_template = user_temp_dir;\n    if (!EndsWithPathSeparator(name_template))\n      name_template.push_back(GTEST_PATH_SEP_[0]);\n#else\n    name_template = &quot;/tmp/&quot;;\n#endif\n    name_template.append(&quot;gtest_captured_stream.XXXXXX&quot;);\n\n    // mkstemp() modifies the string bytes in place, and does not go beyond the\n    // string&#x27;s length. This results in well-defined behavior in C++17.\n    //\n    // The const_cast is needed below C++17. The constraints on std::string\n    // implementations in C++11 and above make assumption behind the const_cast\n    // fairly safe.\n    const int captured_fd = ::mkstemp(const_cast&lt;char*&gt;(name_template.data()));\n    if (captured_fd == -1) {\n      GTEST_LOG_(WARNING)\n          &lt;&lt; &quot;Failed to create tmp file &quot; &lt;&lt; name_template\n          &lt;&lt; &quot; for test; does the test have access to the /tmp directory?&quot;;\n    }\n    filename_ = std::move(name_template);\n#endif  // GTEST_OS_WINDOWS\n    fflush(nullptr);\n    dup2(captured_fd, fd_);\n    close(captured_fd);\n  }\n\n  ~CapturedStream() { remove(filename_.c_str()); }\n\n  std::string GetCapturedString() {\n    if (uncaptured_fd_ != -1) {\n      // Restores the original stream.\n      fflush(nullptr);\n      dup2(uncaptured_fd_, fd_);\n      close(uncaptured_fd_);\n      uncaptured_fd_ = -1;\n    }\n\n    FILE* const file = posix::FOpen(filename_.c_str(), &quot;r&quot;);\n    if (file == nullptr) {\n      GTEST_LOG_(FATAL) &lt;&lt; &quot;Failed to open tmp file &quot; &lt;&lt; filename_\n                        &lt;&lt; &quot; for capturing stream.&quot;;\n    }\n    const std::string content = ReadEntireFile(file);\n    posix::FClose(file);\n    return content;\n  }\n\n private:\n  const int fd_;  // A stream to capture.\n  int uncaptured_fd_;\n  // Name of the temporary file holding the stderr output.\n  ::std::string filename_;\n\n  CapturedStream(const CapturedStream&amp;) = delete;\n  CapturedStream&amp; operator=(const CapturedStream&amp;) = delete;\n};\n\nGTEST_DISABLE_MSC_DEPRECATED_POP_()\n\nstatic CapturedStream* g_captured_stderr = nullptr;\nstatic CapturedStream* g_captured_stdout = nullptr;\n\n// Starts capturing an output stream (stdout/stderr).\nstatic void CaptureStream(int fd, const char* stream_name,\n                          CapturedStream** stream) {\n  if (*stream != nullptr) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Only one &quot; &lt;&lt; stream_name\n                      &lt;&lt; &quot; capturer can exist at a time.&quot;;\n  }\n  *stream = new CapturedStream(fd);\n}\n\n// Stops capturing the output stream and returns the captured string.\nstatic std::string GetCapturedStream(CapturedStream** captured_stream) {\n  const std::string content = (*captured_stream)-&gt;GetCapturedString();\n\n  delete *captured_stream;\n  *captured_stream = nullptr;\n\n  return content;\n}\n\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC and C++Builder do not provide a definition of STDERR_FILENO.\nconst int kStdOutFileno = 1;\nconst int kStdErrFileno = 2;\n#else\nconst int kStdOutFileno = STDOUT_FILENO;\nconst int kStdErrFileno = STDERR_FILENO;\n#endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n\n// Starts capturing stdout.\nvoid CaptureStdout() {\n  CaptureStream(kStdOutFileno, &quot;stdout&quot;, &amp;g_captured_stdout);\n}\n\n// Starts capturing stderr.\nvoid CaptureStderr() {\n  CaptureStream(kStdErrFileno, &quot;stderr&quot;, &amp;g_captured_stderr);\n}\n\n// Stops capturing stdout and returns the captured string.\nstd::string GetCapturedStdout() {\n  return GetCapturedStream(&amp;g_captured_stdout);\n}\n\n// Stops capturing stderr and returns the captured string.\nstd::string GetCapturedStderr() {\n  return GetCapturedStream(&amp;g_captured_stderr);\n}\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\nsize_t GetFileSize(FILE* file) {\n  fseek(file, 0, SEEK_END);\n  return static_cast&lt;size_t&gt;(ftell(file));\n}\n\nstd::string ReadEntireFile(FILE* file) {\n  const size_t file_size = GetFileSize(file);\n  char* const buffer = new char[file_size];\n\n  size_t bytes_last_read = 0;  // # of bytes read in the last fread()\n  size_t bytes_read = 0;       // # of bytes read so far\n\n  fseek(file, 0, SEEK_SET);\n\n  // Keeps reading the file until we cannot read further or the\n  // pre-determined file size is reached.\n  do {\n    bytes_last_read =\n        fread(buffer + bytes_read, 1, file_size - bytes_read, file);\n    bytes_read += bytes_last_read;\n  } while (bytes_last_read &gt; 0 &amp;&amp; bytes_read &lt; file_size);\n\n  const std::string content(buffer, bytes_read);\n  delete[] buffer;\n\n  return content;\n}\n\n#ifdef GTEST_HAS_DEATH_TEST\nstatic const std::vector&lt;std::string&gt;* g_injected_test_argvs =\n    nullptr;  // Owned.\n\nstd::vector&lt;std::string&gt; GetInjectableArgvs() {\n  if (g_injected_test_argvs != nullptr) {\n    return *g_injected_test_argvs;\n  }\n  return GetArgvs();\n}\n\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;* new_argvs) {\n  if (g_injected_test_argvs != new_argvs) delete g_injected_test_argvs;\n  g_injected_test_argvs = new_argvs;\n}\n\nvoid SetInjectableArgvs(const std::vector&lt;std::string&gt;&amp; new_argvs) {\n  SetInjectableArgvs(\n      new std::vector&lt;std::string&gt;(new_argvs.begin(), new_argvs.end()));\n}\n\nvoid ClearInjectableArgvs() {\n  delete g_injected_test_argvs;\n  g_injected_test_argvs = nullptr;\n}\n#endif  // GTEST_HAS_DEATH_TEST\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\nnamespace posix {\nvoid Abort() {\n  DebugBreak();\n  TerminateProcess(GetCurrentProcess(), 1);\n}\n}  // namespace posix\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n// Returns the name of the environment variable corresponding to the\n// given flag.  For example, FlagToEnvVar(&quot;foo&quot;) will return\n// &quot;GTEST_FOO&quot; in the open-source version.\nstatic std::string FlagToEnvVar(const char* flag) {\n  const std::string full_flag =\n      (Message() &lt;&lt; GTEST_FLAG_PREFIX_ &lt;&lt; flag).GetString();\n\n  Message env_var;\n  for (size_t i = 0; i != full_flag.length(); i++) {\n    env_var &lt;&lt; ToUpper(full_flag.c_str()[i]);\n  }\n\n  return env_var.GetString();\n}\n\n// Parses &#x27;str&#x27; for a 32-bit signed integer.  If successful, writes\n// the result to *value and returns true; otherwise leaves *value\n// unchanged and returns false.\nbool ParseInt32(const Message&amp; src_text, const char* str, int32_t* value) {\n  // Parses the environment variable as a decimal integer.\n  char* end = nullptr;\n  const long long_value = strtol(str, &amp;end, 10);  // NOLINT\n\n  // Has strtol() consumed all characters in the string?\n  if (*end != &#x27;\\0&#x27;) {\n    // No - an invalid character was encountered.\n    Message msg;\n    msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text\n        &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot;\n        &lt;&lt; &quot; has value \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;.\\n&quot;;\n    printf(&quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    return false;\n  }\n\n  // Is the parsed value in the range of an int32_t?\n  const auto result = static_cast&lt;int32_t&gt;(long_value);\n  if (long_value == LONG_MAX || long_value == LONG_MIN ||\n      // The parsed value overflows as a long.  (strtol() returns\n      // LONG_MAX or LONG_MIN when the input overflows.)\n      result != long_value\n      // The parsed value overflows as an int32_t.\n  ) {\n    Message msg;\n    msg &lt;&lt; &quot;WARNING: &quot; &lt;&lt; src_text\n        &lt;&lt; &quot; is expected to be a 32-bit integer, but actually&quot; &lt;&lt; &quot; has value &quot;\n        &lt;&lt; str &lt;&lt; &quot;, which overflows.\\n&quot;;\n    printf(&quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    return false;\n  }\n\n  *value = result;\n  return true;\n}\n\n// Reads and returns the Boolean environment variable corresponding to\n// the given flag; if it&#x27;s not set, returns default_value.\n//\n// The value is considered true if and only if it&#x27;s not &quot;0&quot;.\nbool BoolFromGTestEnv(const char* flag, bool default_value) {\n#if defined(GTEST_GET_BOOL_FROM_ENV_)\n  return GTEST_GET_BOOL_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const string_value = posix::GetEnv(env_var.c_str());\n  return string_value == nullptr ? default_value\n                                 : strcmp(string_value, &quot;0&quot;) != 0;\n#endif  // defined(GTEST_GET_BOOL_FROM_ENV_)\n}\n\n// Reads and returns a 32-bit integer stored in the environment\n// variable corresponding to the given flag; if it isn&#x27;t set or\n// doesn&#x27;t represent a valid 32-bit integer, returns default_value.\nint32_t Int32FromGTestEnv(const char* flag, int32_t default_value) {\n#if defined(GTEST_GET_INT32_FROM_ENV_)\n  return GTEST_GET_INT32_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const string_value = posix::GetEnv(env_var.c_str());\n  if (string_value == nullptr) {\n    // The environment variable is not set.\n    return default_value;\n  }\n\n  int32_t result = default_value;\n  if (!ParseInt32(Message() &lt;&lt; &quot;Environment variable &quot; &lt;&lt; env_var, string_value,\n                  &amp;result)) {\n    printf(&quot;The default value %s is used.\\n&quot;,\n           (Message() &lt;&lt; default_value).GetString().c_str());\n    fflush(stdout);\n    return default_value;\n  }\n\n  return result;\n#endif  // defined(GTEST_GET_INT32_FROM_ENV_)\n}\n\n// As a special case for the &#x27;output&#x27; flag, if GTEST_OUTPUT is not\n// set, we look for XML_OUTPUT_FILE, which is set by the Bazel build\n// system.  The value of XML_OUTPUT_FILE is a filename without the\n// &quot;xml:&quot; prefix of GTEST_OUTPUT.\n// Note that this is meant to be called at the call site so it does\n// not check that the flag is &#x27;output&#x27;\n// In essence this checks an env variable called XML_OUTPUT_FILE\n// and if it is set we prepend &quot;xml:&quot; to its value, if it not set we return &quot;&quot;\nstd::string OutputFlagAlsoCheckEnvVar() {\n  std::string default_value_for_output_flag = &quot;&quot;;\n  const char* xml_output_file_env = posix::GetEnv(&quot;XML_OUTPUT_FILE&quot;);\n  if (nullptr != xml_output_file_env) {\n    default_value_for_output_flag = std::string(&quot;xml:&quot;) + xml_output_file_env;\n  }\n  return default_value_for_output_flag;\n}\n\n// Reads and returns the string environment variable corresponding to\n// the given flag; if it&#x27;s not set, returns default_value.\nconst char* StringFromGTestEnv(const char* flag, const char* default_value) {\n#if defined(GTEST_GET_STRING_FROM_ENV_)\n  return GTEST_GET_STRING_FROM_ENV_(flag, default_value);\n#else\n  const std::string env_var = FlagToEnvVar(flag);\n  const char* const value = posix::GetEnv(env_var.c_str());\n  return value == nullptr ? default_value : value;\n#endif  // defined(GTEST_GET_STRING_FROM_ENV_)\n}\n\n}  // namespace internal\n}  // namespace testing\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include &quot;gtest/gtest-typed-test.h&quot;\n\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest.h&quot;\n\nnamespace testing {\nnamespace internal {\n\n// Skips to the first non-space char in str. Returns an empty string if str\n// contains only whitespace characters.\nstatic const char* SkipSpaces(const char* str) {\n  while (IsSpace(*str)) str++;\n  return str;\n}\n\nstatic std::vector&lt;std::string&gt; SplitIntoTestNames(const char* src) {\n  std::vector&lt;std::string&gt; name_vec;\n  src = SkipSpaces(src);\n  for (; src != nullptr; src = SkipComma(src)) {\n    name_vec.push_back(StripTrailingSpaces(GetPrefixUntilComma(src)));\n  }\n  return name_vec;\n}\n\n// Verifies that registered_tests match the test names in\n// registered_tests_; returns registered_tests if successful, or\n// aborts the program otherwise.\nconst char* TypedTestSuitePState::VerifyRegisteredTestNames(\n    const char* test_suite_name, const char* file, int line,\n    const char* registered_tests) {\n  RegisterTypeParameterizedTestSuite(test_suite_name, CodeLocation(file, line));\n\n  typedef RegisteredTestsMap::const_iterator RegisteredTestIter;\n  registered_ = true;\n\n  std::vector&lt;std::string&gt; name_vec = SplitIntoTestNames(registered_tests);\n\n  Message errors;\n\n  std::set&lt;std::string&gt; tests;\n  for (std::vector&lt;std::string&gt;::const_iterator name_it = name_vec.begin();\n       name_it != name_vec.end(); ++name_it) {\n    const std::string&amp; name = *name_it;\n    if (tests.count(name) != 0) {\n      errors &lt;&lt; &quot;Test &quot; &lt;&lt; name &lt;&lt; &quot; is listed more than once.\\n&quot;;\n      continue;\n    }\n\n    if (registered_tests_.count(name) != 0) {\n      tests.insert(name);\n    } else {\n      errors &lt;&lt; &quot;No test named &quot; &lt;&lt; name\n             &lt;&lt; &quot; can be found in this test suite.\\n&quot;;\n    }\n  }\n\n  for (RegisteredTestIter it = registered_tests_.begin();\n       it != registered_tests_.end(); ++it) {\n    if (tests.count(it-&gt;first) == 0) {\n      errors &lt;&lt; &quot;You forgot to list test &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;.\\n&quot;;\n    }\n  }\n\n  const std::string&amp; errors_str = errors.GetString();\n  if (!errors_str.empty()) {\n    fprintf(stderr, &quot;%s %s&quot;, FormatFileLocation(file, line).c_str(),\n            errors_str.c_str());\n    fflush(stderr);\n    posix::Abort();\n  }\n\n  return registered_tests;\n}\n\n}  // namespace internal\n}  // namespace testing\n"}, "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc": {"id": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "filePath": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n//\n// The Google C++ Testing and Mocking Framework (Google Test)\n\n#include &quot;gtest/gtest.h&quot;\n\n#include &lt;ctype.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;wchar.h&gt;\n#include &lt;wctype.h&gt;\n\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;  // NOLINT\n#include &lt;cmath&gt;\n#include &lt;csignal&gt;  // NOLINT: raise(3) is used on some platforms\n#include &lt;cstdint&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iomanip&gt;\n#include &lt;ios&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;limits&gt;\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;ostream&gt;  // NOLINT\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &quot;gtest/gtest-assertion-result.h&quot;\n#include &quot;gtest/gtest-spi.h&quot;\n#include &quot;gtest/internal/custom/gtest.h&quot;\n#include &quot;gtest/internal/gtest-port.h&quot;\n\n#ifdef GTEST_OS_LINUX\n\n#include &lt;fcntl.h&gt;   // NOLINT\n#include &lt;limits.h&gt;  // NOLINT\n#include &lt;sched.h&gt;   // NOLINT\n// Declares vsnprintf().  This header is not available on Windows.\n#include &lt;strings.h&gt;   // NOLINT\n#include &lt;sys/mman.h&gt;  // NOLINT\n#include &lt;sys/time.h&gt;  // NOLINT\n#include &lt;unistd.h&gt;    // NOLINT\n\n#include &lt;string&gt;\n\n#elif defined(GTEST_OS_ZOS)\n#include &lt;sys/time.h&gt;  // NOLINT\n\n// On z/OS we additionally need strings.h for strcasecmp.\n#include &lt;strings.h&gt;   // NOLINT\n\n#elif defined(GTEST_OS_WINDOWS_MOBILE)  // We are on Windows CE.\n\n#include &lt;windows.h&gt;  // NOLINT\n#undef min\n\n#elif defined(GTEST_OS_WINDOWS)  // We are on Windows proper.\n\n#include &lt;windows.h&gt;  // NOLINT\n#undef min\n\n#ifdef _MSC_VER\n#include &lt;crtdbg.h&gt;  // NOLINT\n#endif\n\n#include &lt;io.h&gt;         // NOLINT\n#include &lt;sys/stat.h&gt;   // NOLINT\n#include &lt;sys/timeb.h&gt;  // NOLINT\n#include &lt;sys/types.h&gt;  // NOLINT\n\n#ifdef GTEST_OS_WINDOWS_MINGW\n#include &lt;sys/time.h&gt;  // NOLINT\n#endif                 // GTEST_OS_WINDOWS_MINGW\n\n#else\n\n// cpplint thinks that the header is already included, so we want to\n// silence it.\n#include &lt;sys/time.h&gt;  // NOLINT\n#include &lt;unistd.h&gt;    // NOLINT\n\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n#include &lt;stdexcept&gt;\n#endif\n\n#if GTEST_CAN_STREAM_RESULTS_\n#include &lt;arpa/inet.h&gt;   // NOLINT\n#include &lt;netdb.h&gt;       // NOLINT\n#include &lt;sys/socket.h&gt;  // NOLINT\n#include &lt;sys/types.h&gt;   // NOLINT\n#endif\n\n#include &quot;src/gtest-internal-inl.h&quot;\n\n#ifdef GTEST_OS_WINDOWS\n#define vsnprintf _vsnprintf\n#endif  // GTEST_OS_WINDOWS\n\n#ifdef GTEST_OS_MAC\n#ifndef GTEST_OS_IOS\n#include &lt;crt_externs.h&gt;\n#endif\n#endif\n\n#ifdef GTEST_HAS_ABSL\n#include &quot;absl/container/flat_hash_set.h&quot;\n#include &quot;absl/debugging/failure_signal_handler.h&quot;\n#include &quot;absl/debugging/stacktrace.h&quot;\n#include &quot;absl/debugging/symbolize.h&quot;\n#include &quot;absl/flags/parse.h&quot;\n#include &quot;absl/flags/usage.h&quot;\n#include &quot;absl/strings/str_cat.h&quot;\n#include &quot;absl/strings/str_replace.h&quot;\n#include &quot;absl/strings/string_view.h&quot;\n#include &quot;absl/strings/strip.h&quot;\n#endif  // GTEST_HAS_ABSL\n\n// Checks builtin compiler feature |x| while avoiding an extra layer of #ifdefs\n// at the callsite.\n#if defined(__has_builtin)\n#define GTEST_HAS_BUILTIN(x) __has_builtin(x)\n#else\n#define GTEST_HAS_BUILTIN(x) 0\n#endif  // defined(__has_builtin)\n\n#if defined(GTEST_HAS_ABSL) &amp;&amp; !defined(GTEST_NO_ABSL_FLAGS)\n#define GTEST_HAS_ABSL_FLAGS\n#endif\n\nnamespace testing {\n\nusing internal::CountIf;\nusing internal::ForEach;\nusing internal::GetElementOr;\nusing internal::Shuffle;\n\n// Constants.\n\n// A test whose test suite name or test name matches this filter is\n// disabled and not run.\nstatic const char kDisableTestFilter[] = &quot;DISABLED_*:*/DISABLED_*&quot;;\n\n// A test suite whose name matches this filter is considered a death\n// test suite and will be run before test suites whose name doesn&#x27;t\n// match this filter.\nstatic const char kDeathTestSuiteFilter[] = &quot;*DeathTest:*DeathTest/*&quot;;\n\n// A test filter that matches everything.\nstatic const char kUniversalFilter[] = &quot;*&quot;;\n\n// The default output format.\nstatic const char kDefaultOutputFormat[] = &quot;xml&quot;;\n// The default output file.\nstatic const char kDefaultOutputFile[] = &quot;test_detail&quot;;\n\n// The environment variable name for the test shard index.\nstatic const char kTestShardIndex[] = &quot;GTEST_SHARD_INDEX&quot;;\n// The environment variable name for the total number of test shards.\nstatic const char kTestTotalShards[] = &quot;GTEST_TOTAL_SHARDS&quot;;\n// The environment variable name for the test shard status file.\nstatic const char kTestShardStatusFile[] = &quot;GTEST_SHARD_STATUS_FILE&quot;;\n\nnamespace internal {\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nconst char kStackTraceMarker[] = &quot;\\nStack trace:\\n&quot;;\n\n// g_help_flag is true if and only if the --help flag or an equivalent form\n// is specified on the command line.\nbool g_help_flag = false;\n\n#if GTEST_HAS_FILE_SYSTEM\n// Utility function to Open File for Writing\nstatic FILE* OpenFileForWriting(const std::string&amp; output_file) {\n  FILE* fileout = nullptr;\n  FilePath output_file_path(output_file);\n  FilePath output_dir(output_file_path.RemoveFileName());\n\n  if (output_dir.CreateDirectoriesRecursively()) {\n    fileout = posix::FOpen(output_file.c_str(), &quot;w&quot;);\n  }\n  if (fileout == nullptr) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Unable to open file \\&quot;&quot; &lt;&lt; output_file &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return fileout;\n}\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n}  // namespace internal\n\n// Bazel passes in the argument to &#x27;--test_filter&#x27; via the TESTBRIDGE_TEST_ONLY\n// environment variable.\nstatic const char* GetDefaultFilter() {\n  const char* const testbridge_test_only =\n      internal::posix::GetEnv(&quot;TESTBRIDGE_TEST_ONLY&quot;);\n  if (testbridge_test_only != nullptr) {\n    return testbridge_test_only;\n  }\n  return kUniversalFilter;\n}\n\n// Bazel passes in the argument to &#x27;--test_runner_fail_fast&#x27; via the\n// TESTBRIDGE_TEST_RUNNER_FAIL_FAST environment variable.\nstatic bool GetDefaultFailFast() {\n  const char* const testbridge_test_runner_fail_fast =\n      internal::posix::GetEnv(&quot;TESTBRIDGE_TEST_RUNNER_FAIL_FAST&quot;);\n  if (testbridge_test_runner_fail_fast != nullptr) {\n    return strcmp(testbridge_test_runner_fail_fast, &quot;1&quot;) == 0;\n  }\n  return false;\n}\n\n}  // namespace testing\n\nGTEST_DEFINE_bool_(\n    fail_fast,\n    testing::internal::BoolFromGTestEnv(&quot;fail_fast&quot;,\n                                        testing::GetDefaultFailFast()),\n    &quot;True if and only if a test failure should stop further test execution.&quot;);\n\nGTEST_DEFINE_bool_(\n    also_run_disabled_tests,\n    testing::internal::BoolFromGTestEnv(&quot;also_run_disabled_tests&quot;, false),\n    &quot;Run disabled tests too, in addition to the tests normally being run.&quot;);\n\nGTEST_DEFINE_bool_(\n    break_on_failure,\n    testing::internal::BoolFromGTestEnv(&quot;break_on_failure&quot;, false),\n    &quot;True if and only if a failed assertion should be a debugger &quot;\n    &quot;break-point.&quot;);\n\nGTEST_DEFINE_bool_(catch_exceptions,\n                   testing::internal::BoolFromGTestEnv(&quot;catch_exceptions&quot;,\n                                                       true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should catch exceptions and treat them as test failures.&quot;);\n\nGTEST_DEFINE_string_(\n    color, testing::internal::StringFromGTestEnv(&quot;color&quot;, &quot;auto&quot;),\n    &quot;Whether to use colors in the output.  Valid values: yes, no, &quot;\n    &quot;and auto.  &#x27;auto&#x27; means to use colors if the output is &quot;\n    &quot;being sent to a terminal and the TERM environment variable &quot;\n    &quot;is set to a terminal type that supports colors.&quot;);\n\nGTEST_DEFINE_string_(\n    filter,\n    testing::internal::StringFromGTestEnv(&quot;filter&quot;,\n                                          testing::GetDefaultFilter()),\n    &quot;A colon-separated list of glob (not regex) patterns &quot;\n    &quot;for filtering the tests to run, optionally followed by a &quot;\n    &quot;&#x27;-&#x27; and a : separated list of negative patterns (tests to &quot;\n    &quot;exclude).  A test is run if it matches one of the positive &quot;\n    &quot;patterns and does not match any of the negative patterns.&quot;);\n\nGTEST_DEFINE_bool_(\n    install_failure_signal_handler,\n    testing::internal::BoolFromGTestEnv(&quot;install_failure_signal_handler&quot;,\n                                        false),\n    &quot;If true and supported on the current platform, &quot; GTEST_NAME_\n    &quot; should &quot;\n    &quot;install a signal handler that dumps debugging information when fatal &quot;\n    &quot;signals are raised.&quot;);\n\nGTEST_DEFINE_bool_(list_tests, false, &quot;List all tests without running them.&quot;);\n\n// The net priority order after flag processing is thus:\n//   --gtest_output command line flag\n//   GTEST_OUTPUT environment variable\n//   XML_OUTPUT_FILE environment variable\n//   &#x27;&#x27;\nGTEST_DEFINE_string_(\n    output,\n    testing::internal::StringFromGTestEnv(\n        &quot;output&quot;, testing::internal::OutputFlagAlsoCheckEnvVar().c_str()),\n    &quot;A format (defaults to \\&quot;xml\\&quot; but can be specified to be \\&quot;json\\&quot;), &quot;\n    &quot;optionally followed by a colon and an output file name or directory. &quot;\n    &quot;A directory is indicated by a trailing pathname separator. &quot;\n    &quot;Examples: \\&quot;xml:filename.xml\\&quot;, \\&quot;xml::directoryname/\\&quot;. &quot;\n    &quot;If a directory is specified, output files will be created &quot;\n    &quot;within that directory, with file-names based on the test &quot;\n    &quot;executable&#x27;s name and, if necessary, made unique by adding &quot;\n    &quot;digits.&quot;);\n\nGTEST_DEFINE_bool_(\n    brief, testing::internal::BoolFromGTestEnv(&quot;brief&quot;, false),\n    &quot;True if only test failures should be displayed in text output.&quot;);\n\nGTEST_DEFINE_bool_(print_time,\n                   testing::internal::BoolFromGTestEnv(&quot;print_time&quot;, true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should display elapsed time in text output.&quot;);\n\nGTEST_DEFINE_bool_(print_utf8,\n                   testing::internal::BoolFromGTestEnv(&quot;print_utf8&quot;, true),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; prints UTF8 characters as text.&quot;);\n\nGTEST_DEFINE_int32_(\n    random_seed, testing::internal::Int32FromGTestEnv(&quot;random_seed&quot;, 0),\n    &quot;Random number seed to use when shuffling test orders.  Must be in range &quot;\n    &quot;[1, 99999], or 0 to use a seed based on the current time.&quot;);\n\nGTEST_DEFINE_int32_(\n    repeat, testing::internal::Int32FromGTestEnv(&quot;repeat&quot;, 1),\n    &quot;How many times to repeat each test.  Specify a negative number &quot;\n    &quot;for repeating forever.  Useful for shaking out flaky tests.&quot;);\n\nGTEST_DEFINE_bool_(\n    recreate_environments_when_repeating,\n    testing::internal::BoolFromGTestEnv(&quot;recreate_environments_when_repeating&quot;,\n                                        false),\n    &quot;Controls whether global test environments are recreated for each repeat &quot;\n    &quot;of the tests. If set to false the global test environments are only set &quot;\n    &quot;up once, for the first iteration, and only torn down once, for the last. &quot;\n    &quot;Useful for shaking out flaky tests with stable, expensive test &quot;\n    &quot;environments. If --gtest_repeat is set to a negative number, meaning &quot;\n    &quot;there is no last run, the environments will always be recreated to avoid &quot;\n    &quot;leaks.&quot;);\n\nGTEST_DEFINE_bool_(show_internal_stack_frames, false,\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should include internal stack frames when &quot;\n                   &quot;printing test failure stack traces.&quot;);\n\nGTEST_DEFINE_bool_(shuffle,\n                   testing::internal::BoolFromGTestEnv(&quot;shuffle&quot;, false),\n                   &quot;True if and only if &quot; GTEST_NAME_\n                   &quot; should randomize tests&#x27; order on every run.&quot;);\n\nGTEST_DEFINE_int32_(\n    stack_trace_depth,\n    testing::internal::Int32FromGTestEnv(&quot;stack_trace_depth&quot;,\n                                         testing::kMaxStackTraceDepth),\n    &quot;The maximum number of stack frames to print when an &quot;\n    &quot;assertion fails.  The valid range is 0 through 100, inclusive.&quot;);\n\nGTEST_DEFINE_string_(\n    stream_result_to,\n    testing::internal::StringFromGTestEnv(&quot;stream_result_to&quot;, &quot;&quot;),\n    &quot;This flag specifies the host name and the port number on which to stream &quot;\n    &quot;test results. Example: \\&quot;localhost:555\\&quot;. The flag is effective only on &quot;\n    &quot;Linux and macOS.&quot;);\n\nGTEST_DEFINE_bool_(\n    throw_on_failure,\n    testing::internal::BoolFromGTestEnv(&quot;throw_on_failure&quot;, false),\n    &quot;When this flag is specified, a failed assertion will throw an exception &quot;\n    &quot;if exceptions are enabled or exit the program with a non-zero code &quot;\n    &quot;otherwise. For use with an external test framework.&quot;);\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_\nGTEST_DEFINE_string_(\n    flagfile, testing::internal::StringFromGTestEnv(&quot;flagfile&quot;, &quot;&quot;),\n    &quot;This flag specifies the flagfile to read command-line flags from.&quot;);\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_\n\nnamespace testing {\nnamespace internal {\n\nconst uint32_t Random::kMaxRange;\n\n// Generates a random number from [0, range), using a Linear\n// Congruential Generator (LCG).  Crashes if &#x27;range&#x27; is 0 or greater\n// than kMaxRange.\nuint32_t Random::Generate(uint32_t range) {\n  // These constants are the same as are used in glibc&#x27;s rand(3).\n  // Use wider types than necessary to prevent unsigned overflow diagnostics.\n  state_ = static_cast&lt;uint32_t&gt;(1103515245ULL * state_ + 12345U) % kMaxRange;\n\n  GTEST_CHECK_(range &gt; 0) &lt;&lt; &quot;Cannot generate a number in the range [0, 0).&quot;;\n  GTEST_CHECK_(range &lt;= kMaxRange)\n      &lt;&lt; &quot;Generation of a number in [0, &quot; &lt;&lt; range &lt;&lt; &quot;) was requested, &quot;\n      &lt;&lt; &quot;but this can only generate numbers in [0, &quot; &lt;&lt; kMaxRange &lt;&lt; &quot;).&quot;;\n\n  // Converting via modulus introduces a bit of downward bias, but\n  // it&#x27;s simple, and a linear congruential generator isn&#x27;t too good\n  // to begin with.\n  return state_ % range;\n}\n\n// GTestIsInitialized() returns true if and only if the user has initialized\n// Google Test.  Useful for catching the user mistake of not initializing\n// Google Test before calling RUN_ALL_TESTS().\nstatic bool GTestIsInitialized() { return !GetArgvs().empty(); }\n\n// Iterates over a vector of TestSuites, keeping a running sum of the\n// results of calling a given int-returning method on each.\n// Returns the sum.\nstatic int SumOverTestSuiteList(const std::vector&lt;TestSuite*&gt;&amp; case_list,\n                                int (TestSuite::*method)() const) {\n  int sum = 0;\n  for (size_t i = 0; i &lt; case_list.size(); i++) {\n    sum += (case_list[i]-&gt;*method)();\n  }\n  return sum;\n}\n\n// Returns true if and only if the test suite passed.\nstatic bool TestSuitePassed(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Passed();\n}\n\n// Returns true if and only if the test suite failed.\nstatic bool TestSuiteFailed(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Failed();\n}\n\n// Returns true if and only if test_suite contains at least one test that\n// should run.\nstatic bool ShouldRunTestSuite(const TestSuite* test_suite) {\n  return test_suite-&gt;should_run();\n}\n\nnamespace {\n\n// Returns true if test part results of type `type` should include a stack\n// trace.\nbool ShouldEmitStackTraceForResultType(TestPartResult::Type type) {\n  // Suppress emission of the stack trace for SUCCEED() since it likely never\n  // requires investigation, and GTEST_SKIP() since skipping is an intentional\n  // act by the developer rather than a failure requiring investigation.\n  return type != TestPartResult::kSuccess &amp;&amp; type != TestPartResult::kSkip;\n}\n\n}  // namespace\n\n// AssertHelper constructor.\nAssertHelper::AssertHelper(TestPartResult::Type type, const char* file,\n                           int line, const char* message)\n    : data_(new AssertHelperData(type, file, line, message)) {}\n\nAssertHelper::~AssertHelper() { delete data_; }\n\n// Message assignment, for assertion streaming support.\nvoid AssertHelper::operator=(const Message&amp; message) const {\n  UnitTest::GetInstance()-&gt;AddTestPartResult(\n      data_-&gt;type, data_-&gt;file, data_-&gt;line,\n      AppendUserMessage(data_-&gt;message, message),\n      ShouldEmitStackTraceForResultType(data_-&gt;type)\n          ? UnitTest::GetInstance()-&gt;impl()-&gt;CurrentOsStackTraceExceptTop(1)\n          : &quot;&quot;\n      // Skips the stack frame for this function itself.\n  );  // NOLINT\n}\n\nnamespace {\n\n// When TEST_P is found without a matching INSTANTIATE_TEST_SUITE_P\n// to creates test cases for it, a synthetic test case is\n// inserted to report ether an error or a log message.\n//\n// This configuration bit will likely be removed at some point.\nconstexpr bool kErrorOnUninstantiatedParameterizedTest = true;\nconstexpr bool kErrorOnUninstantiatedTypeParameterizedTest = true;\n\n// A test that fails at a given file/line location with a given message.\nclass FailureTest : public Test {\n public:\n  explicit FailureTest(const CodeLocation&amp; loc, std::string error_message,\n                       bool as_error)\n      : loc_(loc),\n        error_message_(std::move(error_message)),\n        as_error_(as_error) {}\n\n  void TestBody() override {\n    if (as_error_) {\n      AssertHelper(TestPartResult::kNonFatalFailure, loc_.file.c_str(),\n                   loc_.line, &quot;&quot;) = Message() &lt;&lt; error_message_;\n    } else {\n      std::cout &lt;&lt; error_message_ &lt;&lt; std::endl;\n    }\n  }\n\n private:\n  const CodeLocation loc_;\n  const std::string error_message_;\n  const bool as_error_;\n};\n\n}  // namespace\n\nstd::set&lt;std::string&gt;* GetIgnoredParameterizedTestSuites() {\n  return UnitTest::GetInstance()-&gt;impl()-&gt;ignored_parameterized_test_suites();\n}\n\n// Add a given test_suit to the list of them allow to go un-instantiated.\nMarkAsIgnored::MarkAsIgnored(const char* test_suite) {\n  GetIgnoredParameterizedTestSuites()-&gt;insert(test_suite);\n}\n\n// If this parameterized test suite has no instantiations (and that\n// has not been marked as okay), emit a test case reporting that.\nvoid InsertSyntheticTestCase(const std::string&amp; name, CodeLocation location,\n                             bool has_test_p) {\n  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();\n  if (ignored.find(name) != ignored.end()) return;\n\n  const char kMissingInstantiation[] =  //\n      &quot; is defined via TEST_P, but never instantiated. None of the test &quot;\n      &quot;cases &quot;\n      &quot;will run. Either no INSTANTIATE_TEST_SUITE_P is provided or the only &quot;\n      &quot;ones provided expand to nothing.&quot;\n      &quot;\\n\\n&quot;\n      &quot;Ideally, TEST_P definitions should only ever be included as part of &quot;\n      &quot;binaries that intend to use them. (As opposed to, for example, being &quot;\n      &quot;placed in a library that may be linked in to get other utilities.)&quot;;\n\n  const char kMissingTestCase[] =  //\n      &quot; is instantiated via INSTANTIATE_TEST_SUITE_P, but no tests are &quot;\n      &quot;defined via TEST_P . No test cases will run.&quot;\n      &quot;\\n\\n&quot;\n      &quot;Ideally, INSTANTIATE_TEST_SUITE_P should only ever be invoked from &quot;\n      &quot;code that always depend on code that provides TEST_P. Failing to do &quot;\n      &quot;so is often an indication of dead code, e.g. the last TEST_P was &quot;\n      &quot;removed but the rest got left behind.&quot;;\n\n  std::string message =\n      &quot;Parameterized test suite &quot; + name +\n      (has_test_p ? kMissingInstantiation : kMissingTestCase) +\n      &quot;\\n\\n&quot;\n      &quot;To suppress this error for this test suite, insert the following line &quot;\n      &quot;(in a non-header) in the namespace it is defined in:&quot;\n      &quot;\\n\\n&quot;\n      &quot;GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(&quot; +\n      name + &quot;);&quot;;\n\n  std::string full_name = &quot;UninstantiatedParameterizedTestSuite&lt;&quot; + name + &quot;&gt;&quot;;\n  RegisterTest(  //\n      &quot;GoogleTestVerification&quot;, full_name.c_str(),\n      nullptr,  // No type parameter.\n      nullptr,  // No value parameter.\n      location.file.c_str(), location.line, [message, location] {\n        return new FailureTest(location, message,\n                               kErrorOnUninstantiatedParameterizedTest);\n      });\n}\n\nvoid RegisterTypeParameterizedTestSuite(const char* test_suite_name,\n                                        CodeLocation code_location) {\n  GetUnitTestImpl()-&gt;type_parameterized_test_registry().RegisterTestSuite(\n      test_suite_name, std::move(code_location));\n}\n\nvoid RegisterTypeParameterizedTestSuiteInstantiation(const char* case_name) {\n  GetUnitTestImpl()-&gt;type_parameterized_test_registry().RegisterInstantiation(\n      case_name);\n}\n\nvoid TypeParameterizedTestSuiteRegistry::RegisterTestSuite(\n    const char* test_suite_name, CodeLocation code_location) {\n  suites_.emplace(std::string(test_suite_name),\n                  TypeParameterizedTestSuiteInfo(std::move(code_location)));\n}\n\nvoid TypeParameterizedTestSuiteRegistry::RegisterInstantiation(\n    const char* test_suite_name) {\n  auto it = suites_.find(std::string(test_suite_name));\n  if (it != suites_.end()) {\n    it-&gt;second.instantiated = true;\n  } else {\n    GTEST_LOG_(ERROR) &lt;&lt; &quot;Unknown type parameterized test suit &#x27;&quot;\n                      &lt;&lt; test_suite_name &lt;&lt; &quot;&#x27;&quot;;\n  }\n}\n\nvoid TypeParameterizedTestSuiteRegistry::CheckForInstantiations() {\n  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();\n  for (const auto&amp; testcase : suites_) {\n    if (testcase.second.instantiated) continue;\n    if (ignored.find(testcase.first) != ignored.end()) continue;\n\n    std::string message =\n        &quot;Type parameterized test suite &quot; + testcase.first +\n        &quot; is defined via REGISTER_TYPED_TEST_SUITE_P, but never instantiated &quot;\n        &quot;via INSTANTIATE_TYPED_TEST_SUITE_P. None of the test cases will run.&quot;\n        &quot;\\n\\n&quot;\n        &quot;Ideally, TYPED_TEST_P definitions should only ever be included as &quot;\n        &quot;part of binaries that intend to use them. (As opposed to, for &quot;\n        &quot;example, being placed in a library that may be linked in to get &quot;\n        &quot;other &quot;\n        &quot;utilities.)&quot;\n        &quot;\\n\\n&quot;\n        &quot;To suppress this error for this test suite, insert the following &quot;\n        &quot;line &quot;\n        &quot;(in a non-header) in the namespace it is defined in:&quot;\n        &quot;\\n\\n&quot;\n        &quot;GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(&quot; +\n        testcase.first + &quot;);&quot;;\n\n    std::string full_name =\n        &quot;UninstantiatedTypeParameterizedTestSuite&lt;&quot; + testcase.first + &quot;&gt;&quot;;\n    RegisterTest(  //\n        &quot;GoogleTestVerification&quot;, full_name.c_str(),\n        nullptr,  // No type parameter.\n        nullptr,  // No value parameter.\n        testcase.second.code_location.file.c_str(),\n        testcase.second.code_location.line, [message, testcase] {\n          return new FailureTest(testcase.second.code_location, message,\n                                 kErrorOnUninstantiatedTypeParameterizedTest);\n        });\n  }\n}\n\n// A copy of all command line arguments.  Set by InitGoogleTest().\nstatic ::std::vector&lt;std::string&gt; g_argvs;\n\n::std::vector&lt;std::string&gt; GetArgvs() {\n#if defined(GTEST_CUSTOM_GET_ARGVS_)\n  // GTEST_CUSTOM_GET_ARGVS_() may return a container of std::string or\n  // ::string. This code converts it to the appropriate type.\n  const auto&amp; custom = GTEST_CUSTOM_GET_ARGVS_();\n  return ::std::vector&lt;std::string&gt;(custom.begin(), custom.end());\n#else   // defined(GTEST_CUSTOM_GET_ARGVS_)\n  return g_argvs;\n#endif  // defined(GTEST_CUSTOM_GET_ARGVS_)\n}\n\n#if GTEST_HAS_FILE_SYSTEM\n// Returns the current application&#x27;s name, removing directory path if that\n// is present.\nFilePath GetCurrentExecutableName() {\n  FilePath result;\n\n  auto args = GetArgvs();\n  if (!args.empty()) {\n#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_OS2)\n    result.Set(FilePath(args[0]).RemoveExtension(&quot;exe&quot;));\n#else\n    result.Set(FilePath(args[0]));\n#endif  // GTEST_OS_WINDOWS\n  }\n\n  return result.RemoveDirectoryName();\n}\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Functions for processing the gtest_output flag.\n\n// Returns the output format, or &quot;&quot; for normal printed output.\nstd::string UnitTestOptions::GetOutputFormat() {\n  std::string s = GTEST_FLAG_GET(output);\n  const char* const gtest_output_flag = s.c_str();\n  const char* const colon = strchr(gtest_output_flag, &#x27;:&#x27;);\n  return (colon == nullptr)\n             ? std::string(gtest_output_flag)\n             : std::string(gtest_output_flag,\n                           static_cast&lt;size_t&gt;(colon - gtest_output_flag));\n}\n\n#if GTEST_HAS_FILE_SYSTEM\n// Returns the name of the requested output file, or the default if none\n// was explicitly specified.\nstd::string UnitTestOptions::GetAbsolutePathToOutputFile() {\n  std::string s = GTEST_FLAG_GET(output);\n  const char* const gtest_output_flag = s.c_str();\n\n  std::string format = GetOutputFormat();\n  if (format.empty()) format = std::string(kDefaultOutputFormat);\n\n  const char* const colon = strchr(gtest_output_flag, &#x27;:&#x27;);\n  if (colon == nullptr)\n    return internal::FilePath::MakeFileName(\n               internal::FilePath(\n                   UnitTest::GetInstance()-&gt;original_working_dir()),\n               internal::FilePath(kDefaultOutputFile), 0, format.c_str())\n        .string();\n\n  internal::FilePath output_name(colon + 1);\n  if (!output_name.IsAbsolutePath())\n    output_name = internal::FilePath::ConcatPaths(\n        internal::FilePath(UnitTest::GetInstance()-&gt;original_working_dir()),\n        internal::FilePath(colon + 1));\n\n  if (!output_name.IsDirectory()) return output_name.string();\n\n  internal::FilePath result(internal::FilePath::GenerateUniqueFileName(\n      output_name, internal::GetCurrentExecutableName(),\n      GetOutputFormat().c_str()));\n  return result.string();\n}\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Returns true if and only if the wildcard pattern matches the string. Each\n// pattern consists of regular characters, single-character wildcards (?), and\n// multi-character wildcards (*).\n//\n// This function implements a linear-time string globbing algorithm based on\n// https://research.swtch.com/glob.\nstatic bool PatternMatchesString(const std::string&amp; name_str,\n                                 const char* pattern, const char* pattern_end) {\n  const char* name = name_str.c_str();\n  const char* const name_begin = name;\n  const char* const name_end = name + name_str.size();\n\n  const char* pattern_next = pattern;\n  const char* name_next = name;\n\n  while (pattern &lt; pattern_end || name &lt; name_end) {\n    if (pattern &lt; pattern_end) {\n      switch (*pattern) {\n        default:  // Match an ordinary character.\n          if (name &lt; name_end &amp;&amp; *name == *pattern) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case &#x27;?&#x27;:  // Match any single character.\n          if (name &lt; name_end) {\n            ++pattern;\n            ++name;\n            continue;\n          }\n          break;\n        case &#x27;*&#x27;:\n          // Match zero or more characters. Start by skipping over the wildcard\n          // and matching zero characters from name. If that fails, restart and\n          // match one more character than the last attempt.\n          pattern_next = pattern;\n          name_next = name + 1;\n          ++pattern;\n          continue;\n      }\n    }\n    // Failed to match a character. Restart if possible.\n    if (name_begin &lt; name_next &amp;&amp; name_next &lt;= name_end) {\n      pattern = pattern_next;\n      name = name_next;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nnamespace {\n\nbool IsGlobPattern(const std::string&amp; pattern) {\n  return std::any_of(pattern.begin(), pattern.end(),\n                     [](const char c) { return c == &#x27;?&#x27; || c == &#x27;*&#x27;; });\n}\n\nclass UnitTestFilter {\n public:\n  UnitTestFilter() = default;\n\n  // Constructs a filter from a string of patterns separated by `:`.\n  explicit UnitTestFilter(const std::string&amp; filter) {\n    // By design &quot;&quot; filter matches &quot;&quot; string.\n    std::vector&lt;std::string&gt; all_patterns;\n    SplitString(filter, &#x27;:&#x27;, &amp;all_patterns);\n    const auto exact_match_patterns_begin = std::partition(\n        all_patterns.begin(), all_patterns.end(), &amp;IsGlobPattern);\n\n    glob_patterns_.reserve(static_cast&lt;size_t&gt;(\n        std::distance(all_patterns.begin(), exact_match_patterns_begin)));\n    std::move(all_patterns.begin(), exact_match_patterns_begin,\n              std::inserter(glob_patterns_, glob_patterns_.begin()));\n    std::move(\n        exact_match_patterns_begin, all_patterns.end(),\n        std::inserter(exact_match_patterns_, exact_match_patterns_.begin()));\n  }\n\n  // Returns true if and only if name matches at least one of the patterns in\n  // the filter.\n  bool MatchesName(const std::string&amp; name) const {\n    return exact_match_patterns_.find(name) != exact_match_patterns_.end() ||\n           std::any_of(glob_patterns_.begin(), glob_patterns_.end(),\n                       [&amp;name](const std::string&amp; pattern) {\n                         return PatternMatchesString(\n                             name, pattern.c_str(),\n                             pattern.c_str() + pattern.size());\n                       });\n  }\n\n private:\n  std::vector&lt;std::string&gt; glob_patterns_;\n  std::unordered_set&lt;std::string&gt; exact_match_patterns_;\n};\n\nclass PositiveAndNegativeUnitTestFilter {\n public:\n  // Constructs a positive and a negative filter from a string. The string\n  // contains a positive filter optionally followed by a &#x27;-&#x27; character and a\n  // negative filter. In case only a negative filter is provided the positive\n  // filter will be assumed &quot;*&quot;.\n  // A filter is a list of patterns separated by &#x27;:&#x27;.\n  explicit PositiveAndNegativeUnitTestFilter(const std::string&amp; filter) {\n    std::vector&lt;std::string&gt; positive_and_negative_filters;\n\n    // NOTE: `SplitString` always returns a non-empty container.\n    SplitString(filter, &#x27;-&#x27;, &amp;positive_and_negative_filters);\n    const auto&amp; positive_filter = positive_and_negative_filters.front();\n\n    if (positive_and_negative_filters.size() &gt; 1) {\n      positive_filter_ = UnitTestFilter(\n          positive_filter.empty() ? kUniversalFilter : positive_filter);\n\n      // TODO(b/214626361): Fail on multiple &#x27;-&#x27; characters\n      // For the moment to preserve old behavior we concatenate the rest of the\n      // string parts with `-` as separator to generate the negative filter.\n      auto negative_filter_string = positive_and_negative_filters[1];\n      for (std::size_t i = 2; i &lt; positive_and_negative_filters.size(); i++)\n        negative_filter_string =\n            negative_filter_string + &#x27;-&#x27; + positive_and_negative_filters[i];\n      negative_filter_ = UnitTestFilter(negative_filter_string);\n    } else {\n      // In case we don&#x27;t have a negative filter and positive filter is &quot;&quot;\n      // we do not use kUniversalFilter by design as opposed to when we have a\n      // negative filter.\n      positive_filter_ = UnitTestFilter(positive_filter);\n    }\n  }\n\n  // Returns true if and only if test name (this is generated by appending test\n  // suit name and test name via a &#x27;.&#x27; character) matches the positive filter\n  // and does not match the negative filter.\n  bool MatchesTest(const std::string&amp; test_suite_name,\n                   const std::string&amp; test_name) const {\n    return MatchesName(test_suite_name + &quot;.&quot; + test_name);\n  }\n\n  // Returns true if and only if name matches the positive filter and does not\n  // match the negative filter.\n  bool MatchesName(const std::string&amp; name) const {\n    return positive_filter_.MatchesName(name) &amp;&amp;\n           !negative_filter_.MatchesName(name);\n  }\n\n private:\n  UnitTestFilter positive_filter_;\n  UnitTestFilter negative_filter_;\n};\n}  // namespace\n\nbool UnitTestOptions::MatchesFilter(const std::string&amp; name_str,\n                                    const char* filter) {\n  return UnitTestFilter(filter).MatchesName(name_str);\n}\n\n// Returns true if and only if the user-specified filter matches the test\n// suite name and the test name.\nbool UnitTestOptions::FilterMatchesTest(const std::string&amp; test_suite_name,\n                                        const std::string&amp; test_name) {\n  // Split --gtest_filter at &#x27;-&#x27;, if there is one, to separate into\n  // positive filter and negative filter portions\n  return PositiveAndNegativeUnitTestFilter(GTEST_FLAG_GET(filter))\n      .MatchesTest(test_suite_name, test_name);\n}\n\n#if GTEST_HAS_SEH\nstatic std::string FormatSehExceptionMessage(DWORD exception_code,\n                                             const char* location) {\n  Message message;\n  message &lt;&lt; &quot;SEH exception with code 0x&quot; &lt;&lt; std::setbase(16) &lt;&lt; exception_code\n          &lt;&lt; std::setbase(10) &lt;&lt; &quot; thrown in &quot; &lt;&lt; location &lt;&lt; &quot;.&quot;;\n  return message.GetString();\n}\n\nint UnitTestOptions::GTestProcessSEH(DWORD seh_code, const char* location) {\n  // Google Test should handle a SEH exception if:\n  //   1. the user wants it to, AND\n  //   2. this is not a breakpoint exception or stack overflow, AND\n  //   3. this is not a C++ exception (VC++ implements them via SEH,\n  //      apparently).\n  //\n  // SEH exception code for C++ exceptions.\n  // (see https://support.microsoft.com/kb/185294 for more information).\n  const DWORD kCxxExceptionCode = 0xe06d7363;\n\n  if (!GTEST_FLAG_GET(catch_exceptions) || seh_code == kCxxExceptionCode ||\n      seh_code == EXCEPTION_BREAKPOINT ||\n      seh_code == EXCEPTION_STACK_OVERFLOW) {\n    return EXCEPTION_CONTINUE_SEARCH;  // Don&#x27;t handle these exceptions\n  }\n\n  internal::ReportFailureInUnknownLocation(\n      TestPartResult::kFatalFailure,\n      FormatSehExceptionMessage(seh_code, location) +\n          &quot;\\n&quot;\n          &quot;Stack trace:\\n&quot; +\n          ::testing::internal::GetCurrentOsStackTraceExceptTop(1));\n\n  return EXCEPTION_EXECUTE_HANDLER;\n}\n#endif  // GTEST_HAS_SEH\n\n}  // namespace internal\n\n// The c&#x27;tor sets this object as the test part result reporter used by\n// Google Test.  The &#x27;result&#x27; parameter specifies where to report the\n// results. Intercepts only failures from the current thread.\nScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\n    TestPartResultArray* result)\n    : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD), result_(result) {\n  Init();\n}\n\n// The c&#x27;tor sets this object as the test part result reporter used by\n// Google Test.  The &#x27;result&#x27; parameter specifies where to report the\n// results.\nScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\n    InterceptMode intercept_mode, TestPartResultArray* result)\n    : intercept_mode_(intercept_mode), result_(result) {\n  Init();\n}\n\nvoid ScopedFakeTestPartResultReporter::Init() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {\n    old_reporter_ = impl-&gt;GetGlobalTestPartResultReporter();\n    impl-&gt;SetGlobalTestPartResultReporter(this);\n  } else {\n    old_reporter_ = impl-&gt;GetTestPartResultReporterForCurrentThread();\n    impl-&gt;SetTestPartResultReporterForCurrentThread(this);\n  }\n}\n\n// The d&#x27;tor restores the test part result reporter used by Google Test\n// before.\nScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {\n    impl-&gt;SetGlobalTestPartResultReporter(old_reporter_);\n  } else {\n    impl-&gt;SetTestPartResultReporterForCurrentThread(old_reporter_);\n  }\n}\n\n// Increments the test part result count and remembers the result.\n// This method is from the TestPartResultReporterInterface interface.\nvoid ScopedFakeTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  result_-&gt;Append(result);\n}\n\nnamespace internal {\n\n// Returns the type ID of ::testing::Test.  We should always call this\n// instead of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of\n// testing::Test.  This is to work around a suspected linker bug when\n// using Google Test as a framework on Mac OS X.  The bug causes\n// GetTypeId&lt; ::testing::Test&gt;() to return different values depending\n// on whether the call is from the Google Test framework itself or\n// from user test code.  GetTestTypeId() is guaranteed to always\n// return the same value, as it always calls GetTypeId&lt;&gt;() from the\n// gtest.cc, which is within the Google Test framework.\nTypeId GetTestTypeId() { return GetTypeId&lt;Test&gt;(); }\n\n// The value of GetTestTypeId() as seen from within the Google Test\n// library.  This is solely for testing GetTestTypeId().\nextern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();\n\n// This predicate-formatter checks that &#x27;results&#x27; contains a test part\n// failure of the given type and that the failure message contains the\n// given substring.\nstatic AssertionResult HasOneFailure(const char* /* results_expr */,\n                                     const char* /* type_expr */,\n                                     const char* /* substr_expr */,\n                                     const TestPartResultArray&amp; results,\n                                     TestPartResult::Type type,\n                                     const std::string&amp; substr) {\n  const std::string expected(type == TestPartResult::kFatalFailure\n                                 ? &quot;1 fatal failure&quot;\n                                 : &quot;1 non-fatal failure&quot;);\n  Message msg;\n  if (results.size() != 1) {\n    msg &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot;\\n&quot;\n        &lt;&lt; &quot;  Actual: &quot; &lt;&lt; results.size() &lt;&lt; &quot; failures&quot;;\n    for (int i = 0; i &lt; results.size(); i++) {\n      msg &lt;&lt; &quot;\\n&quot; &lt;&lt; results.GetTestPartResult(i);\n    }\n    return AssertionFailure() &lt;&lt; msg;\n  }\n\n  const TestPartResult&amp; r = results.GetTestPartResult(0);\n  if (r.type() != type) {\n    return AssertionFailure() &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot;\\n&quot;\n                              &lt;&lt; &quot;  Actual:\\n&quot;\n                              &lt;&lt; r;\n  }\n\n  if (strstr(r.message(), substr.c_str()) == nullptr) {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: &quot; &lt;&lt; expected &lt;&lt; &quot; containing \\&quot;&quot; &lt;&lt; substr &lt;&lt; &quot;\\&quot;\\n&quot;\n           &lt;&lt; &quot;  Actual:\\n&quot;\n           &lt;&lt; r;\n  }\n\n  return AssertionSuccess();\n}\n\n// The constructor of SingleFailureChecker remembers where to look up\n// test part results, what type of failure we expect, and what\n// substring the failure message should contain.\nSingleFailureChecker::SingleFailureChecker(const TestPartResultArray* results,\n                                           TestPartResult::Type type,\n                                           const std::string&amp; substr)\n    : results_(results), type_(type), substr_(substr) {}\n\n// The destructor of SingleFailureChecker verifies that the given\n// TestPartResultArray contains exactly one failure that has the given\n// type and contains the given substring.  If that&#x27;s not the case, a\n// non-fatal failure will be generated.\nSingleFailureChecker::~SingleFailureChecker() {\n  EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);\n}\n\nDefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(\n    UnitTestImpl* unit_test)\n    : unit_test_(unit_test) {}\n\nvoid DefaultGlobalTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  unit_test_-&gt;current_test_result()-&gt;AddTestPartResult(result);\n  unit_test_-&gt;listeners()-&gt;repeater()-&gt;OnTestPartResult(result);\n}\n\nDefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(\n    UnitTestImpl* unit_test)\n    : unit_test_(unit_test) {}\n\nvoid DefaultPerThreadTestPartResultReporter::ReportTestPartResult(\n    const TestPartResult&amp; result) {\n  unit_test_-&gt;GetGlobalTestPartResultReporter()-&gt;ReportTestPartResult(result);\n}\n\n// Returns the global test part result reporter.\nTestPartResultReporterInterface*\nUnitTestImpl::GetGlobalTestPartResultReporter() {\n  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);\n  return global_test_part_result_reporter_;\n}\n\n// Sets the global test part result reporter.\nvoid UnitTestImpl::SetGlobalTestPartResultReporter(\n    TestPartResultReporterInterface* reporter) {\n  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);\n  global_test_part_result_reporter_ = reporter;\n}\n\n// Returns the test part result reporter for the current thread.\nTestPartResultReporterInterface*\nUnitTestImpl::GetTestPartResultReporterForCurrentThread() {\n  return per_thread_test_part_result_reporter_.get();\n}\n\n// Sets the test part result reporter for the current thread.\nvoid UnitTestImpl::SetTestPartResultReporterForCurrentThread(\n    TestPartResultReporterInterface* reporter) {\n  per_thread_test_part_result_reporter_.set(reporter);\n}\n\n// Gets the number of successful test suites.\nint UnitTestImpl::successful_test_suite_count() const {\n  return CountIf(test_suites_, TestSuitePassed);\n}\n\n// Gets the number of failed test suites.\nint UnitTestImpl::failed_test_suite_count() const {\n  return CountIf(test_suites_, TestSuiteFailed);\n}\n\n// Gets the number of all test suites.\nint UnitTestImpl::total_test_suite_count() const {\n  return static_cast&lt;int&gt;(test_suites_.size());\n}\n\n// Gets the number of all test suites that contain at least one test\n// that should run.\nint UnitTestImpl::test_suite_to_run_count() const {\n  return CountIf(test_suites_, ShouldRunTestSuite);\n}\n\n// Gets the number of successful tests.\nint UnitTestImpl::successful_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::successful_test_count);\n}\n\n// Gets the number of skipped tests.\nint UnitTestImpl::skipped_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::skipped_test_count);\n}\n\n// Gets the number of failed tests.\nint UnitTestImpl::failed_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::failed_test_count);\n}\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint UnitTestImpl::reportable_disabled_test_count() const {\n  return SumOverTestSuiteList(test_suites_,\n                              &amp;TestSuite::reportable_disabled_test_count);\n}\n\n// Gets the number of disabled tests.\nint UnitTestImpl::disabled_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::disabled_test_count);\n}\n\n// Gets the number of tests to be printed in the XML report.\nint UnitTestImpl::reportable_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::reportable_test_count);\n}\n\n// Gets the number of all tests.\nint UnitTestImpl::total_test_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::total_test_count);\n}\n\n// Gets the number of tests that should run.\nint UnitTestImpl::test_to_run_count() const {\n  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::test_to_run_count);\n}\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// CurrentOsStackTraceExceptTop(1), Foo() will be included in the\n// trace but Bar() and CurrentOsStackTraceExceptTop() won&#x27;t.\nstd::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {\n  return os_stack_trace_getter()-&gt;CurrentStackTrace(\n      static_cast&lt;int&gt;(GTEST_FLAG_GET(stack_trace_depth)), skip_count + 1\n      // Skips the user-specified number of frames plus this function\n      // itself.\n  );  // NOLINT\n}\n\n// A helper class for measuring elapsed times.\nclass Timer {\n public:\n  Timer() : start_(clock::now()) {}\n\n  // Return time elapsed in milliseconds since the timer was created.\n  TimeInMillis Elapsed() {\n    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(clock::now() -\n                                                                 start_)\n        .count();\n  }\n\n private:\n  // Fall back to the system_clock when building with newlib on a system\n  // without a monotonic clock.\n#if defined(_NEWLIB_VERSION) &amp;&amp; !defined(CLOCK_MONOTONIC)\n  using clock = std::chrono::system_clock;\n#else\n  using clock = std::chrono::steady_clock;\n#endif\n  clock::time_point start_;\n};\n\n// Returns a timestamp as milliseconds since the epoch. Note this time may jump\n// around subject to adjustments by the system, to measure elapsed time use\n// Timer instead.\nTimeInMillis GetTimeInMillis() {\n  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\n             std::chrono::system_clock::now() -\n             std::chrono::system_clock::from_time_t(0))\n      .count();\n}\n\n// Utilities\n\n// class String.\n\n#ifdef GTEST_OS_WINDOWS_MOBILE\n// Creates a UTF-16 wide string from the given ANSI string, allocating\n// memory using new. The caller is responsible for deleting the return\n// value using delete[]. Returns the wide string, or NULL if the\n// input is NULL.\nLPCWSTR String::AnsiToUtf16(const char* ansi) {\n  if (!ansi) return nullptr;\n  const int length = strlen(ansi);\n  const int unicode_length =\n      MultiByteToWideChar(CP_ACP, 0, ansi, length, nullptr, 0);\n  WCHAR* unicode = new WCHAR[unicode_length + 1];\n  MultiByteToWideChar(CP_ACP, 0, ansi, length, unicode, unicode_length);\n  unicode[unicode_length] = 0;\n  return unicode;\n}\n\n// Creates an ANSI string from the given wide string, allocating\n// memory using new. The caller is responsible for deleting the return\n// value using delete[]. Returns the ANSI string, or NULL if the\n// input is NULL.\nconst char* String::Utf16ToAnsi(LPCWSTR utf16_str) {\n  if (!utf16_str) return nullptr;\n  const int ansi_length = WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, nullptr,\n                                              0, nullptr, nullptr);\n  char* ansi = new char[ansi_length + 1];\n  WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, ansi, ansi_length, nullptr,\n                      nullptr);\n  ansi[ansi_length] = 0;\n  return ansi;\n}\n\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n// Compares two C strings.  Returns true if and only if they have the same\n// content.\n//\n// Unlike strcmp(), this function can handle NULL argument(s).  A NULL\n// C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::CStringEquals(const char* lhs, const char* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n  return strcmp(lhs, rhs) == 0;\n}\n\n#if GTEST_HAS_STD_WSTRING\n\n// Converts an array of wide chars to a narrow string using the UTF-8\n// encoding, and streams the result to the given Message object.\nstatic void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,\n                                     Message* msg) {\n  for (size_t i = 0; i != length;) {  // NOLINT\n    if (wstr[i] != L&#x27;\\0&#x27;) {\n      *msg &lt;&lt; WideStringToUtf8(wstr + i, static_cast&lt;int&gt;(length - i));\n      while (i != length &amp;&amp; wstr[i] != L&#x27;\\0&#x27;) i++;\n    } else {\n      *msg &lt;&lt; &#x27;\\0&#x27;;\n      i++;\n    }\n  }\n}\n\n#endif  // GTEST_HAS_STD_WSTRING\n\nvoid SplitString(const ::std::string&amp; str, char delimiter,\n                 ::std::vector&lt; ::std::string&gt;* dest) {\n  ::std::vector&lt; ::std::string&gt; parsed;\n  ::std::string::size_type pos = 0;\n  while (::testing::internal::AlwaysTrue()) {\n    const ::std::string::size_type colon = str.find(delimiter, pos);\n    if (colon == ::std::string::npos) {\n      parsed.push_back(str.substr(pos));\n      break;\n    } else {\n      parsed.push_back(str.substr(pos, colon - pos));\n      pos = colon + 1;\n    }\n  }\n  dest-&gt;swap(parsed);\n}\n\n}  // namespace internal\n\n// Constructs an empty Message.\n// We allocate the stringstream separately because otherwise each use of\n// ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure&#x27;s\n// stack frame leading to huge stack frames in some cases; gcc does not reuse\n// the stack space.\nMessage::Message() : ss_(new ::std::stringstream) {\n  // By default, we want there to be enough precision when printing\n  // a double to a Message.\n  *ss_ &lt;&lt; std::setprecision(std::numeric_limits&lt;double&gt;::digits10 + 2);\n}\n\n// These two overloads allow streaming a wide C string to a Message\n// using the UTF-8 encoding.\nMessage&amp; Message::operator&lt;&lt;(const wchar_t* wide_c_str) {\n  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);\n}\nMessage&amp; Message::operator&lt;&lt;(wchar_t* wide_c_str) {\n  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);\n}\n\n#if GTEST_HAS_STD_WSTRING\n// Converts the given wide string to a narrow string using the UTF-8\n// encoding, and streams the result to this Message object.\nMessage&amp; Message::operator&lt;&lt;(const ::std::wstring&amp; wstr) {\n  internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);\n  return *this;\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n// Gets the text streamed to this object so far as an std::string.\n// Each &#x27;\\0&#x27; character in the buffer is replaced with &quot;\\\\0&quot;.\nstd::string Message::GetString() const {\n  return internal::StringStreamToString(ss_.get());\n}\n\nnamespace internal {\n\nnamespace edit_distance {\nstd::vector&lt;EditType&gt; CalculateOptimalEdits(const std::vector&lt;size_t&gt;&amp; left,\n                                            const std::vector&lt;size_t&gt;&amp; right) {\n  std::vector&lt;std::vector&lt;double&gt; &gt; costs(\n      left.size() + 1, std::vector&lt;double&gt;(right.size() + 1));\n  std::vector&lt;std::vector&lt;EditType&gt; &gt; best_move(\n      left.size() + 1, std::vector&lt;EditType&gt;(right.size() + 1));\n\n  // Populate for empty right.\n  for (size_t l_i = 0; l_i &lt; costs.size(); ++l_i) {\n    costs[l_i][0] = static_cast&lt;double&gt;(l_i);\n    best_move[l_i][0] = kRemove;\n  }\n  // Populate for empty left.\n  for (size_t r_i = 1; r_i &lt; costs[0].size(); ++r_i) {\n    costs[0][r_i] = static_cast&lt;double&gt;(r_i);\n    best_move[0][r_i] = kAdd;\n  }\n\n  for (size_t l_i = 0; l_i &lt; left.size(); ++l_i) {\n    for (size_t r_i = 0; r_i &lt; right.size(); ++r_i) {\n      if (left[l_i] == right[r_i]) {\n        // Found a match. Consume it.\n        costs[l_i + 1][r_i + 1] = costs[l_i][r_i];\n        best_move[l_i + 1][r_i + 1] = kMatch;\n        continue;\n      }\n\n      const double add = costs[l_i + 1][r_i];\n      const double remove = costs[l_i][r_i + 1];\n      const double replace = costs[l_i][r_i];\n      if (add &lt; remove &amp;&amp; add &lt; replace) {\n        costs[l_i + 1][r_i + 1] = add + 1;\n        best_move[l_i + 1][r_i + 1] = kAdd;\n      } else if (remove &lt; add &amp;&amp; remove &lt; replace) {\n        costs[l_i + 1][r_i + 1] = remove + 1;\n        best_move[l_i + 1][r_i + 1] = kRemove;\n      } else {\n        // We make replace a little more expensive than add/remove to lower\n        // their priority.\n        costs[l_i + 1][r_i + 1] = replace + 1.00001;\n        best_move[l_i + 1][r_i + 1] = kReplace;\n      }\n    }\n  }\n\n  // Reconstruct the best path. We do it in reverse order.\n  std::vector&lt;EditType&gt; best_path;\n  for (size_t l_i = left.size(), r_i = right.size(); l_i &gt; 0 || r_i &gt; 0;) {\n    EditType move = best_move[l_i][r_i];\n    best_path.push_back(move);\n    l_i -= move != kAdd;\n    r_i -= move != kRemove;\n  }\n  std::reverse(best_path.begin(), best_path.end());\n  return best_path;\n}\n\nnamespace {\n\n// Helper class to convert string into ids with deduplication.\nclass InternalStrings {\n public:\n  size_t GetId(const std::string&amp; str) {\n    IdMap::iterator it = ids_.find(str);\n    if (it != ids_.end()) return it-&gt;second;\n    size_t id = ids_.size();\n    return ids_[str] = id;\n  }\n\n private:\n  typedef std::map&lt;std::string, size_t&gt; IdMap;\n  IdMap ids_;\n};\n\n}  // namespace\n\nstd::vector&lt;EditType&gt; CalculateOptimalEdits(\n    const std::vector&lt;std::string&gt;&amp; left,\n    const std::vector&lt;std::string&gt;&amp; right) {\n  std::vector&lt;size_t&gt; left_ids, right_ids;\n  {\n    InternalStrings intern_table;\n    for (size_t i = 0; i &lt; left.size(); ++i) {\n      left_ids.push_back(intern_table.GetId(left[i]));\n    }\n    for (size_t i = 0; i &lt; right.size(); ++i) {\n      right_ids.push_back(intern_table.GetId(right[i]));\n    }\n  }\n  return CalculateOptimalEdits(left_ids, right_ids);\n}\n\nnamespace {\n\n// Helper class that holds the state for one hunk and prints it out to the\n// stream.\n// It reorders adds/removes when possible to group all removes before all\n// adds. It also adds the hunk header before printint into the stream.\nclass Hunk {\n public:\n  Hunk(size_t left_start, size_t right_start)\n      : left_start_(left_start),\n        right_start_(right_start),\n        adds_(),\n        removes_(),\n        common_() {}\n\n  void PushLine(char edit, const char* line) {\n    switch (edit) {\n      case &#x27; &#x27;:\n        ++common_;\n        FlushEdits();\n        hunk_.push_back(std::make_pair(&#x27; &#x27;, line));\n        break;\n      case &#x27;-&#x27;:\n        ++removes_;\n        hunk_removes_.push_back(std::make_pair(&#x27;-&#x27;, line));\n        break;\n      case &#x27;+&#x27;:\n        ++adds_;\n        hunk_adds_.push_back(std::make_pair(&#x27;+&#x27;, line));\n        break;\n    }\n  }\n\n  void PrintTo(std::ostream* os) {\n    PrintHeader(os);\n    FlushEdits();\n    for (std::list&lt;std::pair&lt;char, const char*&gt; &gt;::const_iterator it =\n             hunk_.begin();\n         it != hunk_.end(); ++it) {\n      *os &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;;\n    }\n  }\n\n  bool has_edits() const { return adds_ || removes_; }\n\n private:\n  void FlushEdits() {\n    hunk_.splice(hunk_.end(), hunk_removes_);\n    hunk_.splice(hunk_.end(), hunk_adds_);\n  }\n\n  // Print a unified diff header for one hunk.\n  // The format is\n  //   &quot;@@ -&lt;left_start&gt;,&lt;left_length&gt; +&lt;right_start&gt;,&lt;right_length&gt; @@&quot;\n  // where the left/right parts are omitted if unnecessary.\n  void PrintHeader(std::ostream* ss) const {\n    *ss &lt;&lt; &quot;@@ &quot;;\n    if (removes_) {\n      *ss &lt;&lt; &quot;-&quot; &lt;&lt; left_start_ &lt;&lt; &quot;,&quot; &lt;&lt; (removes_ + common_);\n    }\n    if (removes_ &amp;&amp; adds_) {\n      *ss &lt;&lt; &quot; &quot;;\n    }\n    if (adds_) {\n      *ss &lt;&lt; &quot;+&quot; &lt;&lt; right_start_ &lt;&lt; &quot;,&quot; &lt;&lt; (adds_ + common_);\n    }\n    *ss &lt;&lt; &quot; @@\\n&quot;;\n  }\n\n  size_t left_start_, right_start_;\n  size_t adds_, removes_, common_;\n  std::list&lt;std::pair&lt;char, const char*&gt; &gt; hunk_, hunk_adds_, hunk_removes_;\n};\n\n}  // namespace\n\n// Create a list of diff hunks in Unified diff format.\n// Each hunk has a header generated by PrintHeader above plus a body with\n// lines prefixed with &#x27; &#x27; for no change, &#x27;-&#x27; for deletion and &#x27;+&#x27; for\n// addition.\n// &#x27;context&#x27; represents the desired unchanged prefix/suffix around the diff.\n// If two hunks are close enough that their contexts overlap, then they are\n// joined into one hunk.\nstd::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,\n                              const std::vector&lt;std::string&gt;&amp; right,\n                              size_t context) {\n  const std::vector&lt;EditType&gt; edits = CalculateOptimalEdits(left, right);\n\n  size_t l_i = 0, r_i = 0, edit_i = 0;\n  std::stringstream ss;\n  while (edit_i &lt; edits.size()) {\n    // Find first edit.\n    while (edit_i &lt; edits.size() &amp;&amp; edits[edit_i] == kMatch) {\n      ++l_i;\n      ++r_i;\n      ++edit_i;\n    }\n\n    // Find the first line to include in the hunk.\n    const size_t prefix_context = std::min(l_i, context);\n    Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);\n    for (size_t i = prefix_context; i &gt; 0; --i) {\n      hunk.PushLine(&#x27; &#x27;, left[l_i - i].c_str());\n    }\n\n    // Iterate the edits until we found enough suffix for the hunk or the input\n    // is over.\n    size_t n_suffix = 0;\n    for (; edit_i &lt; edits.size(); ++edit_i) {\n      if (n_suffix &gt;= context) {\n        // Continue only if the next hunk is very close.\n        auto it = edits.begin() + static_cast&lt;int&gt;(edit_i);\n        while (it != edits.end() &amp;&amp; *it == kMatch) ++it;\n        if (it == edits.end() ||\n            static_cast&lt;size_t&gt;(it - edits.begin()) - edit_i &gt;= context) {\n          // There is no next edit or it is too far away.\n          break;\n        }\n      }\n\n      EditType edit = edits[edit_i];\n      // Reset count when a non match is found.\n      n_suffix = edit == kMatch ? n_suffix + 1 : 0;\n\n      if (edit == kMatch || edit == kRemove || edit == kReplace) {\n        hunk.PushLine(edit == kMatch ? &#x27; &#x27; : &#x27;-&#x27;, left[l_i].c_str());\n      }\n      if (edit == kAdd || edit == kReplace) {\n        hunk.PushLine(&#x27;+&#x27;, right[r_i].c_str());\n      }\n\n      // Advance indices, depending on edit type.\n      l_i += edit != kAdd;\n      r_i += edit != kRemove;\n    }\n\n    if (!hunk.has_edits()) {\n      // We are done. We don&#x27;t want this hunk.\n      break;\n    }\n\n    hunk.PrintTo(&amp;ss);\n  }\n  return ss.str();\n}\n\n}  // namespace edit_distance\n\nnamespace {\n\n// The string representation of the values received in EqFailure() are already\n// escaped. Split them on escaped &#x27;\\n&#x27; boundaries. Leave all other escaped\n// characters the same.\nstd::vector&lt;std::string&gt; SplitEscapedString(const std::string&amp; str) {\n  std::vector&lt;std::string&gt; lines;\n  size_t start = 0, end = str.size();\n  if (end &gt; 2 &amp;&amp; str[0] == &#x27;&quot;&#x27; &amp;&amp; str[end - 1] == &#x27;&quot;&#x27;) {\n    ++start;\n    --end;\n  }\n  bool escaped = false;\n  for (size_t i = start; i + 1 &lt; end; ++i) {\n    if (escaped) {\n      escaped = false;\n      if (str[i] == &#x27;n&#x27;) {\n        lines.push_back(str.substr(start, i - start - 1));\n        start = i + 1;\n      }\n    } else {\n      escaped = str[i] == &#x27;\\\\&#x27;;\n    }\n  }\n  lines.push_back(str.substr(start, end - start));\n  return lines;\n}\n\n}  // namespace\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   lhs_expression: &quot;foo&quot;\n//   rhs_expression: &quot;bar&quot;\n//   lhs_value:      &quot;5&quot;\n//   rhs_value:      &quot;6&quot;\n//\n// The ignoring_case parameter is true if and only if the assertion is a\n// *_STRCASEEQ*.  When it&#x27;s true, the string &quot;Ignoring case&quot; will\n// be inserted into the message.\nAssertionResult EqFailure(const char* lhs_expression,\n                          const char* rhs_expression,\n                          const std::string&amp; lhs_value,\n                          const std::string&amp; rhs_value, bool ignoring_case) {\n  Message msg;\n  msg &lt;&lt; &quot;Expected equality of these values:&quot;;\n  msg &lt;&lt; &quot;\\n  &quot; &lt;&lt; lhs_expression;\n  if (lhs_value != lhs_expression) {\n    msg &lt;&lt; &quot;\\n    Which is: &quot; &lt;&lt; lhs_value;\n  }\n  msg &lt;&lt; &quot;\\n  &quot; &lt;&lt; rhs_expression;\n  if (rhs_value != rhs_expression) {\n    msg &lt;&lt; &quot;\\n    Which is: &quot; &lt;&lt; rhs_value;\n  }\n\n  if (ignoring_case) {\n    msg &lt;&lt; &quot;\\nIgnoring case&quot;;\n  }\n\n  if (!lhs_value.empty() &amp;&amp; !rhs_value.empty()) {\n    const std::vector&lt;std::string&gt; lhs_lines = SplitEscapedString(lhs_value);\n    const std::vector&lt;std::string&gt; rhs_lines = SplitEscapedString(rhs_value);\n    if (lhs_lines.size() &gt; 1 || rhs_lines.size() &gt; 1) {\n      msg &lt;&lt; &quot;\\nWith diff:\\n&quot;\n          &lt;&lt; edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\n    }\n  }\n\n  return AssertionFailure() &lt;&lt; msg;\n}\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nstd::string GetBoolAssertionFailureMessage(\n    const AssertionResult&amp; assertion_result, const char* expression_text,\n    const char* actual_predicate_value, const char* expected_predicate_value) {\n  const char* actual_message = assertion_result.message();\n  Message msg;\n  msg &lt;&lt; &quot;Value of: &quot; &lt;&lt; expression_text\n      &lt;&lt; &quot;\\n  Actual: &quot; &lt;&lt; actual_predicate_value;\n  if (actual_message[0] != &#x27;\\0&#x27;) msg &lt;&lt; &quot; (&quot; &lt;&lt; actual_message &lt;&lt; &quot;)&quot;;\n  msg &lt;&lt; &quot;\\nExpected: &quot; &lt;&lt; expected_predicate_value;\n  return msg.GetString();\n}\n\n// Helper function for implementing ASSERT_NEAR.\nAssertionResult DoubleNearPredFormat(const char* expr1, const char* expr2,\n                                     const char* abs_error_expr, double val1,\n                                     double val2, double abs_error) {\n  const double diff = fabs(val1 - val2);\n  if (diff &lt;= abs_error) return AssertionSuccess();\n\n  // Find the value which is closest to zero.\n  const double min_abs = std::min(fabs(val1), fabs(val2));\n  // Find the distance to the next double from that value.\n  const double epsilon =\n      nextafter(min_abs, std::numeric_limits&lt;double&gt;::infinity()) - min_abs;\n  // Detect the case where abs_error is so small that EXPECT_NEAR is\n  // effectively the same as EXPECT_EQUAL, and give an informative error\n  // message so that the situation can be more easily understood without\n  // requiring exotic floating-point knowledge.\n  // Don&#x27;t do an epsilon check if abs_error is zero because that implies\n  // that an equality check was actually intended.\n  if (!(std::isnan)(val1) &amp;&amp; !(std::isnan)(val2) &amp;&amp; abs_error &gt; 0 &amp;&amp;\n      abs_error &lt; epsilon) {\n    return AssertionFailure()\n           &lt;&lt; &quot;The difference between &quot; &lt;&lt; expr1 &lt;&lt; &quot; and &quot; &lt;&lt; expr2 &lt;&lt; &quot; is &quot;\n           &lt;&lt; diff &lt;&lt; &quot;, where\\n&quot;\n           &lt;&lt; expr1 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val1 &lt;&lt; &quot;,\\n&quot;\n           &lt;&lt; expr2 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val2 &lt;&lt; &quot;.\\nThe abs_error parameter &quot;\n           &lt;&lt; abs_error_expr &lt;&lt; &quot; evaluates to &quot; &lt;&lt; abs_error\n           &lt;&lt; &quot; which is smaller than the minimum distance between doubles for &quot;\n              &quot;numbers of this magnitude which is &quot;\n           &lt;&lt; epsilon\n           &lt;&lt; &quot;, thus making this EXPECT_NEAR check equivalent to &quot;\n              &quot;EXPECT_EQUAL. Consider using EXPECT_DOUBLE_EQ instead.&quot;;\n  }\n  return AssertionFailure()\n         &lt;&lt; &quot;The difference between &quot; &lt;&lt; expr1 &lt;&lt; &quot; and &quot; &lt;&lt; expr2 &lt;&lt; &quot; is &quot;\n         &lt;&lt; diff &lt;&lt; &quot;, which exceeds &quot; &lt;&lt; abs_error_expr &lt;&lt; &quot;, where\\n&quot;\n         &lt;&lt; expr1 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val1 &lt;&lt; &quot;,\\n&quot;\n         &lt;&lt; expr2 &lt;&lt; &quot; evaluates to &quot; &lt;&lt; val2 &lt;&lt; &quot;, and\\n&quot;\n         &lt;&lt; abs_error_expr &lt;&lt; &quot; evaluates to &quot; &lt;&lt; abs_error &lt;&lt; &quot;.&quot;;\n}\n\n// Helper template for implementing FloatLE() and DoubleLE().\ntemplate &lt;typename RawType&gt;\nAssertionResult FloatingPointLE(const char* expr1, const char* expr2,\n                                RawType val1, RawType val2) {\n  // Returns success if val1 is less than val2,\n  if (val1 &lt; val2) {\n    return AssertionSuccess();\n  }\n\n  // or if val1 is almost equal to val2.\n  const FloatingPoint&lt;RawType&gt; lhs(val1), rhs(val2);\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  // Note that the above two checks will both fail if either val1 or\n  // val2 is NaN, as the IEEE floating-point standard requires that\n  // any predicate involving a NaN must return false.\n\n  ::std::stringstream val1_ss;\n  val1_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n          &lt;&lt; val1;\n\n  ::std::stringstream val2_ss;\n  val2_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)\n          &lt;&lt; val2;\n\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; expr1 &lt;&lt; &quot;) &lt;= (&quot; &lt;&lt; expr2 &lt;&lt; &quot;)\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; StringStreamToString(&amp;val1_ss) &lt;&lt; &quot; vs &quot;\n         &lt;&lt; StringStreamToString(&amp;val2_ss);\n}\n\n}  // namespace internal\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nAssertionResult FloatLE(const char* expr1, const char* expr2, float val1,\n                        float val2) {\n  return internal::FloatingPointLE&lt;float&gt;(expr1, expr2, val1, val2);\n}\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nAssertionResult DoubleLE(const char* expr1, const char* expr2, double val1,\n                         double val2) {\n  return internal::FloatingPointLE&lt;double&gt;(expr1, expr2, val1, val2);\n}\n\nnamespace internal {\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\nAssertionResult CmpHelperSTREQ(const char* lhs_expression,\n                               const char* rhs_expression, const char* lhs,\n                               const char* rhs) {\n  if (String::CStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), false);\n}\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\nAssertionResult CmpHelperSTRCASEEQ(const char* lhs_expression,\n                                   const char* rhs_expression, const char* lhs,\n                                   const char* rhs) {\n  if (String::CaseInsensitiveCStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), true);\n}\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\nAssertionResult CmpHelperSTRNE(const char* s1_expression,\n                               const char* s2_expression, const char* s1,\n                               const char* s2) {\n  if (!String::CStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  } else {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n           &lt;&lt; &quot;), actual: \\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; vs \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot;;\n  }\n}\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\nAssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                   const char* s2_expression, const char* s1,\n                                   const char* s2) {\n  if (!String::CaseInsensitiveCStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  } else {\n    return AssertionFailure()\n           &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n           &lt;&lt; &quot;) (ignoring case), actual: \\&quot;&quot; &lt;&lt; s1 &lt;&lt; &quot;\\&quot; vs \\&quot;&quot; &lt;&lt; s2 &lt;&lt; &quot;\\&quot;&quot;;\n  }\n}\n\n}  // namespace internal\n\nnamespace {\n\n// Helper functions for implementing IsSubString() and IsNotSubstring().\n\n// This group of overloaded functions return true if and only if needle\n// is a substring of haystack.  NULL is considered a substring of\n// itself only.\n\nbool IsSubstringPred(const char* needle, const char* haystack) {\n  if (needle == nullptr || haystack == nullptr) return needle == haystack;\n\n  return strstr(haystack, needle) != nullptr;\n}\n\nbool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {\n  if (needle == nullptr || haystack == nullptr) return needle == haystack;\n\n  return wcsstr(haystack, needle) != nullptr;\n}\n\n// StringType here can be either ::std::string or ::std::wstring.\ntemplate &lt;typename StringType&gt;\nbool IsSubstringPred(const StringType&amp; needle, const StringType&amp; haystack) {\n  return haystack.find(needle) != StringType::npos;\n}\n\n// This function implements either IsSubstring() or IsNotSubstring(),\n// depending on the value of the expected_to_be_substring parameter.\n// StringType here can be const char*, const wchar_t*, ::std::string,\n// or ::std::wstring.\ntemplate &lt;typename StringType&gt;\nAssertionResult IsSubstringImpl(bool expected_to_be_substring,\n                                const char* needle_expr,\n                                const char* haystack_expr,\n                                const StringType&amp; needle,\n                                const StringType&amp; haystack) {\n  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)\n    return AssertionSuccess();\n\n  const bool is_wide_string = sizeof(needle[0]) &gt; 1;\n  const char* const begin_string_quote = is_wide_string ? &quot;L\\&quot;&quot; : &quot;\\&quot;&quot;;\n  return AssertionFailure()\n         &lt;&lt; &quot;Value of: &quot; &lt;&lt; needle_expr &lt;&lt; &quot;\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; begin_string_quote &lt;&lt; needle &lt;&lt; &quot;\\&quot;\\n&quot;\n         &lt;&lt; &quot;Expected: &quot; &lt;&lt; (expected_to_be_substring ? &quot;&quot; : &quot;not &quot;)\n         &lt;&lt; &quot;a substring of &quot; &lt;&lt; haystack_expr &lt;&lt; &quot;\\n&quot;\n         &lt;&lt; &quot;Which is: &quot; &lt;&lt; begin_string_quote &lt;&lt; haystack &lt;&lt; &quot;\\&quot;&quot;;\n}\n\n}  // namespace\n\n// IsSubstring() and IsNotSubstring() check whether needle is a\n// substring of haystack (NULL is considered a substring of itself\n// only), and return an appropriate error message when they fail.\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const char* needle, const char* haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const wchar_t* needle, const wchar_t* haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr, const char* needle,\n                               const char* haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr, const wchar_t* needle,\n                               const wchar_t* haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const ::std::string&amp; needle,\n                            const ::std::string&amp; haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr,\n                               const ::std::string&amp; needle,\n                               const ::std::string&amp; haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n\n#if GTEST_HAS_STD_WSTRING\nAssertionResult IsSubstring(const char* needle_expr, const char* haystack_expr,\n                            const ::std::wstring&amp; needle,\n                            const ::std::wstring&amp; haystack) {\n  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);\n}\n\nAssertionResult IsNotSubstring(const char* needle_expr,\n                               const char* haystack_expr,\n                               const ::std::wstring&amp; needle,\n                               const ::std::wstring&amp; haystack) {\n  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n#ifdef GTEST_OS_WINDOWS\n\nnamespace {\n\n// Helper function for IsHRESULT{SuccessFailure} predicates\nAssertionResult HRESULTFailureHelper(const char* expr, const char* expected,\n                                     long hr) {  // NOLINT\n#if defined(GTEST_OS_WINDOWS_MOBILE) || defined(GTEST_OS_WINDOWS_TV_TITLE)\n\n  // Windows CE doesn&#x27;t support FormatMessage.\n  const char error_text[] = &quot;&quot;;\n\n#else\n\n  // Looks up the human-readable system message for the HRESULT code\n  // and since we&#x27;re not passing any params to FormatMessage, we don&#x27;t\n  // want inserts expanded.\n  const DWORD kFlags =\n      FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;\n  const DWORD kBufSize = 4096;\n  // Gets the system&#x27;s human readable message string for this HRESULT.\n  char error_text[kBufSize] = {&#x27;\\0&#x27;};\n  DWORD message_length = ::FormatMessageA(kFlags,\n                                          0,  // no source, we&#x27;re asking system\n                                          static_cast&lt;DWORD&gt;(hr),  // the error\n                                          0,  // no line width restrictions\n                                          error_text,  // output buffer\n                                          kBufSize,    // buf size\n                                          nullptr);  // no arguments for inserts\n  // Trims tailing white space (FormatMessage leaves a trailing CR-LF)\n  for (; message_length &amp;&amp; IsSpace(error_text[message_length - 1]);\n       --message_length) {\n    error_text[message_length - 1] = &#x27;\\0&#x27;;\n  }\n\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n  const std::string error_hex(&quot;0x&quot; + String::FormatHexInt(hr));\n  return ::testing::AssertionFailure()\n         &lt;&lt; &quot;Expected: &quot; &lt;&lt; expr &lt;&lt; &quot; &quot; &lt;&lt; expected &lt;&lt; &quot;.\\n&quot;\n         &lt;&lt; &quot;  Actual: &quot; &lt;&lt; error_hex &lt;&lt; &quot; &quot; &lt;&lt; error_text &lt;&lt; &quot;\\n&quot;;\n}\n\n}  // namespace\n\nAssertionResult IsHRESULTSuccess(const char* expr, long hr) {  // NOLINT\n  if (SUCCEEDED(hr)) {\n    return AssertionSuccess();\n  }\n  return HRESULTFailureHelper(expr, &quot;succeeds&quot;, hr);\n}\n\nAssertionResult IsHRESULTFailure(const char* expr, long hr) {  // NOLINT\n  if (FAILED(hr)) {\n    return AssertionSuccess();\n  }\n  return HRESULTFailureHelper(expr, &quot;fails&quot;, hr);\n}\n\n#endif  // GTEST_OS_WINDOWS\n\n// Utility functions for encoding Unicode text (wide strings) in\n// UTF-8.\n\n// A Unicode code-point can have up to 21 bits, and is encoded in UTF-8\n// like this:\n//\n// Code-point length   Encoding\n//   0 -  7 bits       0xxxxxxx\n//   8 - 11 bits       110xxxxx 10xxxxxx\n//  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx\n//  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n// The maximum code-point a one-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint1 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; 7) - 1;\n\n// The maximum code-point a two-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint2 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (5 + 6)) - 1;\n\n// The maximum code-point a three-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint3 =\n    (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (4 + 2 * 6)) - 1;\n\n// The maximum code-point a four-byte UTF-8 sequence can represent.\nconstexpr uint32_t kMaxCodePoint4 =\n    (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (3 + 3 * 6)) - 1;\n\n// Chops off the n lowest bits from a bit pattern.  Returns the n\n// lowest bits.  As a side effect, the original bit pattern will be\n// shifted to the right by n bits.\ninline uint32_t ChopLowBits(uint32_t* bits, int n) {\n  const uint32_t low_bits = *bits &amp; ((static_cast&lt;uint32_t&gt;(1) &lt;&lt; n) - 1);\n  *bits &gt;&gt;= n;\n  return low_bits;\n}\n\n// Converts a Unicode code point to a narrow string in UTF-8 encoding.\n// code_point parameter is of type uint32_t because wchar_t may not be\n// wide enough to contain a code point.\n// If the code_point is not a valid Unicode code point\n// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted\n// to &quot;(Invalid Unicode 0xXXXXXXXX)&quot;.\nstd::string CodePointToUtf8(uint32_t code_point) {\n  if (code_point &gt; kMaxCodePoint4) {\n    return &quot;(Invalid Unicode 0x&quot; + String::FormatHexUInt32(code_point) + &quot;)&quot;;\n  }\n\n  char str[5];  // Big enough for the largest valid code point.\n  if (code_point &lt;= kMaxCodePoint1) {\n    str[1] = &#x27;\\0&#x27;;\n    str[0] = static_cast&lt;char&gt;(code_point);  // 0xxxxxxx\n  } else if (code_point &lt;= kMaxCodePoint2) {\n    str[2] = &#x27;\\0&#x27;;\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xC0 | code_point);                   // 110xxxxx\n  } else if (code_point &lt;= kMaxCodePoint3) {\n    str[3] = &#x27;\\0&#x27;;\n    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xE0 | code_point);                   // 1110xxxx\n  } else {  // code_point &lt;= kMaxCodePoint4\n    str[4] = &#x27;\\0&#x27;;\n    str[3] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx\n    str[0] = static_cast&lt;char&gt;(0xF0 | code_point);                   // 11110xxx\n  }\n  return str;\n}\n\n// The following two functions only make sense if the system\n// uses UTF-16 for wide string encoding. All supported systems\n// with 16 bit wchar_t (Windows, Cygwin) do use UTF-16.\n\n// Determines if the arguments constitute UTF-16 surrogate pair\n// and thus should be combined into a single Unicode code point\n// using CreateCodePointFromUtf16SurrogatePair.\ninline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {\n  return sizeof(wchar_t) == 2 &amp;&amp; (first &amp; 0xFC00) == 0xD800 &amp;&amp;\n         (second &amp; 0xFC00) == 0xDC00;\n}\n\n// Creates a Unicode code point from UTF16 surrogate pair.\ninline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,\n                                                      wchar_t second) {\n  const auto first_u = static_cast&lt;uint32_t&gt;(first);\n  const auto second_u = static_cast&lt;uint32_t&gt;(second);\n  const uint32_t mask = (1 &lt;&lt; 10) - 1;\n  return (sizeof(wchar_t) == 2)\n             ? (((first_u &amp; mask) &lt;&lt; 10) | (second_u &amp; mask)) + 0x10000\n             :\n             // This function should not be called when the condition is\n             // false, but we provide a sensible default in case it is.\n             first_u;\n}\n\n// Converts a wide string to a narrow string in UTF-8 encoding.\n// The wide string is assumed to have the following encoding:\n//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)\n//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)\n// Parameter str points to a null-terminated wide string.\n// Parameter num_chars may additionally limit the number\n// of wchar_t characters processed. -1 is used when the entire string\n// should be processed.\n// If the string contains code points that are not valid Unicode code points\n// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output\n// as &#x27;(Invalid Unicode 0xXXXXXXXX)&#x27;. If the string is in UTF16 encoding\n// and contains invalid UTF-16 surrogate pairs, values in those pairs\n// will be encoded as individual Unicode characters from Basic Normal Plane.\nstd::string WideStringToUtf8(const wchar_t* str, int num_chars) {\n  if (num_chars == -1) num_chars = static_cast&lt;int&gt;(wcslen(str));\n\n  ::std::stringstream stream;\n  for (int i = 0; i &lt; num_chars; ++i) {\n    uint32_t unicode_code_point;\n\n    if (str[i] == L&#x27;\\0&#x27;) {\n      break;\n    } else if (i + 1 &lt; num_chars &amp;&amp; IsUtf16SurrogatePair(str[i], str[i + 1])) {\n      unicode_code_point =\n          CreateCodePointFromUtf16SurrogatePair(str[i], str[i + 1]);\n      i++;\n    } else {\n      unicode_code_point = static_cast&lt;uint32_t&gt;(str[i]);\n    }\n\n    stream &lt;&lt; CodePointToUtf8(unicode_code_point);\n  }\n  return StringStreamToString(&amp;stream);\n}\n\n// Converts a wide C string to an std::string using the UTF-8 encoding.\n// NULL will be converted to &quot;(null)&quot;.\nstd::string String::ShowWideCString(const wchar_t* wide_c_str) {\n  if (wide_c_str == nullptr) return &quot;(null)&quot;;\n\n  return internal::WideStringToUtf8(wide_c_str, -1);\n}\n\n// Compares two wide C strings.  Returns true if and only if they have the\n// same content.\n//\n// Unlike wcscmp(), this function can handle NULL argument(s).  A NULL\n// C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n  return wcscmp(lhs, rhs) == 0;\n}\n\n// Helper function for *_STREQ on wide strings.\nAssertionResult CmpHelperSTREQ(const char* lhs_expression,\n                               const char* rhs_expression, const wchar_t* lhs,\n                               const wchar_t* rhs) {\n  if (String::WideCStringEquals(lhs, rhs)) {\n    return AssertionSuccess();\n  }\n\n  return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs),\n                   PrintToString(rhs), false);\n}\n\n// Helper function for *_STRNE on wide strings.\nAssertionResult CmpHelperSTRNE(const char* s1_expression,\n                               const char* s2_expression, const wchar_t* s1,\n                               const wchar_t* s2) {\n  if (!String::WideCStringEquals(s1, s2)) {\n    return AssertionSuccess();\n  }\n\n  return AssertionFailure()\n         &lt;&lt; &quot;Expected: (&quot; &lt;&lt; s1_expression &lt;&lt; &quot;) != (&quot; &lt;&lt; s2_expression\n         &lt;&lt; &quot;), actual: &quot; &lt;&lt; PrintToString(s1) &lt;&lt; &quot; vs &quot; &lt;&lt; PrintToString(s2);\n}\n\n// Compares two C strings, ignoring case.  Returns true if and only if they have\n// the same content.\n//\n// Unlike strcasecmp(), this function can handle NULL argument(s).  A\n// NULL C string is considered different to any non-NULL C string,\n// including the empty string.\nbool String::CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n  if (rhs == nullptr) return false;\n  return posix::StrCaseCmp(lhs, rhs) == 0;\n}\n\n// Compares two wide C strings, ignoring case.  Returns true if and only if they\n// have the same content.\n//\n// Unlike wcscasecmp(), this function can handle NULL argument(s).\n// A NULL C string is considered different to any non-NULL wide C string,\n// including the empty string.\n// NB: The implementations on different platforms slightly differ.\n// On windows, this method uses _wcsicmp which compares according to LC_CTYPE\n// environment variable. On GNU platform this method uses wcscasecmp\n// which compares according to LC_CTYPE category of the current locale.\n// On MacOS X, it uses towlower, which also uses LC_CTYPE category of the\n// current locale.\nbool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,\n                                              const wchar_t* rhs) {\n  if (lhs == nullptr) return rhs == nullptr;\n\n  if (rhs == nullptr) return false;\n\n#ifdef GTEST_OS_WINDOWS\n  return _wcsicmp(lhs, rhs) == 0;\n#elif defined(GTEST_OS_LINUX) &amp;&amp; !defined(GTEST_OS_LINUX_ANDROID)\n  return wcscasecmp(lhs, rhs) == 0;\n#else\n  // Android, Mac OS X and Cygwin don&#x27;t define wcscasecmp.\n  // Other unknown OSes may not define it either.\n  wint_t left, right;\n  do {\n    left = towlower(static_cast&lt;wint_t&gt;(*lhs++));\n    right = towlower(static_cast&lt;wint_t&gt;(*rhs++));\n  } while (left &amp;&amp; left == right);\n  return left == right;\n#endif  // OS selector\n}\n\n// Returns true if and only if str ends with the given suffix, ignoring case.\n// Any string is considered to end with an empty suffix.\nbool String::EndsWithCaseInsensitive(const std::string&amp; str,\n                                     const std::string&amp; suffix) {\n  const size_t str_len = str.length();\n  const size_t suffix_len = suffix.length();\n  return (str_len &gt;= suffix_len) &amp;&amp;\n         CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,\n                                      suffix.c_str());\n}\n\n// Formats an int value as &quot;%02d&quot;.\nstd::string String::FormatIntWidth2(int value) {\n  return FormatIntWidthN(value, 2);\n}\n\n// Formats an int value to given width with leading zeros.\nstd::string String::FormatIntWidthN(int value, int width) {\n  std::stringstream ss;\n  ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(width) &lt;&lt; value;\n  return ss.str();\n}\n\n// Formats an int value as &quot;%X&quot;.\nstd::string String::FormatHexUInt32(uint32_t value) {\n  std::stringstream ss;\n  ss &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; value;\n  return ss.str();\n}\n\n// Formats an int value as &quot;%X&quot;.\nstd::string String::FormatHexInt(int value) {\n  return FormatHexUInt32(static_cast&lt;uint32_t&gt;(value));\n}\n\n// Formats a byte as &quot;%02X&quot;.\nstd::string String::FormatByte(unsigned char value) {\n  std::stringstream ss;\n  ss &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; std::uppercase\n     &lt;&lt; static_cast&lt;unsigned int&gt;(value);\n  return ss.str();\n}\n\n// Converts the buffer in a stringstream to an std::string, converting NUL\n// bytes to &quot;\\\\0&quot; along the way.\nstd::string StringStreamToString(::std::stringstream* ss) {\n  const ::std::string&amp; str = ss-&gt;str();\n  const char* const start = str.c_str();\n  const char* const end = start + str.length();\n\n  std::string result;\n  result.reserve(static_cast&lt;size_t&gt;(2 * (end - start)));\n  for (const char* ch = start; ch != end; ++ch) {\n    if (*ch == &#x27;\\0&#x27;) {\n      result += &quot;\\\\0&quot;;  // Replaces NUL with &quot;\\\\0&quot;;\n    } else {\n      result += *ch;\n    }\n  }\n\n  return result;\n}\n\n// Appends the user-supplied message to the Google-Test-generated message.\nstd::string AppendUserMessage(const std::string&amp; gtest_msg,\n                              const Message&amp; user_msg) {\n  // Appends the user message if it&#x27;s non-empty.\n  const std::string user_msg_string = user_msg.GetString();\n  if (user_msg_string.empty()) {\n    return gtest_msg;\n  }\n  if (gtest_msg.empty()) {\n    return user_msg_string;\n  }\n  return gtest_msg + &quot;\\n&quot; + user_msg_string;\n}\n\n}  // namespace internal\n\n// class TestResult\n\n// Creates an empty TestResult.\nTestResult::TestResult()\n    : death_test_count_(0), start_timestamp_(0), elapsed_time_(0) {}\n\n// D&#x27;tor.\nTestResult::~TestResult() = default;\n\n// Returns the i-th test part result among all the results. i can\n// range from 0 to total_part_count() - 1. If i is not in that range,\n// aborts the program.\nconst TestPartResult&amp; TestResult::GetTestPartResult(int i) const {\n  if (i &lt; 0 || i &gt;= total_part_count()) internal::posix::Abort();\n  return test_part_results_.at(static_cast&lt;size_t&gt;(i));\n}\n\n// Returns the i-th test property. i can range from 0 to\n// test_property_count() - 1. If i is not in that range, aborts the\n// program.\nconst TestProperty&amp; TestResult::GetTestProperty(int i) const {\n  if (i &lt; 0 || i &gt;= test_property_count()) internal::posix::Abort();\n  return test_properties_.at(static_cast&lt;size_t&gt;(i));\n}\n\n// Clears the test part results.\nvoid TestResult::ClearTestPartResults() { test_part_results_.clear(); }\n\n// Adds a test part result to the list.\nvoid TestResult::AddTestPartResult(const TestPartResult&amp; test_part_result) {\n  test_part_results_.push_back(test_part_result);\n}\n\n// Adds a test property to the list. If a property with the same key as the\n// supplied property is already represented, the value of this test_property\n// replaces the old value for that key.\nvoid TestResult::RecordProperty(const std::string&amp; xml_element,\n                                const TestProperty&amp; test_property) {\n  if (!ValidateTestProperty(xml_element, test_property)) {\n    return;\n  }\n  internal::MutexLock lock(&amp;test_properties_mutex_);\n  const std::vector&lt;TestProperty&gt;::iterator property_with_matching_key =\n      std::find_if(test_properties_.begin(), test_properties_.end(),\n                   internal::TestPropertyKeyIs(test_property.key()));\n  if (property_with_matching_key == test_properties_.end()) {\n    test_properties_.push_back(test_property);\n    return;\n  }\n  property_with_matching_key-&gt;SetValue(test_property.value());\n}\n\n// The list of reserved attributes used in the &lt;testsuites&gt; element of XML\n// output.\nstatic const char* const kReservedTestSuitesAttributes[] = {\n    &quot;disabled&quot;,    &quot;errors&quot;, &quot;failures&quot;, &quot;name&quot;,\n    &quot;random_seed&quot;, &quot;tests&quot;,  &quot;time&quot;,     &quot;timestamp&quot;};\n\n// The list of reserved attributes used in the &lt;testsuite&gt; element of XML\n// output.\nstatic const char* const kReservedTestSuiteAttributes[] = {\n    &quot;disabled&quot;, &quot;errors&quot;, &quot;failures&quot;,  &quot;name&quot;,\n    &quot;tests&quot;,    &quot;time&quot;,   &quot;timestamp&quot;, &quot;skipped&quot;};\n\n// The list of reserved attributes used in the &lt;testcase&gt; element of XML output.\nstatic const char* const kReservedTestCaseAttributes[] = {\n    &quot;classname&quot;,  &quot;name&quot;,        &quot;status&quot;, &quot;time&quot;,\n    &quot;type_param&quot;, &quot;value_param&quot;, &quot;file&quot;,   &quot;line&quot;};\n\n// Use a slightly different set for allowed output to ensure existing tests can\n// still RecordProperty(&quot;result&quot;) or RecordProperty(&quot;timestamp&quot;)\nstatic const char* const kReservedOutputTestCaseAttributes[] = {\n    &quot;classname&quot;,   &quot;name&quot;, &quot;status&quot;, &quot;time&quot;,   &quot;type_param&quot;,\n    &quot;value_param&quot;, &quot;file&quot;, &quot;line&quot;,   &quot;result&quot;, &quot;timestamp&quot;};\n\ntemplate &lt;size_t kSize&gt;\nstd::vector&lt;std::string&gt; ArrayAsVector(const char* const (&amp;array)[kSize]) {\n  return std::vector&lt;std::string&gt;(array, array + kSize);\n}\n\nstatic std::vector&lt;std::string&gt; GetReservedAttributesForElement(\n    const std::string&amp; xml_element) {\n  if (xml_element == &quot;testsuites&quot;) {\n    return ArrayAsVector(kReservedTestSuitesAttributes);\n  } else if (xml_element == &quot;testsuite&quot;) {\n    return ArrayAsVector(kReservedTestSuiteAttributes);\n  } else if (xml_element == &quot;testcase&quot;) {\n    return ArrayAsVector(kReservedTestCaseAttributes);\n  } else {\n    GTEST_CHECK_(false) &lt;&lt; &quot;Unrecognized xml_element provided: &quot; &lt;&lt; xml_element;\n  }\n  // This code is unreachable but some compilers may not realizes that.\n  return std::vector&lt;std::string&gt;();\n}\n\n#if GTEST_HAS_FILE_SYSTEM\n// TODO(jdesprez): Merge the two getReserved attributes once skip is improved\n// This function is only used when file systems are enabled.\nstatic std::vector&lt;std::string&gt; GetReservedOutputAttributesForElement(\n    const std::string&amp; xml_element) {\n  if (xml_element == &quot;testsuites&quot;) {\n    return ArrayAsVector(kReservedTestSuitesAttributes);\n  } else if (xml_element == &quot;testsuite&quot;) {\n    return ArrayAsVector(kReservedTestSuiteAttributes);\n  } else if (xml_element == &quot;testcase&quot;) {\n    return ArrayAsVector(kReservedOutputTestCaseAttributes);\n  } else {\n    GTEST_CHECK_(false) &lt;&lt; &quot;Unrecognized xml_element provided: &quot; &lt;&lt; xml_element;\n  }\n  // This code is unreachable but some compilers may not realizes that.\n  return std::vector&lt;std::string&gt;();\n}\n#endif\n\nstatic std::string FormatWordList(const std::vector&lt;std::string&gt;&amp; words) {\n  Message word_list;\n  for (size_t i = 0; i &lt; words.size(); ++i) {\n    if (i &gt; 0 &amp;&amp; words.size() &gt; 2) {\n      word_list &lt;&lt; &quot;, &quot;;\n    }\n    if (i == words.size() - 1) {\n      word_list &lt;&lt; &quot;and &quot;;\n    }\n    word_list &lt;&lt; &quot;&#x27;&quot; &lt;&lt; words[i] &lt;&lt; &quot;&#x27;&quot;;\n  }\n  return word_list.GetString();\n}\n\nstatic bool ValidateTestPropertyName(\n    const std::string&amp; property_name,\n    const std::vector&lt;std::string&gt;&amp; reserved_names) {\n  if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=\n      reserved_names.end()) {\n    ADD_FAILURE() &lt;&lt; &quot;Reserved key used in RecordProperty(): &quot; &lt;&lt; property_name\n                  &lt;&lt; &quot; (&quot; &lt;&lt; FormatWordList(reserved_names)\n                  &lt;&lt; &quot; are reserved by &quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot;)&quot;;\n    return false;\n  }\n  return true;\n}\n\n// Adds a failure if the key is a reserved attribute of the element named\n// xml_element.  Returns true if the property is valid.\nbool TestResult::ValidateTestProperty(const std::string&amp; xml_element,\n                                      const TestProperty&amp; test_property) {\n  return ValidateTestPropertyName(test_property.key(),\n                                  GetReservedAttributesForElement(xml_element));\n}\n\n// Clears the object.\nvoid TestResult::Clear() {\n  test_part_results_.clear();\n  test_properties_.clear();\n  death_test_count_ = 0;\n  elapsed_time_ = 0;\n}\n\n// Returns true off the test part was skipped.\nstatic bool TestPartSkipped(const TestPartResult&amp; result) {\n  return result.skipped();\n}\n\n// Returns true if and only if the test was skipped.\nbool TestResult::Skipped() const {\n  return !Failed() &amp;&amp; CountIf(test_part_results_, TestPartSkipped) &gt; 0;\n}\n\n// Returns true if and only if the test failed.\nbool TestResult::Failed() const {\n  for (int i = 0; i &lt; total_part_count(); ++i) {\n    if (GetTestPartResult(i).failed()) return true;\n  }\n  return false;\n}\n\n// Returns true if and only if the test part fatally failed.\nstatic bool TestPartFatallyFailed(const TestPartResult&amp; result) {\n  return result.fatally_failed();\n}\n\n// Returns true if and only if the test fatally failed.\nbool TestResult::HasFatalFailure() const {\n  return CountIf(test_part_results_, TestPartFatallyFailed) &gt; 0;\n}\n\n// Returns true if and only if the test part non-fatally failed.\nstatic bool TestPartNonfatallyFailed(const TestPartResult&amp; result) {\n  return result.nonfatally_failed();\n}\n\n// Returns true if and only if the test has a non-fatal failure.\nbool TestResult::HasNonfatalFailure() const {\n  return CountIf(test_part_results_, TestPartNonfatallyFailed) &gt; 0;\n}\n\n// Gets the number of all test parts.  This is the sum of the number\n// of successful test parts and the number of failed test parts.\nint TestResult::total_part_count() const {\n  return static_cast&lt;int&gt;(test_part_results_.size());\n}\n\n// Returns the number of the test properties.\nint TestResult::test_property_count() const {\n  return static_cast&lt;int&gt;(test_properties_.size());\n}\n\n// class Test\n\n// Creates a Test object.\n\n// The c&#x27;tor saves the states of all flags.\nTest::Test() : gtest_flag_saver_(new GTEST_FLAG_SAVER_) {}\n\n// The d&#x27;tor restores the states of all flags.  The actual work is\n// done by the d&#x27;tor of the gtest_flag_saver_ field, and thus not\n// visible here.\nTest::~Test() = default;\n\n// Sets up the test fixture.\n//\n// A sub-class may override this.\nvoid Test::SetUp() {}\n\n// Tears down the test fixture.\n//\n// A sub-class may override this.\nvoid Test::TearDown() {}\n\n// Allows user supplied key value pairs to be recorded for later output.\nvoid Test::RecordProperty(const std::string&amp; key, const std::string&amp; value) {\n  UnitTest::GetInstance()-&gt;RecordProperty(key, value);\n}\n\nnamespace internal {\n\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string&amp; message) {\n  // This function is a friend of UnitTest and as such has access to\n  // AddTestPartResult.\n  UnitTest::GetInstance()-&gt;AddTestPartResult(\n      result_type,\n      nullptr,  // No info about the source file where the exception occurred.\n      -1,       // We have no info on which line caused the exception.\n      message,\n      &quot;&quot;);  // No stack trace, either.\n}\n\n}  // namespace internal\n\n// Google Test requires all tests in the same test suite to use the same test\n// fixture class.  This function checks if the current test has the\n// same fixture class as the first test in the current test suite.  If\n// yes, it returns true; otherwise it generates a Google Test failure and\n// returns false.\nbool Test::HasSameFixtureClass() {\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  const TestSuite* const test_suite = impl-&gt;current_test_suite();\n\n  // Info about the first test in the current test suite.\n  const TestInfo* const first_test_info = test_suite-&gt;test_info_list()[0];\n  const internal::TypeId first_fixture_id = first_test_info-&gt;fixture_class_id_;\n  const char* const first_test_name = first_test_info-&gt;name();\n\n  // Info about the current test.\n  const TestInfo* const this_test_info = impl-&gt;current_test_info();\n  const internal::TypeId this_fixture_id = this_test_info-&gt;fixture_class_id_;\n  const char* const this_test_name = this_test_info-&gt;name();\n\n  if (this_fixture_id != first_fixture_id) {\n    // Is the first test defined using TEST?\n    const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();\n    // Is this test defined using TEST?\n    const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();\n\n    if (first_is_TEST || this_is_TEST) {\n      // Both TEST and TEST_F appear in same test suite, which is incorrect.\n      // Tell the user how to fix this.\n\n      // Gets the name of the TEST and the name of the TEST_F.  Note\n      // that first_is_TEST and this_is_TEST cannot both be true, as\n      // the fixture IDs are different for the two tests.\n      const char* const TEST_name =\n          first_is_TEST ? first_test_name : this_test_name;\n      const char* const TEST_F_name =\n          first_is_TEST ? this_test_name : first_test_name;\n\n      ADD_FAILURE()\n          &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n          &lt;&lt; &quot;class, so mixing TEST_F and TEST in the same test suite is\\n&quot;\n          &lt;&lt; &quot;illegal.  In test suite &quot; &lt;&lt; this_test_info-&gt;test_suite_name()\n          &lt;&lt; &quot;,\\n&quot;\n          &lt;&lt; &quot;test &quot; &lt;&lt; TEST_F_name &lt;&lt; &quot; is defined using TEST_F but\\n&quot;\n          &lt;&lt; &quot;test &quot; &lt;&lt; TEST_name &lt;&lt; &quot; is defined using TEST.  You probably\\n&quot;\n          &lt;&lt; &quot;want to change the TEST to TEST_F or move it to another test\\n&quot;\n          &lt;&lt; &quot;case.&quot;;\n    } else {\n      // Two fixture classes with the same name appear in two different\n      // namespaces, which is not allowed. Tell the user how to fix this.\n      ADD_FAILURE()\n          &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n          &lt;&lt; &quot;class.  However, in test suite &quot;\n          &lt;&lt; this_test_info-&gt;test_suite_name() &lt;&lt; &quot;,\\n&quot;\n          &lt;&lt; &quot;you defined test &quot; &lt;&lt; first_test_name &lt;&lt; &quot; and test &quot;\n          &lt;&lt; this_test_name &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; &quot;using two different test fixture classes.  This can happen if\\n&quot;\n          &lt;&lt; &quot;the two classes are from different namespaces or translation\\n&quot;\n          &lt;&lt; &quot;units and have the same name.  You should probably rename one\\n&quot;\n          &lt;&lt; &quot;of the classes to put the tests into different test suites.&quot;;\n    }\n    return false;\n  }\n\n  return true;\n}\n\nnamespace internal {\n\n#if GTEST_HAS_EXCEPTIONS\n\n// Adds an &quot;exception thrown&quot; fatal failure to the current test.\nstatic std::string FormatCxxExceptionMessage(const char* description,\n                                             const char* location) {\n  Message message;\n  if (description != nullptr) {\n    message &lt;&lt; &quot;C++ exception with description \\&quot;&quot; &lt;&lt; description &lt;&lt; &quot;\\&quot;&quot;;\n  } else {\n    message &lt;&lt; &quot;Unknown C++ exception&quot;;\n  }\n  message &lt;&lt; &quot; thrown in &quot; &lt;&lt; location &lt;&lt; &quot;.&quot;;\n\n  return message.GetString();\n}\n\nstatic std::string PrintTestPartResultToString(\n    const TestPartResult&amp; test_part_result);\n\nGoogleTestFailureException::GoogleTestFailureException(\n    const TestPartResult&amp; failure)\n    : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// We put these helper functions in the internal namespace as IBM&#x27;s xlC\n// compiler rejects the code if they were declared static.\n\n// Runs the given method and handles SEH exceptions it throws, when\n// SEH is supported; returns the 0-value for type Result in case of an\n// SEH exception.  (Microsoft compilers cannot handle SEH and C++\n// exceptions in the same function.  Therefore, we provide a separate\n// wrapper function for handling SEH exceptions.)\ntemplate &lt;class T, typename Result&gt;\nResult HandleSehExceptionsInMethodIfSupported(T* object, Result (T::*method)(),\n                                              const char* location) {\n#if GTEST_HAS_SEH\n  __try {\n    return (object-&gt;*method)();\n  } __except (internal::UnitTestOptions::GTestProcessSEH(  // NOLINT\n      GetExceptionCode(), location)) {\n    return static_cast&lt;Result&gt;(0);\n  }\n#else\n  (void)location;\n  return (object-&gt;*method)();\n#endif  // GTEST_HAS_SEH\n}\n\n// Runs the given method and catches and reports C++ and/or SEH-style\n// exceptions, if they are supported; returns the 0-value for type\n// Result in case of an SEH exception.\ntemplate &lt;class T, typename Result&gt;\nResult HandleExceptionsInMethodIfSupported(T* object, Result (T::*method)(),\n                                           const char* location) {\n  // NOTE: The user code can affect the way in which Google Test handles\n  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before\n  // RUN_ALL_TESTS() starts. It is technically possible to check the flag\n  // after the exception is caught and either report or re-throw the\n  // exception based on the flag&#x27;s value:\n  //\n  // try {\n  //   // Perform the test method.\n  // } catch (...) {\n  //   if (GTEST_FLAG_GET(catch_exceptions))\n  //     // Report the exception as failure.\n  //   else\n  //     throw;  // Re-throws the original exception.\n  // }\n  //\n  // However, the purpose of this flag is to allow the program to drop into\n  // the debugger when the exception is thrown. On most platforms, once the\n  // control enters the catch block, the exception origin information is\n  // lost and the debugger will stop the program at the point of the\n  // re-throw in this function -- instead of at the point of the original\n  // throw statement in the code under test.  For this reason, we perform\n  // the check early, sacrificing the ability to affect Google Test&#x27;s\n  // exception handling in the method where the exception is thrown.\n  if (internal::GetUnitTestImpl()-&gt;catch_exceptions()) {\n#if GTEST_HAS_EXCEPTIONS\n    try {\n      return HandleSehExceptionsInMethodIfSupported(object, method, location);\n    } catch (const AssertionException&amp;) {  // NOLINT\n      // This failure was reported already.\n    } catch (const internal::GoogleTestFailureException&amp;) {  // NOLINT\n      // This exception type can only be thrown by a failed Google\n      // Test assertion with the intention of letting another testing\n      // framework catch it.  Therefore we just re-throw it.\n      throw;\n    } catch (const std::exception&amp; e) {  // NOLINT\n      internal::ReportFailureInUnknownLocation(\n          TestPartResult::kFatalFailure,\n          FormatCxxExceptionMessage(e.what(), location));\n    } catch (...) {  // NOLINT\n      internal::ReportFailureInUnknownLocation(\n          TestPartResult::kFatalFailure,\n          FormatCxxExceptionMessage(nullptr, location));\n    }\n    return static_cast&lt;Result&gt;(0);\n#else\n    return HandleSehExceptionsInMethodIfSupported(object, method, location);\n#endif  // GTEST_HAS_EXCEPTIONS\n  } else {\n    return (object-&gt;*method)();\n  }\n}\n\n}  // namespace internal\n\n// Runs the test and updates the test result.\nvoid Test::Run() {\n  if (!HasSameFixtureClass()) return;\n\n  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::SetUp, &quot;SetUp()&quot;);\n  // We will run the test only if SetUp() was successful and didn&#x27;t call\n  // GTEST_SKIP().\n  if (!HasFatalFailure() &amp;&amp; !IsSkipped()) {\n    impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n    internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::TestBody,\n                                                  &quot;the test body&quot;);\n  }\n\n  // However, we want to clean up as much as possible.  Hence we will\n  // always call TearDown(), even if SetUp() or the test body has\n  // failed.\n  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::TearDown,\n                                                &quot;TearDown()&quot;);\n}\n\n// Returns true if and only if the current test has a fatal failure.\nbool Test::HasFatalFailure() {\n  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;HasFatalFailure();\n}\n\n// Returns true if and only if the current test has a non-fatal failure.\nbool Test::HasNonfatalFailure() {\n  return internal::GetUnitTestImpl()\n      -&gt;current_test_result()\n      -&gt;HasNonfatalFailure();\n}\n\n// Returns true if and only if the current test was skipped.\nbool Test::IsSkipped() {\n  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;Skipped();\n}\n\n// class TestInfo\n\n// Constructs a TestInfo object. It assumes ownership of the test factory\n// object.\nTestInfo::TestInfo(std::string a_test_suite_name, std::string a_name,\n                   const char* a_type_param, const char* a_value_param,\n                   internal::CodeLocation a_code_location,\n                   internal::TypeId fixture_class_id,\n                   internal::TestFactoryBase* factory)\n    : test_suite_name_(std::move(a_test_suite_name)),\n      name_(std::move(a_name)),\n      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),\n      value_param_(a_value_param ? new std::string(a_value_param) : nullptr),\n      location_(std::move(a_code_location)),\n      fixture_class_id_(fixture_class_id),\n      should_run_(false),\n      is_disabled_(false),\n      matches_filter_(false),\n      is_in_another_shard_(false),\n      factory_(factory),\n      result_() {}\n\n// Destructs a TestInfo object.\nTestInfo::~TestInfo() { delete factory_; }\n\nnamespace internal {\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_suite_name:  name of the test suite\n//   name:             name of the test\n//   type_param:       the name of the test&#x27;s type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param:      text representation of the test&#x27;s value parameter,\n//                     or NULL if this is not a value-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test suite\n//   tear_down_tc:     pointer to the function that tears down the test suite\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nTestInfo* MakeAndRegisterTestInfo(\n    std::string test_suite_name, const char* name, const char* type_param,\n    const char* value_param, CodeLocation code_location,\n    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,\n    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory) {\n  TestInfo* const test_info =\n      new TestInfo(std::move(test_suite_name), name, type_param, value_param,\n                   std::move(code_location), fixture_class_id, factory);\n  GetUnitTestImpl()-&gt;AddTestInfo(set_up_tc, tear_down_tc, test_info);\n  return test_info;\n}\n\nvoid ReportInvalidTestSuiteType(const char* test_suite_name,\n                                const CodeLocation&amp; code_location) {\n  Message errors;\n  errors\n      &lt;&lt; &quot;Attempted redefinition of test suite &quot; &lt;&lt; test_suite_name &lt;&lt; &quot;.\\n&quot;\n      &lt;&lt; &quot;All tests in the same test suite must use the same test fixture\\n&quot;\n      &lt;&lt; &quot;class.  However, in test suite &quot; &lt;&lt; test_suite_name &lt;&lt; &quot;, you tried\\n&quot;\n      &lt;&lt; &quot;to define a test using a fixture class different from the one\\n&quot;\n      &lt;&lt; &quot;used earlier. This can happen if the two fixture classes are\\n&quot;\n      &lt;&lt; &quot;from different namespaces and have the same name. You should\\n&quot;\n      &lt;&lt; &quot;probably rename one of the classes to put the tests into different\\n&quot;\n      &lt;&lt; &quot;test suites.&quot;;\n\n  GTEST_LOG_(ERROR) &lt;&lt; FormatFileLocation(code_location.file.c_str(),\n                                          code_location.line)\n                    &lt;&lt; &quot; &quot; &lt;&lt; errors.GetString();\n}\n\n// This method expands all parameterized tests registered with macros TEST_P\n// and INSTANTIATE_TEST_SUITE_P into regular tests and registers those.\n// This will be done just once during the program runtime.\nvoid UnitTestImpl::RegisterParameterizedTests() {\n  if (!parameterized_tests_registered_) {\n    parameterized_test_registry_.RegisterTests();\n    type_parameterized_test_registry_.CheckForInstantiations();\n    parameterized_tests_registered_ = true;\n  }\n}\n\n}  // namespace internal\n\n// Creates the test object, runs it, records its result, and then\n// deletes it.\nvoid TestInfo::Run() {\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n  if (!should_run_) {\n    if (is_disabled_ &amp;&amp; matches_filter_) repeater-&gt;OnTestDisabled(*this);\n    return;\n  }\n\n  // Tells UnitTest where to store test result.\n  UnitTest::GetInstance()-&gt;set_current_test_info(this);\n\n  // Notifies the unit test event listeners that a test is about to start.\n  repeater-&gt;OnTestStart(*this);\n  result_.set_start_timestamp(internal::GetTimeInMillis());\n  internal::Timer timer;\n  UnitTest::GetInstance()-&gt;UponLeavingGTest();\n\n  // Creates the test object.\n  Test* const test = internal::HandleExceptionsInMethodIfSupported(\n      factory_, &amp;internal::TestFactoryBase::CreateTest,\n      &quot;the test fixture&#x27;s constructor&quot;);\n\n  // Runs the test if the constructor didn&#x27;t generate a fatal failure or invoke\n  // GTEST_SKIP().\n  // Note that the object will not be null\n  if (!Test::HasFatalFailure() &amp;&amp; !Test::IsSkipped()) {\n    // This doesn&#x27;t throw as all user code that can throw are wrapped into\n    // exception handling code.\n    test-&gt;Run();\n  }\n\n  if (test != nullptr) {\n    // Deletes the test object.\n    UnitTest::GetInstance()-&gt;UponLeavingGTest();\n    internal::HandleExceptionsInMethodIfSupported(\n        test, &amp;Test::DeleteSelf_, &quot;the test fixture&#x27;s destructor&quot;);\n  }\n\n  result_.set_elapsed_time(timer.Elapsed());\n\n  // Notifies the unit test event listener that a test has just finished.\n  repeater-&gt;OnTestEnd(*this);\n\n  // Tells UnitTest to stop associating assertion results to this\n  // test.\n  UnitTest::GetInstance()-&gt;set_current_test_info(nullptr);\n}\n\n// Skip and records a skipped test result for this object.\nvoid TestInfo::Skip() {\n  if (!should_run_) return;\n\n  UnitTest::GetInstance()-&gt;set_current_test_info(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Notifies the unit test event listeners that a test is about to start.\n  repeater-&gt;OnTestStart(*this);\n\n  const TestPartResult test_part_result =\n      TestPartResult(TestPartResult::kSkip, this-&gt;file(), this-&gt;line(), &quot;&quot;);\n  internal::GetUnitTestImpl()\n      -&gt;GetTestPartResultReporterForCurrentThread()\n      -&gt;ReportTestPartResult(test_part_result);\n\n  // Notifies the unit test event listener that a test has just finished.\n  repeater-&gt;OnTestEnd(*this);\n  UnitTest::GetInstance()-&gt;set_current_test_info(nullptr);\n}\n\n// class TestSuite\n\n// Gets the number of successful tests in this test suite.\nint TestSuite::successful_test_count() const {\n  return CountIf(test_info_list_, TestPassed);\n}\n\n// Gets the number of successful tests in this test suite.\nint TestSuite::skipped_test_count() const {\n  return CountIf(test_info_list_, TestSkipped);\n}\n\n// Gets the number of failed tests in this test suite.\nint TestSuite::failed_test_count() const {\n  return CountIf(test_info_list_, TestFailed);\n}\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint TestSuite::reportable_disabled_test_count() const {\n  return CountIf(test_info_list_, TestReportableDisabled);\n}\n\n// Gets the number of disabled tests in this test suite.\nint TestSuite::disabled_test_count() const {\n  return CountIf(test_info_list_, TestDisabled);\n}\n\n// Gets the number of tests to be printed in the XML report.\nint TestSuite::reportable_test_count() const {\n  return CountIf(test_info_list_, TestReportable);\n}\n\n// Get the number of tests in this test suite that should run.\nint TestSuite::test_to_run_count() const {\n  return CountIf(test_info_list_, ShouldRunTest);\n}\n\n// Gets the number of all tests.\nint TestSuite::total_test_count() const {\n  return static_cast&lt;int&gt;(test_info_list_.size());\n}\n\n// Creates a TestSuite with the given name.\n//\n// Arguments:\n//\n//   a_name:       name of the test suite\n//   a_type_param: the name of the test suite&#x27;s type parameter, or NULL if\n//                 this is not a typed or a type-parameterized test suite.\n//   set_up_tc:    pointer to the function that sets up the test suite\n//   tear_down_tc: pointer to the function that tears down the test suite\nTestSuite::TestSuite(const std::string&amp; a_name, const char* a_type_param,\n                     internal::SetUpTestSuiteFunc set_up_tc,\n                     internal::TearDownTestSuiteFunc tear_down_tc)\n    : name_(a_name),\n      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),\n      set_up_tc_(set_up_tc),\n      tear_down_tc_(tear_down_tc),\n      should_run_(false),\n      start_timestamp_(0),\n      elapsed_time_(0) {}\n\n// Destructor of TestSuite.\nTestSuite::~TestSuite() {\n  // Deletes every Test in the collection.\n  ForEach(test_info_list_, internal::Delete&lt;TestInfo&gt;);\n}\n\n// Returns the i-th test among all the tests. i can range from 0 to\n// total_test_count() - 1. If i is not in that range, returns NULL.\nconst TestInfo* TestSuite::GetTestInfo(int i) const {\n  const int index = GetElementOr(test_indices_, i, -1);\n  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];\n}\n\n// Returns the i-th test among all the tests. i can range from 0 to\n// total_test_count() - 1. If i is not in that range, returns NULL.\nTestInfo* TestSuite::GetMutableTestInfo(int i) {\n  const int index = GetElementOr(test_indices_, i, -1);\n  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];\n}\n\n// Adds a test to this test suite.  Will delete the test upon\n// destruction of the TestSuite object.\nvoid TestSuite::AddTestInfo(TestInfo* test_info) {\n  test_info_list_.push_back(test_info);\n  test_indices_.push_back(static_cast&lt;int&gt;(test_indices_.size()));\n}\n\n// Runs every test in this TestSuite.\nvoid TestSuite::Run() {\n  if (!should_run_) return;\n\n  UnitTest::GetInstance()-&gt;set_current_test_suite(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Ensure our tests are in a deterministic order.\n  //\n  // We do this by sorting lexicographically on (file, line number), providing\n  // an order matching what the user can see in the source code.\n  //\n  // In the common case the line number comparison shouldn&#x27;t be necessary,\n  // because the registrations made by the TEST macro are executed in order\n  // within a translation unit. But this is not true of the manual registration\n  // API, and in more exotic scenarios a single file may be part of multiple\n  // translation units.\n  std::stable_sort(test_info_list_.begin(), test_info_list_.end(),\n                   [](const TestInfo* const a, const TestInfo* const b) {\n                     if (const int result = std::strcmp(a-&gt;file(), b-&gt;file())) {\n                       return result &lt; 0;\n                     }\n\n                     return a-&gt;line() &lt; b-&gt;line();\n                   });\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteStart(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseStart(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  UnitTest::GetInstance()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(\n      this, &amp;TestSuite::RunSetUpTestSuite, &quot;SetUpTestSuite()&quot;);\n\n  const bool skip_all =\n      ad_hoc_test_result().Failed() || ad_hoc_test_result().Skipped();\n\n  start_timestamp_ = internal::GetTimeInMillis();\n  internal::Timer timer;\n  for (int i = 0; i &lt; total_test_count(); i++) {\n    if (skip_all) {\n      GetMutableTestInfo(i)-&gt;Skip();\n    } else {\n      GetMutableTestInfo(i)-&gt;Run();\n    }\n    if (GTEST_FLAG_GET(fail_fast) &amp;&amp;\n        GetMutableTestInfo(i)-&gt;result()-&gt;Failed()) {\n      for (int j = i + 1; j &lt; total_test_count(); j++) {\n        GetMutableTestInfo(j)-&gt;Skip();\n      }\n      break;\n    }\n  }\n  elapsed_time_ = timer.Elapsed();\n\n  UnitTest::GetInstance()-&gt;UponLeavingGTest();\n  internal::HandleExceptionsInMethodIfSupported(\n      this, &amp;TestSuite::RunTearDownTestSuite, &quot;TearDownTestSuite()&quot;);\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteEnd(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseEnd(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  UnitTest::GetInstance()-&gt;set_current_test_suite(nullptr);\n}\n\n// Skips all tests under this TestSuite.\nvoid TestSuite::Skip() {\n  if (!should_run_) return;\n\n  UnitTest::GetInstance()-&gt;set_current_test_suite(this);\n\n  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteStart(*this);\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseStart(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  for (int i = 0; i &lt; total_test_count(); i++) {\n    GetMutableTestInfo(i)-&gt;Skip();\n  }\n\n  // Call both legacy and the new API\n  repeater-&gt;OnTestSuiteEnd(*this);\n  // Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  repeater-&gt;OnTestCaseEnd(*this);\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  UnitTest::GetInstance()-&gt;set_current_test_suite(nullptr);\n}\n\n// Clears the results of all tests in this test suite.\nvoid TestSuite::ClearResult() {\n  ad_hoc_test_result_.Clear();\n  ForEach(test_info_list_, TestInfo::ClearTestResult);\n}\n\n// Shuffles the tests in this test suite.\nvoid TestSuite::ShuffleTests(internal::Random* random) {\n  Shuffle(random, &amp;test_indices_);\n}\n\n// Restores the test order to before the first shuffle.\nvoid TestSuite::UnshuffleTests() {\n  for (size_t i = 0; i &lt; test_indices_.size(); i++) {\n    test_indices_[i] = static_cast&lt;int&gt;(i);\n  }\n}\n\n// Formats a countable noun.  Depending on its quantity, either the\n// singular form or the plural form is used. e.g.\n//\n// FormatCountableNoun(1, &quot;formula&quot;, &quot;formuli&quot;) returns &quot;1 formula&quot;.\n// FormatCountableNoun(5, &quot;book&quot;, &quot;books&quot;) returns &quot;5 books&quot;.\nstatic std::string FormatCountableNoun(int count, const char* singular_form,\n                                       const char* plural_form) {\n  return internal::StreamableToString(count) + &quot; &quot; +\n         (count == 1 ? singular_form : plural_form);\n}\n\n// Formats the count of tests.\nstatic std::string FormatTestCount(int test_count) {\n  return FormatCountableNoun(test_count, &quot;test&quot;, &quot;tests&quot;);\n}\n\n// Formats the count of test suites.\nstatic std::string FormatTestSuiteCount(int test_suite_count) {\n  return FormatCountableNoun(test_suite_count, &quot;test suite&quot;, &quot;test suites&quot;);\n}\n\n// Converts a TestPartResult::Type enum to human-friendly string\n// representation.  Both kNonFatalFailure and kFatalFailure are translated\n// to &quot;Failure&quot;, as the user usually doesn&#x27;t care about the difference\n// between the two when viewing the test result.\nstatic const char* TestPartResultTypeToString(TestPartResult::Type type) {\n  switch (type) {\n    case TestPartResult::kSkip:\n      return &quot;Skipped\\n&quot;;\n    case TestPartResult::kSuccess:\n      return &quot;Success&quot;;\n\n    case TestPartResult::kNonFatalFailure:\n    case TestPartResult::kFatalFailure:\n#ifdef _MSC_VER\n      return &quot;error: &quot;;\n#else\n      return &quot;Failure\\n&quot;;\n#endif\n    default:\n      return &quot;Unknown result type&quot;;\n  }\n}\n\nnamespace internal {\nnamespace {\nenum class GTestColor { kDefault, kRed, kGreen, kYellow };\n}  // namespace\n\n// Prints a TestPartResult to an std::string.\nstatic std::string PrintTestPartResultToString(\n    const TestPartResult&amp; test_part_result) {\n  return (Message() &lt;&lt; internal::FormatFileLocation(\n                           test_part_result.file_name(),\n                           test_part_result.line_number())\n                    &lt;&lt; &quot; &quot;\n                    &lt;&lt; TestPartResultTypeToString(test_part_result.type())\n                    &lt;&lt; test_part_result.message())\n      .GetString();\n}\n\n// Prints a TestPartResult.\nstatic void PrintTestPartResult(const TestPartResult&amp; test_part_result) {\n  const std::string&amp; result = PrintTestPartResultToString(test_part_result);\n  printf(&quot;%s\\n&quot;, result.c_str());\n  fflush(stdout);\n  // If the test program runs in Visual Studio or a debugger, the\n  // following statements add the test part result message to the Output\n  // window such that the user can double-click on it to jump to the\n  // corresponding source code location; otherwise they do nothing.\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE)\n  // We don&#x27;t call OutputDebugString*() on Windows Mobile, as printing\n  // to stdout is done by OutputDebugString() there already - we don&#x27;t\n  // want the same message printed twice.\n  ::OutputDebugStringA(result.c_str());\n  ::OutputDebugStringA(&quot;\\n&quot;);\n#endif\n}\n\n// class PrettyUnitTestResultPrinter\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp;       \\\n    !defined(GTEST_OS_WINDOWS_GAMES) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT) &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n\n// Returns the character attribute for the given color.\nstatic WORD GetColorAttribute(GTestColor color) {\n  switch (color) {\n    case GTestColor::kRed:\n      return FOREGROUND_RED;\n    case GTestColor::kGreen:\n      return FOREGROUND_GREEN;\n    case GTestColor::kYellow:\n      return FOREGROUND_RED | FOREGROUND_GREEN;\n    default:\n      return 0;\n  }\n}\n\nstatic int GetBitOffset(WORD color_mask) {\n  if (color_mask == 0) return 0;\n\n  int bitOffset = 0;\n  while ((color_mask &amp; 1) == 0) {\n    color_mask &gt;&gt;= 1;\n    ++bitOffset;\n  }\n  return bitOffset;\n}\n\nstatic WORD GetNewColor(GTestColor color, WORD old_color_attrs) {\n  // Let&#x27;s reuse the BG\n  static const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN |\n                                      BACKGROUND_RED | BACKGROUND_INTENSITY;\n  static const WORD foreground_mask = FOREGROUND_BLUE | FOREGROUND_GREEN |\n                                      FOREGROUND_RED | FOREGROUND_INTENSITY;\n  const WORD existing_bg = old_color_attrs &amp; background_mask;\n\n  WORD new_color =\n      GetColorAttribute(color) | existing_bg | FOREGROUND_INTENSITY;\n  static const int bg_bitOffset = GetBitOffset(background_mask);\n  static const int fg_bitOffset = GetBitOffset(foreground_mask);\n\n  if (((new_color &amp; background_mask) &gt;&gt; bg_bitOffset) ==\n      ((new_color &amp; foreground_mask) &gt;&gt; fg_bitOffset)) {\n    new_color ^= FOREGROUND_INTENSITY;  // invert intensity\n  }\n  return new_color;\n}\n\n#else\n\n// Returns the ANSI color code for the given color. GTestColor::kDefault is\n// an invalid input.\nstatic const char* GetAnsiColorCode(GTestColor color) {\n  switch (color) {\n    case GTestColor::kRed:\n      return &quot;1&quot;;\n    case GTestColor::kGreen:\n      return &quot;2&quot;;\n    case GTestColor::kYellow:\n      return &quot;3&quot;;\n    default:\n      assert(false);\n      return &quot;9&quot;;\n  }\n}\n\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n\n// Returns true if and only if Google Test should use colors in the output.\nbool ShouldUseColor(bool stdout_is_tty) {\n  std::string c = GTEST_FLAG_GET(color);\n  const char* const gtest_color = c.c_str();\n\n  if (String::CaseInsensitiveCStringEquals(gtest_color, &quot;auto&quot;)) {\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n    // On Windows the TERM variable is usually not set, but the\n    // console there does support colors.\n    return stdout_is_tty;\n#else\n    // On non-Windows platforms, we rely on the TERM variable.\n    const char* const term = posix::GetEnv(&quot;TERM&quot;);\n    const bool term_supports_color =\n        term != nullptr &amp;&amp; (String::CStringEquals(term, &quot;xterm&quot;) ||\n                            String::CStringEquals(term, &quot;xterm-color&quot;) ||\n                            String::CStringEquals(term, &quot;xterm-kitty&quot;) ||\n                            String::CStringEquals(term, &quot;alacritty&quot;) ||\n                            String::CStringEquals(term, &quot;screen&quot;) ||\n                            String::CStringEquals(term, &quot;tmux&quot;) ||\n                            String::CStringEquals(term, &quot;rxvt-unicode&quot;) ||\n                            String::CStringEquals(term, &quot;linux&quot;) ||\n                            String::CStringEquals(term, &quot;cygwin&quot;) ||\n                            String::EndsWithCaseInsensitive(term, &quot;-256color&quot;));\n    return stdout_is_tty &amp;&amp; term_supports_color;\n#endif  // GTEST_OS_WINDOWS\n  }\n\n  return String::CaseInsensitiveCStringEquals(gtest_color, &quot;yes&quot;) ||\n         String::CaseInsensitiveCStringEquals(gtest_color, &quot;true&quot;) ||\n         String::CaseInsensitiveCStringEquals(gtest_color, &quot;t&quot;) ||\n         String::CStringEquals(gtest_color, &quot;1&quot;);\n  // We take &quot;yes&quot;, &quot;true&quot;, &quot;t&quot;, and &quot;1&quot; as meaning &quot;yes&quot;.  If the\n  // value is neither one of these nor &quot;auto&quot;, we treat it as &quot;no&quot; to\n  // be conservative.\n}\n\n// Helpers for printing colored strings to stdout. Note that on Windows, we\n// cannot simply emit special characters and have the terminal change colors.\n// This routine must actually emit the characters rather than return a string\n// that would be colored when printed, as can be done on Linux.\n\nGTEST_ATTRIBUTE_PRINTF_(2, 3)\nstatic void ColoredPrintf(GTestColor color, const char* fmt, ...) {\n  va_list args;\n  va_start(args, fmt);\n\n  static const bool in_color_mode =\n      // We don&#x27;t condition this on GTEST_HAS_FILE_SYSTEM because we still need\n      // to be able to detect terminal I/O regardless.\n      ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);\n\n  const bool use_color = in_color_mode &amp;&amp; (color != GTestColor::kDefault);\n\n  if (!use_color) {\n    vprintf(fmt, args);\n    va_end(args);\n    return;\n  }\n\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp;       \\\n    !defined(GTEST_OS_WINDOWS_GAMES) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT) &amp;&amp; !defined(GTEST_OS_WINDOWS_MINGW)\n  const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);\n\n  // Gets the current text color.\n  CONSOLE_SCREEN_BUFFER_INFO buffer_info;\n  GetConsoleScreenBufferInfo(stdout_handle, &amp;buffer_info);\n  const WORD old_color_attrs = buffer_info.wAttributes;\n  const WORD new_color = GetNewColor(color, old_color_attrs);\n\n  // We need to flush the stream buffers into the console before each\n  // SetConsoleTextAttribute call lest it affect the text that is already\n  // printed but has not yet reached the console.\n  fflush(stdout);\n  SetConsoleTextAttribute(stdout_handle, new_color);\n\n  vprintf(fmt, args);\n\n  fflush(stdout);\n  // Restores the text color.\n  SetConsoleTextAttribute(stdout_handle, old_color_attrs);\n#else\n  printf(&quot;\\033[0;3%sm&quot;, GetAnsiColorCode(color));\n  vprintf(fmt, args);\n  printf(&quot;\\033[m&quot;);  // Resets the terminal to default.\n#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE\n  va_end(args);\n}\n\n// Text printed in Google Test&#x27;s text output and --gtest_list_tests\n// output to label the type parameter and value parameter for a test.\nstatic const char kTypeParamLabel[] = &quot;TypeParam&quot;;\nstatic const char kValueParamLabel[] = &quot;GetParam()&quot;;\n\nstatic void PrintFullTestCommentIfPresent(const TestInfo&amp; test_info) {\n  const char* const type_param = test_info.type_param();\n  const char* const value_param = test_info.value_param();\n\n  if (type_param != nullptr || value_param != nullptr) {\n    printf(&quot;, where &quot;);\n    if (type_param != nullptr) {\n      printf(&quot;%s = %s&quot;, kTypeParamLabel, type_param);\n      if (value_param != nullptr) printf(&quot; and &quot;);\n    }\n    if (value_param != nullptr) {\n      printf(&quot;%s = %s&quot;, kValueParamLabel, value_param);\n    }\n  }\n}\n\n// This class implements the TestEventListener interface.\n//\n// Class PrettyUnitTestResultPrinter is copyable.\nclass PrettyUnitTestResultPrinter : public TestEventListener {\n public:\n  PrettyUnitTestResultPrinter() = default;\n  static void PrintTestName(const char* test_suite, const char* test) {\n    printf(&quot;%s.%s&quot;, test_suite, test);\n  }\n\n  // The following methods override what&#x27;s in the TestEventListener class.\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; test_case) override;\n#else\n  void OnTestSuiteStart(const TestSuite&amp; test_suite) override;\n#endif  // OnTestCaseStart\n\n  void OnTestStart(const TestInfo&amp; test_info) override;\n  void OnTestDisabled(const TestInfo&amp; test_info) override;\n\n  void OnTestPartResult(const TestPartResult&amp; result) override;\n  void OnTestEnd(const TestInfo&amp; test_info) override;\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; test_case) override;\n#else\n  void OnTestSuiteEnd(const TestSuite&amp; test_suite) override;\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) override;\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n\n private:\n  static void PrintFailedTests(const UnitTest&amp; unit_test);\n  static void PrintFailedTestSuites(const UnitTest&amp; unit_test);\n  static void PrintSkippedTests(const UnitTest&amp; unit_test);\n};\n\n// Fired before each iteration of tests starts.\nvoid PrettyUnitTestResultPrinter::OnTestIterationStart(\n    const UnitTest&amp; unit_test, int iteration) {\n  if (GTEST_FLAG_GET(repeat) != 1)\n    printf(&quot;\\nRepeating all tests (iteration %d) . . .\\n\\n&quot;, iteration + 1);\n\n  std::string f = GTEST_FLAG_GET(filter);\n  const char* const filter = f.c_str();\n\n  // Prints the filter if it&#x27;s not *.  This reminds the user that some\n  // tests may be skipped.\n  if (!String::CStringEquals(filter, kUniversalFilter)) {\n    ColoredPrintf(GTestColor::kYellow, &quot;Note: %s filter = %s\\n&quot;, GTEST_NAME_,\n                  filter);\n  }\n\n  if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {\n    const int32_t shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);\n    ColoredPrintf(GTestColor::kYellow, &quot;Note: This is test shard %d of %s.\\n&quot;,\n                  static_cast&lt;int&gt;(shard_index) + 1,\n                  internal::posix::GetEnv(kTestTotalShards));\n  }\n\n  if (GTEST_FLAG_GET(shuffle)) {\n    ColoredPrintf(GTestColor::kYellow,\n                  &quot;Note: Randomizing tests&#x27; orders with a seed of %d .\\n&quot;,\n                  unit_test.random_seed());\n  }\n\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;Running %s from %s.\\n&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  fflush(stdout);\n}\n\nvoid PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(\n    const UnitTest&amp; /*unit_test*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;Global test environment set-up.\\n&quot;);\n  fflush(stdout);\n}\n\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nvoid PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase&amp; test_case) {\n  const std::string counts =\n      FormatCountableNoun(test_case.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s&quot;, counts.c_str(), test_case.name());\n  if (test_case.type_param() == nullptr) {\n    printf(&quot;\\n&quot;);\n  } else {\n    printf(&quot;, where %s = %s\\n&quot;, kTypeParamLabel, test_case.type_param());\n  }\n  fflush(stdout);\n}\n#else\nvoid PrettyUnitTestResultPrinter::OnTestSuiteStart(\n    const TestSuite&amp; test_suite) {\n  const std::string counts =\n      FormatCountableNoun(test_suite.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s&quot;, counts.c_str(), test_suite.name());\n  if (test_suite.type_param() == nullptr) {\n    printf(&quot;\\n&quot;);\n  } else {\n    printf(&quot;, where %s = %s\\n&quot;, kTypeParamLabel, test_suite.type_param());\n  }\n  fflush(stdout);\n}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nvoid PrettyUnitTestResultPrinter::OnTestStart(const TestInfo&amp; test_info) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[ RUN      ] &quot;);\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  printf(&quot;\\n&quot;);\n  fflush(stdout);\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestDisabled(const TestInfo&amp; test_info) {\n  ColoredPrintf(GTestColor::kYellow, &quot;[ DISABLED ] &quot;);\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  printf(&quot;\\n&quot;);\n  fflush(stdout);\n}\n\n// Called after an assertion failure.\nvoid PrettyUnitTestResultPrinter::OnTestPartResult(\n    const TestPartResult&amp; result) {\n  switch (result.type()) {\n    // If the test part succeeded, we don&#x27;t need to do anything.\n    case TestPartResult::kSuccess:\n      return;\n    default:\n      // Print failure message from the assertion\n      // (e.g. expected this and got that).\n      PrintTestPartResult(result);\n      fflush(stdout);\n  }\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {\n  if (test_info.result()-&gt;Passed()) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[       OK ] &quot;);\n  } else if (test_info.result()-&gt;Skipped()) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n  } else {\n    ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n  }\n  PrintTestName(test_info.test_suite_name(), test_info.name());\n  if (test_info.result()-&gt;Failed()) PrintFullTestCommentIfPresent(test_info);\n\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms)\\n&quot;,\n           internal::StreamableToString(test_info.result()-&gt;elapsed_time())\n               .c_str());\n  } else {\n    printf(&quot;\\n&quot;);\n  }\n  fflush(stdout);\n}\n\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nvoid PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase&amp; test_case) {\n  if (!GTEST_FLAG_GET(print_time)) return;\n\n  const std::string counts =\n      FormatCountableNoun(test_case.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s (%s ms total)\\n\\n&quot;, counts.c_str(), test_case.name(),\n         internal::StreamableToString(test_case.elapsed_time()).c_str());\n  fflush(stdout);\n}\n#else\nvoid PrettyUnitTestResultPrinter::OnTestSuiteEnd(const TestSuite&amp; test_suite) {\n  if (!GTEST_FLAG_GET(print_time)) return;\n\n  const std::string counts =\n      FormatCountableNoun(test_suite.test_to_run_count(), &quot;test&quot;, &quot;tests&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;%s from %s (%s ms total)\\n\\n&quot;, counts.c_str(), test_suite.name(),\n         internal::StreamableToString(test_suite.elapsed_time()).c_str());\n  fflush(stdout);\n}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\nvoid PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(\n    const UnitTest&amp; /*unit_test*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[----------] &quot;);\n  printf(&quot;Global test environment tear-down\\n&quot;);\n  fflush(stdout);\n}\n\n// Internal helper for printing the list of failed tests.\nvoid PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest&amp; unit_test) {\n  const int failed_test_count = unit_test.failed_test_count();\n  ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n  printf(&quot;%s, listed below:\\n&quot;, FormatTestCount(failed_test_count).c_str());\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run() || (test_suite.failed_test_count() == 0)) {\n      continue;\n    }\n    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {\n      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);\n      if (!test_info.should_run() || !test_info.result()-&gt;Failed()) {\n        continue;\n      }\n      ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n      printf(&quot;%s.%s&quot;, test_suite.name(), test_info.name());\n      PrintFullTestCommentIfPresent(test_info);\n      printf(&quot;\\n&quot;);\n    }\n  }\n  printf(&quot;\\n%2d FAILED %s\\n&quot;, failed_test_count,\n         failed_test_count == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n}\n\n// Internal helper for printing the list of test suite failures not covered by\n// PrintFailedTests.\nvoid PrettyUnitTestResultPrinter::PrintFailedTestSuites(\n    const UnitTest&amp; unit_test) {\n  int suite_failure_count = 0;\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run()) {\n      continue;\n    }\n    if (test_suite.ad_hoc_test_result().Failed()) {\n      ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n      printf(&quot;%s: SetUpTestSuite or TearDownTestSuite\\n&quot;, test_suite.name());\n      ++suite_failure_count;\n    }\n  }\n  if (suite_failure_count &gt; 0) {\n    printf(&quot;\\n%2d FAILED TEST %s\\n&quot;, suite_failure_count,\n           suite_failure_count == 1 ? &quot;SUITE&quot; : &quot;SUITES&quot;);\n  }\n}\n\n// Internal helper for printing the list of skipped tests.\nvoid PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest&amp; unit_test) {\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count == 0) {\n    return;\n  }\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);\n    if (!test_suite.should_run() || (test_suite.skipped_test_count() == 0)) {\n      continue;\n    }\n    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {\n      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);\n      if (!test_info.should_run() || !test_info.result()-&gt;Skipped()) {\n        continue;\n      }\n      ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n      printf(&quot;%s.%s&quot;, test_suite.name(), test_info.name());\n      printf(&quot;\\n&quot;);\n    }\n  }\n}\n\nvoid PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                     int /*iteration*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;%s from %s ran.&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms total)&quot;,\n           internal::StreamableToString(unit_test.elapsed_time()).c_str());\n  }\n  printf(&quot;\\n&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[  PASSED  ] &quot;);\n  printf(&quot;%s.\\n&quot;, FormatTestCount(unit_test.successful_test_count()).c_str());\n\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count &gt; 0) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n    printf(&quot;%s, listed below:\\n&quot;, FormatTestCount(skipped_test_count).c_str());\n    PrintSkippedTests(unit_test);\n  }\n\n  if (!unit_test.Passed()) {\n    PrintFailedTests(unit_test);\n    PrintFailedTestSuites(unit_test);\n  }\n\n  int num_disabled = unit_test.reportable_disabled_test_count();\n  if (num_disabled &amp;&amp; !GTEST_FLAG_GET(also_run_disabled_tests)) {\n    if (unit_test.Passed()) {\n      printf(&quot;\\n&quot;);  // Add a spacer if no FAILURE banner is displayed.\n    }\n    ColoredPrintf(GTestColor::kYellow, &quot;  YOU HAVE %d DISABLED %s\\n\\n&quot;,\n                  num_disabled, num_disabled == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n  }\n  // Ensure that Google Test output is printed before, e.g., heapchecker output.\n  fflush(stdout);\n}\n\n// End PrettyUnitTestResultPrinter\n\n// This class implements the TestEventListener interface.\n//\n// Class BriefUnitTestResultPrinter is copyable.\nclass BriefUnitTestResultPrinter : public TestEventListener {\n public:\n  BriefUnitTestResultPrinter() = default;\n  static void PrintTestName(const char* test_suite, const char* test) {\n    printf(&quot;%s.%s&quot;, test_suite, test);\n  }\n\n  // The following methods override what&#x27;s in the TestEventListener class.\n  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationStart(const UnitTest&amp; /*unit_test*/,\n                            int /*iteration*/) override {}\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestCase&amp; /*test_case*/) override {}\n#else\n  void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override {}\n#endif  // OnTestCaseStart\n\n  void OnTestStart(const TestInfo&amp; /*test_info*/) override {}\n  void OnTestDisabled(const TestInfo&amp; /*test_info*/) override {}\n\n  void OnTestPartResult(const TestPartResult&amp; result) override;\n  void OnTestEnd(const TestInfo&amp; test_info) override;\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; /*test_case*/) override {}\n#else\n  void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override {}\n#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; /*unit_test*/) override {}\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}\n};\n\n// Called after an assertion failure.\nvoid BriefUnitTestResultPrinter::OnTestPartResult(\n    const TestPartResult&amp; result) {\n  switch (result.type()) {\n    // If the test part succeeded, we don&#x27;t need to do anything.\n    case TestPartResult::kSuccess:\n      return;\n    default:\n      // Print failure message from the assertion\n      // (e.g. expected this and got that).\n      PrintTestPartResult(result);\n      fflush(stdout);\n  }\n}\n\nvoid BriefUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {\n  if (test_info.result()-&gt;Failed()) {\n    ColoredPrintf(GTestColor::kRed, &quot;[  FAILED  ] &quot;);\n    PrintTestName(test_info.test_suite_name(), test_info.name());\n    PrintFullTestCommentIfPresent(test_info);\n\n    if (GTEST_FLAG_GET(print_time)) {\n      printf(&quot; (%s ms)\\n&quot;,\n             internal::StreamableToString(test_info.result()-&gt;elapsed_time())\n                 .c_str());\n    } else {\n      printf(&quot;\\n&quot;);\n    }\n    fflush(stdout);\n  }\n}\n\nvoid BriefUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                    int /*iteration*/) {\n  ColoredPrintf(GTestColor::kGreen, &quot;[==========] &quot;);\n  printf(&quot;%s from %s ran.&quot;,\n         FormatTestCount(unit_test.test_to_run_count()).c_str(),\n         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());\n  if (GTEST_FLAG_GET(print_time)) {\n    printf(&quot; (%s ms total)&quot;,\n           internal::StreamableToString(unit_test.elapsed_time()).c_str());\n  }\n  printf(&quot;\\n&quot;);\n  ColoredPrintf(GTestColor::kGreen, &quot;[  PASSED  ] &quot;);\n  printf(&quot;%s.\\n&quot;, FormatTestCount(unit_test.successful_test_count()).c_str());\n\n  const int skipped_test_count = unit_test.skipped_test_count();\n  if (skipped_test_count &gt; 0) {\n    ColoredPrintf(GTestColor::kGreen, &quot;[  SKIPPED ] &quot;);\n    printf(&quot;%s.\\n&quot;, FormatTestCount(skipped_test_count).c_str());\n  }\n\n  int num_disabled = unit_test.reportable_disabled_test_count();\n  if (num_disabled &amp;&amp; !GTEST_FLAG_GET(also_run_disabled_tests)) {\n    if (unit_test.Passed()) {\n      printf(&quot;\\n&quot;);  // Add a spacer if no FAILURE banner is displayed.\n    }\n    ColoredPrintf(GTestColor::kYellow, &quot;  YOU HAVE %d DISABLED %s\\n\\n&quot;,\n                  num_disabled, num_disabled == 1 ? &quot;TEST&quot; : &quot;TESTS&quot;);\n  }\n  // Ensure that Google Test output is printed before, e.g., heapchecker output.\n  fflush(stdout);\n}\n\n// End BriefUnitTestResultPrinter\n\n// class TestEventRepeater\n//\n// This class forwards events to other event listeners.\nclass TestEventRepeater : public TestEventListener {\n public:\n  TestEventRepeater() : forwarding_enabled_(true) {}\n  ~TestEventRepeater() override;\n  void Append(TestEventListener* listener);\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Controls whether events will be forwarded to listeners_. Set to false\n  // in death test child processes.\n  bool forwarding_enabled() const { return forwarding_enabled_; }\n  void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }\n\n  void OnTestProgramStart(const UnitTest&amp; parameter) override;\n  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;\n  void OnEnvironmentsSetUpStart(const UnitTest&amp; parameter) override;\n  void OnEnvironmentsSetUpEnd(const UnitTest&amp; parameter) override;\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseStart(const TestSuite&amp; parameter) override;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestSuiteStart(const TestSuite&amp; parameter) override;\n  void OnTestStart(const TestInfo&amp; parameter) override;\n  void OnTestDisabled(const TestInfo&amp; parameter) override;\n  void OnTestPartResult(const TestPartResult&amp; parameter) override;\n  void OnTestEnd(const TestInfo&amp; parameter) override;\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestCaseEnd(const TestCase&amp; parameter) override;\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n  void OnTestSuiteEnd(const TestSuite&amp; parameter) override;\n  void OnEnvironmentsTearDownStart(const UnitTest&amp; parameter) override;\n  void OnEnvironmentsTearDownEnd(const UnitTest&amp; parameter) override;\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void OnTestProgramEnd(const UnitTest&amp; parameter) override;\n\n private:\n  // Controls whether events will be forwarded to listeners_. Set to false\n  // in death test child processes.\n  bool forwarding_enabled_;\n  // The list of listeners that receive events.\n  std::vector&lt;TestEventListener*&gt; listeners_;\n\n  TestEventRepeater(const TestEventRepeater&amp;) = delete;\n  TestEventRepeater&amp; operator=(const TestEventRepeater&amp;) = delete;\n};\n\nTestEventRepeater::~TestEventRepeater() {\n  ForEach(listeners_, Delete&lt;TestEventListener&gt;);\n}\n\nvoid TestEventRepeater::Append(TestEventListener* listener) {\n  listeners_.push_back(listener);\n}\n\nTestEventListener* TestEventRepeater::Release(TestEventListener* listener) {\n  for (size_t i = 0; i &lt; listeners_.size(); ++i) {\n    if (listeners_[i] == listener) {\n      listeners_.erase(listeners_.begin() + static_cast&lt;int&gt;(i));\n      return listener;\n    }\n  }\n\n  return nullptr;\n}\n\n// Since most methods are very similar, use macros to reduce boilerplate.\n// This defines a member that forwards the call to all listeners.\n#define GTEST_REPEATER_METHOD_(Name, Type)              \\\n  void TestEventRepeater::Name(const Type&amp; parameter) { \\\n    if (forwarding_enabled_) {                          \\\n      for (size_t i = 0; i &lt; listeners_.size(); i++) {  \\\n        listeners_[i]-&gt;Name(parameter);                 \\\n      }                                                 \\\n    }                                                   \\\n  }\n// This defines a member that forwards the call to all listeners in reverse\n// order.\n#define GTEST_REVERSE_REPEATER_METHOD_(Name, Type)      \\\n  void TestEventRepeater::Name(const Type&amp; parameter) { \\\n    if (forwarding_enabled_) {                          \\\n      for (size_t i = listeners_.size(); i != 0; i--) { \\\n        listeners_[i - 1]-&gt;Name(parameter);             \\\n      }                                                 \\\n    }                                                   \\\n  }\n\nGTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)\nGTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REPEATER_METHOD_(OnTestCaseStart, TestSuite)\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REPEATER_METHOD_(OnTestSuiteStart, TestSuite)\nGTEST_REPEATER_METHOD_(OnTestStart, TestInfo)\nGTEST_REPEATER_METHOD_(OnTestDisabled, TestInfo)\nGTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)\nGTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)\nGTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestSuite)\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nGTEST_REVERSE_REPEATER_METHOD_(OnTestSuiteEnd, TestSuite)\nGTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)\n\n#undef GTEST_REPEATER_METHOD_\n#undef GTEST_REVERSE_REPEATER_METHOD_\n\nvoid TestEventRepeater::OnTestIterationStart(const UnitTest&amp; unit_test,\n                                             int iteration) {\n  if (forwarding_enabled_) {\n    for (size_t i = 0; i &lt; listeners_.size(); i++) {\n      listeners_[i]-&gt;OnTestIterationStart(unit_test, iteration);\n    }\n  }\n}\n\nvoid TestEventRepeater::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                           int iteration) {\n  if (forwarding_enabled_) {\n    for (size_t i = listeners_.size(); i &gt; 0; i--) {\n      listeners_[i - 1]-&gt;OnTestIterationEnd(unit_test, iteration);\n    }\n  }\n}\n\n// End TestEventRepeater\n\n#if GTEST_HAS_FILE_SYSTEM\n// This class generates an XML output file.\nclass XmlUnitTestResultPrinter : public EmptyTestEventListener {\n public:\n  explicit XmlUnitTestResultPrinter(const char* output_file);\n\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n  void ListTestsMatchingFilter(const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n  // Prints an XML summary of all unit tests.\n  static void PrintXmlTestsList(std::ostream* stream,\n                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n private:\n  // Is c a whitespace character that is normalized to a space character\n  // when it appears in an XML attribute value?\n  static bool IsNormalizableWhitespace(unsigned char c) {\n    return c == &#x27;\\t&#x27; || c == &#x27;\\n&#x27; || c == &#x27;\\r&#x27;;\n  }\n\n  // May c appear in a well-formed XML document?\n  // https://www.w3.org/TR/REC-xml/#charsets\n  static bool IsValidXmlCharacter(unsigned char c) {\n    return IsNormalizableWhitespace(c) || c &gt;= 0x20;\n  }\n\n  // Returns an XML-escaped copy of the input string str.  If\n  // is_attribute is true, the text is meant to appear as an attribute\n  // value, and normalizable whitespace is preserved by replacing it\n  // with character references.\n  static std::string EscapeXml(const std::string&amp; str, bool is_attribute);\n\n  // Returns the given string with all characters invalid in XML removed.\n  static std::string RemoveInvalidXmlCharacters(const std::string&amp; str);\n\n  // Convenience wrapper around EscapeXml when str is an attribute value.\n  static std::string EscapeXmlAttribute(const std::string&amp; str) {\n    return EscapeXml(str, true);\n  }\n\n  // Convenience wrapper around EscapeXml when str is not an attribute value.\n  static std::string EscapeXmlText(const char* str) {\n    return EscapeXml(str, false);\n  }\n\n  // Verifies that the given attribute belongs to the given element and\n  // streams the attribute as XML.\n  static void OutputXmlAttribute(std::ostream* stream,\n                                 const std::string&amp; element_name,\n                                 const std::string&amp; name,\n                                 const std::string&amp; value);\n\n  // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.\n  static void OutputXmlCDataSection(::std::ostream* stream, const char* data);\n\n  // Streams a test suite XML stanza containing the given test result.\n  //\n  // Requires: result.Failed()\n  static void OutputXmlTestSuiteForTestResult(::std::ostream* stream,\n                                              const TestResult&amp; result);\n\n  // Streams an XML representation of a TestResult object.\n  static void OutputXmlTestResult(::std::ostream* stream,\n                                  const TestResult&amp; result);\n\n  // Streams an XML representation of a TestInfo object.\n  static void OutputXmlTestInfo(::std::ostream* stream,\n                                const char* test_suite_name,\n                                const TestInfo&amp; test_info);\n\n  // Prints an XML representation of a TestSuite object\n  static void PrintXmlTestSuite(::std::ostream* stream,\n                                const TestSuite&amp; test_suite);\n\n  // Prints an XML summary of unit_test to output stream out.\n  static void PrintXmlUnitTest(::std::ostream* stream,\n                               const UnitTest&amp; unit_test);\n\n  // Produces a string representing the test properties in a result as space\n  // delimited XML attributes based on the property key=&quot;value&quot; pairs.\n  // When the std::string is not empty, it includes a space at the beginning,\n  // to delimit this attribute from prior attributes.\n  static std::string TestPropertiesAsXmlAttributes(const TestResult&amp; result);\n\n  // Streams an XML representation of the test properties of a TestResult\n  // object.\n  static void OutputXmlTestProperties(std::ostream* stream,\n                                      const TestResult&amp; result);\n\n  // The output file.\n  const std::string output_file_;\n\n  XmlUnitTestResultPrinter(const XmlUnitTestResultPrinter&amp;) = delete;\n  XmlUnitTestResultPrinter&amp; operator=(const XmlUnitTestResultPrinter&amp;) = delete;\n};\n\n// Creates a new XmlUnitTestResultPrinter.\nXmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)\n    : output_file_(output_file) {\n  if (output_file_.empty()) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;XML output file may not be null&quot;;\n  }\n}\n\n// Called after the unit test ends.\nvoid XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                  int /*iteration*/) {\n  FILE* xmlout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintXmlUnitTest(&amp;stream, unit_test);\n  fprintf(xmlout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(xmlout);\n}\n\nvoid XmlUnitTestResultPrinter::ListTestsMatchingFilter(\n    const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  FILE* xmlout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintXmlTestsList(&amp;stream, test_suites);\n  fprintf(xmlout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(xmlout);\n}\n\n// Returns an XML-escaped copy of the input string str.  If is_attribute\n// is true, the text is meant to appear as an attribute value, and\n// normalizable whitespace is preserved by replacing it with character\n// references.\n//\n// Invalid XML characters in str, if any, are stripped from the output.\n// It is expected that most, if not all, of the text processed by this\n// module will consist of ordinary English text.\n// If this module is ever modified to produce version 1.1 XML output,\n// most invalid characters can be retained using character references.\nstd::string XmlUnitTestResultPrinter::EscapeXml(const std::string&amp; str,\n                                                bool is_attribute) {\n  Message m;\n\n  for (size_t i = 0; i &lt; str.size(); ++i) {\n    const char ch = str[i];\n    switch (ch) {\n      case &#x27;&lt;&#x27;:\n        m &lt;&lt; &quot;&amp;lt;&quot;;\n        break;\n      case &#x27;&gt;&#x27;:\n        m &lt;&lt; &quot;&amp;gt;&quot;;\n        break;\n      case &#x27;&amp;&#x27;:\n        m &lt;&lt; &quot;&amp;amp;&quot;;\n        break;\n      case &#x27;\\&#x27;&#x27;:\n        if (is_attribute)\n          m &lt;&lt; &quot;&amp;apos;&quot;;\n        else\n          m &lt;&lt; &#x27;\\&#x27;&#x27;;\n        break;\n      case &#x27;&quot;&#x27;:\n        if (is_attribute)\n          m &lt;&lt; &quot;&amp;quot;&quot;;\n        else\n          m &lt;&lt; &#x27;&quot;&#x27;;\n        break;\n      default:\n        if (IsValidXmlCharacter(static_cast&lt;unsigned char&gt;(ch))) {\n          if (is_attribute &amp;&amp;\n              IsNormalizableWhitespace(static_cast&lt;unsigned char&gt;(ch)))\n            m &lt;&lt; &quot;&amp;#x&quot; &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch))\n              &lt;&lt; &quot;;&quot;;\n          else\n            m &lt;&lt; ch;\n        }\n        break;\n    }\n  }\n\n  return m.GetString();\n}\n\n// Returns the given string with all characters invalid in XML removed.\n// Currently invalid characters are dropped from the string. An\n// alternative is to replace them with certain characters such as . or ?.\nstd::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(\n    const std::string&amp; str) {\n  std::string output;\n  output.reserve(str.size());\n  for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)\n    if (IsValidXmlCharacter(static_cast&lt;unsigned char&gt;(*it)))\n      output.push_back(*it);\n\n  return output;\n}\n\n// The following routines generate an XML representation of a UnitTest\n// object.\n//\n// This is how Google Test concepts map to the DTD:\n//\n// &lt;testsuites name=&quot;AllTests&quot;&gt;        &lt;-- corresponds to a UnitTest object\n//   &lt;testsuite name=&quot;testcase-name&quot;&gt;  &lt;-- corresponds to a TestSuite object\n//     &lt;testcase name=&quot;test-name&quot;&gt;     &lt;-- corresponds to a TestInfo object\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//       &lt;failure message=&quot;...&quot;&gt;...&lt;/failure&gt;\n//                                     &lt;-- individual assertion failures\n//     &lt;/testcase&gt;\n//   &lt;/testsuite&gt;\n// &lt;/testsuites&gt;\n\n// Formats the given time in milliseconds as seconds.\nstd::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {\n  ::std::stringstream ss;\n  // For the exact N seconds, makes sure output has a trailing decimal point.\n  // Sets precision so that we won&#x27;t have many trailing zeros (e.g., 300 ms\n  // will be just 0.3, 410 ms 0.41, and so on)\n  ss &lt;&lt; std::fixed\n     &lt;&lt; std::setprecision(\n            ms % 1000 == 0 ? 0 : (ms % 100 == 0 ? 1 : (ms % 10 == 0 ? 2 : 3)))\n     &lt;&lt; std::showpoint;\n  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3);\n  return ss.str();\n}\n\nstatic bool PortableLocaltime(time_t seconds, struct tm* out) {\n#if defined(_MSC_VER)\n  return localtime_s(out, &amp;seconds) == 0;\n#elif defined(__MINGW32__) || defined(__MINGW64__)\n  // MINGW &lt;time.h&gt; provides neither localtime_r nor localtime_s, but uses\n  // Windows&#x27; localtime(), which has a thread-local tm buffer.\n  struct tm* tm_ptr = localtime(&amp;seconds);  // NOLINT\n  if (tm_ptr == nullptr) return false;\n  *out = *tm_ptr;\n  return true;\n#elif defined(__STDC_LIB_EXT1__)\n  // Uses localtime_s when available as localtime_r is only available from\n  // C23 standard.\n  return localtime_s(&amp;seconds, out) != nullptr;\n#else\n  return localtime_r(&amp;seconds, out) != nullptr;\n#endif\n}\n\n// Converts the given epoch time in milliseconds to a date string in the ISO\n// 8601 format, without the timezone information.\nstd::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {\n  struct tm time_struct;\n  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))\n    return &quot;&quot;;\n  // YYYY-MM-DDThh:mm:ss.sss\n  return StreamableToString(time_struct.tm_year + 1900) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mon + 1) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mday) + &quot;T&quot; +\n         String::FormatIntWidth2(time_struct.tm_hour) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_min) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_sec) + &quot;.&quot; +\n         String::FormatIntWidthN(static_cast&lt;int&gt;(ms % 1000), 3);\n}\n\n// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.\nvoid XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,\n                                                     const char* data) {\n  const char* segment = data;\n  *stream &lt;&lt; &quot;&lt;![CDATA[&quot;;\n  for (;;) {\n    const char* const next_segment = strstr(segment, &quot;]]&gt;&quot;);\n    if (next_segment != nullptr) {\n      stream-&gt;write(segment,\n                    static_cast&lt;std::streamsize&gt;(next_segment - segment));\n      *stream &lt;&lt; &quot;]]&gt;]]&amp;gt;&lt;![CDATA[&quot;;\n      segment = next_segment + strlen(&quot;]]&gt;&quot;);\n    } else {\n      *stream &lt;&lt; segment;\n      break;\n    }\n  }\n  *stream &lt;&lt; &quot;]]&gt;&quot;;\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlAttribute(\n    std::ostream* stream, const std::string&amp; element_name,\n    const std::string&amp; name, const std::string&amp; value) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Attribute &quot; &lt;&lt; name &lt;&lt; &quot; is not allowed for element &lt;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;&gt;.&quot;;\n\n  *stream &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot;=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(value) &lt;&lt; &quot;\\&quot;&quot;;\n}\n\n// Streams a test suite XML stanza containing the given test result.\nvoid XmlUnitTestResultPrinter::OutputXmlTestSuiteForTestResult(\n    ::std::ostream* stream, const TestResult&amp; result) {\n  // Output the boilerplate for a minimal test suite with one test.\n  *stream &lt;&lt; &quot;  &lt;testsuite&quot;;\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;name&quot;, &quot;NonTestSuiteFailure&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;tests&quot;, &quot;1&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;failures&quot;, &quot;1&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;disabled&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;skipped&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;errors&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, &quot;testsuite&quot;, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, &quot;testsuite&quot;, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n  *stream &lt;&lt; &quot;&gt;&quot;;\n\n  // Output the boilerplate for a minimal test case with a single test.\n  *stream &lt;&lt; &quot;    &lt;testcase&quot;;\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;name&quot;, &quot;&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;status&quot;, &quot;run&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;result&quot;, &quot;completed&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;classname&quot;, &quot;&quot;);\n  OutputXmlAttribute(stream, &quot;testcase&quot;, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, &quot;testcase&quot;, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n\n  // Output the actual test result.\n  OutputXmlTestResult(stream, result);\n\n  // Complete the test suite.\n  *stream &lt;&lt; &quot;  &lt;/testsuite&gt;\\n&quot;;\n}\n\n// Prints an XML representation of a TestInfo object.\nvoid XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,\n                                                 const char* test_suite_name,\n                                                 const TestInfo&amp; test_info) {\n  const TestResult&amp; result = *test_info.result();\n  const std::string kTestsuite = &quot;testcase&quot;;\n\n  if (test_info.is_in_another_shard()) {\n    return;\n  }\n\n  *stream &lt;&lt; &quot;    &lt;testcase&quot;;\n  OutputXmlAttribute(stream, kTestsuite, &quot;name&quot;, test_info.name());\n\n  if (test_info.value_param() != nullptr) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;value_param&quot;,\n                       test_info.value_param());\n  }\n  if (test_info.type_param() != nullptr) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;type_param&quot;,\n                       test_info.type_param());\n  }\n\n  OutputXmlAttribute(stream, kTestsuite, &quot;file&quot;, test_info.file());\n  OutputXmlAttribute(stream, kTestsuite, &quot;line&quot;,\n                     StreamableToString(test_info.line()));\n  if (GTEST_FLAG_GET(list_tests)) {\n    *stream &lt;&lt; &quot; /&gt;\\n&quot;;\n    return;\n  }\n\n  OutputXmlAttribute(stream, kTestsuite, &quot;status&quot;,\n                     test_info.should_run() ? &quot;run&quot; : &quot;notrun&quot;);\n  OutputXmlAttribute(stream, kTestsuite, &quot;result&quot;,\n                     test_info.should_run()\n                         ? (result.Skipped() ? &quot;skipped&quot; : &quot;completed&quot;)\n                         : &quot;suppressed&quot;);\n  OutputXmlAttribute(stream, kTestsuite, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(result.elapsed_time()));\n  OutputXmlAttribute(\n      stream, kTestsuite, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));\n  OutputXmlAttribute(stream, kTestsuite, &quot;classname&quot;, test_suite_name);\n\n  OutputXmlTestResult(stream, result);\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlTestResult(::std::ostream* stream,\n                                                   const TestResult&amp; result) {\n  int failures = 0;\n  int skips = 0;\n  for (int i = 0; i &lt; result.total_part_count(); ++i) {\n    const TestPartResult&amp; part = result.GetTestPartResult(i);\n    if (part.failed()) {\n      if (++failures == 1 &amp;&amp; skips == 0) {\n        *stream &lt;&lt; &quot;&gt;\\n&quot;;\n      }\n      const std::string location =\n          internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                          part.line_number());\n      const std::string summary = location + &quot;\\n&quot; + part.summary();\n      *stream &lt;&lt; &quot;      &lt;failure message=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(summary)\n              &lt;&lt; &quot;\\&quot; type=\\&quot;\\&quot;&gt;&quot;;\n      const std::string detail = location + &quot;\\n&quot; + part.message();\n      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());\n      *stream &lt;&lt; &quot;&lt;/failure&gt;\\n&quot;;\n    } else if (part.skipped()) {\n      if (++skips == 1 &amp;&amp; failures == 0) {\n        *stream &lt;&lt; &quot;&gt;\\n&quot;;\n      }\n      const std::string location =\n          internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                          part.line_number());\n      const std::string summary = location + &quot;\\n&quot; + part.summary();\n      *stream &lt;&lt; &quot;      &lt;skipped message=\\&quot;&quot;\n              &lt;&lt; EscapeXmlAttribute(summary.c_str()) &lt;&lt; &quot;\\&quot;&gt;&quot;;\n      const std::string detail = location + &quot;\\n&quot; + part.message();\n      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());\n      *stream &lt;&lt; &quot;&lt;/skipped&gt;\\n&quot;;\n    }\n  }\n\n  if (failures == 0 &amp;&amp; skips == 0 &amp;&amp; result.test_property_count() == 0) {\n    *stream &lt;&lt; &quot; /&gt;\\n&quot;;\n  } else {\n    if (failures == 0 &amp;&amp; skips == 0) {\n      *stream &lt;&lt; &quot;&gt;\\n&quot;;\n    }\n    OutputXmlTestProperties(stream, result);\n    *stream &lt;&lt; &quot;    &lt;/testcase&gt;\\n&quot;;\n  }\n}\n\n// Prints an XML representation of a TestSuite object\nvoid XmlUnitTestResultPrinter::PrintXmlTestSuite(std::ostream* stream,\n                                                 const TestSuite&amp; test_suite) {\n  const std::string kTestsuite = &quot;testsuite&quot;;\n  *stream &lt;&lt; &quot;  &lt;&quot; &lt;&lt; kTestsuite;\n  OutputXmlAttribute(stream, kTestsuite, &quot;name&quot;, test_suite.name());\n  OutputXmlAttribute(stream, kTestsuite, &quot;tests&quot;,\n                     StreamableToString(test_suite.reportable_test_count()));\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputXmlAttribute(stream, kTestsuite, &quot;failures&quot;,\n                       StreamableToString(test_suite.failed_test_count()));\n    OutputXmlAttribute(\n        stream, kTestsuite, &quot;disabled&quot;,\n        StreamableToString(test_suite.reportable_disabled_test_count()));\n    OutputXmlAttribute(stream, kTestsuite, &quot;skipped&quot;,\n                       StreamableToString(test_suite.skipped_test_count()));\n\n    OutputXmlAttribute(stream, kTestsuite, &quot;errors&quot;, &quot;0&quot;);\n\n    OutputXmlAttribute(stream, kTestsuite, &quot;time&quot;,\n                       FormatTimeInMillisAsSeconds(test_suite.elapsed_time()));\n    OutputXmlAttribute(\n        stream, kTestsuite, &quot;timestamp&quot;,\n        FormatEpochTimeInMillisAsIso8601(test_suite.start_timestamp()));\n    *stream &lt;&lt; TestPropertiesAsXmlAttributes(test_suite.ad_hoc_test_result());\n  }\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {\n    if (test_suite.GetTestInfo(i)-&gt;is_reportable())\n      OutputXmlTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));\n  }\n  *stream &lt;&lt; &quot;  &lt;/&quot; &lt;&lt; kTestsuite &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// Prints an XML summary of unit_test to output stream out.\nvoid XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,\n                                                const UnitTest&amp; unit_test) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n\n  *stream &lt;&lt; &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot;;\n  *stream &lt;&lt; &quot;&lt;&quot; &lt;&lt; kTestsuites;\n\n  OutputXmlAttribute(stream, kTestsuites, &quot;tests&quot;,\n                     StreamableToString(unit_test.reportable_test_count()));\n  OutputXmlAttribute(stream, kTestsuites, &quot;failures&quot;,\n                     StreamableToString(unit_test.failed_test_count()));\n  OutputXmlAttribute(\n      stream, kTestsuites, &quot;disabled&quot;,\n      StreamableToString(unit_test.reportable_disabled_test_count()));\n  OutputXmlAttribute(stream, kTestsuites, &quot;errors&quot;, &quot;0&quot;);\n  OutputXmlAttribute(stream, kTestsuites, &quot;time&quot;,\n                     FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));\n  OutputXmlAttribute(\n      stream, kTestsuites, &quot;timestamp&quot;,\n      FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));\n\n  if (GTEST_FLAG_GET(shuffle)) {\n    OutputXmlAttribute(stream, kTestsuites, &quot;random_seed&quot;,\n                       StreamableToString(unit_test.random_seed()));\n  }\n  *stream &lt;&lt; TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());\n\n  OutputXmlAttribute(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;);\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0)\n      PrintXmlTestSuite(stream, *unit_test.GetTestSuite(i));\n  }\n\n  // If there was a test failure outside of one of the test suites (like in a\n  // test environment) include that in the output.\n  if (unit_test.ad_hoc_test_result().Failed()) {\n    OutputXmlTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());\n  }\n\n  *stream &lt;&lt; &quot;&lt;/&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\nvoid XmlUnitTestResultPrinter::PrintXmlTestsList(\n    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n\n  *stream &lt;&lt; &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot;;\n  *stream &lt;&lt; &quot;&lt;&quot; &lt;&lt; kTestsuites;\n\n  int total_tests = 0;\n  for (auto test_suite : test_suites) {\n    total_tests += test_suite-&gt;total_test_count();\n  }\n  OutputXmlAttribute(stream, kTestsuites, &quot;tests&quot;,\n                     StreamableToString(total_tests));\n  OutputXmlAttribute(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;);\n  *stream &lt;&lt; &quot;&gt;\\n&quot;;\n\n  for (auto test_suite : test_suites) {\n    PrintXmlTestSuite(stream, *test_suite);\n  }\n  *stream &lt;&lt; &quot;&lt;/&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// Produces a string representing the test properties in a result as space\n// delimited XML attributes based on the property key=&quot;value&quot; pairs.\nstd::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(\n    const TestResult&amp; result) {\n  Message attributes;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    attributes &lt;&lt; &quot; &quot; &lt;&lt; property.key() &lt;&lt; &quot;=&quot; &lt;&lt; &quot;\\&quot;&quot;\n               &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return attributes.GetString();\n}\n\nvoid XmlUnitTestResultPrinter::OutputXmlTestProperties(\n    std::ostream* stream, const TestResult&amp; result) {\n  const std::string kProperties = &quot;properties&quot;;\n  const std::string kProperty = &quot;property&quot;;\n\n  if (result.test_property_count() &lt;= 0) {\n    return;\n  }\n\n  *stream &lt;&lt; &quot;      &lt;&quot; &lt;&lt; kProperties &lt;&lt; &quot;&gt;\\n&quot;;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    *stream &lt;&lt; &quot;        &lt;&quot; &lt;&lt; kProperty;\n    *stream &lt;&lt; &quot; name=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(property.key()) &lt;&lt; &quot;\\&quot;&quot;;\n    *stream &lt;&lt; &quot; value=\\&quot;&quot; &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n    *stream &lt;&lt; &quot;/&gt;\\n&quot;;\n  }\n  *stream &lt;&lt; &quot;      &lt;/&quot; &lt;&lt; kProperties &lt;&lt; &quot;&gt;\\n&quot;;\n}\n\n// End XmlUnitTestResultPrinter\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n#if GTEST_HAS_FILE_SYSTEM\n// This class generates an JSON output file.\nclass JsonUnitTestResultPrinter : public EmptyTestEventListener {\n public:\n  explicit JsonUnitTestResultPrinter(const char* output_file);\n\n  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;\n\n  // Prints an JSON summary of all unit tests.\n  static void PrintJsonTestList(::std::ostream* stream,\n                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);\n\n private:\n  // Returns an JSON-escaped copy of the input string str.\n  static std::string EscapeJson(const std::string&amp; str);\n\n  //// Verifies that the given attribute belongs to the given element and\n  //// streams the attribute as JSON.\n  static void OutputJsonKey(std::ostream* stream,\n                            const std::string&amp; element_name,\n                            const std::string&amp; name, const std::string&amp; value,\n                            const std::string&amp; indent, bool comma = true);\n  static void OutputJsonKey(std::ostream* stream,\n                            const std::string&amp; element_name,\n                            const std::string&amp; name, int value,\n                            const std::string&amp; indent, bool comma = true);\n\n  // Streams a test suite JSON stanza containing the given test result.\n  //\n  // Requires: result.Failed()\n  static void OutputJsonTestSuiteForTestResult(::std::ostream* stream,\n                                               const TestResult&amp; result);\n\n  // Streams a JSON representation of a TestResult object.\n  static void OutputJsonTestResult(::std::ostream* stream,\n                                   const TestResult&amp; result);\n\n  // Streams a JSON representation of a TestInfo object.\n  static void OutputJsonTestInfo(::std::ostream* stream,\n                                 const char* test_suite_name,\n                                 const TestInfo&amp; test_info);\n\n  // Prints a JSON representation of a TestSuite object\n  static void PrintJsonTestSuite(::std::ostream* stream,\n                                 const TestSuite&amp; test_suite);\n\n  // Prints a JSON summary of unit_test to output stream out.\n  static void PrintJsonUnitTest(::std::ostream* stream,\n                                const UnitTest&amp; unit_test);\n\n  // Produces a string representing the test properties in a result as\n  // a JSON dictionary.\n  static std::string TestPropertiesAsJson(const TestResult&amp; result,\n                                          const std::string&amp; indent);\n\n  // The output file.\n  const std::string output_file_;\n\n  JsonUnitTestResultPrinter(const JsonUnitTestResultPrinter&amp;) = delete;\n  JsonUnitTestResultPrinter&amp; operator=(const JsonUnitTestResultPrinter&amp;) =\n      delete;\n};\n\n// Creates a new JsonUnitTestResultPrinter.\nJsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char* output_file)\n    : output_file_(output_file) {\n  if (output_file_.empty()) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;JSON output file may not be null&quot;;\n  }\n}\n\nvoid JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,\n                                                   int /*iteration*/) {\n  FILE* jsonout = OpenFileForWriting(output_file_);\n  std::stringstream stream;\n  PrintJsonUnitTest(&amp;stream, unit_test);\n  fprintf(jsonout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n  fclose(jsonout);\n}\n\n// Returns an JSON-escaped copy of the input string str.\nstd::string JsonUnitTestResultPrinter::EscapeJson(const std::string&amp; str) {\n  Message m;\n\n  for (size_t i = 0; i &lt; str.size(); ++i) {\n    const char ch = str[i];\n    switch (ch) {\n      case &#x27;\\\\&#x27;:\n      case &#x27;&quot;&#x27;:\n      case &#x27;/&#x27;:\n        m &lt;&lt; &#x27;\\\\&#x27; &lt;&lt; ch;\n        break;\n      case &#x27;\\b&#x27;:\n        m &lt;&lt; &quot;\\\\b&quot;;\n        break;\n      case &#x27;\\t&#x27;:\n        m &lt;&lt; &quot;\\\\t&quot;;\n        break;\n      case &#x27;\\n&#x27;:\n        m &lt;&lt; &quot;\\\\n&quot;;\n        break;\n      case &#x27;\\f&#x27;:\n        m &lt;&lt; &quot;\\\\f&quot;;\n        break;\n      case &#x27;\\r&#x27;:\n        m &lt;&lt; &quot;\\\\r&quot;;\n        break;\n      default:\n        if (ch &lt; &#x27; &#x27;) {\n          m &lt;&lt; &quot;\\\\u00&quot; &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch));\n        } else {\n          m &lt;&lt; ch;\n        }\n        break;\n    }\n  }\n\n  return m.GetString();\n}\n\n// The following routines generate an JSON representation of a UnitTest\n// object.\n\n// Formats the given time in milliseconds as seconds.\nstatic std::string FormatTimeInMillisAsDuration(TimeInMillis ms) {\n  ::std::stringstream ss;\n  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3) &lt;&lt; &quot;s&quot;;\n  return ss.str();\n}\n\n// Converts the given epoch time in milliseconds to a date string in the\n// RFC3339 format, without the timezone information.\nstatic std::string FormatEpochTimeInMillisAsRFC3339(TimeInMillis ms) {\n  struct tm time_struct;\n  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))\n    return &quot;&quot;;\n  // YYYY-MM-DDThh:mm:ss\n  return StreamableToString(time_struct.tm_year + 1900) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mon + 1) + &quot;-&quot; +\n         String::FormatIntWidth2(time_struct.tm_mday) + &quot;T&quot; +\n         String::FormatIntWidth2(time_struct.tm_hour) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_min) + &quot;:&quot; +\n         String::FormatIntWidth2(time_struct.tm_sec) + &quot;Z&quot;;\n}\n\nstatic inline std::string Indent(size_t width) {\n  return std::string(width, &#x27; &#x27;);\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonKey(std::ostream* stream,\n                                              const std::string&amp; element_name,\n                                              const std::string&amp; name,\n                                              const std::string&amp; value,\n                                              const std::string&amp; indent,\n                                              bool comma) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Key \\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot; is not allowed for value \\&quot;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;\\&quot;.&quot;;\n\n  *stream &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot;: \\&quot;&quot; &lt;&lt; EscapeJson(value) &lt;&lt; &quot;\\&quot;&quot;;\n  if (comma) *stream &lt;&lt; &quot;,\\n&quot;;\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonKey(\n    std::ostream* stream, const std::string&amp; element_name,\n    const std::string&amp; name, int value, const std::string&amp; indent, bool comma) {\n  const std::vector&lt;std::string&gt;&amp; allowed_names =\n      GetReservedOutputAttributesForElement(element_name);\n\n  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\n               allowed_names.end())\n      &lt;&lt; &quot;Key \\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot; is not allowed for value \\&quot;&quot; &lt;&lt; element_name\n      &lt;&lt; &quot;\\&quot;.&quot;;\n\n  *stream &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; StreamableToString(value);\n  if (comma) *stream &lt;&lt; &quot;,\\n&quot;;\n}\n\n// Streams a test suite JSON stanza containing the given test result.\nvoid JsonUnitTestResultPrinter::OutputJsonTestSuiteForTestResult(\n    ::std::ostream* stream, const TestResult&amp; result) {\n  // Output the boilerplate for a new test suite.\n  *stream &lt;&lt; Indent(4) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, &quot;testsuite&quot;, &quot;name&quot;, &quot;NonTestSuiteFailure&quot;, Indent(6));\n  OutputJsonKey(stream, &quot;testsuite&quot;, &quot;tests&quot;, 1, Indent(6));\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;failures&quot;, 1, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;disabled&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;skipped&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;errors&quot;, 0, Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;time&quot;,\n                  FormatTimeInMillisAsDuration(result.elapsed_time()),\n                  Indent(6));\n    OutputJsonKey(stream, &quot;testsuite&quot;, &quot;timestamp&quot;,\n                  FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                  Indent(6));\n  }\n  *stream &lt;&lt; Indent(6) &lt;&lt; &quot;\\&quot;testsuite\\&quot;: [\\n&quot;;\n\n  // Output the boilerplate for a new test case.\n  *stream &lt;&lt; Indent(8) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;name&quot;, &quot;&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;status&quot;, &quot;RUN&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;result&quot;, &quot;COMPLETED&quot;, Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(result.elapsed_time()),\n                Indent(10));\n  OutputJsonKey(stream, &quot;testcase&quot;, &quot;classname&quot;, &quot;&quot;, Indent(10), false);\n  *stream &lt;&lt; TestPropertiesAsJson(result, Indent(10));\n\n  // Output the actual test result.\n  OutputJsonTestResult(stream, result);\n\n  // Finish the test suite.\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(6) &lt;&lt; &quot;]\\n&quot; &lt;&lt; Indent(4) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints a JSON representation of a TestInfo object.\nvoid JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,\n                                                   const char* test_suite_name,\n                                                   const TestInfo&amp; test_info) {\n  const TestResult&amp; result = *test_info.result();\n  const std::string kTestsuite = &quot;testcase&quot;;\n  const std::string kIndent = Indent(10);\n\n  *stream &lt;&lt; Indent(8) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, kTestsuite, &quot;name&quot;, test_info.name(), kIndent);\n\n  if (test_info.value_param() != nullptr) {\n    OutputJsonKey(stream, kTestsuite, &quot;value_param&quot;, test_info.value_param(),\n                  kIndent);\n  }\n  if (test_info.type_param() != nullptr) {\n    OutputJsonKey(stream, kTestsuite, &quot;type_param&quot;, test_info.type_param(),\n                  kIndent);\n  }\n\n  OutputJsonKey(stream, kTestsuite, &quot;file&quot;, test_info.file(), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;line&quot;, test_info.line(), kIndent, false);\n  if (GTEST_FLAG_GET(list_tests)) {\n    *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(8) &lt;&lt; &quot;}&quot;;\n    return;\n  } else {\n    *stream &lt;&lt; &quot;,\\n&quot;;\n  }\n\n  OutputJsonKey(stream, kTestsuite, &quot;status&quot;,\n                test_info.should_run() ? &quot;RUN&quot; : &quot;NOTRUN&quot;, kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;result&quot;,\n                test_info.should_run()\n                    ? (result.Skipped() ? &quot;SKIPPED&quot; : &quot;COMPLETED&quot;)\n                    : &quot;SUPPRESSED&quot;,\n                kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),\n                kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;classname&quot;, test_suite_name, kIndent,\n                false);\n  *stream &lt;&lt; TestPropertiesAsJson(result, kIndent);\n\n  OutputJsonTestResult(stream, result);\n}\n\nvoid JsonUnitTestResultPrinter::OutputJsonTestResult(::std::ostream* stream,\n                                                     const TestResult&amp; result) {\n  const std::string kIndent = Indent(10);\n\n  {\n    int failures = 0;\n    for (int i = 0; i &lt; result.total_part_count(); ++i) {\n      const TestPartResult&amp; part = result.GetTestPartResult(i);\n      if (part.failed()) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n        if (++failures == 1) {\n          *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;failures&quot; &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n        }\n        const std::string location =\n            internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                            part.line_number());\n        const std::string message =\n            EscapeJson(location + &quot;\\n&quot; + part.message());\n        *stream &lt;&lt; kIndent &lt;&lt; &quot;  {\\n&quot;\n                &lt;&lt; kIndent &lt;&lt; &quot;    \\&quot;failure\\&quot;: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;,\\n&quot;\n                &lt;&lt; kIndent &lt;&lt; &quot;    \\&quot;type\\&quot;: \\&quot;\\&quot;\\n&quot;\n                &lt;&lt; kIndent &lt;&lt; &quot;  }&quot;;\n      }\n    }\n\n    if (failures &gt; 0) *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; kIndent &lt;&lt; &quot;]&quot;;\n  }\n\n  {\n    int skipped = 0;\n    for (int i = 0; i &lt; result.total_part_count(); ++i) {\n      const TestPartResult&amp; part = result.GetTestPartResult(i);\n      if (part.skipped()) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n        if (++skipped == 1) {\n          *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; &quot;skipped&quot; &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n        }\n        const std::string location =\n            internal::FormatCompilerIndependentFileLocation(part.file_name(),\n                                                            part.line_number());\n        const std::string message =\n            EscapeJson(location + &quot;\\n&quot; + part.message());\n        *stream &lt;&lt; kIndent &lt;&lt; &quot;  {\\n&quot;\n                &lt;&lt; kIndent &lt;&lt; &quot;    \\&quot;message\\&quot;: \\&quot;&quot; &lt;&lt; message &lt;&lt; &quot;\\&quot;\\n&quot;\n                &lt;&lt; kIndent &lt;&lt; &quot;  }&quot;;\n      }\n    }\n\n    if (skipped &gt; 0) *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; kIndent &lt;&lt; &quot;]&quot;;\n  }\n\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; Indent(8) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints an JSON representation of a TestSuite object\nvoid JsonUnitTestResultPrinter::PrintJsonTestSuite(\n    std::ostream* stream, const TestSuite&amp; test_suite) {\n  const std::string kTestsuite = &quot;testsuite&quot;;\n  const std::string kIndent = Indent(6);\n\n  *stream &lt;&lt; Indent(4) &lt;&lt; &quot;{\\n&quot;;\n  OutputJsonKey(stream, kTestsuite, &quot;name&quot;, test_suite.name(), kIndent);\n  OutputJsonKey(stream, kTestsuite, &quot;tests&quot;, test_suite.reportable_test_count(),\n                kIndent);\n  if (!GTEST_FLAG_GET(list_tests)) {\n    OutputJsonKey(stream, kTestsuite, &quot;failures&quot;,\n                  test_suite.failed_test_count(), kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;disabled&quot;,\n                  test_suite.reportable_disabled_test_count(), kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;errors&quot;, 0, kIndent);\n    OutputJsonKey(\n        stream, kTestsuite, &quot;timestamp&quot;,\n        FormatEpochTimeInMillisAsRFC3339(test_suite.start_timestamp()),\n        kIndent);\n    OutputJsonKey(stream, kTestsuite, &quot;time&quot;,\n                  FormatTimeInMillisAsDuration(test_suite.elapsed_time()),\n                  kIndent, false);\n    *stream &lt;&lt; TestPropertiesAsJson(test_suite.ad_hoc_test_result(), kIndent)\n            &lt;&lt; &quot;,\\n&quot;;\n  }\n\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuite &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  bool comma = false;\n  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {\n    if (test_suite.GetTestInfo(i)-&gt;is_reportable()) {\n      if (comma) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n      } else {\n        comma = true;\n      }\n      OutputJsonTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));\n    }\n  }\n  *stream &lt;&lt; &quot;\\n&quot; &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot; &lt;&lt; Indent(4) &lt;&lt; &quot;}&quot;;\n}\n\n// Prints a JSON summary of unit_test to output stream out.\nvoid JsonUnitTestResultPrinter::PrintJsonUnitTest(std::ostream* stream,\n                                                  const UnitTest&amp; unit_test) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n  const std::string kIndent = Indent(2);\n  *stream &lt;&lt; &quot;{\\n&quot;;\n\n  OutputJsonKey(stream, kTestsuites, &quot;tests&quot;, unit_test.reportable_test_count(),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;failures&quot;, unit_test.failed_test_count(),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;disabled&quot;,\n                unit_test.reportable_disabled_test_count(), kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;errors&quot;, 0, kIndent);\n  if (GTEST_FLAG_GET(shuffle)) {\n    OutputJsonKey(stream, kTestsuites, &quot;random_seed&quot;, unit_test.random_seed(),\n                  kIndent);\n  }\n  OutputJsonKey(stream, kTestsuites, &quot;timestamp&quot;,\n                FormatEpochTimeInMillisAsRFC3339(unit_test.start_timestamp()),\n                kIndent);\n  OutputJsonKey(stream, kTestsuites, &quot;time&quot;,\n                FormatTimeInMillisAsDuration(unit_test.elapsed_time()), kIndent,\n                false);\n\n  *stream &lt;&lt; TestPropertiesAsJson(unit_test.ad_hoc_test_result(), kIndent)\n          &lt;&lt; &quot;,\\n&quot;;\n\n  OutputJsonKey(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;, kIndent);\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  bool comma = false;\n  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {\n    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0) {\n      if (comma) {\n        *stream &lt;&lt; &quot;,\\n&quot;;\n      } else {\n        comma = true;\n      }\n      PrintJsonTestSuite(stream, *unit_test.GetTestSuite(i));\n    }\n  }\n\n  // If there was a test failure outside of one of the test suites (like in a\n  // test environment) include that in the output.\n  if (unit_test.ad_hoc_test_result().Failed()) {\n    if (comma) {\n      *stream &lt;&lt; &quot;,\\n&quot;;\n    }\n    OutputJsonTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());\n  }\n\n  *stream &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot;\n          &lt;&lt; &quot;}\\n&quot;;\n}\n\nvoid JsonUnitTestResultPrinter::PrintJsonTestList(\n    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {\n  const std::string kTestsuites = &quot;testsuites&quot;;\n  const std::string kIndent = Indent(2);\n  *stream &lt;&lt; &quot;{\\n&quot;;\n  int total_tests = 0;\n  for (auto test_suite : test_suites) {\n    total_tests += test_suite-&gt;total_test_count();\n  }\n  OutputJsonKey(stream, kTestsuites, &quot;tests&quot;, total_tests, kIndent);\n\n  OutputJsonKey(stream, kTestsuites, &quot;name&quot;, &quot;AllTests&quot;, kIndent);\n  *stream &lt;&lt; kIndent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; kTestsuites &lt;&lt; &quot;\\&quot;: [\\n&quot;;\n\n  for (size_t i = 0; i &lt; test_suites.size(); ++i) {\n    if (i != 0) {\n      *stream &lt;&lt; &quot;,\\n&quot;;\n    }\n    PrintJsonTestSuite(stream, *test_suites[i]);\n  }\n\n  *stream &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; kIndent &lt;&lt; &quot;]\\n&quot;\n          &lt;&lt; &quot;}\\n&quot;;\n}\n// Produces a string representing the test properties in a result as\n// a JSON dictionary.\nstd::string JsonUnitTestResultPrinter::TestPropertiesAsJson(\n    const TestResult&amp; result, const std::string&amp; indent) {\n  Message attributes;\n  for (int i = 0; i &lt; result.test_property_count(); ++i) {\n    const TestProperty&amp; property = result.GetTestProperty(i);\n    attributes &lt;&lt; &quot;,\\n&quot;\n               &lt;&lt; indent &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; property.key() &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; &quot;\\&quot;&quot;\n               &lt;&lt; EscapeJson(property.value()) &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  return attributes.GetString();\n}\n\n// End JsonUnitTestResultPrinter\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n#if GTEST_CAN_STREAM_RESULTS_\n\n// Checks if str contains &#x27;=&#x27;, &#x27;&amp;&#x27;, &#x27;%&#x27; or &#x27;\\n&#x27; characters. If yes,\n// replaces them by &quot;%xx&quot; where xx is their hexadecimal value. For\n// example, replaces &quot;=&quot; with &quot;%3D&quot;.  This algorithm is O(strlen(str))\n// in both time and space -- important as the input str may contain an\n// arbitrarily long test failure message and stack trace.\nstd::string StreamingListener::UrlEncode(const char* str) {\n  std::string result;\n  result.reserve(strlen(str) + 1);\n  for (char ch = *str; ch != &#x27;\\0&#x27;; ch = *++str) {\n    switch (ch) {\n      case &#x27;%&#x27;:\n      case &#x27;=&#x27;:\n      case &#x27;&amp;&#x27;:\n      case &#x27;\\n&#x27;:\n        result.push_back(&#x27;%&#x27;);\n        result.append(String::FormatByte(static_cast&lt;unsigned char&gt;(ch)));\n        break;\n      default:\n        result.push_back(ch);\n        break;\n    }\n  }\n  return result;\n}\n\nvoid StreamingListener::SocketWriter::MakeConnection() {\n  GTEST_CHECK_(sockfd_ == -1)\n      &lt;&lt; &quot;MakeConnection() can&#x27;t be called when there is already a connection.&quot;;\n\n  addrinfo hints;\n  memset(&amp;hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;  // To allow both IPv4 and IPv6 addresses.\n  hints.ai_socktype = SOCK_STREAM;\n  addrinfo* servinfo = nullptr;\n\n  // Use the getaddrinfo() to get a linked list of IP addresses for\n  // the given host name.\n  const int error_num =\n      getaddrinfo(host_name_.c_str(), port_num_.c_str(), &amp;hints, &amp;servinfo);\n  if (error_num != 0) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;stream_result_to: getaddrinfo() failed: &quot;\n                        &lt;&lt; gai_strerror(error_num);\n  }\n\n  // Loop through all the results and connect to the first we can.\n  for (addrinfo* cur_addr = servinfo; sockfd_ == -1 &amp;&amp; cur_addr != nullptr;\n       cur_addr = cur_addr-&gt;ai_next) {\n    sockfd_ = socket(cur_addr-&gt;ai_family, cur_addr-&gt;ai_socktype,\n                     cur_addr-&gt;ai_protocol);\n    if (sockfd_ != -1) {\n      // Connect the client socket to the server socket.\n      if (connect(sockfd_, cur_addr-&gt;ai_addr, cur_addr-&gt;ai_addrlen) == -1) {\n        close(sockfd_);\n        sockfd_ = -1;\n      }\n    }\n  }\n\n  freeaddrinfo(servinfo);  // all done with this structure\n\n  if (sockfd_ == -1) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;stream_result_to: failed to connect to &quot;\n                        &lt;&lt; host_name_ &lt;&lt; &quot;:&quot; &lt;&lt; port_num_;\n  }\n}\n\n// End of class Streaming Listener\n#endif  // GTEST_CAN_STREAM_RESULTS__\n\n// class OsStackTraceGetter\n\nconst char* const OsStackTraceGetterInterface::kElidedFramesMarker =\n    &quot;... &quot; GTEST_NAME_ &quot; internal frames ...&quot;;\n\nstd::string OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n#ifdef GTEST_HAS_ABSL\n  std::string result;\n\n  if (max_depth &lt;= 0) {\n    return result;\n  }\n\n  max_depth = std::min(max_depth, kMaxStackTraceDepth);\n\n  std::vector&lt;void*&gt; raw_stack(max_depth);\n  // Skips the frames requested by the caller, plus this function.\n  const int raw_stack_size =\n      absl::GetStackTrace(&amp;raw_stack[0], max_depth, skip_count + 1);\n\n  void* caller_frame = nullptr;\n  {\n    MutexLock lock(&amp;mutex_);\n    caller_frame = caller_frame_;\n  }\n\n  for (int i = 0; i &lt; raw_stack_size; ++i) {\n    if (raw_stack[i] == caller_frame &amp;&amp;\n        !GTEST_FLAG_GET(show_internal_stack_frames)) {\n      // Add a marker to the trace and stop adding frames.\n      absl::StrAppend(&amp;result, kElidedFramesMarker, &quot;\\n&quot;);\n      break;\n    }\n\n    char tmp[1024];\n    const char* symbol = &quot;(unknown)&quot;;\n    if (absl::Symbolize(raw_stack[i], tmp, sizeof(tmp))) {\n      symbol = tmp;\n    }\n\n    char line[1024];\n    snprintf(line, sizeof(line), &quot;  %p: %s\\n&quot;, raw_stack[i], symbol);\n    result += line;\n  }\n\n  return result;\n\n#else   // !GTEST_HAS_ABSL\n  static_cast&lt;void&gt;(max_depth);\n  static_cast&lt;void&gt;(skip_count);\n  return &quot;&quot;;\n#endif  // GTEST_HAS_ABSL\n}\n\nvoid OsStackTraceGetter::UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_) {\n#ifdef GTEST_HAS_ABSL\n  void* caller_frame = nullptr;\n  if (absl::GetStackTrace(&amp;caller_frame, 1, 3) &lt;= 0) {\n    caller_frame = nullptr;\n  }\n\n  MutexLock lock(&amp;mutex_);\n  caller_frame_ = caller_frame;\n#endif  // GTEST_HAS_ABSL\n}\n\n#ifdef GTEST_HAS_DEATH_TEST\n// A helper class that creates the premature-exit file in its\n// constructor and deletes the file in its destructor.\nclass ScopedPrematureExitFile {\n public:\n  explicit ScopedPrematureExitFile(const char* premature_exit_filepath)\n      : premature_exit_filepath_(\n            premature_exit_filepath ? premature_exit_filepath : &quot;&quot;) {\n    // If a path to the premature-exit file is specified...\n    if (!premature_exit_filepath_.empty()) {\n      // create the file with a single &quot;0&quot; character in it.  I/O\n      // errors are ignored as there&#x27;s nothing better we can do and we\n      // don&#x27;t want to fail the test because of this.\n      FILE* pfile = posix::FOpen(premature_exit_filepath_.c_str(), &quot;w&quot;);\n      fwrite(&quot;0&quot;, 1, 1, pfile);\n      fclose(pfile);\n    }\n  }\n\n  ~ScopedPrematureExitFile() {\n#ifndef GTEST_OS_ESP8266\n    if (!premature_exit_filepath_.empty()) {\n      int retval = remove(premature_exit_filepath_.c_str());\n      if (retval) {\n        GTEST_LOG_(ERROR) &lt;&lt; &quot;Failed to remove premature exit filepath \\&quot;&quot;\n                          &lt;&lt; premature_exit_filepath_ &lt;&lt; &quot;\\&quot; with error &quot;\n                          &lt;&lt; retval;\n      }\n    }\n#endif\n  }\n\n private:\n  const std::string premature_exit_filepath_;\n\n  ScopedPrematureExitFile(const ScopedPrematureExitFile&amp;) = delete;\n  ScopedPrematureExitFile&amp; operator=(const ScopedPrematureExitFile&amp;) = delete;\n};\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace internal\n\n// class TestEventListeners\n\nTestEventListeners::TestEventListeners()\n    : repeater_(new internal::TestEventRepeater()),\n      default_result_printer_(nullptr),\n      default_xml_generator_(nullptr) {}\n\nTestEventListeners::~TestEventListeners() { delete repeater_; }\n\n// Returns the standard listener responsible for the default console\n// output.  Can be removed from the listeners list to shut down default\n// console output.  Note that removing this object from the listener list\n// with Release transfers its ownership to the user.\nvoid TestEventListeners::Append(TestEventListener* listener) {\n  repeater_-&gt;Append(listener);\n}\n\n// Removes the given event listener from the list and returns it.  It then\n// becomes the caller&#x27;s responsibility to delete the listener. Returns\n// NULL if the listener is not found in the list.\nTestEventListener* TestEventListeners::Release(TestEventListener* listener) {\n  if (listener == default_result_printer_)\n    default_result_printer_ = nullptr;\n  else if (listener == default_xml_generator_)\n    default_xml_generator_ = nullptr;\n  return repeater_-&gt;Release(listener);\n}\n\n// Returns repeater that broadcasts the TestEventListener events to all\n// subscribers.\nTestEventListener* TestEventListeners::repeater() { return repeater_; }\n\n// Sets the default_result_printer attribute to the provided listener.\n// The listener is also added to the listener list and previous\n// default_result_printer is removed from it and deleted. The listener can\n// also be NULL in which case it will not be added to the list. Does\n// nothing if the previous and the current listener objects are the same.\nvoid TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {\n  if (default_result_printer_ != listener) {\n    // It is an error to pass this method a listener that is already in the\n    // list.\n    delete Release(default_result_printer_);\n    default_result_printer_ = listener;\n    if (listener != nullptr) Append(listener);\n  }\n}\n\n// Sets the default_xml_generator attribute to the provided listener.  The\n// listener is also added to the listener list and previous\n// default_xml_generator is removed from it and deleted. The listener can\n// also be NULL in which case it will not be added to the list. Does\n// nothing if the previous and the current listener objects are the same.\nvoid TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {\n  if (default_xml_generator_ != listener) {\n    // It is an error to pass this method a listener that is already in the\n    // list.\n    delete Release(default_xml_generator_);\n    default_xml_generator_ = listener;\n    if (listener != nullptr) Append(listener);\n  }\n}\n\n// Controls whether events will be forwarded by the repeater to the\n// listeners in the list.\nbool TestEventListeners::EventForwardingEnabled() const {\n  return repeater_-&gt;forwarding_enabled();\n}\n\nvoid TestEventListeners::SuppressEventForwarding(bool suppress) {\n  repeater_-&gt;set_forwarding_enabled(!suppress);\n}\n\n// class UnitTest\n\n// Gets the singleton UnitTest object.  The first time this method is\n// called, a UnitTest object is constructed and returned.  Consecutive\n// calls will return the same object.\n//\n// We don&#x27;t protect this under mutex_ as a user is not supposed to\n// call this before main() starts, from which point on the return\n// value will never change.\nUnitTest* UnitTest::GetInstance() {\n  // CodeGear C++Builder insists on a public destructor for the\n  // default implementation.  Use this implementation to keep good OO\n  // design with private destructor.\n\n#if defined(__BORLANDC__)\n  static UnitTest* const instance = new UnitTest;\n  return instance;\n#else\n  static UnitTest instance;\n  return &amp;instance;\n#endif  // defined(__BORLANDC__)\n}\n\n// Gets the number of successful test suites.\nint UnitTest::successful_test_suite_count() const {\n  return impl()-&gt;successful_test_suite_count();\n}\n\n// Gets the number of failed test suites.\nint UnitTest::failed_test_suite_count() const {\n  return impl()-&gt;failed_test_suite_count();\n}\n\n// Gets the number of all test suites.\nint UnitTest::total_test_suite_count() const {\n  return impl()-&gt;total_test_suite_count();\n}\n\n// Gets the number of all test suites that contain at least one test\n// that should run.\nint UnitTest::test_suite_to_run_count() const {\n  return impl()-&gt;test_suite_to_run_count();\n}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nint UnitTest::successful_test_case_count() const {\n  return impl()-&gt;successful_test_suite_count();\n}\nint UnitTest::failed_test_case_count() const {\n  return impl()-&gt;failed_test_suite_count();\n}\nint UnitTest::total_test_case_count() const {\n  return impl()-&gt;total_test_suite_count();\n}\nint UnitTest::test_case_to_run_count() const {\n  return impl()-&gt;test_suite_to_run_count();\n}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n// Gets the number of successful tests.\nint UnitTest::successful_test_count() const {\n  return impl()-&gt;successful_test_count();\n}\n\n// Gets the number of skipped tests.\nint UnitTest::skipped_test_count() const {\n  return impl()-&gt;skipped_test_count();\n}\n\n// Gets the number of failed tests.\nint UnitTest::failed_test_count() const { return impl()-&gt;failed_test_count(); }\n\n// Gets the number of disabled tests that will be reported in the XML report.\nint UnitTest::reportable_disabled_test_count() const {\n  return impl()-&gt;reportable_disabled_test_count();\n}\n\n// Gets the number of disabled tests.\nint UnitTest::disabled_test_count() const {\n  return impl()-&gt;disabled_test_count();\n}\n\n// Gets the number of tests to be printed in the XML report.\nint UnitTest::reportable_test_count() const {\n  return impl()-&gt;reportable_test_count();\n}\n\n// Gets the number of all tests.\nint UnitTest::total_test_count() const { return impl()-&gt;total_test_count(); }\n\n// Gets the number of tests that should run.\nint UnitTest::test_to_run_count() const { return impl()-&gt;test_to_run_count(); }\n\n// Gets the time of the test program start, in ms from the start of the\n// UNIX epoch.\ninternal::TimeInMillis UnitTest::start_timestamp() const {\n  return impl()-&gt;start_timestamp();\n}\n\n// Gets the elapsed time, in milliseconds.\ninternal::TimeInMillis UnitTest::elapsed_time() const {\n  return impl()-&gt;elapsed_time();\n}\n\n// Returns true if and only if the unit test passed (i.e. all test suites\n// passed).\nbool UnitTest::Passed() const { return impl()-&gt;Passed(); }\n\n// Returns true if and only if the unit test failed (i.e. some test suite\n// failed or something outside of all tests failed).\nbool UnitTest::Failed() const { return impl()-&gt;Failed(); }\n\n// Gets the i-th test suite among all the test suites. i can range from 0 to\n// total_test_suite_count() - 1. If i is not in that range, returns NULL.\nconst TestSuite* UnitTest::GetTestSuite(int i) const {\n  return impl()-&gt;GetTestSuite(i);\n}\n\n//  Legacy API is deprecated but still available\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nconst TestCase* UnitTest::GetTestCase(int i) const {\n  return impl()-&gt;GetTestCase(i);\n}\n#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_\n\n// Returns the TestResult containing information on test failures and\n// properties logged outside of individual test suites.\nconst TestResult&amp; UnitTest::ad_hoc_test_result() const {\n  return *impl()-&gt;ad_hoc_test_result();\n}\n\n// Gets the i-th test suite among all the test suites. i can range from 0 to\n// total_test_suite_count() - 1. If i is not in that range, returns NULL.\nTestSuite* UnitTest::GetMutableTestSuite(int i) {\n  return impl()-&gt;GetMutableSuiteCase(i);\n}\n\nvoid UnitTest::UponLeavingGTest() {\n  impl()-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();\n}\n\n// Sets the TestSuite object for the test that&#x27;s currently running.\nvoid UnitTest::set_current_test_suite(TestSuite* a_current_test_suite) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;set_current_test_suite(a_current_test_suite);\n}\n\n// Sets the TestInfo object for the test that&#x27;s currently running.\nvoid UnitTest::set_current_test_info(TestInfo* a_current_test_info) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;set_current_test_info(a_current_test_info);\n}\n\n// Returns the list of event listeners that can be used to track events\n// inside Google Test.\nTestEventListeners&amp; UnitTest::listeners() { return *impl()-&gt;listeners(); }\n\n// Registers and returns a global test environment.  When a test\n// program is run, all global test environments will be set-up in the\n// order they were registered.  After all tests in the program have\n// finished, all global test environments will be torn-down in the\n// *reverse* order they were registered.\n//\n// The UnitTest object takes ownership of the given environment.\n//\n// We don&#x27;t protect this under mutex_, as we only support calling it\n// from the main thread.\nEnvironment* UnitTest::AddEnvironment(Environment* env) {\n  if (env == nullptr) {\n    return nullptr;\n  }\n\n  impl_-&gt;environments().push_back(env);\n  return env;\n}\n\n// Adds a TestPartResult to the current TestResult object.  All Google Test\n// assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call\n// this to report their results.  The user code should use the\n// assertion macros instead of calling this directly.\nvoid UnitTest::AddTestPartResult(TestPartResult::Type result_type,\n                                 const char* file_name, int line_number,\n                                 const std::string&amp; message,\n                                 const std::string&amp; os_stack_trace)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  Message msg;\n  msg &lt;&lt; message;\n\n  internal::MutexLock lock(&amp;mutex_);\n  if (!impl_-&gt;gtest_trace_stack().empty()) {\n    msg &lt;&lt; &quot;\\n&quot; &lt;&lt; GTEST_NAME_ &lt;&lt; &quot; trace:&quot;;\n\n    for (size_t i = impl_-&gt;gtest_trace_stack().size(); i &gt; 0; --i) {\n      const internal::TraceInfo&amp; trace = impl_-&gt;gtest_trace_stack()[i - 1];\n      msg &lt;&lt; &quot;\\n&quot;\n          &lt;&lt; internal::FormatFileLocation(trace.file, trace.line) &lt;&lt; &quot; &quot;\n          &lt;&lt; trace.message;\n    }\n  }\n\n  if (os_stack_trace.c_str() != nullptr &amp;&amp; !os_stack_trace.empty()) {\n    msg &lt;&lt; internal::kStackTraceMarker &lt;&lt; os_stack_trace;\n  } else {\n    msg &lt;&lt; &quot;\\n&quot;;\n  }\n\n  const TestPartResult result = TestPartResult(\n      result_type, file_name, line_number, msg.GetString().c_str());\n  impl_-&gt;GetTestPartResultReporterForCurrentThread()-&gt;ReportTestPartResult(\n      result);\n\n  if (result_type != TestPartResult::kSuccess &amp;&amp;\n      result_type != TestPartResult::kSkip) {\n    // gtest_break_on_failure takes precedence over\n    // gtest_throw_on_failure.  This allows a user to set the latter\n    // in the code (perhaps in order to use Google Test assertions\n    // with another testing framework) and specify the former on the\n    // command line for debugging.\n    if (GTEST_FLAG_GET(break_on_failure)) {\n#if defined(GTEST_OS_WINDOWS) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT)\n      // Using DebugBreak on Windows allows gtest to still break into a debugger\n      // when a failure happens and both the --gtest_break_on_failure and\n      // the --gtest_catch_exceptions flags are specified.\n      DebugBreak();\n#elif (!defined(__native_client__)) &amp;&amp;            \\\n    ((defined(__clang__) || defined(__GNUC__)) &amp;&amp; \\\n     (defined(__x86_64__) || defined(__i386__)))\n      // with clang/gcc we can achieve the same effect on x86 by invoking int3\n      asm(&quot;int3&quot;);\n#elif GTEST_HAS_BUILTIN(__builtin_trap)\n      __builtin_trap();\n#elif defined(SIGTRAP)\n      raise(SIGTRAP);\n#else\n      // Dereference nullptr through a volatile pointer to prevent the compiler\n      // from removing. We use this rather than abort() or __builtin_trap() for\n      // portability: some debuggers don&#x27;t correctly trap abort().\n      *static_cast&lt;volatile int*&gt;(nullptr) = 1;\n#endif  // GTEST_OS_WINDOWS\n    } else if (GTEST_FLAG_GET(throw_on_failure)) {\n#if GTEST_HAS_EXCEPTIONS\n      throw internal::GoogleTestFailureException(result);\n#else\n      // We cannot call abort() as it generates a pop-up in debug mode\n      // that cannot be suppressed in VC 7.1 or below.\n      exit(1);\n#endif\n    }\n  }\n}\n\n// Adds a TestProperty to the current TestResult object when invoked from\n// inside a test, to current TestSuite&#x27;s ad_hoc_test_result_ when invoked\n// from SetUpTestSuite or TearDownTestSuite, or to the global property set\n// when invoked elsewhere.  If the result already contains a property with\n// the same key, the value will be updated.\nvoid UnitTest::RecordProperty(const std::string&amp; key,\n                              const std::string&amp; value) {\n  impl_-&gt;RecordProperty(TestProperty(key, value));\n}\n\n// Runs all tests in this UnitTest object and prints the result.\n// Returns 0 if successful, or 1 otherwise.\n//\n// We don&#x27;t protect this under mutex_, as we only support calling it\n// from the main thread.\nint UnitTest::Run() {\n#ifdef GTEST_HAS_DEATH_TEST\n  const bool in_death_test_child_process =\n      !GTEST_FLAG_GET(internal_run_death_test).empty();\n\n  // Google Test implements this protocol for catching that a test\n  // program exits before returning control to Google Test:\n  //\n  //   1. Upon start, Google Test creates a file whose absolute path\n  //      is specified by the environment variable\n  //      TEST_PREMATURE_EXIT_FILE.\n  //   2. When Google Test has finished its work, it deletes the file.\n  //\n  // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before\n  // running a Google-Test-based test program and check the existence\n  // of the file at the end of the test execution to see if it has\n  // exited prematurely.\n\n  // If we are in the child process of a death test, don&#x27;t\n  // create/delete the premature exit file, as doing so is unnecessary\n  // and will confuse the parent process.  Otherwise, create/delete\n  // the file upon entering/leaving this function.  If the program\n  // somehow exits before this function has a chance to return, the\n  // premature-exit file will be left undeleted, causing a test runner\n  // that understands the premature-exit-file protocol to report the\n  // test as having failed.\n  const internal::ScopedPrematureExitFile premature_exit_file(\n      in_death_test_child_process\n          ? nullptr\n          : internal::posix::GetEnv(&quot;TEST_PREMATURE_EXIT_FILE&quot;));\n#else\n  const bool in_death_test_child_process = false;\n#endif  // GTEST_HAS_DEATH_TEST\n\n  // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be\n  // used for the duration of the program.\n  impl()-&gt;set_catch_exceptions(GTEST_FLAG_GET(catch_exceptions));\n\n#ifdef GTEST_OS_WINDOWS\n  // Either the user wants Google Test to catch exceptions thrown by the\n  // tests or this is executing in the context of death test child\n  // process. In either case the user does not want to see pop-up dialogs\n  // about crashes - they are expected.\n  if (impl()-&gt;catch_exceptions() || in_death_test_child_process) {\n#if !defined(GTEST_OS_WINDOWS_MOBILE) &amp;&amp; !defined(GTEST_OS_WINDOWS_PHONE) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_RT) &amp;&amp; !defined(GTEST_OS_WINDOWS_GAMES)\n    // SetErrorMode doesn&#x27;t exist on CE.\n    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |\n                 SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n#if (defined(_MSC_VER) || defined(GTEST_OS_WINDOWS_MINGW)) &amp;&amp; \\\n    !defined(GTEST_OS_WINDOWS_MOBILE)\n    // Death test children can be terminated with _abort().  On Windows,\n    // _abort() can show a dialog with a warning message.  This forces the\n    // abort message to go to stderr instead.\n    _set_error_mode(_OUT_TO_STDERR);\n#endif\n\n#if defined(_MSC_VER) &amp;&amp; !defined(GTEST_OS_WINDOWS_MOBILE)\n    // In the debug version, Visual Studio pops up a separate dialog\n    // offering a choice to debug the aborted program. We need to suppress\n    // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement\n    // executed. Google Test will notify the user of any unexpected\n    // failure via stderr.\n    if (!GTEST_FLAG_GET(break_on_failure))\n      _set_abort_behavior(\n          0x0,                                    // Clear the following flags:\n          _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  // pop-up window, core dump.\n\n    // In debug mode, the Windows CRT can crash with an assertion over invalid\n    // input (e.g. passing an invalid file descriptor).  The default handling\n    // for these assertions is to pop up a dialog and wait for user input.\n    // Instead ask the CRT to dump such assertions to stderr non-interactively.\n    if (!IsDebuggerPresent()) {\n      (void)_CrtSetReportMode(_CRT_ASSERT,\n                              _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n      (void)_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n    }\n#endif\n  }\n#else\n  (void)in_death_test_child_process;  // Needed inside the #if block above\n#endif  // GTEST_OS_WINDOWS\n\n  return internal::HandleExceptionsInMethodIfSupported(\n             impl(), &amp;internal::UnitTestImpl::RunAllTests,\n             &quot;auxiliary test code (environments or event listeners)&quot;)\n             ? 0\n             : 1;\n}\n\n#if GTEST_HAS_FILE_SYSTEM\n// Returns the working directory when the first TEST() or TEST_F() was\n// executed.\nconst char* UnitTest::original_working_dir() const {\n  return impl_-&gt;original_working_dir_.c_str();\n}\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Returns the TestSuite object for the test that&#x27;s currently running,\n// or NULL if no test is running.\nconst TestSuite* UnitTest::current_test_suite() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_suite();\n}\n\n// Legacy API is still available but deprecated\n#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_\nconst TestCase* UnitTest::current_test_case() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_suite();\n}\n#endif\n\n// Returns the TestInfo object for the test that&#x27;s currently running,\n// or NULL if no test is running.\nconst TestInfo* UnitTest::current_test_info() const\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  return impl_-&gt;current_test_info();\n}\n\n// Returns the random seed used at the start of the current test run.\nint UnitTest::random_seed() const { return impl_-&gt;random_seed(); }\n\n// Returns ParameterizedTestSuiteRegistry object used to keep track of\n// value-parameterized tests and instantiate and register them.\ninternal::ParameterizedTestSuiteRegistry&amp;\nUnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) {\n  return impl_-&gt;parameterized_test_registry();\n}\n\n// Creates an empty UnitTest.\nUnitTest::UnitTest() { impl_ = new internal::UnitTestImpl(this); }\n\n// Destructor of UnitTest.\nUnitTest::~UnitTest() { delete impl_; }\n\n// Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n// Google Test trace stack.\nvoid UnitTest::PushGTestTrace(const internal::TraceInfo&amp; trace)\n    GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;gtest_trace_stack().push_back(trace);\n}\n\n// Pops a trace from the per-thread Google Test trace stack.\nvoid UnitTest::PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_) {\n  internal::MutexLock lock(&amp;mutex_);\n  impl_-&gt;gtest_trace_stack().pop_back();\n}\n\nnamespace internal {\n\nUnitTestImpl::UnitTestImpl(UnitTest* parent)\n    : parent_(parent),\n      GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 /* using this in initializer */)\n          default_global_test_part_result_reporter_(this),\n      default_per_thread_test_part_result_reporter_(this),\n      GTEST_DISABLE_MSC_WARNINGS_POP_() global_test_part_result_reporter_(\n          &amp;default_global_test_part_result_reporter_),\n      per_thread_test_part_result_reporter_(\n          &amp;default_per_thread_test_part_result_reporter_),\n      parameterized_test_registry_(),\n      parameterized_tests_registered_(false),\n      last_death_test_suite_(-1),\n      current_test_suite_(nullptr),\n      current_test_info_(nullptr),\n      ad_hoc_test_result_(),\n      os_stack_trace_getter_(nullptr),\n      post_flag_parse_init_performed_(false),\n      random_seed_(0),  // Will be overridden by the flag before first use.\n      random_(0),       // Will be reseeded before first use.\n      start_timestamp_(0),\n      elapsed_time_(0),\n#ifdef GTEST_HAS_DEATH_TEST\n      death_test_factory_(new DefaultDeathTestFactory),\n#endif\n      // Will be overridden by the flag before first use.\n      catch_exceptions_(false) {\n  listeners()-&gt;SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);\n}\n\nUnitTestImpl::~UnitTestImpl() {\n  // Deletes every TestSuite.\n  ForEach(test_suites_, internal::Delete&lt;TestSuite&gt;);\n\n  // Deletes every Environment.\n  ForEach(environments_, internal::Delete&lt;Environment&gt;);\n\n  delete os_stack_trace_getter_;\n}\n\n// Adds a TestProperty to the current TestResult object when invoked in a\n// context of a test, to current test suite&#x27;s ad_hoc_test_result when invoke\n// from SetUpTestSuite/TearDownTestSuite, or to the global property set\n// otherwise.  If the result already contains a property with the same key,\n// the value will be updated.\nvoid UnitTestImpl::RecordProperty(const TestProperty&amp; test_property) {\n  std::string xml_element;\n  TestResult* test_result;  // TestResult appropriate for property recording.\n\n  if (current_test_info_ != nullptr) {\n    xml_element = &quot;testcase&quot;;\n    test_result = &amp;(current_test_info_-&gt;result_);\n  } else if (current_test_suite_ != nullptr) {\n    xml_element = &quot;testsuite&quot;;\n    test_result = &amp;(current_test_suite_-&gt;ad_hoc_test_result_);\n  } else {\n    xml_element = &quot;testsuites&quot;;\n    test_result = &amp;ad_hoc_test_result_;\n  }\n  test_result-&gt;RecordProperty(xml_element, test_property);\n}\n\n#ifdef GTEST_HAS_DEATH_TEST\n// Disables event forwarding if the control is currently in a death test\n// subprocess. Must not be called before InitGoogleTest.\nvoid UnitTestImpl::SuppressTestEventsIfInSubprocess() {\n  if (internal_run_death_test_flag_ != nullptr)\n    listeners()-&gt;SuppressEventForwarding(true);\n}\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Initializes event listeners performing XML output as specified by\n// UnitTestOptions. Must not be called before InitGoogleTest.\nvoid UnitTestImpl::ConfigureXmlOutput() {\n  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();\n#if GTEST_HAS_FILE_SYSTEM\n  if (output_format == &quot;xml&quot;) {\n    listeners()-&gt;SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(\n        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\n  } else if (output_format == &quot;json&quot;) {\n    listeners()-&gt;SetDefaultXmlGenerator(new JsonUnitTestResultPrinter(\n        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\n  } else if (!output_format.empty()) {\n    GTEST_LOG_(WARNING) &lt;&lt; &quot;WARNING: unrecognized output format \\&quot;&quot;\n                        &lt;&lt; output_format &lt;&lt; &quot;\\&quot; ignored.&quot;;\n  }\n#else\n  if (!output_format.empty()) {\n    GTEST_LOG_(ERROR) &lt;&lt; &quot;ERROR: alternative output formats require &quot;\n                      &lt;&lt; &quot;GTEST_HAS_FILE_SYSTEM to be enabled&quot;;\n  }\n#endif  // GTEST_HAS_FILE_SYSTEM\n}\n\n#if GTEST_CAN_STREAM_RESULTS_\n// Initializes event listeners for streaming test results in string form.\n// Must not be called before InitGoogleTest.\nvoid UnitTestImpl::ConfigureStreamingOutput() {\n  const std::string&amp; target = GTEST_FLAG_GET(stream_result_to);\n  if (!target.empty()) {\n    const size_t pos = target.find(&#x27;:&#x27;);\n    if (pos != std::string::npos) {\n      listeners()-&gt;Append(\n          new StreamingListener(target.substr(0, pos), target.substr(pos + 1)));\n    } else {\n      GTEST_LOG_(WARNING) &lt;&lt; &quot;unrecognized streaming target \\&quot;&quot; &lt;&lt; target\n                          &lt;&lt; &quot;\\&quot; ignored.&quot;;\n    }\n  }\n}\n#endif  // GTEST_CAN_STREAM_RESULTS_\n\n// Performs initialization dependent upon flag values obtained in\n// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to\n// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest\n// this function is also called from RunAllTests.  Since this function can be\n// called more than once, it has to be idempotent.\nvoid UnitTestImpl::PostFlagParsingInit() {\n  // Ensures that this function does not execute more than once.\n  if (!post_flag_parse_init_performed_) {\n    post_flag_parse_init_performed_ = true;\n\n#if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)\n    // Register to send notifications about key process state changes.\n    listeners()-&gt;Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());\n#endif  // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)\n\n#ifdef GTEST_HAS_DEATH_TEST\n    InitDeathTestSubprocessControlInfo();\n    SuppressTestEventsIfInSubprocess();\n#endif  // GTEST_HAS_DEATH_TEST\n\n    // Registers parameterized tests. This makes parameterized tests\n    // available to the UnitTest reflection API without running\n    // RUN_ALL_TESTS.\n    RegisterParameterizedTests();\n\n    // Configures listeners for XML output. This makes it possible for users\n    // to shut down the default XML output before invoking RUN_ALL_TESTS.\n    ConfigureXmlOutput();\n\n    if (GTEST_FLAG_GET(brief)) {\n      listeners()-&gt;SetDefaultResultPrinter(new BriefUnitTestResultPrinter);\n    }\n\n#if GTEST_CAN_STREAM_RESULTS_\n    // Configures listeners for streaming test results to the specified server.\n    ConfigureStreamingOutput();\n#endif  // GTEST_CAN_STREAM_RESULTS_\n\n#ifdef GTEST_HAS_ABSL\n    if (GTEST_FLAG_GET(install_failure_signal_handler)) {\n      absl::FailureSignalHandlerOptions options;\n      absl::InstallFailureSignalHandler(options);\n    }\n#endif  // GTEST_HAS_ABSL\n  }\n}\n\n// Finds and returns a TestSuite with the given name.  If one doesn&#x27;t\n// exist, creates one and returns it.  It&#x27;s the CALLER&#x27;S\n// RESPONSIBILITY to ensure that this function is only called WHEN THE\n// TESTS ARE NOT SHUFFLED.\n//\n// Arguments:\n//\n//   test_suite_name: name of the test suite\n//   type_param:      the name of the test suite&#x27;s type parameter, or NULL if\n//                    this is not a typed or a type-parameterized test suite.\n//   set_up_tc:       pointer to the function that sets up the test suite\n//   tear_down_tc:    pointer to the function that tears down the test suite\nTestSuite* UnitTestImpl::GetTestSuite(\n    const std::string&amp; test_suite_name, const char* type_param,\n    internal::SetUpTestSuiteFunc set_up_tc,\n    internal::TearDownTestSuiteFunc tear_down_tc) {\n  // During initialization, all TestInfos for a given suite are added in\n  // sequence. To optimize this case, see if the most recently added suite is\n  // the one being requested now.\n  if (!test_suites_.empty() &amp;&amp;\n      (*test_suites_.rbegin())-&gt;name_ == test_suite_name) {\n    return *test_suites_.rbegin();\n  }\n\n  // Fall back to searching the collection.\n  auto item_it = test_suites_by_name_.find(test_suite_name);\n  if (item_it != test_suites_by_name_.end()) {\n    return item_it-&gt;second;\n  }\n\n  // Not found. Create a new instance.\n  auto* const new_test_suite =\n      new TestSuite(test_suite_name, type_param, set_up_tc, tear_down_tc);\n  test_suites_by_name_.emplace(test_suite_name, new_test_suite);\n\n  const UnitTestFilter death_test_suite_filter(kDeathTestSuiteFilter);\n  // Is this a death test suite?\n  if (death_test_suite_filter.MatchesName(test_suite_name)) {\n    // Yes.  Inserts the test suite after the last death test suite\n    // defined so far.  This only works when the test suites haven&#x27;t\n    // been shuffled.  Otherwise we may end up running a death test\n    // after a non-death test.\n    ++last_death_test_suite_;\n    test_suites_.insert(test_suites_.begin() + last_death_test_suite_,\n                        new_test_suite);\n  } else {\n    // No.  Appends to the end of the list.\n    test_suites_.push_back(new_test_suite);\n  }\n\n  test_suite_indices_.push_back(static_cast&lt;int&gt;(test_suite_indices_.size()));\n  return new_test_suite;\n}\n\n// Helpers for setting up / tearing down the given environment.  They\n// are for use in the ForEach() function.\nstatic void SetUpEnvironment(Environment* env) { env-&gt;SetUp(); }\nstatic void TearDownEnvironment(Environment* env) { env-&gt;TearDown(); }\n\n// Runs all tests in this UnitTest object, prints the result, and\n// returns true if all tests are successful.  If any exception is\n// thrown during a test, the test is considered to be failed, but the\n// rest of the tests will still be run.\n//\n// When parameterized tests are enabled, it expands and registers\n// parameterized tests first in RegisterParameterizedTests().\n// All other functions called from RunAllTests() may safely assume that\n// parameterized tests are ready to be counted and run.\nbool UnitTestImpl::RunAllTests() {\n  // True if and only if Google Test is initialized before RUN_ALL_TESTS() is\n  // called.\n  const bool gtest_is_initialized_before_run_all_tests = GTestIsInitialized();\n\n  // Do not run any test if the --help flag was specified.\n  if (g_help_flag) return true;\n\n  // Repeats the call to the post-flag parsing initialization in case the\n  // user didn&#x27;t call InitGoogleTest.\n  PostFlagParsingInit();\n\n#if GTEST_HAS_FILE_SYSTEM\n  // Even if sharding is not on, test runners may want to use the\n  // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding\n  // protocol.\n  internal::WriteToShardStatusFileIfNeeded();\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n  // True if and only if we are in a subprocess for running a thread-safe-style\n  // death test.\n  bool in_subprocess_for_death_test = false;\n\n#ifdef GTEST_HAS_DEATH_TEST\n  in_subprocess_for_death_test = (internal_run_death_test_flag_ != nullptr);\n#if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)\n  if (in_subprocess_for_death_test) {\n    GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();\n  }\n#endif  // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)\n#endif  // GTEST_HAS_DEATH_TEST\n\n  const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,\n                                        in_subprocess_for_death_test);\n\n  // Compares the full test names with the filter to decide which\n  // tests to run.\n  const bool has_tests_to_run =\n      FilterTests(should_shard ? HONOR_SHARDING_PROTOCOL\n                               : IGNORE_SHARDING_PROTOCOL) &gt; 0;\n\n  // Lists the tests and exits if the --gtest_list_tests flag was specified.\n  if (GTEST_FLAG_GET(list_tests)) {\n    // This must be called *after* FilterTests() has been called.\n    ListTestsMatchingFilter();\n    return true;\n  }\n\n  random_seed_ = GetRandomSeedFromFlag(GTEST_FLAG_GET(random_seed));\n\n  // True if and only if at least one test has failed.\n  bool failed = false;\n\n  TestEventListener* repeater = listeners()-&gt;repeater();\n\n  start_timestamp_ = GetTimeInMillis();\n  repeater-&gt;OnTestProgramStart(*parent_);\n\n  // How many times to repeat the tests?  We don&#x27;t want to repeat them\n  // when we are inside the subprocess of a death test.\n  const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG_GET(repeat);\n\n  // Repeats forever if the repeat count is negative.\n  const bool gtest_repeat_forever = repeat &lt; 0;\n\n  // Should test environments be set up and torn down for each repeat, or only\n  // set up on the first and torn down on the last iteration? If there is no\n  // &quot;last&quot; iteration because the tests will repeat forever, always recreate the\n  // environments to avoid leaks in case one of the environments is using\n  // resources that are external to this process. Without this check there would\n  // be no way to clean up those external resources automatically.\n  const bool recreate_environments_when_repeating =\n      GTEST_FLAG_GET(recreate_environments_when_repeating) ||\n      gtest_repeat_forever;\n\n  for (int i = 0; gtest_repeat_forever || i != repeat; i++) {\n    // We want to preserve failures generated by ad-hoc test\n    // assertions executed before RUN_ALL_TESTS().\n    ClearNonAdHocTestResult();\n\n    Timer timer;\n\n    // Shuffles test suites and tests if requested.\n    if (has_tests_to_run &amp;&amp; GTEST_FLAG_GET(shuffle)) {\n      random()-&gt;Reseed(static_cast&lt;uint32_t&gt;(random_seed_));\n      // This should be done before calling OnTestIterationStart(),\n      // such that a test event listener can see the actual test order\n      // in the event.\n      ShuffleTests();\n    }\n\n    // Tells the unit test event listeners that the tests are about to start.\n    repeater-&gt;OnTestIterationStart(*parent_, i);\n\n    // Runs each test suite if there is at least one test to run.\n    if (has_tests_to_run) {\n      // Sets up all environments beforehand. If test environments aren&#x27;t\n      // recreated for each iteration, only do so on the first iteration.\n      if (i == 0 || recreate_environments_when_repeating) {\n        repeater-&gt;OnEnvironmentsSetUpStart(*parent_);\n        ForEach(environments_, SetUpEnvironment);\n        repeater-&gt;OnEnvironmentsSetUpEnd(*parent_);\n      }\n\n      // Runs the tests only if there was no fatal failure or skip triggered\n      // during global set-up.\n      if (Test::IsSkipped()) {\n        // Emit diagnostics when global set-up calls skip, as it will not be\n        // emitted by default.\n        TestResult&amp; test_result =\n            *internal::GetUnitTestImpl()-&gt;current_test_result();\n        for (int j = 0; j &lt; test_result.total_part_count(); ++j) {\n          const TestPartResult&amp; test_part_result =\n              test_result.GetTestPartResult(j);\n          if (test_part_result.type() == TestPartResult::kSkip) {\n            const std::string&amp; result = test_part_result.message();\n            printf(&quot;%s\\n&quot;, result.c_str());\n          }\n        }\n        fflush(stdout);\n      } else if (!Test::HasFatalFailure()) {\n        for (int test_index = 0; test_index &lt; total_test_suite_count();\n             test_index++) {\n          GetMutableSuiteCase(test_index)-&gt;Run();\n          if (GTEST_FLAG_GET(fail_fast) &amp;&amp;\n              GetMutableSuiteCase(test_index)-&gt;Failed()) {\n            for (int j = test_index + 1; j &lt; total_test_suite_count(); j++) {\n              GetMutableSuiteCase(j)-&gt;Skip();\n            }\n            break;\n          }\n        }\n      } else if (Test::HasFatalFailure()) {\n        // If there was a fatal failure during the global setup then we know we\n        // aren&#x27;t going to run any tests. Explicitly mark all of the tests as\n        // skipped to make this obvious in the output.\n        for (int test_index = 0; test_index &lt; total_test_suite_count();\n             test_index++) {\n          GetMutableSuiteCase(test_index)-&gt;Skip();\n        }\n      }\n\n      // Tears down all environments in reverse order afterwards. If test\n      // environments aren&#x27;t recreated for each iteration, only do so on the\n      // last iteration.\n      if (i == repeat - 1 || recreate_environments_when_repeating) {\n        repeater-&gt;OnEnvironmentsTearDownStart(*parent_);\n        std::for_each(environments_.rbegin(), environments_.rend(),\n                      TearDownEnvironment);\n        repeater-&gt;OnEnvironmentsTearDownEnd(*parent_);\n      }\n    }\n\n    elapsed_time_ = timer.Elapsed();\n\n    // Tells the unit test event listener that the tests have just finished.\n    repeater-&gt;OnTestIterationEnd(*parent_, i);\n\n    // Gets the result and clears it.\n    if (!Passed()) {\n      failed = true;\n    }\n\n    // Restores the original test order after the iteration.  This\n    // allows the user to quickly repro a failure that happens in the\n    // N-th iteration without repeating the first (N - 1) iterations.\n    // This is not enclosed in &quot;if (GTEST_FLAG(shuffle)) { ... }&quot;, in\n    // case the user somehow changes the value of the flag somewhere\n    // (it&#x27;s always safe to unshuffle the tests).\n    UnshuffleTests();\n\n    if (GTEST_FLAG_GET(shuffle)) {\n      // Picks a new random seed for each iteration.\n      random_seed_ = GetNextRandomSeed(random_seed_);\n    }\n  }\n\n  repeater-&gt;OnTestProgramEnd(*parent_);\n  // Destroy environments in normal code, not in static teardown.\n  bool delete_environment_on_teardown = true;\n  if (delete_environment_on_teardown) {\n    ForEach(environments_, internal::Delete&lt;Environment&gt;);\n    environments_.clear();\n  }\n\n  if (!gtest_is_initialized_before_run_all_tests) {\n    ColoredPrintf(\n        GTestColor::kRed,\n        &quot;\\nIMPORTANT NOTICE - DO NOT IGNORE:\\n&quot;\n        &quot;This test program did NOT call &quot; GTEST_INIT_GOOGLE_TEST_NAME_\n        &quot;() before calling RUN_ALL_TESTS(). This is INVALID. Soon &quot; GTEST_NAME_\n        &quot; will start to enforce the valid usage. &quot;\n        &quot;Please fix it ASAP, or IT WILL START TO FAIL.\\n&quot;);  // NOLINT\n  }\n\n  return !failed;\n}\n\n#if GTEST_HAS_FILE_SYSTEM\n// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file\n// if the variable is present. If a file already exists at this location, this\n// function will write over it. If the variable is present, but the file cannot\n// be created, prints an error and exits.\nvoid WriteToShardStatusFileIfNeeded() {\n  const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);\n  if (test_shard_file != nullptr) {\n    FILE* const file = posix::FOpen(test_shard_file, &quot;w&quot;);\n    if (file == nullptr) {\n      ColoredPrintf(GTestColor::kRed,\n                    &quot;Could not write to the test shard status file \\&quot;%s\\&quot; &quot;\n                    &quot;specified by the %s environment variable.\\n&quot;,\n                    test_shard_file, kTestShardStatusFile);\n      fflush(stdout);\n      exit(EXIT_FAILURE);\n    }\n    fclose(file);\n  }\n}\n#endif  // GTEST_HAS_FILE_SYSTEM\n\n// Checks whether sharding is enabled by examining the relevant\n// environment variable values. If the variables are present,\n// but inconsistent (i.e., shard_index &gt;= total_shards), prints\n// an error and exits. If in_subprocess_for_death_test, sharding is\n// disabled because it must only be applied to the original test\n// process. Otherwise, we could filter out death tests we intended to execute.\nbool ShouldShard(const char* total_shards_env, const char* shard_index_env,\n                 bool in_subprocess_for_death_test) {\n  if (in_subprocess_for_death_test) {\n    return false;\n  }\n\n  const int32_t total_shards = Int32FromEnvOrDie(total_shards_env, -1);\n  const int32_t shard_index = Int32FromEnvOrDie(shard_index_env, -1);\n\n  if (total_shards == -1 &amp;&amp; shard_index == -1) {\n    return false;\n  } else if (total_shards == -1 &amp;&amp; shard_index != -1) {\n    const Message msg = Message() &lt;&lt; &quot;Invalid environment variables: you have &quot;\n                                  &lt;&lt; kTestShardIndex &lt;&lt; &quot; = &quot; &lt;&lt; shard_index\n                                  &lt;&lt; &quot;, but have left &quot; &lt;&lt; kTestTotalShards\n                                  &lt;&lt; &quot; unset.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  } else if (total_shards != -1 &amp;&amp; shard_index == -1) {\n    const Message msg = Message()\n                        &lt;&lt; &quot;Invalid environment variables: you have &quot;\n                        &lt;&lt; kTestTotalShards &lt;&lt; &quot; = &quot; &lt;&lt; total_shards\n                        &lt;&lt; &quot;, but have left &quot; &lt;&lt; kTestShardIndex &lt;&lt; &quot; unset.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  } else if (shard_index &lt; 0 || shard_index &gt;= total_shards) {\n    const Message msg =\n        Message() &lt;&lt; &quot;Invalid environment variables: we require 0 &lt;= &quot;\n                  &lt;&lt; kTestShardIndex &lt;&lt; &quot; &lt; &quot; &lt;&lt; kTestTotalShards\n                  &lt;&lt; &quot;, but you have &quot; &lt;&lt; kTestShardIndex &lt;&lt; &quot;=&quot; &lt;&lt; shard_index\n                  &lt;&lt; &quot;, &quot; &lt;&lt; kTestTotalShards &lt;&lt; &quot;=&quot; &lt;&lt; total_shards &lt;&lt; &quot;.\\n&quot;;\n    ColoredPrintf(GTestColor::kRed, &quot;%s&quot;, msg.GetString().c_str());\n    fflush(stdout);\n    exit(EXIT_FAILURE);\n  }\n\n  return total_shards &gt; 1;\n}\n\n// Parses the environment variable var as an Int32. If it is unset,\n// returns default_val. If it is not an Int32, prints an error\n// and aborts.\nint32_t Int32FromEnvOrDie(const char* var, int32_t default_val) {\n  const char* str_val = posix::GetEnv(var);\n  if (str_val == nullptr) {\n    return default_val;\n  }\n\n  int32_t result;\n  if (!ParseInt32(Message() &lt;&lt; &quot;The value of environment variable &quot; &lt;&lt; var,\n                  str_val, &amp;result)) {\n    exit(EXIT_FAILURE);\n  }\n  return result;\n}\n\n// Given the total number of shards, the shard index, and the test id,\n// returns true if and only if the test should be run on this shard. The test id\n// is some arbitrary but unique non-negative integer assigned to each test\n// method. Assumes that 0 &lt;= shard_index &lt; total_shards.\nbool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {\n  return (test_id % total_shards) == shard_index;\n}\n\n// Compares the name of each test with the user-specified filter to\n// decide whether the test should be run, then records the result in\n// each TestSuite and TestInfo object.\n// If shard_tests == true, further filters tests based on sharding\n// variables in the environment - see\n// https://github.com/google/googletest/blob/main/docs/advanced.md\n// . Returns the number of tests that should run.\nint UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {\n  const int32_t total_shards = shard_tests == HONOR_SHARDING_PROTOCOL\n                                   ? Int32FromEnvOrDie(kTestTotalShards, -1)\n                                   : -1;\n  const int32_t shard_index = shard_tests == HONOR_SHARDING_PROTOCOL\n                                  ? Int32FromEnvOrDie(kTestShardIndex, -1)\n                                  : -1;\n\n  const PositiveAndNegativeUnitTestFilter gtest_flag_filter(\n      GTEST_FLAG_GET(filter));\n  const UnitTestFilter disable_test_filter(kDisableTestFilter);\n  // num_runnable_tests are the number of tests that will\n  // run across all shards (i.e., match filter and are not disabled).\n  // num_selected_tests are the number of tests to be run on\n  // this shard.\n  int num_runnable_tests = 0;\n  int num_selected_tests = 0;\n  for (auto* test_suite : test_suites_) {\n    const std::string&amp; test_suite_name = test_suite-&gt;name_;\n    test_suite-&gt;set_should_run(false);\n\n    for (TestInfo* test_info : test_suite-&gt;test_info_list()) {\n      const std::string&amp; test_name = test_info-&gt;name_;\n      // A test is disabled if test suite name or test name matches\n      // kDisableTestFilter.\n      const bool is_disabled =\n          disable_test_filter.MatchesName(test_suite_name) ||\n          disable_test_filter.MatchesName(test_name);\n      test_info-&gt;is_disabled_ = is_disabled;\n\n      const bool matches_filter =\n          gtest_flag_filter.MatchesTest(test_suite_name, test_name);\n      test_info-&gt;matches_filter_ = matches_filter;\n\n      const bool is_runnable =\n          (GTEST_FLAG_GET(also_run_disabled_tests) || !is_disabled) &amp;&amp;\n          matches_filter;\n\n      const bool is_in_another_shard =\n          shard_tests != IGNORE_SHARDING_PROTOCOL &amp;&amp;\n          !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests);\n      test_info-&gt;is_in_another_shard_ = is_in_another_shard;\n      const bool is_selected = is_runnable &amp;&amp; !is_in_another_shard;\n\n      num_runnable_tests += is_runnable;\n      num_selected_tests += is_selected;\n\n      test_info-&gt;should_run_ = is_selected;\n      test_suite-&gt;set_should_run(test_suite-&gt;should_run() || is_selected);\n    }\n  }\n  return num_selected_tests;\n}\n\n// Prints the given C-string on a single line by replacing all &#x27;\\n&#x27;\n// characters with string &quot;\\\\n&quot;.  If the output takes more than\n// max_length characters, only prints the first max_length characters\n// and &quot;...&quot;.\nstatic void PrintOnOneLine(const char* str, int max_length) {\n  if (str != nullptr) {\n    for (int i = 0; *str != &#x27;\\0&#x27;; ++str) {\n      if (i &gt;= max_length) {\n        printf(&quot;...&quot;);\n        break;\n      }\n      if (*str == &#x27;\\n&#x27;) {\n        printf(&quot;\\\\n&quot;);\n        i += 2;\n      } else {\n        printf(&quot;%c&quot;, *str);\n        ++i;\n      }\n    }\n  }\n}\n\n// Prints the names of the tests matching the user-specified filter flag.\nvoid UnitTestImpl::ListTestsMatchingFilter() {\n  // Print at most this many characters for each type/value parameter.\n  const int kMaxParamLength = 250;\n\n  for (auto* test_suite : test_suites_) {\n    bool printed_test_suite_name = false;\n\n    for (size_t j = 0; j &lt; test_suite-&gt;test_info_list().size(); j++) {\n      const TestInfo* const test_info = test_suite-&gt;test_info_list()[j];\n      if (test_info-&gt;matches_filter_) {\n        if (!printed_test_suite_name) {\n          printed_test_suite_name = true;\n          printf(&quot;%s.&quot;, test_suite-&gt;name());\n          if (test_suite-&gt;type_param() != nullptr) {\n            printf(&quot;  # %s = &quot;, kTypeParamLabel);\n            // We print the type parameter on a single line to make\n            // the output easy to parse by a program.\n            PrintOnOneLine(test_suite-&gt;type_param(), kMaxParamLength);\n          }\n          printf(&quot;\\n&quot;);\n        }\n        printf(&quot;  %s&quot;, test_info-&gt;name());\n        if (test_info-&gt;value_param() != nullptr) {\n          printf(&quot;  # %s = &quot;, kValueParamLabel);\n          // We print the value parameter on a single line to make the\n          // output easy to parse by a program.\n          PrintOnOneLine(test_info-&gt;value_param(), kMaxParamLength);\n        }\n        printf(&quot;\\n&quot;);\n      }\n    }\n  }\n  fflush(stdout);\n#if GTEST_HAS_FILE_SYSTEM\n  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();\n  if (output_format == &quot;xml&quot; || output_format == &quot;json&quot;) {\n    FILE* fileout =\n        OpenFileForWriting(UnitTestOptions::GetAbsolutePathToOutputFile());\n    std::stringstream stream;\n    if (output_format == &quot;xml&quot;) {\n      XmlUnitTestResultPrinter(\n          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())\n          .PrintXmlTestsList(&amp;stream, test_suites_);\n    } else if (output_format == &quot;json&quot;) {\n      JsonUnitTestResultPrinter(\n          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())\n          .PrintJsonTestList(&amp;stream, test_suites_);\n    }\n    fprintf(fileout, &quot;%s&quot;, StringStreamToString(&amp;stream).c_str());\n    fclose(fileout);\n  }\n#endif  // GTEST_HAS_FILE_SYSTEM\n}\n\n// Sets the OS stack trace getter.\n//\n// Does nothing if the input and the current OS stack trace getter are\n// the same; otherwise, deletes the old getter and makes the input the\n// current getter.\nvoid UnitTestImpl::set_os_stack_trace_getter(\n    OsStackTraceGetterInterface* getter) {\n  if (os_stack_trace_getter_ != getter) {\n    delete os_stack_trace_getter_;\n    os_stack_trace_getter_ = getter;\n  }\n}\n\n// Returns the current OS stack trace getter if it is not NULL;\n// otherwise, creates an OsStackTraceGetter, makes it the current\n// getter, and returns it.\nOsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {\n  if (os_stack_trace_getter_ == nullptr) {\n#ifdef GTEST_OS_STACK_TRACE_GETTER_\n    os_stack_trace_getter_ = new GTEST_OS_STACK_TRACE_GETTER_;\n#else\n    os_stack_trace_getter_ = new OsStackTraceGetter;\n#endif  // GTEST_OS_STACK_TRACE_GETTER_\n  }\n\n  return os_stack_trace_getter_;\n}\n\n// Returns the most specific TestResult currently running.\nTestResult* UnitTestImpl::current_test_result() {\n  if (current_test_info_ != nullptr) {\n    return &amp;current_test_info_-&gt;result_;\n  }\n  if (current_test_suite_ != nullptr) {\n    return &amp;current_test_suite_-&gt;ad_hoc_test_result_;\n  }\n  return &amp;ad_hoc_test_result_;\n}\n\n// Shuffles all test suites, and the tests within each test suite,\n// making sure that death tests are still run first.\nvoid UnitTestImpl::ShuffleTests() {\n  // Shuffles the death test suites.\n  ShuffleRange(random(), 0, last_death_test_suite_ + 1, &amp;test_suite_indices_);\n\n  // Shuffles the non-death test suites.\n  ShuffleRange(random(), last_death_test_suite_ + 1,\n               static_cast&lt;int&gt;(test_suites_.size()), &amp;test_suite_indices_);\n\n  // Shuffles the tests inside each test suite.\n  for (auto&amp; test_suite : test_suites_) {\n    test_suite-&gt;ShuffleTests(random());\n  }\n}\n\n// Restores the test suites and tests to their order before the first shuffle.\nvoid UnitTestImpl::UnshuffleTests() {\n  for (size_t i = 0; i &lt; test_suites_.size(); i++) {\n    // Unshuffles the tests in each test suite.\n    test_suites_[i]-&gt;UnshuffleTests();\n    // Resets the index of each test suite.\n    test_suite_indices_[i] = static_cast&lt;int&gt;(i);\n  }\n}\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn&#x27;t\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won&#x27;t.\nGTEST_NO_INLINE_ GTEST_NO_TAIL_CALL_ std::string\nGetCurrentOsStackTraceExceptTop(int skip_count) {\n  // We pass skip_count + 1 to skip this wrapper function in addition\n  // to what the user really wants to skip.\n  return GetUnitTestImpl()-&gt;CurrentOsStackTraceExceptTop(skip_count + 1);\n}\n\n// Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to\n// suppress unreachable code warnings.\nnamespace {\nclass ClassUniqueToAlwaysTrue {};\n}  // namespace\n\nbool IsTrue(bool condition) { return condition; }\n\nbool AlwaysTrue() {\n#if GTEST_HAS_EXCEPTIONS\n  // This condition is always false so AlwaysTrue() never actually throws,\n  // but it makes the compiler think that it may throw.\n  if (IsTrue(false)) throw ClassUniqueToAlwaysTrue();\n#endif  // GTEST_HAS_EXCEPTIONS\n  return true;\n}\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nbool SkipPrefix(const char* prefix, const char** pstr) {\n  const size_t prefix_len = strlen(prefix);\n  if (strncmp(*pstr, prefix, prefix_len) == 0) {\n    *pstr += prefix_len;\n    return true;\n  }\n  return false;\n}\n\n// Parses a string as a command line flag.  The string should have\n// the format &quot;--flag=value&quot;.  When def_optional is true, the &quot;=value&quot;\n// part can be omitted.\n//\n// Returns the value of the flag, or NULL if the parsing failed.\nstatic const char* ParseFlagValue(const char* str, const char* flag_name,\n                                  bool def_optional) {\n  // str and flag must not be NULL.\n  if (str == nullptr || flag_name == nullptr) return nullptr;\n\n  // The flag must start with &quot;--&quot; followed by GTEST_FLAG_PREFIX_.\n  const std::string flag_str =\n      std::string(&quot;--&quot;) + GTEST_FLAG_PREFIX_ + flag_name;\n  const size_t flag_len = flag_str.length();\n  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;\n\n  // Skips the flag name.\n  const char* flag_end = str + flag_len;\n\n  // When def_optional is true, it&#x27;s OK to not have a &quot;=value&quot; part.\n  if (def_optional &amp;&amp; (flag_end[0] == &#x27;\\0&#x27;)) {\n    return flag_end;\n  }\n\n  // If def_optional is true and there are more characters after the\n  // flag name, or if def_optional is false, there must be a &#x27;=&#x27; after\n  // the flag name.\n  if (flag_end[0] != &#x27;=&#x27;) return nullptr;\n\n  // Returns the string after &quot;=&quot;.\n  return flag_end + 1;\n}\n\n// Parses a string for a bool flag, in the form of either\n// &quot;--flag=value&quot; or &quot;--flag&quot;.\n//\n// In the former case, the value is taken as true as long as it does\n// not start with &#x27;0&#x27;, &#x27;f&#x27;, or &#x27;F&#x27;.\n//\n// In the latter case, the value is taken as true.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\nstatic bool ParseFlag(const char* str, const char* flag_name, bool* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, true);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Converts the string value to a bool.\n  *value = !(*value_str == &#x27;0&#x27; || *value_str == &#x27;f&#x27; || *value_str == &#x27;F&#x27;);\n  return true;\n}\n\n// Parses a string for an int32_t flag, in the form of &quot;--flag=value&quot;.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\nbool ParseFlag(const char* str, const char* flag_name, int32_t* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, false);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Sets *value to the value of the flag.\n  return ParseInt32(Message() &lt;&lt; &quot;The value of flag --&quot; &lt;&lt; flag_name, value_str,\n                    value);\n}\n\n// Parses a string for a string flag, in the form of &quot;--flag=value&quot;.\n//\n// On success, stores the value of the flag in *value, and returns\n// true.  On failure, returns false without changing *value.\ntemplate &lt;typename String&gt;\nstatic bool ParseFlag(const char* str, const char* flag_name, String* value) {\n  // Gets the value of the flag as a string.\n  const char* const value_str = ParseFlagValue(str, flag_name, false);\n\n  // Aborts if the parsing failed.\n  if (value_str == nullptr) return false;\n\n  // Sets *value to the value of the flag.\n  *value = value_str;\n  return true;\n}\n\n// Determines whether a string has a prefix that Google Test uses for its\n// flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.\n// If Google Test detects that a command line flag has its prefix but is not\n// recognized, it will print its help message. Flags starting with\n// GTEST_INTERNAL_PREFIX_ followed by &quot;internal_&quot; are considered Google Test\n// internal flags and do not trigger the help message.\nstatic bool HasGoogleTestFlagPrefix(const char* str) {\n  return (SkipPrefix(&quot;--&quot;, &amp;str) || SkipPrefix(&quot;-&quot;, &amp;str) ||\n          SkipPrefix(&quot;/&quot;, &amp;str)) &amp;&amp;\n         !SkipPrefix(GTEST_FLAG_PREFIX_ &quot;internal_&quot;, &amp;str) &amp;&amp;\n         (SkipPrefix(GTEST_FLAG_PREFIX_, &amp;str) ||\n          SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &amp;str));\n}\n\n// Prints a string containing code-encoded text.  The following escape\n// sequences can be used in the string to control the text color:\n//\n//   @@    prints a single &#x27;@&#x27; character.\n//   @R    changes the color to red.\n//   @G    changes the color to green.\n//   @Y    changes the color to yellow.\n//   @D    changes to the default terminal text color.\n//\nstatic void PrintColorEncoded(const char* str) {\n  GTestColor color = GTestColor::kDefault;  // The current color.\n\n  // Conceptually, we split the string into segments divided by escape\n  // sequences.  Then we print one segment at a time.  At the end of\n  // each iteration, the str pointer advances to the beginning of the\n  // next segment.\n  for (;;) {\n    const char* p = strchr(str, &#x27;@&#x27;);\n    if (p == nullptr) {\n      ColoredPrintf(color, &quot;%s&quot;, str);\n      return;\n    }\n\n    ColoredPrintf(color, &quot;%s&quot;, std::string(str, p).c_str());\n\n    const char ch = p[1];\n    str = p + 2;\n    if (ch == &#x27;@&#x27;) {\n      ColoredPrintf(color, &quot;@&quot;);\n    } else if (ch == &#x27;D&#x27;) {\n      color = GTestColor::kDefault;\n    } else if (ch == &#x27;R&#x27;) {\n      color = GTestColor::kRed;\n    } else if (ch == &#x27;G&#x27;) {\n      color = GTestColor::kGreen;\n    } else if (ch == &#x27;Y&#x27;) {\n      color = GTestColor::kYellow;\n    } else {\n      --str;\n    }\n  }\n}\n\nstatic const char kColorEncodedHelpMessage[] =\n    &quot;This program contains tests written using &quot; GTEST_NAME_\n    &quot;. You can use the\\n&quot;\n    &quot;following command line flags to control its behavior:\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Selection:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;list_tests@D\\n&quot;\n    &quot;      List the names of all tests instead of running them. The name of\\n&quot;\n    &quot;      TEST(Foo, Bar) is \\&quot;Foo.Bar\\&quot;.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;filter=@YPOSITIVE_PATTERNS&quot;\n    &quot;[@G-@YNEGATIVE_PATTERNS]@D\\n&quot;\n    &quot;      Run only the tests whose name matches one of the positive patterns &quot;\n    &quot;but\\n&quot;\n    &quot;      none of the negative patterns. &#x27;?&#x27; matches any single character; &quot;\n    &quot;&#x27;*&#x27;\\n&quot;\n    &quot;      matches any substring; &#x27;:&#x27; separates two patterns.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;also_run_disabled_tests@D\\n&quot;\n    &quot;      Run all disabled tests too.\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Execution:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;repeat=@Y[COUNT]@D\\n&quot;\n    &quot;      Run the tests repeatedly; use a negative count to repeat forever.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;shuffle@D\\n&quot;\n    &quot;      Randomize tests&#x27; orders on every iteration.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;random_seed=@Y[NUMBER]@D\\n&quot;\n    &quot;      Random number seed to use for shuffling test orders (between 1 and\\n&quot;\n    &quot;      99999, or 0 to use a seed based on the current time).\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;recreate_environments_when_repeating@D\\n&quot;\n    &quot;      Sets up and tears down the global test environment on each repeat\\n&quot;\n    &quot;      of the test.\\n&quot;\n    &quot;\\n&quot;\n    &quot;Test Output:\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\\n&quot;\n    &quot;      Enable/disable colored output. The default is @Gauto@D.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;brief=1@D\\n&quot;\n    &quot;      Only print test failures.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;print_time=0@D\\n&quot;\n    &quot;      Don&#x27;t print the elapsed time of each test.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G&quot; GTEST_PATH_SEP_\n    &quot;@Y|@G:@YFILE_PATH]@D\\n&quot;\n    &quot;      Generate a JSON or XML report in the given directory or with the &quot;\n    &quot;given\\n&quot;\n    &quot;      file name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\\n&quot;\n#if GTEST_CAN_STREAM_RESULTS_\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;stream_result_to=@YHOST@G:@YPORT@D\\n&quot;\n    &quot;      Stream test results to the given server.\\n&quot;\n#endif  // GTEST_CAN_STREAM_RESULTS_\n    &quot;\\n&quot;\n    &quot;Assertion Behavior:\\n&quot;\n#if defined(GTEST_HAS_DEATH_TEST) &amp;&amp; !defined(GTEST_OS_WINDOWS)\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\\n&quot;\n    &quot;      Set the default death test style.\\n&quot;\n#endif  // GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;break_on_failure@D\\n&quot;\n    &quot;      Turn assertion failures into debugger break-points.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;throw_on_failure@D\\n&quot;\n    &quot;      Turn assertion failures into C++ exceptions for use by an external\\n&quot;\n    &quot;      test framework.\\n&quot;\n    &quot;  @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;catch_exceptions=0@D\\n&quot;\n    &quot;      Do not report exceptions as test failures. Instead, allow them\\n&quot;\n    &quot;      to crash the program or throw a pop-up (on Windows).\\n&quot;\n    &quot;\\n&quot;\n    &quot;Except for @G--&quot; GTEST_FLAG_PREFIX_\n    &quot;list_tests@D, you can alternatively set &quot;\n    &quot;the corresponding\\n&quot;\n    &quot;environment variable of a flag (all letters in upper-case). For example, &quot;\n    &quot;to\\n&quot;\n    &quot;disable colored text output, you can either specify &quot;\n    &quot;@G--&quot; GTEST_FLAG_PREFIX_\n    &quot;color=no@D or set\\n&quot;\n    &quot;the @G&quot; GTEST_FLAG_PREFIX_UPPER_\n    &quot;COLOR@D environment variable to @Gno@D.\\n&quot;\n    &quot;\\n&quot;\n    &quot;For more information, please read the &quot; GTEST_NAME_\n    &quot; documentation at\\n&quot;\n    &quot;@G&quot; GTEST_PROJECT_URL_ &quot;@D. If you find a bug in &quot; GTEST_NAME_\n    &quot;\\n&quot;\n    &quot;(not one in your own code or tests), please report it to\\n&quot;\n    &quot;@G&lt;&quot; GTEST_DEV_EMAIL_ &quot;&gt;@D.\\n&quot;;\n\nstatic bool ParseGoogleTestFlag(const char* const arg) {\n#define GTEST_INTERNAL_PARSE_FLAG(flag_name)  \\\n  do {                                        \\\n    auto value = GTEST_FLAG_GET(flag_name);   \\\n    if (ParseFlag(arg, #flag_name, &amp;value)) { \\\n      GTEST_FLAG_SET(flag_name, value);       \\\n      return true;                            \\\n    }                                         \\\n  } while (false)\n\n  GTEST_INTERNAL_PARSE_FLAG(also_run_disabled_tests);\n  GTEST_INTERNAL_PARSE_FLAG(break_on_failure);\n  GTEST_INTERNAL_PARSE_FLAG(catch_exceptions);\n  GTEST_INTERNAL_PARSE_FLAG(color);\n  GTEST_INTERNAL_PARSE_FLAG(death_test_style);\n  GTEST_INTERNAL_PARSE_FLAG(death_test_use_fork);\n  GTEST_INTERNAL_PARSE_FLAG(fail_fast);\n  GTEST_INTERNAL_PARSE_FLAG(filter);\n  GTEST_INTERNAL_PARSE_FLAG(internal_run_death_test);\n  GTEST_INTERNAL_PARSE_FLAG(list_tests);\n  GTEST_INTERNAL_PARSE_FLAG(output);\n  GTEST_INTERNAL_PARSE_FLAG(brief);\n  GTEST_INTERNAL_PARSE_FLAG(print_time);\n  GTEST_INTERNAL_PARSE_FLAG(print_utf8);\n  GTEST_INTERNAL_PARSE_FLAG(random_seed);\n  GTEST_INTERNAL_PARSE_FLAG(repeat);\n  GTEST_INTERNAL_PARSE_FLAG(recreate_environments_when_repeating);\n  GTEST_INTERNAL_PARSE_FLAG(shuffle);\n  GTEST_INTERNAL_PARSE_FLAG(stack_trace_depth);\n  GTEST_INTERNAL_PARSE_FLAG(stream_result_to);\n  GTEST_INTERNAL_PARSE_FLAG(throw_on_failure);\n  return false;\n}\n\n#if GTEST_USE_OWN_FLAGFILE_FLAG_ &amp;&amp; GTEST_HAS_FILE_SYSTEM\nstatic void LoadFlagsFromFile(const std::string&amp; path) {\n  FILE* flagfile = posix::FOpen(path.c_str(), &quot;r&quot;);\n  if (!flagfile) {\n    GTEST_LOG_(FATAL) &lt;&lt; &quot;Unable to open file \\&quot;&quot; &lt;&lt; GTEST_FLAG_GET(flagfile)\n                      &lt;&lt; &quot;\\&quot;&quot;;\n  }\n  std::string contents(ReadEntireFile(flagfile));\n  posix::FClose(flagfile);\n  std::vector&lt;std::string&gt; lines;\n  SplitString(contents, &#x27;\\n&#x27;, &amp;lines);\n  for (size_t i = 0; i &lt; lines.size(); ++i) {\n    if (lines[i].empty()) continue;\n    if (!ParseGoogleTestFlag(lines[i].c_str())) g_help_flag = true;\n  }\n}\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_ &amp;&amp; GTEST_HAS_FILE_SYSTEM\n\n// Parses the command line for Google Test flags, without initializing\n// other parts of Google Test.  The type parameter CharType can be\n// instantiated to either char or wchar_t.\ntemplate &lt;typename CharType&gt;\nvoid ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {\n  std::string flagfile_value;\n  for (int i = 1; i &lt; *argc; i++) {\n    const std::string arg_string = StreamableToString(argv[i]);\n    const char* const arg = arg_string.c_str();\n\n    using internal::ParseFlag;\n\n    bool remove_flag = false;\n    if (ParseGoogleTestFlag(arg)) {\n      remove_flag = true;\n#if GTEST_USE_OWN_FLAGFILE_FLAG_ &amp;&amp; GTEST_HAS_FILE_SYSTEM\n    } else if (ParseFlag(arg, &quot;flagfile&quot;, &amp;flagfile_value)) {\n      GTEST_FLAG_SET(flagfile, flagfile_value);\n      LoadFlagsFromFile(flagfile_value);\n      remove_flag = true;\n#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_ &amp;&amp; GTEST_HAS_FILE_SYSTEM\n    } else if (arg_string == &quot;--help&quot; || HasGoogleTestFlagPrefix(arg)) {\n      // Both help flag and unrecognized Google Test flags (excluding\n      // internal ones) trigger help display.\n      g_help_flag = true;\n    }\n\n    if (remove_flag) {\n      // Shift the remainder of the argv list left by one.\n      for (int j = i + 1; j &lt; *argc; ++j) {\n        argv[j - 1] = argv[j];\n      }\n\n      // Decrements the argument count.\n      (*argc)--;\n\n      // Terminate the array with nullptr.\n      argv[*argc] = nullptr;\n\n      // We also need to decrement the iterator as we just removed\n      // an element.\n      i--;\n    }\n  }\n\n  if (g_help_flag) {\n    // We print the help here instead of in RUN_ALL_TESTS(), as the\n    // latter may not be called at all if the user is using Google\n    // Test with another testing framework.\n    PrintColorEncoded(kColorEncodedHelpMessage);\n  }\n}\n\n// Parses the command line for Google Test flags, without initializing\n// other parts of Google Test. This function updates argc and argv by removing\n// flags that are known to GoogleTest (including other user flags defined using\n// ABSL_FLAG if GoogleTest is built with GTEST_USE_ABSL). Other arguments\n// remain in place. Unrecognized flags are not reported and do not cause the\n// program to exit.\nvoid ParseGoogleTestFlagsOnly(int* argc, char** argv) {\n#ifdef GTEST_HAS_ABSL_FLAGS\n  if (*argc &lt;= 0) return;\n\n  std::vector&lt;char*&gt; positional_args;\n  std::vector&lt;absl::UnrecognizedFlag&gt; unrecognized_flags;\n  absl::ParseAbseilFlagsOnly(*argc, argv, positional_args, unrecognized_flags);\n  absl::flat_hash_set&lt;absl::string_view&gt; unrecognized;\n  for (const auto&amp; flag : unrecognized_flags) {\n    unrecognized.insert(flag.flag_name);\n  }\n  absl::flat_hash_set&lt;char*&gt; positional;\n  for (const auto&amp; arg : positional_args) {\n    positional.insert(arg);\n  }\n\n  int out_pos = 1;\n  int in_pos = 1;\n  for (; in_pos &lt; *argc; ++in_pos) {\n    char* arg = argv[in_pos];\n    absl::string_view arg_str(arg);\n    if (absl::ConsumePrefix(&amp;arg_str, &quot;--&quot;)) {\n      // Flag-like argument. If the flag was unrecognized, keep it.\n      // If it was a GoogleTest flag, remove it.\n      if (unrecognized.contains(arg_str)) {\n        argv[out_pos++] = argv[in_pos];\n        continue;\n      }\n    }\n\n    if (arg_str.empty()) {\n      ++in_pos;\n      break;  // &#x27;--&#x27; indicates that the rest of the arguments are positional\n    }\n\n    // Probably a positional argument. If it is in fact positional, keep it.\n    // If it was a value for the flag argument, remove it.\n    if (positional.contains(arg)) {\n      argv[out_pos++] = arg;\n    }\n  }\n\n  // The rest are positional args for sure.\n  while (in_pos &lt; *argc) {\n    argv[out_pos++] = argv[in_pos++];\n  }\n\n  *argc = out_pos;\n  argv[out_pos] = nullptr;\n#else\n  ParseGoogleTestFlagsOnlyImpl(argc, argv);\n#endif\n\n  // Fix the value of *_NSGetArgc() on macOS, but if and only if\n  // *_NSGetArgv() == argv\n  // Only applicable to char** version of argv\n#ifdef GTEST_OS_MAC\n#ifndef GTEST_OS_IOS\n  if (*_NSGetArgv() == argv) {\n    *_NSGetArgc() = *argc;\n  }\n#endif\n#endif\n}\nvoid ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {\n  ParseGoogleTestFlagsOnlyImpl(argc, argv);\n}\n\n// The internal implementation of InitGoogleTest().\n//\n// The type parameter CharType can be instantiated to either char or\n// wchar_t.\ntemplate &lt;typename CharType&gt;\nvoid InitGoogleTestImpl(int* argc, CharType** argv) {\n  // We don&#x27;t want to run the initialization code twice.\n  if (GTestIsInitialized()) return;\n\n  if (*argc &lt;= 0) return;\n\n  g_argvs.clear();\n  for (int i = 0; i != *argc; i++) {\n    g_argvs.push_back(StreamableToString(argv[i]));\n  }\n\n#ifdef GTEST_HAS_ABSL\n  absl::InitializeSymbolizer(g_argvs[0].c_str());\n\n#ifdef GTEST_HAS_ABSL_FLAGS\n  // When using the Abseil Flags library, set the program usage message to the\n  // help message, but remove the color-encoding from the message first.\n  absl::SetProgramUsageMessage(absl::StrReplaceAll(\n      kColorEncodedHelpMessage,\n      {{&quot;@D&quot;, &quot;&quot;}, {&quot;@R&quot;, &quot;&quot;}, {&quot;@G&quot;, &quot;&quot;}, {&quot;@Y&quot;, &quot;&quot;}, {&quot;@@&quot;, &quot;@&quot;}}));\n#endif  // GTEST_HAS_ABSL_FLAGS\n#endif  // GTEST_HAS_ABSL\n\n  ParseGoogleTestFlagsOnly(argc, argv);\n  GetUnitTestImpl()-&gt;PostFlagParsingInit();\n}\n\n}  // namespace internal\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nvoid InitGoogleTest(int* argc, char** argv) {\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nvoid InitGoogleTest(int* argc, wchar_t** argv) {\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n// This overloaded version can be used on Arduino/embedded platforms where\n// there is no argc/argv.\nvoid InitGoogleTest() {\n  // Since Arduino doesn&#x27;t have a command line, fake out the argc/argv arguments\n  int argc = 1;\n  const auto arg0 = &quot;dummy&quot;;\n  char* argv0 = const_cast&lt;char*&gt;(arg0);\n  char** argv = &amp;argv0;\n\n#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(&amp;argc, argv);\n#else   // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n  internal::InitGoogleTestImpl(&amp;argc, argv);\n#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)\n}\n\n#if !defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_) || \\\n    !defined(GTEST_CUSTOM_SRCDIR_FUNCTION_)\n// Returns the value of the first environment variable that is set and contains\n// a non-empty string. If there are none, returns the &quot;fallback&quot; string. Adds\n// the director-separator character as a suffix if not provided in the\n// environment variable value.\nstatic std::string GetDirFromEnv(\n    std::initializer_list&lt;const char*&gt; environment_variables,\n    const char* fallback, char separator) {\n  for (const char* variable_name : environment_variables) {\n    const char* value = internal::posix::GetEnv(variable_name);\n    if (value != nullptr &amp;&amp; value[0] != &#x27;\\0&#x27;) {\n      if (value[strlen(value) - 1] != separator) {\n        return std::string(value).append(1, separator);\n      }\n      return value;\n    }\n  }\n  return fallback;\n}\n#endif\n\nstd::string TempDir() {\n#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)\n  return GTEST_CUSTOM_TEMPDIR_FUNCTION_();\n#elif defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_WINDOWS_MOBILE)\n  return GetDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TEMP&quot;}, &quot;\\\\temp\\\\&quot;, &#x27;\\\\&#x27;);\n#elif defined(GTEST_OS_LINUX_ANDROID)\n  return GetDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TMPDIR&quot;}, &quot;/data/local/tmp/&quot;, &#x27;/&#x27;);\n#else\n  return GetDirFromEnv({&quot;TEST_TMPDIR&quot;, &quot;TMPDIR&quot;}, &quot;/tmp/&quot;, &#x27;/&#x27;);\n#endif\n}\n\n#if GTEST_HAS_FILE_SYSTEM &amp;&amp; !defined(GTEST_CUSTOM_SRCDIR_FUNCTION_)\n// Returns the directory path (including terminating separator) of the current\n// executable as derived from argv[0].\nstatic std::string GetCurrentExecutableDirectory() {\n  internal::FilePath argv_0(internal::GetArgvs()[0]);\n  return argv_0.RemoveFileName().string();\n}\n#endif\n\n#if GTEST_HAS_FILE_SYSTEM\nstd::string SrcDir() {\n#if defined(GTEST_CUSTOM_SRCDIR_FUNCTION_)\n  return GTEST_CUSTOM_SRCDIR_FUNCTION_();\n#elif defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_WINDOWS_MOBILE)\n  return GetDirFromEnv({&quot;TEST_SRCDIR&quot;}, GetCurrentExecutableDirectory().c_str(),\n                       &#x27;\\\\&#x27;);\n#elif defined(GTEST_OS_LINUX_ANDROID)\n  return GetDirFromEnv({&quot;TEST_SRCDIR&quot;}, GetCurrentExecutableDirectory().c_str(),\n                       &#x27;/&#x27;);\n#else\n  return GetDirFromEnv({&quot;TEST_SRCDIR&quot;}, GetCurrentExecutableDirectory().c_str(),\n                       &#x27;/&#x27;);\n#endif\n}\n#endif\n\n// Class ScopedTrace\n\n// Pushes the given source file location and message onto a per-thread\n// trace stack maintained by Google Test.\nvoid ScopedTrace::PushTrace(const char* file, int line, std::string message) {\n  internal::TraceInfo trace;\n  trace.file = file;\n  trace.line = line;\n  trace.message.swap(message);\n\n  UnitTest::GetInstance()-&gt;PushGTestTrace(trace);\n}\n\n// Pops the info pushed by the c&#x27;tor.\nScopedTrace::~ScopedTrace() GTEST_LOCK_EXCLUDED_(&amp;UnitTest::mutex_) {\n  UnitTest::GetInstance()-&gt;PopGTestTrace();\n}\n\n}  // namespace testing\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-assertion-result.h", "reportHash": "6f87e08a2df979d2ba3b17611a7fc51c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 133, "column": 18, "message": "class 'AssertionResult' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'AssertionResult' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-assertion-result.h", "line": 133, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-death-test.h", "reportHash": "4cfff0dd272ce402b1eff4d0f5e5d789", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 195, "column": 18, "message": "class 'ExitedWithCode' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ExitedWithCode' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-death-test.h", "line": 195, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "98c7a2180852a88cf8200c0d39e25f98", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 78, "column": 7, "message": "class 'MatchResultListener' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'MatchResultListener' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 78, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "4b369090465dd68d8ecf56489b1e3abb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 114, "column": 18, "message": "class 'MatcherDescriberInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'MatcherDescriberInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 114, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "71af86aa4822e20b890b3d9dd94acf84", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 183, "column": 7, "message": "class 'DummyMatchResultListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'DummyMatchResultListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 183, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "e0da003adbc3c0629dfebebdc1cd2b0f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 195, "column": 7, "message": "class 'StreamMatchResultListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamMatchResultListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 195, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "35ffd59c8fd1485608d2d153ac7bc95f", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 228, "column": 7, "message": "destructor of 'MatcherBase<const std::basic_string<char> &>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}, {"message": "destructor of 'MatcherBase<const std::basic_string<char> &>' is protected and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "b19c88c2e02e95a6ec471ddeaf9e3eb6", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 228, "column": 7, "message": "destructor of 'MatcherBase<const std::basic_string_view<char> &>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}, {"message": "destructor of 'MatcherBase<const std::basic_string_view<char> &>' is protected and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "1eb34686ef8bafd95bf4427425893870", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 228, "column": 7, "message": "destructor of 'MatcherBase<std::basic_string<char>>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}, {"message": "destructor of 'MatcherBase<std::basic_string<char>>' is protected and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "8fa234cb9af70db7dbeb74940e45af43", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 228, "column": 7, "message": "destructor of 'MatcherBase<std::basic_string_view<char>>' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}, {"message": "destructor of 'MatcherBase<std::basic_string_view<char>>' is protected and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 228, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "b4942153ff03a7289a4de3a2168de314", "checker": {"name": "performance-noexcept-move-constructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/noexcept-move-constructor.html"}, "analyzerName": "clang-tidy", "line": 304, "column": 16, "message": "move assignment operators should be marked noexcept", "events": [{"message": "|                                                noexcept (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 304, "column": 7}, {"message": "move assignment operators should be marked noexcept", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 304, "column": 16}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "reportHash": "0798390759c146716094c50f4d852ce8", "checker": {"name": "bugprone-sizeof-expression", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/sizeof-expression.html"}, "analyzerName": "clang-tidy", "line": 397, "column": 12, "message": "suspicious usage of 'sizeof(A*)' on pointer-to-aggregate type; did you mean 'sizeof(A)'?", "events": [{"message": "suspicious usage of 'sizeof(A*)' on pointer-to-aggregate type; did you mean 'sizeof(A)'?", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-matchers.h", "line": 397, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "reportHash": "8d31e8893c51689fe2b9d465b6136120", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 101, "column": 18, "message": "class 'Message' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'Message' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-message.h", "line": 101, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-printers.h", "reportHash": "2bd1ce96d901e7e8846f0cd0d73945c0", "checker": {"name": "clang-diagnostic-undef", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wundef"}, "analyzerName": "clang-tidy", "line": 236, "column": 5, "message": "'__apple_build_version__' is not defined, evaluates to 0", "events": [{"message": "'__apple_build_version__' is not defined, evaluates to 0", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-printers.h", "line": 236, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "reportHash": "9a19ea7970fbd553eb60a30502057f8d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 54, "column": 18, "message": "class 'ScopedFakeTestPartResultReporter' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ScopedFakeTestPartResultReporter' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "line": 54, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "reportHash": "afd8d001325d43e3a4d71ec7e0284dc3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 103, "column": 18, "message": "class 'SingleFailureChecker' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'SingleFailureChecker' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-spi.h", "line": 103, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "reportHash": "d0c14bf5f96d1e1f7cd95f335f214478", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 134, "column": 18, "message": "class 'TestPartResultArray' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'TestPartResultArray' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "line": 134, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "reportHash": "991ddde6c0c367b9e9b14b39ff59b9c5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 155, "column": 18, "message": "class 'TestPartResultReporterInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'TestPartResultReporterInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "line": 155, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "reportHash": "8eb85ba9784f3b3bfc4f7308996768e0", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 170, "column": 18, "message": "class 'HasNewFatalFailureHelper' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'HasNewFatalFailureHelper' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest-test-part.h", "line": 170, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "aabd181a75c6b1a73673fb9df8de83aa", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 196, "column": 7, "message": "class 'GTestNonCopyable' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'GTestNonCopyable' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 196, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "89855321cd9d176ed96ccbe48b3a7192", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 242, "column": 18, "message": "class 'Test' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'Test' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 242, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "8b830177e10dd4775ef28f2999e10082", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 399, "column": 18, "message": "class 'TestResult' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestResult' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 399, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "a4145196f681dbc4b185567373e429df", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 533, "column": 18, "message": "class 'TestInfo' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestInfo' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 533, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "1a7afc67717107a644675161b9a02205", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 672, "column": 18, "message": "class 'TestSuite' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestSuite' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 672, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "94add94d42c6f02d5199a8a92cc1221f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 893, "column": 7, "message": "class 'Environment' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Environment' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 893, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "1c980a8f0806c152a96377ef74064198", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 925, "column": 7, "message": "class 'TestEventListener' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'TestEventListener' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 925, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "fdb086a464549d8a92f2310c4ef3e3ff", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1022, "column": 18, "message": "class 'TestEventListeners' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestEventListeners' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1022, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "ac99892218ac9f918dc5da27049a912e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1113, "column": 18, "message": "class 'UnitTest' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'UnitTest' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1113, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "9460180f021935b0f218e03d4812e000", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 1113, "column": 18, "message": "destructor of 'UnitTest' is private and prevents using the type", "events": [{"message": "make it public and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1113, "column": 18}, {"message": "make it protected", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1113, "column": 18}, {"message": "destructor of 'UnitTest' is private and prevents using the type", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1113, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "1b12e77ee562669f105edf1e49bd7f80", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1615, "column": 18, "message": "class 'AssertHelper' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'AssertHelper' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1615, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "4719eada12705e8e20a73dafcb832e93", "checker": {"name": "misc-unconventional-assign-operator", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"}, "analyzerName": "clang-tidy", "line": 1624, "column": 3, "message": "operator=() should return 'AssertHelper&'", "events": [{"message": "operator=() should return 'AssertHelper&'", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1624, "column": 3}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "02a08409e6b15a71d47762d5f10c6c01", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1631, "column": 10, "message": "class 'AssertHelperData' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'AssertHelperData' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1631, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "e2bccc748e58621217b37f2880cdabd5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1689, "column": 7, "message": "class 'WithParamInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'WithParamInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 1689, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "reportHash": "2054852948b62f8afcda1e1a46fbb7bb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 2071, "column": 18, "message": "class 'ScopedTrace' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ScopedTrace' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/gtest.h", "line": 2071, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "af57618e2f0865bae93fae0fa607f8f3", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 99, "column": 18, "message": "class 'DeathTest' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'DeathTest' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "line": 99, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "8cc58f1452be19af503523d50f7cf85a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 115, "column": 9, "message": "class 'ReturnSentinel' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ReturnSentinel' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "line": 115, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "9203344866ea829ae3afcb8448d35fa5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 175, "column": 7, "message": "class 'DeathTestFactory' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DeathTestFactory' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "line": 175, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "f581ad5f8cfe6edbe4eb8240a3678abb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 271, "column": 7, "message": "class 'InternalRunDeathTestFlag' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'InternalRunDeathTestFlag' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h", "line": 271, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-filepath.h", "reportHash": "acf55d462cf531766c00db9265b36d77", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 70, "column": 18, "message": "class 'FilePath' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "events": [{"message": "class 'FilePath' defines a copy constructor, a copy assignment operator, a move constructor and a move assignment operator but does not define a destructor", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-filepath.h", "line": 70, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "93f6db057fac9def6e7ecc64d0c7de5d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 435, "column": 7, "message": "class 'TestFactoryBase' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestFactoryBase' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 435, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "95a81e3c151bf8cbb5792c65a9c71c9d", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 603, "column": 30, "message": "use 'contains' to check for membership", "events": [{"message": "|                              contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 603, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 603, "column": 30}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "0d3feff4472494fc65a68f9f3b8befc5", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 849, "column": 18, "message": "class 'Random' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'Random' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 849, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "b051929966a049347955ae3d285894d2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1080, "column": 7, "message": "class 'NativeArray' defines a non-default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'NativeArray' defines a non-default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 1080, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "1c4176a968476513342f4ee98abfbf15", "checker": {"name": "cert-dcl58-cpp", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl58-cpp.html"}, "analyzerName": "clang-tidy", "line": 1281, "column": 8, "message": "modification of 'std' namespace can result in undefined behavior", "events": [{"message": "'std' namespace opened here", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 1272, "column": 11}, {"message": "modification of 'std' namespace can result in undefined behavior", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-internal.h", "line": 1281, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "f12edf5c516c056a674fde506f87fbcf", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 99, "column": 7, "message": "class 'ParamIteratorInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ParamIteratorInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 99, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "d3f37d96538e006d81a5f43a4cde8e8c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 129, "column": 7, "message": "class 'ParamIterator' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ParamIterator' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 129, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "a4373710171b5dc3b92ee6e979176745", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 171, "column": 7, "message": "class 'ParamGeneratorInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ParamGeneratorInterface' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 171, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "25c8d28ded3e7a87160e1328176079e1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 188, "column": 7, "message": "class 'ParamGenerator' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ParamGenerator' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 188, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "5191c43754843f8acbc7f2336b16c6db", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 212, "column": 7, "message": "class 'RangeGenerator' defines a default destructor and a copy assignment operator but does not define a copy constructor, a move constructor or a move assignment operator", "events": [{"message": "class 'RangeGenerator' defines a default destructor and a copy assignment operator but does not define a copy constructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 212, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "d32c702203220dcb3062765e4528ae2d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 229, "column": 9, "message": "class 'Iterator' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'Iterator' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 229, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "f2da98bfa1e6cb39d619ef50ee829479", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 298, "column": 7, "message": "class 'ValuesInIteratorRangeGenerator' defines a default destructor and a copy assignment operator but does not define a copy constructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ValuesInIteratorRangeGenerator' defines a default destructor and a copy assignment operator but does not define a copy constructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 298, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "6e81eec971914a35b35d6fb00d32f911", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 315, "column": 9, "message": "class 'Iterator' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Iterator' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 315, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "8994f0fb4cec4a2e68093e8930303843", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 398, "column": 7, "message": "class 'ParameterizedTestFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ParameterizedTestFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 398, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "a1223a7da6b96ea6ffa9cf381a67c8cc", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 420, "column": 7, "message": "class 'TestMetaFactoryBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'TestMetaFactoryBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 420, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "27a36590862a91d5c286f8c9c19973c2", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 436, "column": 7, "message": "class 'TestMetaFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'TestMetaFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 436, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "de65b75a4b174b950a36064c987932b4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 462, "column": 7, "message": "class 'ParameterizedTestSuiteInfoBase' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ParameterizedTestSuiteInfoBase' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 462, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "405eb30109839d5f55d3094c42369455", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 505, "column": 7, "message": "class 'ParameterizedTestSuiteInfo' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ParameterizedTestSuiteInfo' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 505, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "92bf9a79a96f2cbc4821fa3d3ad29312", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 589, "column": 41, "message": "use 'contains' to check for membership", "events": [{"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 589, "column": 41}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "cfddf3ef875055f1ad8cea26145a1822", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 691, "column": 7, "message": "class 'ParameterizedTestSuiteRegistry' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ParameterizedTestSuiteRegistry' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 691, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "6bac24d61ba24dd40b5b01bc63614eab", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 825, "column": 7, "message": "class 'CartesianProductGenerator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'CartesianProductGenerator' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 825, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "b4e6b252e87c23748f092e42a5ca98e6", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 845, "column": 9, "message": "class 'IteratorImpl' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'IteratorImpl' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 845, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "78ce1d54f6833c1de7dc97425daee809", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 969, "column": 9, "message": "class 'Iterator' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Iterator' defines a default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-param-util.h", "line": 969, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "c9ed9d98b27fa06fbe8bcf58315c2b2d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 965, "column": 7, "message": "class 'Secret' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'Secret' defines a copy constructor but does not define a destructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 965, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "4d708fc8d1a2525daf966bb354b248f9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1006, "column": 18, "message": "class 'RE' defines a non-default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'RE' defines a non-default destructor and a copy constructor but does not define a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1006, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "d635707fc1ef6264d6c136a07773e2f1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1075, "column": 18, "message": "class 'GTestLog' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'GTestLog' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1075, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "3faa435dde22ff5b6d3e4bf54f12061a", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1282, "column": 18, "message": "class 'Notification' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'Notification' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1282, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "be4a722fedbd95f7e7b36c82c445e84d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1321, "column": 7, "message": "class 'ThreadWithParamBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ThreadWithParamBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1321, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "a2e2d0b441db874a59681a53738e777b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1351, "column": 7, "message": "class 'ThreadWithParam' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ThreadWithParam' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1351, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "b9f06c71c1262669ffcfdd05548c116c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1744, "column": 7, "message": "class 'Mutex' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'Mutex' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1744, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "34b0d2cc188703ed6e7526bb591a14cc", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1762, "column": 7, "message": "class 'GTestMutexLock' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'GTestMutexLock' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1762, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "5d5edf0f20f3e0f7da0773ed75964efb", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1783, "column": 18, "message": "class 'ThreadLocalValueHolderBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'ThreadLocalValueHolderBase' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1783, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "e5ab8e1251d89391b904b10fa755bbc0", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1796, "column": 18, "message": "class 'ThreadLocal' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ThreadLocal' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1796, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "8c746a6235f637a792d589b20b32c319", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1820, "column": 9, "message": "class 'ValueHolder' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'ValueHolder' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1820, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "bf7ee4b6ff91a41049579daffc4d479c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1855, "column": 9, "message": "class 'ValueHolderFactory' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ValueHolderFactory' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1855, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "b1f55be70f349c5042090380ad6ed31b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1866, "column": 9, "message": "class 'DefaultValueHolderFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'DefaultValueHolderFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1866, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "3466b2f6cdbf06798a8f6fcfc4dc70cd", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1877, "column": 9, "message": "class 'InstanceValueHolderFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'InstanceValueHolderFactory' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 1877, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "9975a8fe37957a4a78a591f900b3eb46", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 2005, "column": 10, "message": "comparison between 'signed char' and 'unsigned char'", "events": [{"message": "comparison between 'signed char' and 'unsigned char'", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/include/gtest/internal/gtest-port.h", "line": 2005, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "reportHash": "5b20a82c9dcb8151934b34f1a8ad011d", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 406, "column": 7, "message": "class 'DeathTestImpl' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'DeathTestImpl' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 406, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "reportHash": "f7cd5f970ab45b94451773d4e72d8502", "checker": {"name": "cppcoreguidelines-virtual-class-destructor", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/virtual-class-destructor.html"}, "analyzerName": "clang-tidy", "line": 406, "column": 7, "message": "destructor of 'DeathTestImpl' is protected and virtual", "events": [{"message": "make it protected and non-virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 406, "column": 7}, {"message": "destructor of 'DeathTestImpl' is protected and virtual", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 406, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "reportHash": "a72b045eb3bb59271683dffa98a3f188", "checker": {"name": "readability-container-data-pointer", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-data-pointer.html"}, "analyzerName": "clang-tidy", "line": 637, "column": 22, "message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "events": [{"message": "|                      arg.data() (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 637, "column": 7}, {"message": "'data' should be used for accessing the data pointer instead of taking the address of the 0-th element", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 637, "column": 22}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "reportHash": "fcc9cc2737f4eb3931f895df8c7f7eca", "checker": {"name": "bugprone-misplaced-widening-cast", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/misplaced-widening-cast.html"}, "analyzerName": "clang-tidy", "line": 1309, "column": 29, "message": "either cast from 'int' to 'size_t' (aka 'unsigned long') is ineffective, or there is loss of precision before the conversion", "events": [{"message": "either cast from 'int' to 'size_t' (aka 'unsigned long') is ineffective, or there is loss of precision before the conversion", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-death-test.cc", "line": 1309, "column": 29}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "286db9e12889ff3a914fed786adc7e31", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 141, "column": 7, "message": "class 'GTestFlagSaver' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'GTestFlagSaver' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 141, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "12bf3a1454f3fb21bbb370fbabd34308", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 409, "column": 7, "message": "class 'OsStackTraceGetterInterface' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'OsStackTraceGetterInterface' defines a default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 409, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "11aef7f6abf99770bd1e863f2e90d696", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 438, "column": 7, "message": "class 'OsStackTraceGetter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'OsStackTraceGetter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 438, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "071693503347e3bf2e95911d1e90479f", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 469, "column": 7, "message": "class 'DefaultGlobalTestPartResultReporter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'DefaultGlobalTestPartResultReporter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 469, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "0f9537d1ceeb68a46e409edce051a2cd", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 488, "column": 7, "message": "class 'DefaultPerThreadTestPartResultReporter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'DefaultPerThreadTestPartResultReporter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 488, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "ad2e5ff68634438ce027fcebdceb105c", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 509, "column": 18, "message": "class 'UnitTestImpl' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'UnitTestImpl' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 509, "column": 18}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "955563c2c2bb7d9bd24f0bfcbf313678", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1074, "column": 7, "message": "class 'StreamingListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'StreamingListener' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 1074, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "c41c720fda0377e4447b6a6ad43038ee", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1077, "column": 9, "message": "class 'AbstractSocketWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'AbstractSocketWriter' defines a default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 1077, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "reportHash": "6f62f5c5e7d458cbb5a89a0ef1a102be", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1092, "column": 9, "message": "class 'SocketWriter' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'SocketWriter' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-internal-inl.h", "line": 1092, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "reportHash": "6134e2f51d9a70add64241e9260cd186", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 1026, "column": 12, "message": "constness of 'file_name' prevents automatic move", "events": [{"message": "constness of 'file_name' prevents automatic move", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "line": 1026, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "reportHash": "ebedf0fd906d52a78f27f71aa967e5b4", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 1068, "column": 7, "message": "class 'CapturedStream' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'CapturedStream' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-port.cc", "line": 1068, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "reportHash": "21a75e876a45319a51d2b96a880aa2f5", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 76, "column": 15, "message": "use 'contains' to check for membership", "events": [{"message": "|               contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 76, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 76, "column": 15}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "reportHash": "05f583973df566e005821916b1ac4989", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 81, "column": 27, "message": "use 'contains' to check for membership", "events": [{"message": "|                           contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 81, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 81, "column": 27}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "reportHash": "caf6b2bfda6c54428c4eac70eb81ce61", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 91, "column": 15, "message": "use 'contains' to check for membership", "events": [{"message": "|         !     contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 91, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest-typed-test.cc", "line": 91, "column": 15}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "f80c5bce29099fce32d463462be3b130", "checker": {"name": "misc-unconventional-assign-operator", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc/unconventional-assign-operator.html"}, "analyzerName": "clang-tidy", "line": 475, "column": 1, "message": "operator=() should return 'AssertHelper&'", "events": [{"message": "operator=() should return 'AssertHelper&'", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 475, "column": 1}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "d86fd1ba73c8686ca771aefefce6d8dd", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 536, "column": 15, "message": "use 'contains' to check for membership", "events": [{"message": "|               contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 536, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 536, "column": 15}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "47b09ea613733a5748803db1af385dc1", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 610, "column": 17, "message": "use 'contains' to check for membership", "events": [{"message": "|                 contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 610, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 610, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "068577b8d602990ace6e1c46cdfd8565", "checker": {"name": "readability-container-contains", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability/container-contains.html"}, "analyzerName": "clang-tidy", "line": 807, "column": 34, "message": "use 'contains' to check for membership", "events": [{"message": "|                                  contains (fixit)", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 807, "column": 7}, {"message": "use 'contains' to check for membership", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 807, "column": 34}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "d7184c9c70c627c5197f89b84286dac0", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 2058, "column": 46, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 2058, "column": 46}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "c26676b030dbe5cf2494c31821d66d8f", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 2059, "column": 47, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 2059, "column": 47}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "7ad8974e969ea676ada1282ec3a62fcf", "checker": {"name": "bugprone-signed-char-misuse", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/signed-char-misuse.html"}, "analyzerName": "clang-tidy", "line": 2096, "column": 50, "message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "events": [{"message": "'signed char' to 'uint32_t' (aka 'unsigned int') conversion; consider casting to 'unsigned char' first.", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 2096, "column": 50}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "9111c5c26bd8fc0720498c0bb9213b99", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance/no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 2269, "column": 12, "message": "constness of 'user_msg_string' prevents automatic move", "events": [{"message": "constness of 'user_msg_string' prevents automatic move", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 2269, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "150bc6758ba72ce49279b5722cd348c1", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 3786, "column": 7, "message": "class 'TestEventRepeater' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'TestEventRepeater' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 3786, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "e62079d63770661cd5f8168e06efb38b", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 3918, "column": 7, "message": "class 'XmlUnitTestResultPrinter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'XmlUnitTestResultPrinter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 3918, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "3a524ac6cb5d3bda63c9e343d5d813a7", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 4475, "column": 7, "message": "class 'JsonUnitTestResultPrinter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "events": [{"message": "class 'JsonUnitTestResultPrinter' defines a copy constructor and a copy assignment operator but does not define a destructor, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 4475, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "reportHash": "74f9aa1c91282b4f3a080ec8a48ad46e", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 5082, "column": 7, "message": "class 'ScopedPrematureExitFile' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "events": [{"message": "class 'ScopedPrematureExitFile' defines a non-default destructor, a copy constructor and a copy assignment operator but does not define a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/googletest/googletest/src/gtest.cc", "line": 5082, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
