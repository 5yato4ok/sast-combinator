<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "content": "// Tencent is pleased to support the open source community by making RapidJSON available.\n// \n// Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip.\n//\n// Licensed under the MIT License (the &quot;License&quot;); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://opensource.org/licenses/MIT\n//\n// Unless required by applicable law or agreed to in writing, software distributed \n// under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR \n// CONDITIONS OF ANY KIND, either express or implied. See the License for the \n// specific language governing permissions and limitations under the License.\n\n#ifndef RAPIDJSON_ALLOCATORS_H_\n#define RAPIDJSON_ALLOCATORS_H_\n\n#include &quot;rapidjson.h&quot;\n#include &quot;internal/meta.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;limits&gt;\n\n#if RAPIDJSON_HAS_CXX11\n#include &lt;type_traits&gt;\n#endif\n\nRAPIDJSON_NAMESPACE_BEGIN\n\n///////////////////////////////////////////////////////////////////////////////\n// Allocator\n\n/*! \\class rapidjson::Allocator\n    \\brief Concept for allocating, resizing and freeing memory block.\n    \n    Note that Malloc() and Realloc() are non-static but Free() is static.\n    \n    So if an allocator need to support Free(), it needs to put its pointer in \n    the header of memory block.\n\n\\code\nconcept Allocator {\n    static const bool kNeedFree;    //!&lt; Whether this allocator needs to call Free().\n\n    // Allocate a memory block.\n    // \\param size of the memory block in bytes.\n    // \\returns pointer to the memory block.\n    void* Malloc(size_t size);\n\n    // Resize a memory block.\n    // \\param originalPtr The pointer to current memory block. Null pointer is permitted.\n    // \\param originalSize The current size in bytes. (Design issue: since some allocator may not book-keep this, explicitly pass to it can save memory.)\n    // \\param newSize the new size in bytes.\n    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize);\n\n    // Free a memory block.\n    // \\param pointer to the memory block. Null pointer is permitted.\n    static void Free(void *ptr);\n};\n\\endcode\n*/\n\n\n/*! \\def RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY\n    \\ingroup RAPIDJSON_CONFIG\n    \\brief User-defined kDefaultChunkCapacity definition.\n\n    User can define this as any \\c size that is a power of 2.\n*/\n\n#ifndef RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY\n#define RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY (64 * 1024)\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////\n// CrtAllocator\n\n//! C-runtime library allocator.\n/*! This class is just wrapper for standard C library memory routines.\n    \\note implements Allocator concept\n*/\nclass CrtAllocator {\npublic:\n    static const bool kNeedFree = true;\n    void* Malloc(size_t size) { \n        if (size) //  behavior of malloc(0) is implementation defined.\n        {\n            if (auto r = RAPIDJSON_MALLOC(size))\n                return r;\n            throw std::bad_alloc();\n        }\n        else\n            return NULL; // standardize to returning NULL.\n    }\n    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {\n        (void)originalSize;\n        if (newSize == 0) {\n            RAPIDJSON_FREE(originalPtr);\n            return NULL;\n        }\n        if (auto r = RAPIDJSON_REALLOC(originalPtr, newSize))\n            return r;\n        throw std::bad_alloc();\n    }\n    static void Free(void *ptr) RAPIDJSON_NOEXCEPT { RAPIDJSON_FREE(ptr); }\n\n    bool operator==(const CrtAllocator&amp;) const RAPIDJSON_NOEXCEPT {\n        return true;\n    }\n    bool operator!=(const CrtAllocator&amp;) const RAPIDJSON_NOEXCEPT {\n        return false;\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// MemoryPoolAllocator\n\n//! Default memory allocator used by the parser and DOM.\n/*! This allocator allocate memory blocks from pre-allocated memory chunks. \n\n    It does not free memory blocks. And Realloc() only allocate new memory.\n\n    The memory chunks are allocated by BaseAllocator, which is CrtAllocator by default.\n\n    User may also supply a buffer as the first chunk.\n\n    If the user-buffer is full then additional chunks are allocated by BaseAllocator.\n\n    The user-buffer is not deallocated by this allocator.\n\n    \\tparam BaseAllocator the allocator type for allocating memory chunks. Default is CrtAllocator.\n    \\note implements Allocator concept\n*/\ntemplate &lt;typename BaseAllocator = CrtAllocator&gt;\nclass MemoryPoolAllocator {\n    //! Chunk header for perpending to each chunk.\n    /*! Chunks are stored as a singly linked list.\n    */\n    struct ChunkHeader {\n        size_t capacity;    //!&lt; Capacity of the chunk in bytes (excluding the header itself).\n        size_t size;        //!&lt; Current size of allocated memory in bytes.\n        ChunkHeader *next;  //!&lt; Next chunk in the linked list.\n    };\n\n    struct SharedData {\n        ChunkHeader *chunkHead;  //!&lt; Head of the chunk linked-list. Only the head chunk serves allocation.\n        BaseAllocator* ownBaseAllocator; //!&lt; base allocator created by this object.\n        size_t refcount;\n        bool ownBuffer;\n    };\n\n    static const size_t SIZEOF_SHARED_DATA = RAPIDJSON_ALIGN(sizeof(SharedData));\n    static const size_t SIZEOF_CHUNK_HEADER = RAPIDJSON_ALIGN(sizeof(ChunkHeader));\n\n    static inline ChunkHeader *GetChunkHead(SharedData *shared)\n    {\n        return reinterpret_cast&lt;ChunkHeader*&gt;(reinterpret_cast&lt;uint8_t*&gt;(shared) + SIZEOF_SHARED_DATA);\n    }\n    static inline uint8_t *GetChunkBuffer(SharedData *shared)\n    {\n        return reinterpret_cast&lt;uint8_t*&gt;(shared-&gt;chunkHead) + SIZEOF_CHUNK_HEADER;\n    }\n\n    static const size_t kDefaultChunkCapacity = RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY; //!&lt; Default chunk capacity.\n\npublic:\n    static const bool kNeedFree = false;    //!&lt; Tell users that no need to call Free() with this allocator. (concept Allocator)\n    static const bool kRefCounted = true;   //!&lt; Tell users that this allocator is reference counted on copy\n\n    //! Constructor with chunkSize.\n    /*! \\param chunkSize The size of memory chunk. The default is kDefaultChunkSize.\n        \\param baseAllocator The allocator for allocating memory chunks.\n    */\n    explicit\n    MemoryPoolAllocator(size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) : \n        chunk_capacity_(chunkSize),\n        baseAllocator_(baseAllocator ? baseAllocator : RAPIDJSON_NEW(BaseAllocator)()),\n        shared_(static_cast&lt;SharedData*&gt;(baseAllocator_ ? baseAllocator_-&gt;Malloc(SIZEOF_SHARED_DATA + SIZEOF_CHUNK_HEADER) : 0))\n    {\n        RAPIDJSON_ASSERT(baseAllocator_ != 0);\n        RAPIDJSON_ASSERT(shared_ != 0);\n        if (baseAllocator) {\n            shared_-&gt;ownBaseAllocator = 0;\n        }\n        else {\n            shared_-&gt;ownBaseAllocator = baseAllocator_;\n        }\n        shared_-&gt;chunkHead = GetChunkHead(shared_);\n        shared_-&gt;chunkHead-&gt;capacity = 0;\n        shared_-&gt;chunkHead-&gt;size = 0;\n        shared_-&gt;chunkHead-&gt;next = 0;\n        shared_-&gt;ownBuffer = true;\n        shared_-&gt;refcount = 1;\n    }\n\n    //! Constructor with user-supplied buffer.\n    /*! The user buffer will be used firstly. When it is full, memory pool allocates new chunk with chunk size.\n\n        The user buffer will not be deallocated when this allocator is destructed.\n\n        \\param buffer User supplied buffer.\n        \\param size Size of the buffer in bytes. It must at least larger than sizeof(ChunkHeader).\n        \\param chunkSize The size of memory chunk. The default is kDefaultChunkSize.\n        \\param baseAllocator The allocator for allocating memory chunks.\n    */\n    MemoryPoolAllocator(void *buffer, size_t size, size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :\n        chunk_capacity_(chunkSize),\n        baseAllocator_(baseAllocator),\n        shared_(static_cast&lt;SharedData*&gt;(AlignBuffer(buffer, size)))\n    {\n        RAPIDJSON_ASSERT(size &gt;= SIZEOF_SHARED_DATA + SIZEOF_CHUNK_HEADER);\n        shared_-&gt;chunkHead = GetChunkHead(shared_);\n        shared_-&gt;chunkHead-&gt;capacity = size - SIZEOF_SHARED_DATA - SIZEOF_CHUNK_HEADER;\n        shared_-&gt;chunkHead-&gt;size = 0;\n        shared_-&gt;chunkHead-&gt;next = 0;\n        shared_-&gt;ownBaseAllocator = 0;\n        shared_-&gt;ownBuffer = false;\n        shared_-&gt;refcount = 1;\n    }\n\n    MemoryPoolAllocator(const MemoryPoolAllocator&amp; rhs) RAPIDJSON_NOEXCEPT :\n        chunk_capacity_(rhs.chunk_capacity_),\n        baseAllocator_(rhs.baseAllocator_),\n        shared_(rhs.shared_)\n    {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        ++shared_-&gt;refcount;\n    }\n    MemoryPoolAllocator&amp; operator=(const MemoryPoolAllocator&amp; rhs) RAPIDJSON_NOEXCEPT\n    {\n        RAPIDJSON_NOEXCEPT_ASSERT(rhs.shared_-&gt;refcount &gt; 0);\n        ++rhs.shared_-&gt;refcount;\n        this-&gt;~MemoryPoolAllocator();\n        baseAllocator_ = rhs.baseAllocator_;\n        chunk_capacity_ = rhs.chunk_capacity_;\n        shared_ = rhs.shared_;\n        return *this;\n    }\n\n#if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n    MemoryPoolAllocator(MemoryPoolAllocator&amp;&amp; rhs) RAPIDJSON_NOEXCEPT :\n        chunk_capacity_(rhs.chunk_capacity_),\n        baseAllocator_(rhs.baseAllocator_),\n        shared_(rhs.shared_)\n    {\n        RAPIDJSON_NOEXCEPT_ASSERT(rhs.shared_-&gt;refcount &gt; 0);\n        rhs.shared_ = 0;\n    }\n    MemoryPoolAllocator&amp; operator=(MemoryPoolAllocator&amp;&amp; rhs) RAPIDJSON_NOEXCEPT\n    {\n        RAPIDJSON_NOEXCEPT_ASSERT(rhs.shared_-&gt;refcount &gt; 0);\n        this-&gt;~MemoryPoolAllocator();\n        baseAllocator_ = rhs.baseAllocator_;\n        chunk_capacity_ = rhs.chunk_capacity_;\n        shared_ = rhs.shared_;\n        rhs.shared_ = 0;\n        return *this;\n    }\n#endif\n\n    //! Destructor.\n    /*! This deallocates all memory chunks, excluding the user-supplied buffer.\n    */\n    ~MemoryPoolAllocator() RAPIDJSON_NOEXCEPT {\n        if (!shared_) {\n            // do nothing if moved\n            return;\n        }\n        if (shared_-&gt;refcount &gt; 1) {\n            --shared_-&gt;refcount;\n            return;\n        }\n        Clear();\n        BaseAllocator *a = shared_-&gt;ownBaseAllocator;\n        if (shared_-&gt;ownBuffer) {\n            baseAllocator_-&gt;Free(shared_);\n        }\n        RAPIDJSON_DELETE(a);\n    }\n\n    //! Deallocates all memory chunks, excluding the first/user one.\n    void Clear() RAPIDJSON_NOEXCEPT {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        for (;;) {\n            ChunkHeader* c = shared_-&gt;chunkHead;\n            if (!c-&gt;next) {\n                break;\n            }\n            shared_-&gt;chunkHead = c-&gt;next;\n            baseAllocator_-&gt;Free(c);\n        }\n        shared_-&gt;chunkHead-&gt;size = 0;\n    }\n\n    //! Computes the total capacity of allocated memory chunks.\n    /*! \\return total capacity in bytes.\n    */\n    size_t Capacity() const RAPIDJSON_NOEXCEPT {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        size_t capacity = 0;\n        for (ChunkHeader* c = shared_-&gt;chunkHead; c != 0; c = c-&gt;next)\n            capacity += c-&gt;capacity;\n        return capacity;\n    }\n\n    //! Computes the memory blocks allocated.\n    /*! \\return total used bytes.\n    */\n    size_t Size() const RAPIDJSON_NOEXCEPT {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        size_t size = 0;\n        for (ChunkHeader* c = shared_-&gt;chunkHead; c != 0; c = c-&gt;next)\n            size += c-&gt;size;\n        return size;\n    }\n\n    //! Whether the allocator is shared.\n    /*! \\return true or false.\n    */\n    bool Shared() const RAPIDJSON_NOEXCEPT {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        return shared_-&gt;refcount &gt; 1;\n    }\n\n    //! Allocates a memory block. (concept Allocator)\n    void* Malloc(size_t size) {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        if (!size)\n            return NULL;\n\n        size = RAPIDJSON_ALIGN(size);\n        if (RAPIDJSON_UNLIKELY(shared_-&gt;chunkHead-&gt;size + size &gt; shared_-&gt;chunkHead-&gt;capacity))\n            if (!AddChunk(chunk_capacity_ &gt; size ? chunk_capacity_ : size))\n                return NULL;\n\n        void *buffer = GetChunkBuffer(shared_) + shared_-&gt;chunkHead-&gt;size;\n        shared_-&gt;chunkHead-&gt;size += size;\n        return buffer;\n    }\n\n    //! Resizes a memory block (concept Allocator)\n    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {\n        if (originalPtr == 0)\n            return Malloc(newSize);\n\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        if (newSize == 0)\n            return NULL;\n\n        originalSize = RAPIDJSON_ALIGN(originalSize);\n        newSize = RAPIDJSON_ALIGN(newSize);\n\n        // Do not shrink if new size is smaller than original\n        if (originalSize &gt;= newSize)\n            return originalPtr;\n\n        // Simply expand it if it is the last allocation and there is sufficient space\n        if (originalPtr == GetChunkBuffer(shared_) + shared_-&gt;chunkHead-&gt;size - originalSize) {\n            size_t increment = static_cast&lt;size_t&gt;(newSize - originalSize);\n            if (shared_-&gt;chunkHead-&gt;size + increment &lt;= shared_-&gt;chunkHead-&gt;capacity) {\n                shared_-&gt;chunkHead-&gt;size += increment;\n                return originalPtr;\n            }\n        }\n\n        // Realloc process: allocate and copy memory, do not free original buffer.\n        if (void* newBuffer = Malloc(newSize)) {\n            if (originalSize)\n                std::memcpy(newBuffer, originalPtr, originalSize);\n            return newBuffer;\n        }\n        else\n            return NULL;\n    }\n\n    //! Frees a memory block (concept Allocator)\n    static void Free(void *ptr) RAPIDJSON_NOEXCEPT { (void)ptr; } // Do nothing\n\n    //! Compare (equality) with another MemoryPoolAllocator\n    bool operator==(const MemoryPoolAllocator&amp; rhs) const RAPIDJSON_NOEXCEPT {\n        RAPIDJSON_NOEXCEPT_ASSERT(shared_-&gt;refcount &gt; 0);\n        RAPIDJSON_NOEXCEPT_ASSERT(rhs.shared_-&gt;refcount &gt; 0);\n        return shared_ == rhs.shared_;\n    }\n    //! Compare (inequality) with another MemoryPoolAllocator\n    bool operator!=(const MemoryPoolAllocator&amp; rhs) const RAPIDJSON_NOEXCEPT {\n        return !operator==(rhs);\n    }\n\nprivate:\n    //! Creates a new chunk.\n    /*! \\param capacity Capacity of the chunk in bytes.\n        \\return true if success.\n    */\n    bool AddChunk(size_t capacity) {\n        if (!baseAllocator_)\n            shared_-&gt;ownBaseAllocator = baseAllocator_ = RAPIDJSON_NEW(BaseAllocator)();\n        if (ChunkHeader* chunk = static_cast&lt;ChunkHeader*&gt;(baseAllocator_-&gt;Malloc(SIZEOF_CHUNK_HEADER + capacity))) {\n            chunk-&gt;capacity = capacity;\n            chunk-&gt;size = 0;\n            chunk-&gt;next = shared_-&gt;chunkHead;\n            shared_-&gt;chunkHead = chunk;\n            return true;\n        }\n        else\n            return false;\n    }\n\n    static inline void* AlignBuffer(void* buf, size_t &amp;size)\n    {\n        RAPIDJSON_NOEXCEPT_ASSERT(buf != 0);\n        const uintptr_t mask = sizeof(void*) - 1;\n        const uintptr_t ubuf = reinterpret_cast&lt;uintptr_t&gt;(buf);\n        if (RAPIDJSON_UNLIKELY(ubuf &amp; mask)) {\n            const uintptr_t abuf = (ubuf + mask) &amp; ~mask;\n            RAPIDJSON_ASSERT(size &gt;= abuf - ubuf);\n            buf = reinterpret_cast&lt;void*&gt;(abuf);\n            size -= abuf - ubuf;\n        }\n        return buf;\n    }\n\n    size_t chunk_capacity_;     //!&lt; The minimum capacity of chunk when they are allocated.\n    BaseAllocator* baseAllocator_;  //!&lt; base allocator for allocating memory chunks.\n    SharedData *shared_;        //!&lt; The shared data of the allocator\n};\n\nnamespace internal {\n    template&lt;typename, typename = void&gt;\n    struct IsRefCounted :\n        public FalseType\n    { };\n    template&lt;typename T&gt;\n    struct IsRefCounted&lt;T, typename internal::EnableIfCond&lt;T::kRefCounted&gt;::Type&gt; :\n        public TrueType\n    { };\n}\n\ntemplate&lt;typename T, typename A&gt;\ninline T* Realloc(A&amp; a, T* old_p, size_t old_n, size_t new_n)\n{\n    RAPIDJSON_NOEXCEPT_ASSERT(old_n &lt;= (std::numeric_limits&lt;size_t&gt;::max)() / sizeof(T) &amp;&amp; new_n &lt;= (std::numeric_limits&lt;size_t&gt;::max)() / sizeof(T));\n    return static_cast&lt;T*&gt;(a.Realloc(old_p, old_n * sizeof(T), new_n * sizeof(T)));\n}\n\ntemplate&lt;typename T, typename A&gt;\ninline T *Malloc(A&amp; a, size_t n = 1)\n{\n    return Realloc&lt;T, A&gt;(a, NULL, 0, n);\n}\n\ntemplate&lt;typename T, typename A&gt;\ninline void Free(A&amp; a, T *p, size_t n = 1)\n{\n    static_cast&lt;void&gt;(Realloc&lt;T, A&gt;(a, p, n, 0));\n}\n\n#ifdef __GNUC__\nRAPIDJSON_DIAG_PUSH\nRAPIDJSON_DIAG_OFF(effc++) // std::allocator can safely be inherited\n#endif\n\ntemplate &lt;typename T, typename BaseAllocator = CrtAllocator&gt;\nclass StdAllocator :\n    public std::allocator&lt;T&gt;\n{\n    typedef std::allocator&lt;T&gt; allocator_type;\n#if RAPIDJSON_HAS_CXX11\n    typedef std::allocator_traits&lt;allocator_type&gt; traits_type;\n#else\n    typedef allocator_type traits_type;\n#endif\n\npublic:\n    typedef BaseAllocator BaseAllocatorType;\n\n    StdAllocator() RAPIDJSON_NOEXCEPT :\n        allocator_type(),\n        baseAllocator_()\n    { }\n\n    StdAllocator(const StdAllocator&amp; rhs) RAPIDJSON_NOEXCEPT :\n        allocator_type(rhs),\n        baseAllocator_(rhs.baseAllocator_)\n    { }\n\n    template&lt;typename U&gt;\n    StdAllocator(const StdAllocator&lt;U, BaseAllocator&gt;&amp; rhs) RAPIDJSON_NOEXCEPT :\n        allocator_type(rhs),\n        baseAllocator_(rhs.baseAllocator_)\n    { }\n\n#if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n    StdAllocator(StdAllocator&amp;&amp; rhs) RAPIDJSON_NOEXCEPT :\n        allocator_type(std::move(rhs)),\n        baseAllocator_(std::move(rhs.baseAllocator_))\n    { }\n#endif\n#if RAPIDJSON_HAS_CXX11\n    using propagate_on_container_move_assignment = std::true_type;\n    using propagate_on_container_swap = std::true_type;\n#endif\n\n    /* implicit */\n    StdAllocator(const BaseAllocator&amp; baseAllocator) RAPIDJSON_NOEXCEPT :\n        allocator_type(),\n        baseAllocator_(baseAllocator)\n    { }\n\n    ~StdAllocator() RAPIDJSON_NOEXCEPT\n    { }\n\n    template&lt;typename U&gt;\n    struct rebind {\n        typedef StdAllocator&lt;U, BaseAllocator&gt; other;\n    };\n\n    typedef typename traits_type::size_type         size_type;\n    typedef typename traits_type::difference_type   difference_type;\n\n    typedef typename traits_type::value_type        value_type;\n    typedef typename traits_type::pointer           pointer;\n    typedef typename traits_type::const_pointer     const_pointer;\n\n#if RAPIDJSON_HAS_CXX11\n\n    typedef typename std::add_lvalue_reference&lt;value_type&gt;::type &amp;reference;\n    typedef typename std::add_lvalue_reference&lt;typename std::add_const&lt;value_type&gt;::type&gt;::type &amp;const_reference;\n\n    pointer address(reference r) const RAPIDJSON_NOEXCEPT\n    {\n        return std::addressof(r);\n    }\n    const_pointer address(const_reference r) const RAPIDJSON_NOEXCEPT\n    {\n        return std::addressof(r);\n    }\n\n    size_type max_size() const RAPIDJSON_NOEXCEPT\n    {\n        return traits_type::max_size(*this);\n    }\n\n    template &lt;typename ...Args&gt;\n    void construct(pointer p, Args&amp;&amp;... args)\n    {\n        traits_type::construct(*this, p, std::forward&lt;Args&gt;(args)...);\n    }\n    void destroy(pointer p)\n    {\n        traits_type::destroy(*this, p);\n    }\n\n#else // !RAPIDJSON_HAS_CXX11\n\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n\n    pointer address(reference r) const RAPIDJSON_NOEXCEPT\n    {\n        return allocator_type::address(r);\n    }\n    const_pointer address(const_reference r) const RAPIDJSON_NOEXCEPT\n    {\n        return allocator_type::address(r);\n    }\n\n    size_type max_size() const RAPIDJSON_NOEXCEPT\n    {\n        return allocator_type::max_size();\n    }\n\n    void construct(pointer p, const_reference r)\n    {\n        allocator_type::construct(p, r);\n    }\n    void destroy(pointer p)\n    {\n        allocator_type::destroy(p);\n    }\n\n#endif // !RAPIDJSON_HAS_CXX11\n\n    template &lt;typename U&gt;\n    U* allocate(size_type n = 1, const void* = 0)\n    {\n        return RAPIDJSON_NAMESPACE::Malloc&lt;U&gt;(baseAllocator_, n);\n    }\n    template &lt;typename U&gt;\n    void deallocate(U* p, size_type n = 1)\n    {\n        RAPIDJSON_NAMESPACE::Free&lt;U&gt;(baseAllocator_, p, n);\n    }\n\n    pointer allocate(size_type n = 1, const void* = 0)\n    {\n        return allocate&lt;value_type&gt;(n);\n    }\n    void deallocate(pointer p, size_type n = 1)\n    {\n        deallocate&lt;value_type&gt;(p, n);\n    }\n\n#if RAPIDJSON_HAS_CXX11\n    using is_always_equal = std::is_empty&lt;BaseAllocator&gt;;\n#endif\n\n    template&lt;typename U&gt;\n    bool operator==(const StdAllocator&lt;U, BaseAllocator&gt;&amp; rhs) const RAPIDJSON_NOEXCEPT\n    {\n        return baseAllocator_ == rhs.baseAllocator_;\n    }\n    template&lt;typename U&gt;\n    bool operator!=(const StdAllocator&lt;U, BaseAllocator&gt;&amp; rhs) const RAPIDJSON_NOEXCEPT\n    {\n        return !operator==(rhs);\n    }\n\n    //! rapidjson Allocator concept\n    static const bool kNeedFree = BaseAllocator::kNeedFree;\n    static const bool kRefCounted = internal::IsRefCounted&lt;BaseAllocator&gt;::Value;\n    void* Malloc(size_t size)\n    {\n        return baseAllocator_.Malloc(size);\n    }\n    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize)\n    {\n        return baseAllocator_.Realloc(originalPtr, originalSize, newSize);\n    }\n    static void Free(void *ptr) RAPIDJSON_NOEXCEPT\n    {\n        BaseAllocator::Free(ptr);\n    }\n\nprivate:\n    template &lt;typename, typename&gt;\n    friend class StdAllocator; // access to StdAllocator&lt;!T&gt;.*\n\n    BaseAllocator baseAllocator_;\n};\n\n#if !RAPIDJSON_HAS_CXX17 // std::allocator&lt;void&gt; deprecated in C++17\ntemplate &lt;typename BaseAllocator&gt;\nclass StdAllocator&lt;void, BaseAllocator&gt; :\n    public std::allocator&lt;void&gt;\n{\n    typedef std::allocator&lt;void&gt; allocator_type;\n\npublic:\n    typedef BaseAllocator BaseAllocatorType;\n\n    StdAllocator() RAPIDJSON_NOEXCEPT :\n        allocator_type(),\n        baseAllocator_()\n    { }\n\n    StdAllocator(const StdAllocator&amp; rhs) RAPIDJSON_NOEXCEPT :\n        allocator_type(rhs),\n        baseAllocator_(rhs.baseAllocator_)\n    { }\n\n    template&lt;typename U&gt;\n    StdAllocator(const StdAllocator&lt;U, BaseAllocator&gt;&amp; rhs) RAPIDJSON_NOEXCEPT :\n        allocator_type(rhs),\n        baseAllocator_(rhs.baseAllocator_)\n    { }\n\n    /* implicit */\n    StdAllocator(const BaseAllocator&amp; baseAllocator) RAPIDJSON_NOEXCEPT :\n        allocator_type(),\n        baseAllocator_(baseAllocator)\n    { }\n\n    ~StdAllocator() RAPIDJSON_NOEXCEPT\n    { }\n\n    template&lt;typename U&gt;\n    struct rebind {\n        typedef StdAllocator&lt;U, BaseAllocator&gt; other;\n    };\n\n    typedef typename allocator_type::value_type value_type;\n\nprivate:\n    template &lt;typename, typename&gt;\n    friend class StdAllocator; // access to StdAllocator&lt;!T&gt;.*\n\n    BaseAllocator baseAllocator_;\n};\n#endif\n\n#ifdef __GNUC__\nRAPIDJSON_DIAG_POP\n#endif\n\nRAPIDJSON_NAMESPACE_END\n\n#endif // RAPIDJSON_ENCODINGS_H_\n"}, "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp": {"id": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "filePath": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#include &quot;server_rest_connection.h&quot;\n\n#include &lt;QtCore/QPointer&gt;\n#include &lt;QtNetwork/QAuthenticator&gt;\n\n#include &lt;api/helpers/chunks_request_data.h&gt;\n#include &lt;api/helpers/empty_request_data.h&gt;\n#include &lt;api/helpers/send_statistics_request_data.h&gt;\n#include &lt;api/helpers/thumbnail_request_data.h&gt;\n#include &lt;api/model/cloud_credentials_data.h&gt;\n#include &lt;api/model/update_information_reply.h&gt;\n#include &lt;core/resource/camera_resource.h&gt;\n#include &lt;core/resource/media_server_resource.h&gt;\n#include &lt;core/resource/user_resource.h&gt;\n#include &lt;core/resource_management/resource_pool.h&gt;\n#include &lt;core/resource_management/resource_properties.h&gt;\n#include &lt;network/router.h&gt;\n#include &lt;nx/api/mediaserver/image_request.h&gt;\n#include &lt;nx/branding.h&gt;\n#include &lt;nx/build_info.h&gt;\n#include &lt;nx/fusion/model_functions.h&gt;\n#include &lt;nx/fusion/serialization/compressed_time_functions.h&gt;\n#include &lt;nx/metric/application_metrics_storage.h&gt;\n#include &lt;nx/network/http/custom_headers.h&gt;\n#include &lt;nx/network/http/http_types.h&gt;\n#include &lt;nx/network/rest/result.h&gt;\n#include &lt;nx/network/ssl/helpers.h&gt;\n#include &lt;nx/network/url/url_builder.h&gt;\n#include &lt;nx/reflect/json.h&gt;\n#include &lt;nx/reflect/string_conversion.h&gt;\n#include &lt;nx/reflect/urlencoded/serializer.h&gt;\n#include &lt;nx/utils/buffer.h&gt;\n#include &lt;nx/utils/coro/task_utils.h&gt;\n#include &lt;nx/utils/guarded_callback.h&gt;\n#include &lt;nx/utils/i18n/translation_manager.h&gt;\n#include &lt;nx/utils/json/qjson.h&gt;\n#include &lt;nx/utils/json/qt_containers_reflect.h&gt;\n#include &lt;nx/utils/log/log.h&gt;\n#include &lt;nx/utils/random.h&gt;\n#include &lt;nx/vms/api/analytics/device_agent_active_setting_changed_request.h&gt;\n#include &lt;nx/vms/api/analytics/device_agent_settings_request.h&gt;\n#include &lt;nx/vms/api/data/device_actions.h&gt;\n#include &lt;nx/vms/api/data/ldap.h&gt;\n#include &lt;nx/vms/api/data/login.h&gt;\n#include &lt;nx/vms/api/data/lookup_list_data.h&gt;\n#include &lt;nx/vms/api/data/peer_data.h&gt;\n#include &lt;nx/vms/api/data/site_information.h&gt;\n#include &lt;nx/vms/api/data/site_setup.h&gt;\n#include &lt;nx/vms/api/data/storage_encryption_data.h&gt;\n#include &lt;nx/vms/api/rules/event_log.h&gt;\n#include &lt;nx/vms/common/api/helpers/parser_helper.h&gt;\n#include &lt;nx/vms/common/application_context.h&gt;\n#include &lt;nx/vms/common/network/abstract_certificate_verifier.h&gt;\n#include &lt;nx/vms/common/resource/analytics_engine_resource.h&gt;\n#include &lt;nx/vms/common/resource/analytics_plugin_resource.h&gt;\n#include &lt;nx/vms/common/system_context.h&gt;\n#include &lt;nx/vms/event/rule.h&gt;\n#include &lt;nx/vms/event/rule_manager.h&gt;\n#include &lt;nx_ec/abstract_ec_connection.h&gt;\n#include &lt;nx_ec/data/api_conversion_functions.h&gt;\n#include &lt;utils/common/delayed.h&gt;\n\n#include &quot;parsing_utils.h&quot;\n#include &quot;request_rerunner.h&quot;\n\nusing namespace nx;\nusing namespace nx::coro;\n\nnamespace {\n\nconstexpr auto kJsonRpcPath = &quot;/jsonrpc&quot;;\n\nvoid proxyRequestUsingServer(\n    nx::network::http::ClientPool::Request&amp; request,\n    const nx::Uuid&amp; proxyServerId)\n{\n    nx::network::http::HttpHeader header(Qn::SERVER_GUID_HEADER_NAME, proxyServerId.toSimpleStdString());\n    nx::network::http::insertOrReplaceHeader(&amp;request.headers, header);\n}\n\ntemplate&lt;typename T&gt;\nrest::Callback&lt;nx::network::rest::JsonResult&gt; extractJsonResult(\n    rest::Callback&lt;T&gt; callback)\n{\n    return\n        [callback = std::move(callback)](bool success, rest::Handle requestId,\n            const nx::network::rest::JsonResult&amp; result)\n        {\n            callback(success, requestId, result.deserialized&lt;T&gt;());\n        };\n}\n\nstd::string prepareUserAgent()\n{\n    static const QMap&lt;nx::vms::api::PeerType, std::string_view&gt; kPeerTypeToUserAgent = {\n        {nx::vms::api::PeerType::server, &quot;VMS Server&quot;},\n        {nx::vms::api::PeerType::desktopClient, &quot;Desktop Client&quot;},\n        {nx::vms::api::PeerType::videowallClient, &quot;VideoWall Client&quot;},\n        {nx::vms::api::PeerType::oldMobileClient, &quot;Old Mobile Client&quot;},\n        {nx::vms::api::PeerType::mobileClient, &quot;Mobile Client&quot;},\n        {nx::vms::api::PeerType::cloudServer, &quot;Cloud Server&quot;},\n        {nx::vms::api::PeerType::oldServer, &quot;Old VMS Server&quot;},\n        {nx::vms::api::PeerType::notDefined, &quot;Not Defined&quot;}};\n\n\n    return NX_FMT(&quot;%1 %2 %3&quot;,\n        nx::branding::vmsName(),\n        kPeerTypeToUserAgent.value(nx::vms::common::appContext()-&gt;localPeerType(), &quot;Unknown Peer&quot;),\n        nx::build_info::vmsVersion()).toStdString();\n}\n\nnx::log::Tag makeLogTag(\n    rest::ServerConnection* instance, const nx::Uuid&amp; serverId, const char *subTag)\n{\n    return nx::log::Tag(NX_FMT(&quot;%1 %2 [%3]&quot;,\n        nx::toString(instance), subTag, serverId.toSimpleString()));\n}\n\n} // namespace\n\n// --------------------------- public methods -------------------------------------------\n\nnamespace rest {\n\nusing HandleCallback = nx::MoveOnlyFunc&lt;void(rest::Handle)&gt;;\n\nstruct ServerConnection::Private\n{\n    auto executeRequestAwaitable(\n        nx::network::http::ClientPool::Request request,\n        std::optional&lt;nx::network::http::AsyncClient::Timeouts&gt; timeouts,\n        HandleCallback onSuspend,\n        const nx::log::Tag&amp; logTag)\n    {\n        struct RequestAwaiter\n        {\n            RequestAwaiter(\n                rest::ServerConnection* connection,\n                nx::network::http::ClientPool::Request request,\n                std::optional&lt;nx::network::http::AsyncClient::Timeouts&gt; timeouts,\n                HandleCallback onSuspend,\n                const nx::log::Tag&amp; logTag)\n                :\n                m_connection(connection),\n                m_request(std::move(request)),\n                m_timeouts(timeouts),\n                m_onSuspend(std::move(onSuspend)),\n                m_logTag(logTag)\n            {\n            }\n\n            bool await_ready() const { return false; }\n\n            void await_suspend(std::coroutine_handle&lt;&gt; h)\n            {\n                auto guard = nx::utils::ScopeGuard(\n                    [this, h]()\n                    {\n                        m_context.reset();\n                        h();\n                    });\n\n                auto onSuspend = std::move(m_onSuspend);\n\n                auto context = m_connection-&gt;prepareContext(\n                    m_request,\n                    [this, h = std::move(h), guard = std::move(guard)](\n                        nx::network::http::ClientPool::ContextPtr context) mutable\n                    {\n                        // Executes in asio thread.\n                        const auto osErrorCode = context-&gt;systemError;\n\n                        NX_VERBOSE(m_logTag,\n                            &quot;&lt;%1&gt; Got serialized reply. OS error: %2, HTTP status: %3&quot;,\n                            context-&gt;handle, osErrorCode, context-&gt;getStatusLine().statusCode);\n\n                        m_context = std::move(context);\n                        guard.disarm();\n                        h();\n                    },\n                    m_timeouts);\n\n                auto handle = m_connection-&gt;sendRequest(context);\n                // If we resumed from sendRequest() immediately, `this` is already destroyed!\n                if (handle != 0)\n                    onSuspend(handle);\n            }\n\n            nx::network::http::ClientPool::ContextPtr await_resume() const\n            {\n                if (!m_context)\n                    throw TaskCancelException();\n                return m_context;\n            }\n\n            QPointer&lt;rest::ServerConnection&gt; m_connection;\n            nx::network::http::ClientPool::Request m_request;\n            std::optional&lt;nx::network::http::AsyncClient::Timeouts&gt; m_timeouts;\n            HandleCallback m_onSuspend;\n            nx::log::Tag m_logTag;\n\n            nx::network::http::ClientPool::ContextPtr m_context;\n        };\n\n        return RequestAwaiter{\n            this-&gt;q, std::move(request), std::move(timeouts), std::move(onSuspend), logTag};\n    }\n\n    Handle executeRequest(\n        nx::vms::common::SessionTokenHelperPtr helper,\n        const nx::network::http::ClientPool::Request&amp; request,\n        std::unique_ptr&lt;BaseResultContext&gt; requestContext,\n        RequestCallback callback,\n        nx::utils::AsyncHandlerExecutor executor,\n        std::optional&lt;Timeouts&gt; timeouts = std::nullopt);\n\n    // Coroutine-based request execution, resumes the coroutine on ASIO thread!\n    // Reports rest::Handle from HttpClientPool via onSuspend callback.\n    nx::coro::Task&lt;\n        std::tuple&lt;\n            std::unique_ptr&lt;BaseResultContext&gt;,\n            rest::Handle&gt;&gt;\n    executeRequestAsync(\n        nx::network::http::ClientPool::Request request,\n        std::unique_ptr&lt;BaseResultContext&gt; requestContext,\n        std::optional&lt;Timeouts&gt; timeouts,\n        nx::vms::common::SessionTokenHelperPtr helper,\n        HandleCallback onSuspend);\n\n    ServerConnection* const q;\n    const nx::vms::common::SystemContext* systemContext = nullptr;\n    nx::network::http::ClientPool* const httpClientPool;\n    const nx::Uuid auditId;\n    const nx::Uuid serverId;\n    const nx::log::Tag logTag;\n\n    nx::vms::common::RequestRerunner rerunner;\n\n    /**\n     * Unique certificate func id to avoid reusing old functions when the Server Connection is\n     * re-created (thus correct certificate verifier will always be used).\n     */\n    const nx::Uuid certificateFuncId = nx::Uuid::createUuid();\n\n    // While most fields of this struct never change during struct&#x27;s lifetime, some data can be\n    // rarely updated. Therefore the following non-const fields should be protected by mutex.\n    nx::Mutex mutex;\n\n    struct DirectConnect\n    {\n        QPointer&lt;nx::vms::common::AbstractCertificateVerifier&gt; certificateVerifier;\n        nx::network::SocketAddress address;\n        nx::network::http::Credentials credentials;\n    };\n    nx::Uuid userId;\n    std::optional&lt;DirectConnect&gt; directConnect;\n\n    std::map&lt;Handle, Handle&gt; substitutions;\n};\n\nServerConnection::ServerConnection(\n    nx::vms::common::SystemContext* systemContext,\n    const nx::Uuid&amp; serverId)\n    :\n    d(new Private{\n        .q = this,\n        .systemContext = systemContext,\n        .httpClientPool = systemContext-&gt;httpClientPool(),\n        .auditId = systemContext-&gt;auditId(),\n        .serverId = serverId,\n        .logTag = makeLogTag(this, serverId, &quot;C&quot;)})\n{\n    // TODO: #sivanov Raw pointer is unsafe here as ServerConnection instance may be not deleted\n    // after it&#x27;s owning server (and context) are destroyed. Need to change\n    // QnMediaServerResource::restConnection() method to return weak pointer instead.\n\n    NX_VERBOSE(d-&gt;logTag, &quot;Create&quot;);\n}\n\nServerConnection::ServerConnection(\n    nx::network::http::ClientPool* httpClientPool,\n    const nx::Uuid&amp; serverId,\n    const nx::Uuid&amp; auditId,\n    AbstractCertificateVerifier* certificateVerifier,\n    nx::network::SocketAddress address,\n    nx::network::http::Credentials credentials)\n    :\n    QObject(),\n    d(new Private{\n        .q = this,\n        .systemContext = nullptr,\n        .httpClientPool = httpClientPool,\n        .auditId = auditId,\n        .serverId = serverId,\n        .logTag = makeLogTag(this, serverId, &quot;D&quot;),\n        .directConnect{Private::DirectConnect{\n            .certificateVerifier = certificateVerifier,\n            .address = std::move(address),\n            .credentials = std::move(credentials)}}})\n{\n    NX_VERBOSE(d-&gt;logTag, &quot;Create&quot;);\n\n    if (NX_ASSERT(certificateVerifier))\n    {\n        connect(certificateVerifier, &amp;QObject::destroyed, this,\n            [this]() {\n                NX_ASSERT(false, &quot;%1: Premature certificate verifier destruction&quot;, d-&gt;logTag);\n            });\n    }\n}\n\nServerConnection::~ServerConnection()\n{\n    NX_VERBOSE(d-&gt;logTag, &quot;Destroy&quot;);\n\n    if (d-&gt;directConnect)\n    {\n        NX_ASSERT(d-&gt;directConnect-&gt;certificateVerifier,\n            &quot;%1: Certificate verifier already destroyed&quot;, d-&gt;logTag);\n    }\n}\n\nvoid ServerConnection::updateAddress(nx::network::SocketAddress address)\n{\n    NX_MUTEX_LOCKER lock(&amp;d-&gt;mutex);\n\n    if (NX_ASSERT(d-&gt;directConnect))\n        d-&gt;directConnect-&gt;address = std::move(address);\n}\n\nvoid ServerConnection::updateCredentials(nx::network::http::Credentials credentials)\n{\n    NX_MUTEX_LOCKER lock(&amp;d-&gt;mutex);\n\n    // All requests must be made with session credentials, and should only be changed if the new\n    // credentials are session ones.\n    if (NX_ASSERT(d-&gt;directConnect) &amp;&amp; credentials.authToken.isBearerToken())\n        d-&gt;directConnect-&gt;credentials = std::move(credentials);\n}\n\nvoid ServerConnection::setUserId(const nx::Uuid&amp; id)\n{\n    NX_MUTEX_LOCKER lock(&amp;d-&gt;mutex);\n    d-&gt;userId = id;\n}\n\nHandle ServerConnection::cameraHistoryAsync(\n    const QnChunksRequestData&amp; request,\n    Callback&lt;nx::vms::api::CameraHistoryDataList&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/ec2/cameraHistory&quot;, request.toParams(), std::move(callback), executor);\n}\n\nHandle ServerConnection::backupPositionAsyncV1(const nx::Uuid&amp; serverId,\n    const nx::Uuid&amp; deviceId,\n    Callback&lt;nx::vms::api::BackupPositionExV1&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto requestStr =\n        NX_FMT(&quot;/rest/v1/servers/%1/backupPositions/%2&quot;).args(serverId, deviceId);\n    return executeGet(requestStr, nx::network::rest::Params(), std::move(callback), executor);\n}\n\nHandle ServerConnection::setBackupPositionAsyncV1(const nx::Uuid&amp; serverId,\n    const nx::Uuid&amp; deviceId,\n    const nx::vms::api::BackupPositionV1&amp; backupPosition,\n    Callback&lt;nx::vms::api::BackupPositionV1&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto requestStr =\n        NX_FMT(&quot;/rest/v1/servers/%1/backupPositions/%2&quot;).args(serverId, deviceId);\n    return executePut(\n        requestStr,\n        nx::network::rest::Params(),\n        &quot;application/json&quot;,\n        QJson::serialized(backupPosition),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::setBackupPositionsAsyncV1(const nx::Uuid&amp; serverId,\n    const nx::vms::api::BackupPositionV1&amp; backupPosition,\n    Callback&lt;nx::vms::api::BackupPositionV1&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto requestStr = NX_FMT(&quot;/rest/v1/servers/%1/backupPositions&quot;, serverId);\n    return executePut(\n        requestStr,\n        nx::network::rest::Params(),\n        &quot;application/json&quot;,\n        QJson::serialized(backupPosition),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getServerLocalTime(\n    const nx::Uuid&amp; serverId,\n    Callback&lt;nx::network::rest::JsonResult&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params{{&quot;local&quot;, QnLexical::serialized(true)}};\n    return executeGet(&quot;/api/gettime&quot;, params, std::move(callback), executor, serverId);\n}\n\nrest::Handle ServerConnection::cameraThumbnailAsync(const nx::api::CameraImageRequest&amp; request,\n    DataCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    if (debugFlags().testFlag(DebugFlag::disableThumbnailRequests))\n        return {};\n\n    QnThumbnailRequestData data{request, QnThumbnailRequestData::RequestType::cameraThumbnail};\n    data.format = Qn::SerializationFormat::ubjson;\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        prepareRequest(\n            nx::network::http::Method::get,\n            prepareUrl(&quot;/ec2/cameraThumbnail&quot;, data.toParams())),\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::sendStatisticsUsingServer(\n    const nx::Uuid&amp; proxyServerId,\n    const QnSendStatisticsRequestData&amp; statisticsData,\n    PostCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    static const QString kPath = &quot;/ec2/statistics/send&quot;;\n\n    using namespace nx::network::http;\n    ClientPool::Request request = prepareRequest(\n        Method::post,\n        prepareUrl(kPath, statisticsData.toParams()),\n        header::ContentType::kJson.toString(),\n        QJson::serialized(statisticsData.metricsList));\n    proxyRequestUsingServer(request, proxyServerId);\n\n    using Context = ResultContext&lt;EmptyResponseType&gt;;\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::getModuleInformation(\n    Callback&lt;ResultWithData&lt;nx::vms::api::ModuleInformation&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    return executeGet(&quot;/api/moduleInformation&quot;, params, std::move(callback), executor);\n}\n\nHandle ServerConnection::getModuleInformationAll(\n    Callback&lt;ResultWithData&lt;QList&lt;nx::vms::api::ModuleInformation&gt;&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    params.insert(&quot;allModules&quot;, lit(&quot;true&quot;));\n    return executeGet(&quot;/api/moduleInformation&quot;, params, std::move(callback), executor);\n}\n\nHandle ServerConnection::getServersInfo(\n    bool onlyFreshInfo,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::ServerInformationV1List&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/rest/v1/servers/*/info&quot;,\n        {{&quot;onlyFreshInfo&quot;, QnLexical::serialized(onlyFreshInfo)}},\n        std::move(callback), executor);\n}\n\nHandle ServerConnection::bindSystemToCloud(\n    const QString&amp; cloudSystemId,\n    const QString&amp; cloudAuthKey,\n    const QString&amp; cloudAccountName,\n    const QString&amp; organizationId,\n    const std::string&amp; ownerSessionToken,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::CloudSystemAuth data;\n    data.systemId = cloudSystemId;\n    data.authKey = cloudAuthKey;\n    data.owner = cloudAccountName;\n    data.organizationId = organizationId;\n\n    auto request = prepareRestRequest(\n        nx::network::http::Method::post,\n        prepareUrl(&quot;/rest/v3/system/cloud/bind&quot;, /*params*/ {}),\n        nx::reflect::json::serialize(data));\n    request.credentials = nx::network::http::BearerAuthToken(ownerSessionToken);\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::unbindSystemFromCloud(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    const QString&amp; password,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::LocalSiteAuth data;\n    data.password = password;\n\n    auto request = prepareRestRequest(\n        nx::network::http::Method::post,\n        prepareUrl(&quot;/rest/v3/system/cloud/unbind&quot;, /*params*/ {}),\n        nx::reflect::json::serialize(data));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::dumpDatabase(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;QByteArray&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(&quot;/rest/v2/system/database&quot;, /*params*/ {}),\n        nx::network::http::header::ContentType::kBinary.value);\n\n    auto internalCallback =\n        [callback = std::move(callback)](\n            bool success,\n            Handle requestId,\n            QByteArray body,\n            const network::http::HttpHeaders&amp;)\n        {\n            if (success)\n            {\n                callback(success, requestId, body);\n                return;\n            }\n            nx::network::rest::Result result;\n            QJson::deserialize(body, &amp;result);\n            callback(success, requestId, nx::utils::unexpected(result));\n        };\n\n    auto timeouts = nx::network::http::AsyncClient::Timeouts::defaults();\n    timeouts.responseReadTimeout = std::chrono::minutes(5);\n    timeouts.messageBodyReadTimeout = std::chrono::minutes(5);\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(internalCallback)),\n        executor,\n        timeouts);\n}\n\nHandle ServerConnection::restoreDatabase(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    const QByteArray&amp; data,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(&quot;/rest/v2/system/database&quot;, /*params*/ {}),\n        nx::network::http::header::ContentType::kBinary.value,\n        data);\n\n    auto timeouts = nx::network::http::AsyncClient::Timeouts::defaults();\n    timeouts.sendTimeout = std::chrono::minutes(5);\n    timeouts.responseReadTimeout = std::chrono::minutes(5);\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor,\n        timeouts);\n}\n\nHandle ServerConnection::putServerLogSettings(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    const nx::Uuid&amp; serverId,\n    const nx::vms::api::ServerLogSettings&amp; settings,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::put,\n        prepareUrl(\n            QString(&quot;/rest/v2/servers/%1/logSettings&quot;).arg(serverId.toSimpleString()),\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(settings));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::patchSystemSettings(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    const nx::vms::api::SaveableSystemSettings&amp; settings,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::patch,\n        prepareUrl(\n            &quot;/rest/v3/system/settings&quot;,\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(settings));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::addFileDownload(\n    const QString&amp; fileName,\n    qint64 size,\n    const QByteArray&amp; md5,\n    const QUrl&amp; url,\n    const QString&amp; peerPolicy,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        QString(&quot;/api/downloads/%1&quot;).arg(fileName),\n        nx::network::rest::Params{\n            {&quot;size&quot;, QString::number(size)},\n            {&quot;md5&quot;, QString::fromUtf8(md5)},\n            {&quot;url&quot;, url.toString()},\n            {&quot;peerPolicy&quot;, peerPolicy}},\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::addCamera(\n    const nx::Uuid&amp; targetServerId,\n    const nx::vms::api::DeviceModelForSearch&amp; device,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::DeviceModelForSearch&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(nx::network::http::Method::post,\n        prepareUrl(QString(&quot;/rest/v4/devices&quot;), {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(device));\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::DeviceModelForSearch&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::patchCamera(\n    const nx::Uuid&amp; targetServerId,\n    const nx::vms::api::DeviceModelGeneral&amp; device,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::DeviceModelForSearch&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(nx::network::http::Method::patch,\n        prepareUrl(NX_FMT(&quot;/rest/v4/devices/%1&quot;, device.id), {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(device));\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::DeviceModelForSearch&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::searchCamera(\n    const nx::Uuid&amp; targetServerId,\n    const nx::vms::api::DeviceSearch&amp; deviceSearchData,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::DeviceSearch&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(nx::network::http::Method::post,\n        prepareUrl(QString(&quot;/rest/v3/devices/*/searches/&quot;), {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(deviceSearchData));\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::DeviceSearch&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::searchCameraStatus(\n    const nx::Uuid&amp; targetServerId,\n    const QString&amp; searchId,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::DeviceSearch&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(nx::network::http::Method::get,\n        prepareUrl(NX_FMT(&quot;/rest/v3/devices/*/searches/%1&quot;, searchId), {}));\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::DeviceSearch&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::searchCameraStop(\n    const nx::Uuid&amp; targetServerId,\n    const QString&amp; searchId,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(nx::network::http::Method::delete_,\n        prepareUrl(NX_FMT(&quot;/rest/v3/devices/*/searches/%1&quot;, searchId), {}));\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::executeAnalyticsAction(\n    const nx::vms::api::AnalyticsAction&amp; action,\n    Callback&lt;nx::network::rest::JsonResult&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/executeAnalyticsAction&quot;,\n        QJson::serialized(action),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getRemoteArchiveSynchronizationStatus(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::RemoteArchiveSynchronizationStatusList&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/rest/v3/servers/this/remoteArchive/*/sync&quot;,\n        nx::network::rest::Params(),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getOverlappedIds(\n    const QString&amp; nvrGroupId,\n    Callback&lt;nx::vms::api::OverlappedIdResponse&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/api/overlappedIds&quot;,\n        nx::network::rest::Params{{&quot;groupId&quot;, nvrGroupId}},\n        Callback&lt;nx::network::rest::JsonResult&gt;(\n            [callback = std::move(callback)](\n                bool success, Handle requestId, const nx::network::rest::JsonResult&amp; result)\n            {\n                callback(\n                    success,\n                    requestId,\n                    result.deserialized&lt;nx::vms::api::OverlappedIdResponse&gt;());\n            }),\n        executor);\n}\n\nHandle ServerConnection::setOverlappedId(\n    const QString&amp; nvrGroupId,\n    int overlappedId,\n    Callback&lt;nx::vms::api::OverlappedIdResponse&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::SetOverlappedIdRequest request;\n    request.groupId = nvrGroupId;\n    request.overlappedId = overlappedId;\n\n    return executePost(\n        &quot;/api/overlappedIds&quot;,\n        nx::network::rest::Params(),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        QJson::serialized(request),\n        Callback&lt;nx::network::rest::JsonResult&gt;(\n            [callback = std::move(callback)](\n                bool success, Handle requestId, const nx::network::rest::JsonResult&amp; result)\n            {\n                callback(\n                    success,\n                    requestId,\n                    result.deserialized&lt;nx::vms::api::OverlappedIdResponse&gt;());\n            }),\n        executor);\n}\n\nHandle ServerConnection::executeEventAction(\n    const nx::vms::api::EventActionData&amp; action,\n    Callback&lt;nx::network::rest::Result&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return executePost(\n        &quot;/api/executeEventAction&quot;,\n        QJson::serialized(action),\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\nHandle ServerConnection::addFileUpload(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    qint64 size,\n    qint64 chunkSize,\n    const QByteArray&amp; md5,\n    qint64 ttl,\n    bool recreateIfExists,\n    AddUploadCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params\n    {\n        {&quot;size&quot;, QString::number(size)},\n        {&quot;chunkSize&quot;, QString::number(chunkSize)},\n        {&quot;md5&quot;, QString::fromUtf8(md5)},\n        {&quot;ttl&quot;, QString::number(ttl)},\n        {&quot;upload&quot;, &quot;true&quot;},\n        {&quot;recreate&quot;, recreateIfExists ? &quot;true&quot; : &quot;false&quot;},\n    };\n    const auto path = QString(&quot;/api/downloads/%1&quot;).arg(fileName);\n    return executePost(\n        path,\n        params,\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::removeFileDownload(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    bool deleteData,\n    PostCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeDelete(\n        lit(&quot;/api/downloads/%1&quot;).arg(fileName),\n        nx::network::rest::Params{{lit(&quot;deleteData&quot;), QnLexical::serialized(deleteData)}},\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::fileChunkChecksums(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        lit(&quot;/api/downloads/%1/checksums&quot;).arg(fileName),\n        nx::network::rest::Params(),\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::downloadFileChunk(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    int chunkIndex,\n    DataCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(\n            nx::format(&quot;/api/downloads/%1/chunks/%2&quot;, fileName, chunkIndex),\n            /*params*/{}));\n\n    proxyRequestUsingServer(request, serverId);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::downloadFileChunkFromInternet(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    const nx::Url&amp; url,\n    int chunkIndex,\n    int chunkSize,\n    qint64 fileSize,\n    DataCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(\n            nx::format(&quot;/api/downloads/%1/chunks/%2&quot;, fileName, chunkIndex),\n            {\n                {&quot;url&quot;, url.toString()},\n                {&quot;chunkSize&quot;, QString::number(chunkSize)},\n                {&quot;fileSize&quot;, QString::number(fileSize)},\n                {&quot;fromInternet&quot;, &quot;true&quot;}\n            }));\n\n    proxyRequestUsingServer(request, serverId);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::uploadFileChunk(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    int index,\n    const QByteArray&amp; data,\n    PostCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePut(\n        lit(&quot;/api/downloads/%1/chunks/%2&quot;).arg(fileName).arg(index),\n        nx::network::rest::Params(),\n        &quot;application/octet-stream&quot;,\n        data,\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::downloadsStatus(\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        lit(&quot;/api/downloads/status&quot;),\n        nx::network::rest::Params(),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::fileDownloadStatus(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; fileName,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        QString(&quot;/api/downloads/%1/status&quot;).arg(fileName),\n        nx::network::rest::Params(),\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::getTimeOfServersAsync(\n    Callback&lt;MultiServerTimeData&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/ec2/getTimeOfServers&quot;, nx::network::rest::Params(), std::move(callback), executor);\n}\n\nHandle ServerConnection::addVirtualCamera(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; name,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/add&quot;,\n        nx::network::rest::Params{{ &quot;name&quot;, name }},\n        std::move(callback),\n        executor,\n        serverId);\n}\n\nHandle ServerConnection::prepareVirtualCameraUploads(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const QnVirtualCameraPrepareData&amp; data,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/prepare&quot;,\n        nx::network::rest::Params{ { &quot;cameraId&quot;, camera-&gt;getId().toSimpleString() } },\n        nx::network::http::header::ContentType::kJson.toString(),\n        QJson::serialized(data),\n        std::move(callback),\n        executor,\n        /*timeouts*/ {},\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::virtualCameraStatus(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/api/virtualCamera/status&quot;,\n        nx::network::rest::Params{ { lit(&quot;cameraId&quot;), camera-&gt;getId().toSimpleString() } },\n        std::move(callback),\n        executor,\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::lockVirtualCamera(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const QnUserResourcePtr&amp; user,\n    qint64 ttl,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/lock&quot;,\n        nx::network::rest::Params{\n            { &quot;cameraId&quot;, camera-&gt;getId().toSimpleString() },\n            { &quot;userId&quot;, user-&gt;getId().toSimpleString() },\n            { &quot;ttl&quot;, QString::number(ttl) } },\n        std::move(callback),\n        executor,\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::extendVirtualCameraLock(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const QnUserResourcePtr&amp; user,\n    const nx::Uuid&amp; token,\n    qint64 ttl,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/extend&quot;,\n        nx::network::rest::Params{\n            { &quot;cameraId&quot;, camera-&gt;getId().toSimpleString() },\n            { &quot;token&quot;, token.toSimpleString() },\n            { &quot;userId&quot;, user-&gt;getId().toSimpleString() },\n            { &quot;ttl&quot;, QString::number(ttl) } },\n        std::move(callback),\n        executor,\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::releaseVirtualCameraLock(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const nx::Uuid&amp; token,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/release&quot;,\n        nx::network::rest::Params{\n            { &quot;cameraId&quot;, camera-&gt;getId().toSimpleString() },\n            { &quot;token&quot;, token.toSimpleString() } },\n        std::move(callback),\n        executor,\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::consumeVirtualCameraFile(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const nx::Uuid&amp; token,\n    const QString&amp; uploadId,\n    qint64 startTimeMs,\n    PostCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/api/virtualCamera/consume&quot;,\n        nx::network::rest::Params{\n            { &quot;cameraId&quot;, camera-&gt;getId().toSimpleString() },\n            { &quot;token&quot;, token.toSimpleString() },\n            { &quot;uploadId&quot;, uploadId },\n            { &quot;startTime&quot;, QString::number(startTimeMs) } },\n        std::move(callback),\n        executor,\n        camera-&gt;getParentId());\n}\n\nHandle ServerConnection::getStatistics(\n    const nx::Uuid&amp; serverId,\n    ServerConnection::GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/api/statistics&quot;, {}, std::move(callback), executor, serverId);\n}\n\nHandle ServerConnection::getAuditLogRecords(\n    std::chrono::milliseconds from,\n    std::chrono::milliseconds to,\n    UbJsonResultCallback callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return getUbJsonResult(\n        &quot;/api/auditLog&quot;,\n        {\n            {&quot;from&quot;, QString::number(from.count())},\n            {&quot;to&quot;, QString::number(to.count())},\n        },\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\nHandle ServerConnection::eventLog(\n    const nx::vms::api::rules::EventLogFilter&amp; filter,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::rules::EventLogRecordList&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;Timeouts&gt; timeouts)\n{\n    QJsonValue value;\n    QJson::serialize(filter, &amp;value);\n    NX_ASSERT(value.isObject());\n    return executeGet(\n        &quot;rest/v4/events/log&quot;,\n        nx::network::rest::Params::fromJson(value.toObject()),\n        std::move(callback),\n        executor,\n        /*proxyToServer*/{},\n        timeouts);\n}\n\nHandle ServerConnection::createSoftTrigger(\n    const nx::vms::api::rules::SoftTriggerData&amp; data,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;rest/v4/events/triggers&quot;,\n        nx::reflect::json::serialize(data),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getEventsToAcknowledge(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::rules::EventLogRecordList&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;rest/v4/events/acknowledges&quot;, {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::acknowledge(\n    const nx::vms::api::rules::AcknowledgeBookmark&amp; bookmark,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::BookmarkV3&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    if (!NX_ASSERT(!bookmark.actionServerId.isNull()))\n        return {};\n\n    return executePost(\n        &quot;rest/v4/events/acknowledges&quot;,\n        nx::reflect::json::serialize(bookmark),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getCameraCredentials(\n    const nx::Uuid&amp; deviceId,\n    Callback&lt;QAuthenticator&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(nx::format(&quot;/rest/v1/devices/%1&quot;, deviceId), {{&quot;_with&quot;, &quot;credentials&quot;}}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json));\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(\n            [callback = std::move(callback)](\n                bool success,\n                Handle requestId,\n                QByteArray result,\n                const nx::network::http::HttpHeaders&amp; /*headers*/)\n            {\n                nx::vms::api::DeviceModelV1 resultObject;\n\n                if (success)\n                {\n                    success = QJson::deserialize(result, &amp;resultObject)\n                        &amp;&amp; resultObject.credentials.has_value()\n                        &amp;&amp; resultObject.credentials-&gt;password != nx::Url::kMaskedPassword;\n                }\n\n                QAuthenticator credentials;\n                if (success)\n                {\n                    credentials.setUser(resultObject.credentials-&gt;user);\n                    credentials.setPassword(resultObject.credentials-&gt;password);\n                }\n\n                callback(\n                    success,\n                    requestId,\n                    credentials);\n            }),\n        executor);\n}\n\nHandle ServerConnection::changeCameraPassword(\n    const QnVirtualCameraResourcePtr&amp; camera,\n    const QAuthenticator&amp; auth,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    if (!camera || camera-&gt;getParentId().isNull())\n        return Handle();\n\n    nx::vms::api::DevicePasswordRequest request;\n    request.user = auth.user();\n    request.password = auth.password();\n\n    return executePost(\n        nx::format(&quot;/rest/v1/devices/%1/changePassword&quot;, camera-&gt;getId()),\n        nx::reflect::json::serialize(request),\n        std::move(callback),\n        executor);\n}\n\nint ServerConnection::checkCameraList(\n    const nx::Uuid&amp; serverId,\n    const QnVirtualCameraResourceList&amp; cameras,\n    Callback&lt;QnCameraListReply&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    QnCameraListReply camList;\n    for (const auto&amp; c: cameras)\n        camList.physicalIdList &lt;&lt; c-&gt;getPhysicalId();\n\n    return executePost(\n        &quot;/api/checkDiscovery&quot;,\n        QJson::serialized(camList),\n        extractJsonResult&lt;QnCameraListReply&gt;(std::move(callback)),\n        executor,\n        serverId);\n\n}\n\nHandle ServerConnection::lookupObjectTracks(\n    const nx::analytics::db::Filter&amp; request,\n    bool isLocal,\n    Callback&lt;nx::analytics::db::LookupResult&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    nx::network::rest::Params queryParams;\n    nx::analytics::db::serializeToParams(request, &amp;queryParams);\n    queryParams.insert(&quot;isLocal&quot;, isLocal? &quot;true&quot; : &quot;false&quot;);\n\n    return executeGet(\n        &quot;/ec2/analyticsLookupObjectTracks&quot;,\n        queryParams,\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\n//--------------------------------------------------------------------------------------------------\n\nHandle ServerConnection::getEngineAnalyticsSettings(\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    Callback&lt;nx::vms::api::analytics::EngineSettingsResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/ec2/analyticsEngineSettings&quot;,\n        nx::network::rest::Params{\n            {&quot;analyticsEngineId&quot;, engine-&gt;getId().toSimpleString()}\n        },\n        extractJsonResult&lt;nx::vms::api::analytics::EngineSettingsResponse&gt;(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::setEngineAnalyticsSettings(\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    const QJsonObject&amp; settings,\n    Callback&lt;nx::vms::api::analytics::EngineSettingsResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::analytics::EngineSettingsRequest request;\n    request.settingsValues = settings;\n    request.analyticsEngineId = engine-&gt;getId();\n    using namespace nx::vms::api::analytics;\n    return executePost&lt;nx::network::rest::JsonResult&gt;(\n        &quot;/ec2/analyticsEngineSettings&quot;,\n        QJson::serialized(request),\n        extractJsonResult&lt;EngineSettingsResponse&gt;(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::engineAnalyticsActiveSettingsChanged(\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    const QString&amp; activeElement,\n    const QJsonObject&amp; settingsModel,\n    const QJsonObject&amp; settingsValues,\n    const QJsonObject&amp; paramValues,\n    Callback&lt;nx::vms::api::analytics::EngineActiveSettingChangedResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::analytics::EngineActiveSettingChangedRequest request;\n    request.analyticsEngineId = engine-&gt;getId();\n    request.activeSettingName = activeElement;\n    request.settingsModel = settingsModel;\n    request.settingsValues = settingsValues;\n    request.paramValues = paramValues;\n\n    using namespace nx::vms::api::analytics;\n    return executePost&lt;nx::network::rest::JsonResult&gt;(\n        &quot;/ec2/notifyAnalyticsEngineActiveSettingChanged&quot;,\n        QJson::serialized(request),\n        extractJsonResult&lt;EngineActiveSettingChangedResponse&gt;(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::postMetadata(\n    const std::string&amp; integrationUserSessionToken,\n    const QString&amp; path,\n    const QByteArray&amp; messageBody,\n    PostCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRestRequest(\n        nx::network::http::Method::post,\n        prepareUrl(path, /*params*/ {}),\n        messageBody);\n\n    request.credentials = nx::network::http::BearerAuthToken(integrationUserSessionToken);\n\n    using Context = ResultContext&lt;EmptyResponseType&gt;;\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::getDeviceAnalyticsSettings(\n    const QnVirtualCameraResourcePtr&amp; device,\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    Callback&lt;nx::vms::api::analytics::DeviceAgentSettingsResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    using namespace nx::vms::api::analytics;\n    return executeGet(\n        &quot;/ec2/deviceAnalyticsSettings&quot;,\n        nx::network::rest::Params{\n            {&quot;deviceId&quot;, device-&gt;getId().toSimpleString()},\n            {&quot;analyticsEngineId&quot;, engine-&gt;getId().toSimpleString()},\n        },\n        extractJsonResult&lt;DeviceAgentSettingsResponse&gt;(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::setDeviceAnalyticsSettings(\n    const QnVirtualCameraResourcePtr&amp; device,\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    const QJsonObject&amp; settingsValues,\n    const QJsonObject&amp; settingsModel,\n    Callback&lt;nx::vms::api::analytics::DeviceAgentSettingsResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::analytics::DeviceAgentSettingsRequest request;\n    request.settingsValues = settingsValues;\n    request.settingsModel = settingsModel;\n    request.analyticsEngineId = engine-&gt;getId();\n    request.deviceId = device-&gt;getId().toSimpleString();\n\n    return executePost&lt;nx::network::rest::JsonResult&gt;(\n        &quot;/ec2/deviceAnalyticsSettings&quot;,\n        QJson::serialized(request),\n        extractJsonResult&lt;nx::vms::api::analytics::DeviceAgentSettingsResponse&gt;(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::deviceAnalyticsActiveSettingsChanged(\n    const QnVirtualCameraResourcePtr&amp; device,\n    const nx::vms::common::AnalyticsEngineResourcePtr&amp; engine,\n    const QString&amp; activeElement,\n    const QJsonObject&amp; settingsModel,\n    const QJsonObject&amp; settingsValues,\n    const QJsonObject&amp; paramValues,\n    Callback&lt;nx::vms::api::analytics::DeviceAgentActiveSettingChangedResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::analytics::DeviceAgentActiveSettingChangedRequest request;\n    request.analyticsEngineId = engine-&gt;getId();\n    request.deviceId = device-&gt;getId().toSimpleString();\n    request.activeSettingName = activeElement;\n    request.settingsModel = settingsModel;\n    request.settingsValues = settingsValues;\n    request.paramValues = paramValues;\n\n    return executePost&lt;nx::network::rest::JsonResult&gt;(\n        &quot;/ec2/notifyDeviceAnalyticsActiveSettingChanged&quot;,\n        QJson::serialized(request),\n        extractJsonResult&lt;nx::vms::api::analytics::DeviceAgentActiveSettingChangedResponse&gt;(\n            std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::startArchiveRebuild(const nx::Uuid&amp; serverId,\n    const QString pool,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StorageScanInfoFull&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto endpoint =\n        NX_FMT(&quot;/rest/v2/servers/%1/rebuildArchive/%2&quot;, serverId, pool);\n    return executePost(endpoint, nx::network::rest::Params(), std::move(callback), executor);\n}\n\nHandle ServerConnection::getArchiveRebuildProgress(const nx::Uuid&amp; serverId,\n    const QString pool,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StorageScanInfoFull&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto endpoint =\n        NX_FMT(&quot;/rest/v2/servers/%1/rebuildArchive/%2&quot;, serverId, pool);\n    return executeGet(endpoint,\n        nx::network::rest::Params{{&quot;_keepDefault&quot;, QnLexical::serialized(true)}},\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::stopArchiveRebuild(const nx::Uuid&amp; serverId,\n    const QString pool,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    const auto endpoint =\n        NX_FMT(&quot;/rest/v2/servers/%1/rebuildArchive/%2&quot;, serverId, pool);\n    return executeDelete(endpoint, nx::network::rest::Params(), std::move(callback), executor);\n}\n\nHandle ServerConnection::postJsonResult(\n    const QString&amp; action,\n    const nx::network::rest::Params&amp; params,\n    const QByteArray&amp; body,\n    JsonResultCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;Timeouts&gt; timeouts,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    const auto contentType = Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json);\n    return executePost&lt;nx::network::rest::JsonResult&gt;(\n        action,\n        params,\n        contentType,\n        body,\n        std::move(callback),\n        executor,\n        timeouts,\n        proxyToServer);\n}\n\nusing JsonRpcRequestIdType = decltype(nx::vms::api::JsonRpcRequest::id);\nusing JsonRpcResponseIdType = decltype(nx::vms::api::JsonRpcResponse::id);\n\nstd::tuple&lt;\n    std::unordered_set&lt;JsonRpcRequestIdType&gt;,\n    std::vector&lt;nx::vms::api::JsonRpcResponse&gt;&gt;\nextractJsonRpcExpired(rest::ErrorOrData&lt;JsonRpcResultType&gt;&amp; result)\n{\n    if (!result)\n        return {};\n\n    auto responseArray = std::get_if&lt;\n        std::vector&lt;nx::vms::api::JsonRpcResponse&gt;&gt;(&amp;*result);\n\n    if (!responseArray)\n        return {};\n\n    std::unordered_set&lt;JsonRpcRequestIdType&gt; ids;\n\n    for (auto&amp; response: *responseArray)\n    {\n        if (isSessionExpiredError(response))\n        {\n            if (const auto intId = std::get_if&lt;int&gt;(&amp;response.id))\n                ids.insert(*intId);\n            else if (const auto strId = std::get_if&lt;QString&gt;(&amp;response.id))\n                ids.insert(*strId);\n        }\n    }\n\n    return {std::move(ids), std::move(*responseArray)};\n}\n\nbool mergeJsonRpcResults(\n    std::vector&lt;nx::vms::api::JsonRpcResponse&gt;&amp; originalResponse,\n    rest::ErrorOrData&lt;JsonRpcResultType&gt; result)\n{\n    if (!result)\n    {\n        // Server could not handle the request.\n        auto error = result.error();\n\n        // For all requests with expired session fill in error from single rest::Result.\n        for (auto&amp; response: originalResponse)\n        {\n            if (isSessionExpiredError(response))\n            {\n                response = nx::json_rpc::Response::makeError(response.id,\n                    nx::json_rpc::Error::applicationError,\n                    error.errorString.toStdString(),\n                    error);\n            }\n        }\n        return true;\n    }\n\n    auto responseArray = std::get_if&lt;std::vector&lt;nx::vms::api::JsonRpcResponse&gt;&gt;(&amp;*result);\n    if (!responseArray)\n    {\n        // This should not happen because original requests were valid. But handle it anyway.\n\n        if (auto error = std::get_if&lt;nx::vms::api::JsonRpcResponse&gt;(&amp;*result))\n        {\n            // For all requests with expired session fill in error from single json-rpc response.\n            for (auto&amp; response: originalResponse)\n            {\n                if (isSessionExpiredError(response))\n                {\n                    response.result = {};\n                    response.error = std::move(error-&gt;error);\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // Build a map for faster response replacement.\n    std::unordered_map&lt;JsonRpcResponseIdType, nx::vms::api::JsonRpcResponse*&gt; idToResponse;\n\n    for (auto&amp; response: *responseArray)\n    {\n        if (!std::holds_alternative&lt;std::nullptr_t&gt;(response.id))\n            idToResponse.insert({response.id, &amp;response});\n    }\n\n    std::vector&lt;nx::vms::api::JsonRpcResponse&gt; updatedResponses;\n\n    for (auto&amp; response: originalResponse)\n    {\n        // Replace original response with the new one if it has the same id.\n        if (auto it = idToResponse.find(response.id); it != idToResponse.end())\n            response = std::move(*it-&gt;second);\n    }\n\n    return true;\n}\n\nclass JsonRpcResultContext: public BaseResultContext\n{\npublic:\n    JsonRpcResultContext(std::vector&lt;nx::vms::api::JsonRpcRequest&gt; requests):\n        result(nx::utils::unexpected(nx::network::rest::Result::notImplemented())),\n        requestData(std::move(requests))\n    {\n    }\n\n    void parse(\n        Qn::SerializationFormat format,\n        const QByteArray&amp; messageBody,\n        SystemError::ErrorCode systemError,\n        const nx::network::http::StatusLine&amp; statusLine,\n        const nx::network::http::HttpHeaders&amp;) override\n    {\n        auto parsedResult = parseMessageBody&lt;decltype(result)&gt;(\n            format, messageBody, statusLine, &amp;success);\n\n        if (!success\n            || systemError != SystemError::noError\n            || statusLine.statusCode != nx::network::http::StatusCode::ok)\n        {\n            success = false;\n            result = std::move(parsedResult);\n            return;\n        }\n\n        if (!expiredIds.empty() &amp;&amp; mergeJsonRpcResults(originalResponse, std::move(parsedResult)))\n        {\n            // Even if the new request failed, it is still\n            // considered as json-rpc success.\n            success = true;\n            std::vector&lt;nx::vms::api::JsonRpcResponse&gt; responses;\n            responses.reserve(originalResponse.size());\n            for (const auto&amp; r: originalResponse)\n                responses.emplace_back(r.copy());\n            result = std::move(responses);\n            expiredIds.clear(); //&lt; isSessionExpired() should return false so request can proceed.\n            return;\n        }\n\n        std::tie(expiredIds, originalResponse) = extractJsonRpcExpired(parsedResult);\n        result = std::move(parsedResult);\n    }\n\n    virtual nx::network::http::ClientPool::Request fixup(\n        const nx::network::http::ClientPool::Request&amp; request) override\n    {\n        auto fixedRequest = request;\n\n        // Update message body to resend only failed json-rpc requests.\n        std::vector&lt;nx::vms::api::JsonRpcRequest&gt; newRequests;\n        for (const auto&amp; request: requestData)\n        {\n            if (expiredIds.contains(request.id))\n                newRequests.emplace_back(request.copy());\n        }\n        fixedRequest.messageBody = nx::reflect::json::serialize(newRequests);\n\n        return fixedRequest;\n    }\n\n    bool isSessionExpired() const override\n    {\n        return !expiredIds.empty();\n    }\n\n    virtual bool isSuccess() const override\n    {\n        return success;\n    }\n\n    rest::ErrorOrData&lt;JsonRpcResultType&gt;&amp;&amp; getResult() &amp;&amp;\n    {\n        return std::move(result);\n    }\n\nprivate:\n    rest::ErrorOrData&lt;JsonRpcResultType&gt; result;\n\n    std::unordered_set&lt;JsonRpcRequestIdType&gt; expiredIds;\n    std::vector&lt;nx::vms::api::JsonRpcResponse&gt; originalResponse;\n    std::vector&lt;nx::vms::api::JsonRpcRequest&gt; requestData;\n\n    bool success = false;\n};\n\nHandle ServerConnection::jsonRpcBatchCall(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    std::vector&lt;nx::vms::api::JsonRpcRequest&gt; requests,\n    JsonRpcBatchResultCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;Timeouts&gt; timeouts)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(kJsonRpcPath, /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(requests));\n\n    auto internalCallback =\n        [callback = std::move(callback)](\n            bool success,\n            Handle requestId,\n            rest::ErrorOrData&lt;JsonRpcResultType&gt; result)\n        {\n            if (success)\n            {\n                if (result)\n                {\n                    if (auto responseArray = std::get_if&lt;\n                        std::vector&lt;nx::vms::api::JsonRpcResponse&gt;&gt;(&amp;*result))\n                    {\n                        callback(success, requestId, std::move(*responseArray));\n                        return;\n                    }\n                }\n                NX_ASSERT(false, &quot;jsonrpc success but response data is invalid&quot;);\n                return;\n            }\n\n            if (!result)\n            {\n                std::vector&lt;nx::json_rpc::Response&gt; response;\n                response.emplace_back(nx::json_rpc::Response::makeError(std::nullptr_t{},\n                    nx::json_rpc::Error::applicationError,\n                    result.error().errorString.toStdString(),\n                    result.error()));\n                callback(success, requestId, std::move(response));\n                return;\n            }\n\n            if (auto singleResponse = std::get_if&lt;nx::vms::api::JsonRpcResponse&gt;(&amp;*result))\n            {\n                std::vector&lt;nx::json_rpc::Response&gt; response;\n                response.emplace_back(std::move(*singleResponse));\n                callback(success, requestId, std::move(response));\n            }\n        };\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;JsonRpcResultContext&gt;(std::move(requests)),\n        [callback = std::move(internalCallback)](\n            std::unique_ptr&lt;BaseResultContext&gt; resultContext, rest::Handle handle)\n        {\n            auto context = static_cast&lt;JsonRpcResultContext*&gt;(resultContext.get());\n            callback(context-&gt;isSuccess(), handle, std::move(*context).getResult());\n        },\n        executor,\n        timeouts);\n}\n\nHandle ServerConnection::getUbJsonResult(\n    const QString&amp; path,\n    nx::network::rest::Params params,\n    UbJsonResultCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    if (!params.contains(&quot;format&quot;))\n        params.insert(&quot;format&quot;, &quot;ubjson&quot;);\n    return executeGet(path, params, std::move(callback), executor, proxyToServer);\n}\n\nHandle ServerConnection::getJsonResult(\n    const QString&amp; path,\n    nx::network::rest::Params params,\n    JsonResultCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    if (!params.contains(&quot;format&quot;))\n        params.insert(&quot;format&quot;, &quot;json&quot;);\n    return executeGet(path, params, std::move(callback), executor, proxyToServer);\n}\n\nHandle ServerConnection::getRawResult(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    DataCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        prepareRequest(nx::network::http::Method::get, prepareUrl(path, params)),\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(callback)),\n        executor);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::sendRequest(\n    nx::vms::common::SessionTokenHelperPtr helper,\n    nx::network::http::Method method,\n    const QString&amp; action,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; body,\n    Callback&lt;ResultType&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    const nx::network::http::HttpHeaders&amp; customHeaders)\n{\n    auto request = prepareRequest(\n        method,\n        prepareUrl(action, params),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        body);\n\n    for (const auto&amp; header: customHeaders)\n        nx::network::http::insertOrReplaceHeader(&amp;request.headers, header);\n\n    using Context = ResultContext&lt;ResultType&gt;;\n\n    return d-&gt;executeRequest(\n        helper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\ntemplate\nHandle NX_VMS_COMMON_API ServerConnection::sendRequest(\n    nx::vms::common::SessionTokenHelperPtr helper,\n    nx::network::http::Method method,\n    const QString&amp; action,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; body,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    const nx::network::http::HttpHeaders&amp; customHeaders);\n\ntemplate\nHandle NX_VMS_COMMON_API ServerConnection::sendRequest(\n    nx::vms::common::SessionTokenHelperPtr helper,\n    nx::network::http::Method method,\n    const QString&amp; action,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; body,\n    Callback&lt;ErrorOrData&lt;QByteArray&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    const nx::network::http::HttpHeaders&amp; customHeaders);\n\nHandle ServerConnection::getPluginInformation(\n    const nx::Uuid&amp; serverId,\n    GetCallback callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/api/pluginInfo&quot;, {}, std::move(callback), executor, serverId);\n}\n\nHandle ServerConnection::testEmailSettings(\n    const nx::vms::api::EmailSettings&amp; settings,\n    Callback&lt;ResultWithData&lt;QnTestEmailSettingsReply&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return executePost(\n        &quot;/api/testEmailSettings&quot;,\n        QJson::serialized(settings),\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\nHandle ServerConnection::testEmailSettings(\n    Callback&lt;ResultWithData&lt;QnTestEmailSettingsReply&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return executePost(\n        &quot;/api/testEmailSettings&quot;,\n        /*messageBody*/ QByteArray(),\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\nHandle ServerConnection::getStorageStatus(\n    const nx::Uuid&amp; serverId,\n    const QString&amp; path,\n    Callback&lt;ResultWithData&lt;StorageStatusReply&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    params.insert(&quot;path&quot;, path);\n    return executeGet(&quot;/api/storageStatus&quot;, params, std::move(callback), executor, serverId);\n}\n\nHandle ServerConnection::checkStoragePath(\n    const QString&amp; path,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StorageSpaceDataWithDbInfoV3&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    // Method prepareUrl calls params.toUrlQuery() which uses QUrlQuery::setQueryItems()\n    // which has requirement: `The keys and values are expected to be in percent-encoded form.`\n    // So it is required to encode path manually because it can be a url with many\n    // symbols like &#x27;@&#x27;, &#x27;:&#x27;, &#x27;%&#x27; and others or even be a path with utf-8 symbols.\n    params.insert(&quot;path&quot;, nx::reflect::urlencoded::serialize(path));\n    return executeGet(\n        &quot;/rest/v4/servers/this/storages/*/check&quot;,\n        params,\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::setStorageEncryptionPassword(\n    const QString&amp; password,\n    bool makeCurrent,\n    const QByteArray&amp; salt,\n    PostCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::vms::api::StorageEncryptionData data;\n    data.password = password;\n    data.makeCurrent = makeCurrent;\n    data.salt = salt;\n\n    return executePost(\n        &quot;/rest/v1/system/storageEncryption&quot;,\n        QJson::serialized(data),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::getSystemIdFromServer(\n    const nx::Uuid&amp; serverId,\n    Callback&lt;QString&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto internalCallback =\n        [callback=std::move(callback)](\n            bool success, Handle requestId, QByteArray result,\n            const nx::network::http::HttpHeaders&amp; /*headers*/)\n        {\n            callback(success, requestId, QString::fromUtf8(result));\n        };\n\n    auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(&quot;/api/getSystemId&quot;, /*params*/ {}));\n\n    proxyRequestUsingServer(request, serverId);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(internalCallback)),\n        executor);\n}\n\nHandle ServerConnection::doCameraDiagnosticsStep(\n    const nx::Uuid&amp; serverId,\n    const nx::Uuid&amp; cameraId,\n    CameraDiagnostics::Step::Value previousStep,\n    Callback&lt;ResultWithData&lt;QnCameraDiagnosticsReply&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    params.insert(&quot;cameraId&quot;, cameraId);\n    params.insert(&quot;type&quot;, CameraDiagnostics::Step::toString(previousStep));\n\n    return executeGet(&quot;/api/doCameraDiagnosticsStep&quot;, params, std::move(callback), executor, serverId);\n}\n\nHandle ServerConnection::ldapAuthenticateAsync(\n    const nx::vms::api::Credentials&amp; credentials,\n    bool localOnly,\n    LdapAuthenticateCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    if (localOnly)\n        params.insert(&quot;_local&quot;, true);\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(&quot;/rest/v3/ldap/authenticate&quot;, params),\n        nx::network::http::header::ContentType::kJson.toString(),\n        nx::reflect::json::serialize(credentials));\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback([callback = std::move(callback)](\n            bool success,\n            Handle requestId,\n            QByteArray body,\n            const nx::network::http::HttpHeaders&amp; httpHeaders)\n        {\n            using AuthResult = nx::network::rest::AuthResult;\n            AuthResult authResult = AuthResult::Auth_LDAPConnectError;\n            const auto authResultString = nx::network::http::getHeaderValue(\n                httpHeaders, Qn::AUTH_RESULT_HEADER_NAME);\n            if (!authResultString.empty())\n                nx::reflect::fromString&lt;AuthResult&gt;(authResultString, &amp;authResult);\n            if (!success)\n            {\n                nx::network::rest::Result result;\n                QJson::deserialize(body, &amp;result);\n                callback(requestId, nx::utils::unexpected(std::move(result)), authResult);\n                return;\n            }\n\n            nx::vms::api::UserModelV3 user;\n            QJson::deserialize(body, &amp;user);\n            callback(requestId, std::move(user), authResult);\n        }),\n        executor);\n}\n\nHandle ServerConnection::testLdapSettingsAsync(\n    const nx::vms::api::LdapSettings&amp; settings,\n    Callback&lt;ErrorOrData&lt;std::vector&lt;QString&gt;&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/rest/v3/ldap/test&quot;,\n        nx::reflect::json::serialize(settings),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::setLdapSettingsAsync(\n    const nx::vms::api::LdapSettings&amp; settings,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LdapSettings&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::put,\n        prepareUrl(\n            &quot;/rest/v3/ldap/settings&quot;,\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(settings));\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::LdapSettings&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::modifyLdapSettingsAsync(\n    const nx::vms::api::LdapSettings&amp; settings,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LdapSettings&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::patch,\n        prepareUrl(\n            &quot;/rest/v3/ldap/settings&quot;,\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(settings));\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::LdapSettings&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::loginInfoAsync(\n    const QString&amp; login,\n    bool localOnly,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LoginUser&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    nx::network::rest::Params params;\n    if (localOnly)\n        params.insert(&quot;_local&quot;, true);\n    return executeGet(&quot;/rest/v3/login/users/&quot; + login, params, std::move(callback), executor);\n}\n\nHandle ServerConnection::getLdapSettingsAsync(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LdapSettings&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/rest/v3/ldap/settings&quot;, {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::getLdapStatusAsync(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LdapStatus&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/rest/v3/ldap/sync&quot;, {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::syncLdapAsync(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(\n            &quot;/rest/v3/ldap/sync&quot;,\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::resetLdapAsync(\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::delete_,\n        prepareUrl(\n            &quot;/rest/v3/ldap/settings&quot;,\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::saveUserAsync(\n    bool newUser,\n    const nx::vms::api::UserModelV3&amp; userData,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::UserModelV3&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        newUser ? nx::network::http::Method::put : nx::network::http::Method::patch,\n        prepareUrl(\n            QString(&quot;/rest/v4/users/%1&quot;).arg(userData.id.toSimpleString()),\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(userData));\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::UserModelV3&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\n Handle ServerConnection::patchUserSettings(\n    nx::Uuid id,\n    const nx::vms::api::UserSettings&amp; settings,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::UserModelV3&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    QJsonValue serializedSettings;\n    QJson::serialize(settings, &amp;serializedSettings);\n\n    auto request = prepareRequest(\n        nx::network::http::Method::patch,\n        prepareUrl(\n            QString(&quot;/rest/v4/users/%1&quot;).arg(id.toSimpleString()),\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(QJsonObject{{&quot;settings&quot;, serializedSettings}}));\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::UserModelV3&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        /*tokenHelper*/ nullptr,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::removeUserAsync(\n    const nx::Uuid&amp; userId,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::delete_,\n        prepareUrl(\n            QString(&quot;/rest/v4/users/%1&quot;).arg(userId.toSimpleString()),\n            /*params*/ {}));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::saveGroupAsync(\n    bool newGroup,\n    const nx::vms::api::UserGroupModel&amp; groupData,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::UserGroupModel&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        newGroup ? nx::network::http::Method::put : nx::network::http::Method::patch,\n        prepareUrl(\n            QString(&quot;/rest/v4/userGroups/%1&quot;).arg(groupData.id.toSimpleString()),\n            /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(groupData));\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::UserGroupModel&gt;&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::removeGroupAsync(\n    const nx::Uuid&amp; groupId,\n    nx::vms::common::SessionTokenHelperPtr tokenHelper,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::delete_,\n        prepareUrl(\n            QString(&quot;/rest/v4/userGroups/%1&quot;).arg(groupId.toSimpleString()),\n            /*params*/ {}));\n\n    using Context = ResultContext&lt;ErrorOrEmpty&gt;;\n\n    return d-&gt;executeRequest(\n        tokenHelper,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::getStoredFiles(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StoredFileDataList&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/rest/v4/storedFiles&quot;, {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::getStoredFile(const QString&amp; filePath,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StoredFileData&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        nx::format(&quot;/rest/v4/storedFiles/%1&quot;, filePath), {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::putStoredFile(const nx::vms::api::StoredFileData&amp; storedFileData,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::StoredFileData&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePut(nx::format(&quot;/rest/v4/storedFiles/%1&quot;, storedFileData.path),\n        {},\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        nx::reflect::json::serialize(storedFileData),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::deleteStoredFile(const QString&amp; filePath,\n    Callback&lt;ErrorOrEmpty&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeDelete(\n        nx::format(&quot;/rest/v4/storedFiles/%1&quot;, filePath), {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::createTicket(\n    const nx::Uuid&amp; targetServerId,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LoginSession&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(&quot;/rest/v3/login/tickets&quot;, {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        {});\n\n    using Context = ResultContext&lt;ErrorOrData&lt;nx::vms::api::LoginSession&gt;&gt;;\n\n    proxyRequestUsingServer(request, targetServerId);\n\n    return d-&gt;executeRequest(\n        /*tokenHelper*/ nullptr,\n        request,\n        std::make_unique&lt;Context&gt;(),\n        Context::wrapCallback(std::move(callback)),\n        executor);\n}\n\nHandle ServerConnection::getCurrentSession(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LoginSession&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/rest/v1/login/sessions/current&quot;,\n        {},\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::loginAsync(\n    const nx::vms::api::LoginSessionRequest&amp; data,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LoginSession&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/rest/v1/login/sessions&quot;,\n        nx::reflect::json::serialize(data),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::loginAsync(\n    const nx::vms::api::TemporaryLoginSessionRequest&amp; data,\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LoginSession&gt;&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePost(\n        &quot;/rest/v3/login/temporaryToken&quot;,\n        nx::reflect::json::serialize(data),\n        std::move(callback),\n        executor);\n}\n\nHandle ServerConnection::replaceDevice(\n    const nx::Uuid&amp; deviceToBeReplacedId,\n    const QString&amp; replacementDevicePhysicalId,\n    bool returnReportOnly,\n    Callback&lt;nx::vms::api::DeviceReplacementResponse&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    if (!NX_ASSERT(\n        !deviceToBeReplacedId.isNull() &amp;&amp; !replacementDevicePhysicalId.isEmpty(),\n        &quot;Invalid parameters&quot;))\n    {\n        return Handle();\n    }\n\n    nx::vms::api::DeviceReplacementRequest requestData;\n    requestData.id = deviceToBeReplacedId;\n    requestData.replaceWithDeviceId = replacementDevicePhysicalId;\n    requestData.dryRun = returnReportOnly;\n\n    auto internal_callback =\n        [callback = std::move(callback)]\n        (bool success, Handle handle, QByteArray messageBody,\n            const nx::network::http::HttpHeaders&amp; /*headers*/)\n        {\n            nx::vms::api::DeviceReplacementResponse response;\n            if (success)\n                success = nx::reflect::json::deserialize(messageBody.data(), &amp;response).success;\n            callback(success, handle, response);\n        };\n\n    auto request = prepareRequest(\n        nx::network::http::Method::post,\n        prepareUrl(nx::format(&quot;/rest/v2/devices/%1/replace&quot;, deviceToBeReplacedId), /*params*/ {}),\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        QJson::serialized(requestData));\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(internal_callback)),\n        executor);\n}\n\nHandle ServerConnection::undoReplaceDevice(\n    const nx::Uuid&amp; deviceId,\n    PostCallback&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeDelete(\n        nx::format(&quot;/rest/v2/devices/%1/replace&quot;, deviceId),\n        nx::network::rest::Params(),\n        std::move(callback),\n        executor,\n        {});\n}\n\nHandle ServerConnection::recordedTimePeriods(\n    const QnChunksRequestData&amp; requestData,\n    Callback&lt;MultiServerPeriodDataList&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    QnChunksRequestData fixedFormatRequest(requestData);\n    fixedFormatRequest.format = Qn::SerializationFormat::compressedPeriods;\n    auto internalCallback =\n        [callback=std::move(callback)](\n            bool success, Handle requestId, QByteArray result,\n            const nx::network::http::HttpHeaders&amp; /*headers*/)\n        {\n            if (success)\n            {\n                bool goodData = false;\n                auto chunks = QnCompressedTime::deserialized&lt;MultiServerPeriodDataList&gt;(\n                    result, {}, &amp;goodData);\n                callback(goodData, requestId, chunks);\n                return;\n            }\n            callback(false, requestId, {});\n        };\n\n    auto request = prepareRequest(\n        nx::network::http::Method::get,\n        prepareUrl(&quot;/ec2/recordedTimePeriods&quot;, fixedFormatRequest.toParams()));\n    request.priority = nx::network::http::ClientPool::Request::Priority::high;\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;RawResultContext&gt;(),\n        RawResultContext::wrapCallback(std::move(internalCallback)),\n        executor);\n}\n\nHandle ServerConnection::getExtendedPluginInformation(\n    Callback&lt;nx::vms::api::ExtendedPluginInfoByServer&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(\n        &quot;/ec2/pluginInfo&quot;,\n        {},\n        Callback&lt;nx::network::rest::JsonResult&gt;(\n            [funcName = __func__, callback = std::move(callback), this](\n                bool success, Handle requestId, const nx::network::rest::JsonResult&amp; result)\n            {\n                nx::vms::api::ExtendedPluginInfoByServer pluginInfo;\n                if (!QJson::deserialize(result.reply, &amp;pluginInfo))\n                {\n                    NX_DEBUG(d-&gt;logTag,\n                        &quot;%1: Unable to deserialize the response from the Server %2, %3&quot;,\n                        funcName, d-&gt;serverId, QJson::serialize(result.reply));\n                }\n\n                callback(\n                    success,\n                    requestId,\n                    std::move(pluginInfo));\n            }),\n        executor);\n}\n\nHandle ServerConnection::debug(\n    const QString&amp; action, const QString&amp; value, PostCallback callback, nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/api/debug&quot;, {{action, value}}, std::move(callback), executor);\n}\n\nHandle ServerConnection::getLookupLists(\n    Callback&lt;ErrorOrData&lt;nx::vms::api::LookupListDataList&gt;&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executeGet(&quot;/rest/v3/lookupLists&quot;, {}, std::move(callback), executor);\n}\n\nHandle ServerConnection::saveLookupList(\n    const nx::vms::api::LookupListData&amp; lookupList,\n    Callback&lt;ErrorOrEmpty&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    return executePut(\n        nx::format(&quot;/rest/v4/lookupLists/%1&quot;).arg(lookupList.id),\n        {},\n        Qn::serializationFormatToHttpContentType(Qn::SerializationFormat::json),\n        QByteArray::fromStdString(nx::reflect::json::serialize(lookupList)),\n        std::move(callback),\n        executor);\n}\n\n// --------------------------- private implementation -------------------------------------\n\nQUrl ServerConnection::prepareUrl(const QString&amp; path, const nx::network::rest::Params&amp; params) const\n{\n    QUrl result;\n    result.setPath(path);\n    result.setQuery(params.toUrlQuery());\n    return result;\n}\n\ntemplate&lt;typename ResultType&gt;\nHandle ServerConnection::executeGet(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer,\n    std::optional&lt;Timeouts&gt; timeouts)\n{\n    auto request = this-&gt;prepareRequest(nx::network::http::Method::get, prepareUrl(path, params));\n    if (proxyToServer)\n        proxyRequestUsingServer(request, *proxyToServer);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;ResultContext&lt;ResultType&gt;&gt;(),\n        ResultContext&lt;ResultType&gt;::wrapCallback(std::move(callback)),\n        executor,\n        timeouts);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executePost(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return executePost(\n        path,\n        QJson::serialized(params.toJson()),\n        std::move(callback),\n        executor,\n        proxyToServer);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executePost(\n    const QString&amp; path,\n    const nx::String&amp; messageBody,\n    Callback&lt;ResultType&gt;&amp;&amp; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    return executePost(\n        path,\n        /*params*/ {},\n        nx::network::http::header::ContentType::kJson.toString(),\n        messageBody,\n        std::move(callback),\n        executor,\n        /*timeouts*/ {},\n        proxyToServer);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executePost(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; contentType,\n    const nx::String&amp; messageBody,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;Timeouts&gt; timeouts,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    auto request = this-&gt;prepareRequest(\n        nx::network::http::Method::post, prepareUrl(path, params), contentType, messageBody);\n\n    if (proxyToServer)\n        proxyRequestUsingServer(request, *proxyToServer);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;ResultContext&lt;ResultType&gt;&gt;(),\n        ResultContext&lt;ResultType&gt;::wrapCallback(std::move(callback)),\n        executor,\n        timeouts);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executePut(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; contentType,\n    const nx::String&amp; messageBody,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::put, prepareUrl(path, params), contentType, messageBody);\n    if (proxyToServer)\n        proxyRequestUsingServer(request, *proxyToServer);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;ResultContext&lt;ResultType&gt;&gt;(),\n        ResultContext&lt;ResultType&gt;::wrapCallback(std::move(callback)),\n        executor);\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executePatch(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    const nx::String&amp; contentType,\n    const nx::String&amp; messageBody,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor)\n{\n    auto request = prepareRequest(\n        nx::network::http::Method::patch, prepareUrl(path, params), contentType, messageBody);\n    auto handle = request.isValid()\n        ? d-&gt;executeRequest(request, std::move(callback), executor)\n        : Handle();\n\n    NX_VERBOSE(d-&gt;logTag, &quot;&lt;%1&gt; %2&quot;, handle, request.url);\n    return handle;\n}\n\ntemplate &lt;typename ResultType&gt;\nHandle ServerConnection::executeDelete(\n    const QString&amp; path,\n    const nx::network::rest::Params&amp; params,\n    Callback&lt;ResultType&gt; callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;nx::Uuid&gt; proxyToServer)\n{\n    auto request = prepareRequest(nx::network::http::Method::delete_, prepareUrl(path, params));\n    if (proxyToServer)\n        proxyRequestUsingServer(request, *proxyToServer);\n\n    return d-&gt;executeRequest(\n        /*helper*/ nullptr,\n        request,\n        std::make_unique&lt;ResultContext&lt;ResultType&gt;&gt;(),\n        ResultContext&lt;ResultType&gt;::wrapCallback(std::move(callback)),\n        executor);\n}\n\n// Coroutine style request.\nnx::coro::Task&lt;\n    std::tuple&lt;\n        std::unique_ptr&lt;BaseResultContext&gt;,\n        rest::Handle&gt;&gt;\nServerConnection::Private::executeRequestAsync(\n    nx::network::http::ClientPool::Request request,\n    std::unique_ptr&lt;BaseResultContext&gt; requestContext,\n    std::optional&lt;Timeouts&gt; timeouts,\n    nx::vms::common::SessionTokenHelperPtr helper,\n    HandleCallback onSuspend)\n{\n    co_await guard(q);\n\n    auto context = co_await executeRequestAwaitable(\n        request,\n        timeouts,\n        std::move(onSuspend),\n        logTag);\n\n    rest::Handle originalHandle = context-&gt;handle;\n\n    // Asio thread.\n\n    requestContext-&gt;parse(\n        Qn::serializationFormatFromHttpContentType(context-&gt;response.contentType),\n        context-&gt;response.messageBody,\n        context-&gt;systemError,\n        context-&gt;getStatusLine(),\n        context-&gt;response.headers);\n\n    if (requestContext-&gt;isSessionExpired() &amp;&amp; helper)\n    {\n        co_await nx::utils::AsyncHandlerExecutor(qApp);\n\n        std::optional&lt;nx::network::http::AuthToken&gt; updatedToken;\n        {\n            NX_MUTEX_LOCKER lock(&amp;mutex);\n            // Check if the token was updated while the request was in flight.\n            if (request.credentials-&gt;authToken != directConnect-&gt;credentials.authToken)\n                updatedToken = directConnect-&gt;credentials.authToken;\n        }\n\n        if (!updatedToken)\n        {\n            updatedToken = co_await rerunner.getNewToken(helper);\n            if (updatedToken)\n            {\n                NX_MUTEX_LOCKER lock(&amp;mutex);\n                directConnect-&gt;credentials.authToken = *updatedToken;\n            }\n        }\n        if (updatedToken)\n        {\n            // GUI or ASIO thread.\n            auto fixedRequest = requestContext-&gt;fixup(request);\n            fixedRequest.credentials-&gt;authToken = *updatedToken;\n\n            // Remove substitution even if the task is cancelled.\n            auto removeSubstitution = nx::utils::makeScopeGuard(\n                nx::utils::AsyncHandlerExecutor(qApp).bind(\n                    [this, originalHandle]\n                    {\n                        NX_MUTEX_LOCKER lock(&amp;mutex);\n                        substitutions.erase(originalHandle);\n                    }));\n\n            context = co_await executeRequestAwaitable(\n                fixedRequest, timeouts,\n                [originalHandle, this](rest::Handle handle)\n                {\n                    NX_MUTEX_LOCKER lock(&amp;mutex);\n                    substitutions[originalHandle] = handle;\n                },\n                logTag);\n\n            removeSubstitution.fire(); //&lt; Remove substitution early.\n\n            // Asio thread.\n            requestContext-&gt;parse(\n                Qn::serializationFormatFromHttpContentType(context-&gt;response.contentType),\n                context-&gt;response.messageBody,\n                context-&gt;systemError,\n                context-&gt;getStatusLine(),\n                context-&gt;response.headers);\n        }\n    }\n\n    co_return {std::move(requestContext), originalHandle};\n}\n\n// Callback style request.\nHandle ServerConnection::Private::executeRequest(\n    nx::vms::common::SessionTokenHelperPtr helper,\n    const nx::network::http::ClientPool::Request&amp; request,\n    std::unique_ptr&lt;BaseResultContext&gt; requestContext,\n    RequestCallback callback,\n    nx::utils::AsyncHandlerExecutor executor,\n    std::optional&lt;Timeouts&gt; timeouts)\n{\n    if (!request.isValid())\n    {\n        NX_VERBOSE(logTag, &quot;&lt;%1&gt; %2&quot;, 0, request.url);\n        return {};\n    }\n\n    rest::Handle handle = 0;\n\n    [this](\n        const nx::network::http::ClientPool::Request&amp; request,\n        std::unique_ptr&lt;BaseResultContext&gt; requestContext,\n        RequestCallback callback,\n        std::optional&lt;Timeouts&gt; timeouts,\n        nx::vms::common::SessionTokenHelperPtr helper,\n        HandleCallback onHandle) -&gt; FireAndForget\n    {\n        co_await guard(q);\n\n        nx::log::Tag tag(QString(&quot;%1 [%2]&quot;).arg(\n            nx::toString(typeid(rest::ServerConnection)), serverId.toSimpleString()));\n\n        QElapsedTimer timer;\n        timer.start();\n\n        auto [context, handle] = co_await executeRequestAsync(\n            request,\n            std::move(requestContext),\n            timeouts,\n            helper,\n            std::move(onHandle));\n\n        const auto elapsedMs = timer.elapsed();\n        if (context-&gt;isSuccess())\n            NX_VERBOSE(tag, &quot;&lt;%1&gt;: Reply success for %2ms&quot;, handle, elapsedMs);\n        else\n            NX_VERBOSE(tag, &quot;&lt;%1&gt;: Reply failed for %2ms&quot;, handle, elapsedMs);\n\n        if (callback)\n            callback(std::move(context), handle);\n\n    }(\n        request,\n        std::move(requestContext),\n        executor.bind(std::move(callback)),\n        timeouts,\n        helper,\n        [&amp;handle](rest::Handle h) { handle = h; });\n\n    NX_VERBOSE(logTag, &quot;&lt;%1&gt; %2&quot;, 0, request.url);\n    return handle;\n}\n\nvoid ServerConnection::cancelRequest(const Handle&amp; requestId)\n{\n    std::optional&lt;Handle&gt; actualId;\n    {\n        // Check if we had re-send this request with updated credentials.\n        NX_MUTEX_LOCKER lock(&amp;d-&gt;mutex);\n\n        if (auto it = d-&gt;substitutions.find(requestId);\n            it != d-&gt;substitutions.end())\n        {\n            actualId = it-&gt;second;\n        }\n    }\n\n    if (actualId)\n    {\n        NX_VERBOSE(d-&gt;logTag,\n            &quot;&lt;%1&gt; Cancelling request (which is actually &lt;%2&gt;)...&quot;, requestId, *actualId);\n        d-&gt;httpClientPool-&gt;terminate(*actualId);\n    }\n    else\n    {\n        NX_VERBOSE(d-&gt;logTag, &quot;&lt;%1&gt; Cancelling request...&quot;, requestId);\n        d-&gt;httpClientPool-&gt;terminate(requestId);\n    }\n}\n\nnx::network::http::Credentials getRequestCredentials(\n    std::shared_ptr&lt;ec2::AbstractECConnection&gt; connection,\n    const QnMediaServerResourcePtr&amp; targetServer)\n{\n    using namespace nx::vms::api;\n    const auto localPeerType = nx::vms::common::appContext()-&gt;localPeerType();\n    if (PeerData::isClient(localPeerType))\n        return connection-&gt;credentials();\n\n    NX_ASSERT(PeerData::isServer(localPeerType), &quot;Unexpected peer type&quot;);\n    return targetServer-&gt;credentials();\n}\n\nbool setupAuth(\n    const nx::vms::common::SystemContext* systemContext,\n    const nx::Uuid&amp; auditId,\n    const nx::Uuid&amp; serverId,\n    nx::network::http::ClientPool::Request&amp; request,\n    const QUrl&amp; url,\n    const nx::Uuid&amp; userId)\n{\n    if (!NX_ASSERT(systemContext))\n        return false;\n\n    auto resPool = systemContext-&gt;resourcePool();\n    const auto server = resPool-&gt;getResourceById&lt;QnMediaServerResource&gt;(serverId);\n    if (!server)\n        return false;\n\n    request.url = server-&gt;getApiUrl();\n    request.url.setPath(url.path());\n    request.url.setQuery(url.query());\n\n    // This header is used by the server to identify the client login session for audit.\n    request.headers.emplace(\n        Qn::EC2_RUNTIME_GUID_HEADER_NAME, auditId.toSimpleStdString());\n\n    const QnRoute route = QnRouter::routeTo(server);\n\n    if (route.reverseConnect)\n    {\n        if (nx::vms::api::PeerData::isClient(nx::vms::common::appContext()-&gt;localPeerType()))\n        {\n            const auto connection = systemContext-&gt;messageBusConnection();\n            if (!NX_ASSERT(connection))\n                return false;\n\n            const auto address = connection-&gt;address();\n            request.url.setHost(address.address);\n            if ((int16_t) address.port != -1)\n                request.url.setPort(address.port);\n        }\n        else //&lt; Server-side option.\n        {\n            request.url.setHost(&quot;127.0.0.1&quot;);\n            auto currentServer = systemContext-&gt;resourcePool()\n                -&gt;getResourceById&lt;QnMediaServerResource&gt;(systemContext-&gt;peerId());\n            if (NX_ASSERT(currentServer))\n            {\n                const auto url = nx::Url(currentServer-&gt;getUrl());\n                if (url.port() &gt; 0)\n                    request.url.setPort(url.port());\n            }\n        }\n    }\n    else if (!route.addr.isNull())\n    {\n        request.url.setHost(route.addr.address);\n        request.url.setPort(route.addr.port);\n    }\n\n    // TODO: #sivanov Only client-side connection is actually used.\n    const auto connection = systemContext-&gt;messageBusConnection();\n    if (!connection)\n        return false;\n\n    request.headers.emplace(Qn::SERVER_GUID_HEADER_NAME, server-&gt;getId().toSimpleStdString());\n    request.credentials = getRequestCredentials(connection, server);\n\n    QString userName;\n    if (!userId.isNull())\n    {\n        if (auto user = systemContext-&gt;resourcePool()-&gt;getResourceById&lt;QnUserResource&gt;(userId))\n            userName = user-&gt;getName();\n    }\n    else\n    {\n        userName = QString::fromStdString(request.credentials-&gt;username);\n    }\n\n    if (!userName.isEmpty())\n        request.headers.emplace(Qn::CUSTOM_USERNAME_HEADER_NAME, userName.toLower().toUtf8());\n    if (!route.gatewayId.isNull())\n        request.gatewayId = route.gatewayId;\n\n    return true;\n}\n\nvoid setupAuthDirect(\n    nx::network::http::ClientPool::Request&amp; request,\n    const nx::Uuid&amp; auditId,\n    nx::network::SocketAddress address,\n    nx::network::http::Credentials credentials,\n    QString path,\n    QString query)\n{\n    request.url = nx::network::url::Builder()\n        .setScheme(nx::network::http::kSecureUrlSchemeName)\n        .setEndpoint(address)\n        .setPath(path)\n        .setQuery(query)\n        .toUrl();\n\n    request.credentials = std::move(credentials);\n\n    // This header is used by the server to identify the client login session for audit.\n    request.headers.emplace(Qn::EC2_RUNTIME_GUID_HEADER_NAME, auditId.toSimpleStdString());\n\n    // This header was used to migrate digest in the old server&#x27;s db. Most probably is not needed.\n    request.headers.emplace(Qn::CUSTOM_USERNAME_HEADER_NAME,\n        QString::fromStdString(request.credentials-&gt;username).toLower().toUtf8());\n}\n\nnx::network::http::ClientPool::Request ServerConnection::prepareRequest(\n    nx::network::http::Method method,\n    const QUrl&amp; url,\n    const nx::String&amp; contentType,\n    const nx::String&amp; messageBody)\n{\n    nx::network::http::ClientPool::Request request;\n\n    bool isDirect = false, authIsSet = false;\n\n    {\n        NX_MUTEX_LOCKER lock(&amp;d-&gt;mutex);\n\n        if (d-&gt;directConnect)\n        {\n            setupAuthDirect(\n                request,\n                d-&gt;auditId,\n                d-&gt;directConnect-&gt;address,\n                d-&gt;directConnect-&gt;credentials,\n                url.path(),\n                url.query());\n            isDirect = authIsSet = true;\n        }\n    }\n\n    if (!isDirect)\n        authIsSet = setupAuth(d-&gt;systemContext, d-&gt;auditId, d-&gt;serverId, request, url, d-&gt;userId);\n\n    if (!authIsSet)\n        return nx::network::http::ClientPool::Request();\n\n    request.method = method;\n    request.contentType = contentType;\n    request.messageBody = messageBody;\n    QString locale = nx::i18n::TranslationManager::getCurrentThreadLocale();\n    if (locale.isEmpty())\n        locale = nx::vms::common::appContext()-&gt;locale();\n    request.headers.emplace(nx::network::http::header::kAcceptLanguage, locale.toStdString());\n    return request;\n}\n\nnx::network::http::ClientPool::Request ServerConnection::prepareRestRequest(\n    nx::network::http::Method method,\n    const QUrl&amp; url,\n    const nx::String&amp; messageBody)\n{\n    static const nx::String contentType = nx::network::http::header::ContentType::kJson.toString();\n\n    auto request = prepareRequest(method, url, contentType, messageBody);\n    request.headers.emplace(nx::network::http::header::kAccept, contentType);\n    request.headers.emplace(nx::network::http::header::kUserAgent, prepareUserAgent());\n\n    return request;\n}\n\nnx::network::http::ClientPool::ContextPtr ServerConnection::prepareContext(\n    const nx::network::http::ClientPool::Request&amp; request,\n    nx::MoveOnlyFunc&lt;void (ContextPtr)&gt; callback,\n    std::optional&lt;Timeouts&gt; timeouts)\n{\n    auto certificateVerifier = d-&gt;directConnect\n        ? d-&gt;directConnect-&gt;certificateVerifier.data()\n        : d-&gt;systemContext-&gt;certificateVerifier();\n    if (!NX_ASSERT(certificateVerifier))\n        return {};\n\n    auto context = d-&gt;httpClientPool-&gt;createContext(\n        d-&gt;certificateFuncId,\n        certificateVerifier-&gt;makeAdapterFunc(\n            request.gatewayId.value_or(d-&gt;serverId), request.url));\n    context-&gt;request = request;\n    context-&gt;completionFunc = std::move(callback);\n    if (timeouts)\n        context-&gt;timeouts = *timeouts;\n    context-&gt;setTargetThread(nullptr); //&lt; Callback runs in target thread via AsyncHandlerExecutor.\n\n    return context;\n}\n\nHandle ServerConnection::sendRequest(const ContextPtr&amp; context)\n{\n    if (!context)\n        return 0;\n\n    auto metrics = nx::vms::common::appContext()-&gt;metrics();\n    metrics-&gt;totalServerRequests()++;\n    NX_VERBOSE(\n        d-&gt;logTag, &quot;%1: %2&quot;, metrics-&gt;totalServerRequests.name(), metrics-&gt;totalServerRequests());\n    Handle requestId = d-&gt;httpClientPool-&gt;sendRequest(context);\n\n    // Request can be complete just inside `sendRequest`, so requestId is already invalid.\n    if (!requestId || context-&gt;isFinished())\n        return 0;\n\n    return requestId;\n}\n\nstatic ServerConnection::DebugFlags localDebugFlags = ServerConnection::DebugFlag::none;\n\nServerConnection::DebugFlags ServerConnection::debugFlags()\n{\n    return localDebugFlags;\n}\n\nvoid ServerConnection::setDebugFlag(DebugFlag flag, bool on)\n{\n    localDebugFlags.setFlag(flag, on);\n}\n\n} // namespace rest\n"}, "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional": {"id": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "filePath": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "content": "// &lt;optional&gt; -*- C++ -*-\n\n// Copyright (C) 2013-2023 Free Software Foundation, Inc.\n// Copyright The GNU Toolchain Authors.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file include/optional\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_OPTIONAL\n#define _GLIBCXX_OPTIONAL 1\n\n#pragma GCC system_header\n\n#if __cplusplus &gt;= 201703L\n\n#include &lt;type_traits&gt;\n#include &lt;exception&gt;\n#include &lt;new&gt;\n#include &lt;initializer_list&gt;\n#include &lt;bits/enable_special_members.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/stl_construct.h&gt; // _Construct\n#include &lt;bits/utility.h&gt; // in_place_t\n#if __cplusplus &gt; 201703L\n# include &lt;compare&gt;\n# include &lt;bits/invoke.h&gt; // std::__invoke\n#endif\n#if __cplusplus &gt; 202002L\n# include &lt;concepts&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n#if __cplusplus &gt; 202002L &amp;&amp; __cpp_lib_concepts\n# define __cpp_lib_optional 202110L\n#elif __cplusplus &gt;= 202002L\n# define __cpp_lib_optional 202106L\n#else\n# define __cpp_lib_optional 201606L\n#endif\n\n  template&lt;typename _Tp&gt;\n    class optional;\n\n  /// Tag type to disengage optional objects.\n  struct nullopt_t\n  {\n    // Do not user-declare default constructor at all for\n    // optional_value = {} syntax to work.\n    // nullopt_t() = delete;\n\n    // Used for constructing nullopt.\n    enum class _Construct { _Token };\n\n    // Must be constexpr for nullopt_t to be literal.\n    explicit constexpr nullopt_t(_Construct) noexcept { }\n  };\n\n  /// Tag to disengage optional objects.\n  inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };\n\n  template&lt;typename _Fn&gt; struct _Optional_func { _Fn&amp; _M_f; };\n\n  /**\n   *  @brief Exception class thrown when a disengaged optional object is\n   *  dereferenced.\n   *  @ingroup exceptions\n   */\n  class bad_optional_access : public exception\n  {\n  public:\n    bad_optional_access() = default;\n    virtual ~bad_optional_access() = default;\n\n    const char* what() const noexcept override\n    { return &quot;bad optional access&quot;; }\n  };\n\n  // XXX Does not belong here.\n  [[__noreturn__]] inline void\n  __throw_bad_optional_access()\n  { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }\n\n  // This class template manages construction/destruction of\n  // the contained value for a std::optional.\n  template &lt;typename _Tp&gt;\n    struct _Optional_payload_base\n    {\n      using _Stored_type = remove_const_t&lt;_Tp&gt;;\n\n      _Optional_payload_base() = default;\n      ~_Optional_payload_base() = default;\n\n      template&lt;typename... _Args&gt;\n\tconstexpr\n\t_Optional_payload_base(in_place_t __tag, _Args&amp;&amp;... __args)\n\t: _M_payload(__tag, std::forward&lt;_Args&gt;(__args)...),\n\t  _M_engaged(true)\n\t{ }\n\n      template&lt;typename _Up, typename... _Args&gt;\n\tconstexpr\n\t_Optional_payload_base(std::initializer_list&lt;_Up&gt; __il,\n\t\t\t       _Args&amp;&amp;... __args)\n\t: _M_payload(__il, std::forward&lt;_Args&gt;(__args)...),\n\t  _M_engaged(true)\n\t{ }\n\n      // Constructor used by _Optional_base copy constructor when the\n      // contained value is not trivially copy constructible.\n      constexpr\n      _Optional_payload_base(bool /* __engaged */,\n\t\t\t     const _Optional_payload_base&amp; __other)\n      {\n\tif (__other._M_engaged)\n\t  this-&gt;_M_construct(__other._M_get());\n      }\n\n      // Constructor used by _Optional_base move constructor when the\n      // contained value is not trivially move constructible.\n      constexpr\n      _Optional_payload_base(bool /* __engaged */,\n\t\t\t     _Optional_payload_base&amp;&amp; __other)\n      {\n\tif (__other._M_engaged)\n\t  this-&gt;_M_construct(std::move(__other._M_get()));\n      }\n\n      // Copy constructor is only used to when the contained value is\n      // trivially copy constructible.\n      _Optional_payload_base(const _Optional_payload_base&amp;) = default;\n\n      // Move constructor is only used to when the contained value is\n      // trivially copy constructible.\n      _Optional_payload_base(_Optional_payload_base&amp;&amp;) = default;\n\n      _Optional_payload_base&amp;\n      operator=(const _Optional_payload_base&amp;) = default;\n\n      _Optional_payload_base&amp;\n      operator=(_Optional_payload_base&amp;&amp;) = default;\n\n      // used to perform non-trivial copy assignment.\n      constexpr void\n      _M_copy_assign(const _Optional_payload_base&amp; __other)\n      {\n\tif (this-&gt;_M_engaged &amp;&amp; __other._M_engaged)\n\t  this-&gt;_M_get() = __other._M_get();\n\telse\n\t  {\n\t    if (__other._M_engaged)\n\t      this-&gt;_M_construct(__other._M_get());\n\t    else\n\t      this-&gt;_M_reset();\n\t  }\n      }\n\n      // used to perform non-trivial move assignment.\n      constexpr void\n      _M_move_assign(_Optional_payload_base&amp;&amp; __other)\n      noexcept(__and_v&lt;is_nothrow_move_constructible&lt;_Tp&gt;,\n\t\t       is_nothrow_move_assignable&lt;_Tp&gt;&gt;)\n      {\n\tif (this-&gt;_M_engaged &amp;&amp; __other._M_engaged)\n\t  this-&gt;_M_get() = std::move(__other._M_get());\n\telse\n\t  {\n\t    if (__other._M_engaged)\n\t      this-&gt;_M_construct(std::move(__other._M_get()));\n\t    else\n\t      this-&gt;_M_reset();\n\t  }\n      }\n\n      struct _Empty_byte { };\n\n      template&lt;typename _Up, bool = is_trivially_destructible_v&lt;_Up&gt;&gt;\n\tunion _Storage\n\t{\n\t  constexpr _Storage() noexcept : _M_empty() { }\n\n\t  template&lt;typename... _Args&gt;\n\t    constexpr\n\t    _Storage(in_place_t, _Args&amp;&amp;... __args)\n\t    : _M_value(std::forward&lt;_Args&gt;(__args)...)\n\t    { }\n\n\t  template&lt;typename _Vp, typename... _Args&gt;\n\t    constexpr\n\t    _Storage(std::initializer_list&lt;_Vp&gt; __il, _Args&amp;&amp;... __args)\n\t    : _M_value(__il, std::forward&lt;_Args&gt;(__args)...)\n\t    { }\n\n#if __cplusplus &gt;= 202002L\n\t  template&lt;typename _Fn, typename _Arg&gt;\n\t    constexpr\n\t    _Storage(_Optional_func&lt;_Fn&gt; __f, _Arg&amp;&amp; __arg)\n\t    : _M_value(std::__invoke(std::forward&lt;_Fn&gt;(__f._M_f),\n\t\t\t\t     std::forward&lt;_Arg&gt;(__arg)))\n\t    { }\n#endif\n\n\t  _Empty_byte _M_empty;\n\t  _Up _M_value;\n\t};\n\n      template&lt;typename _Up&gt;\n\tunion _Storage&lt;_Up, false&gt;\n\t{\n\t  constexpr _Storage() noexcept : _M_empty() { }\n\n\t  template&lt;typename... _Args&gt;\n\t    constexpr\n\t    _Storage(in_place_t, _Args&amp;&amp;... __args)\n\t    : _M_value(std::forward&lt;_Args&gt;(__args)...)\n\t    { }\n\n\t  template&lt;typename _Vp, typename... _Args&gt;\n\t    constexpr\n\t    _Storage(std::initializer_list&lt;_Vp&gt; __il, _Args&amp;&amp;... __args)\n\t    : _M_value(__il, std::forward&lt;_Args&gt;(__args)...)\n\t    { }\n\n#if __cplusplus &gt;= 202002L\n\t  template&lt;typename _Fn, typename _Arg&gt;\n\t    constexpr\n\t    _Storage(_Optional_func&lt;_Fn&gt; __f, _Arg&amp;&amp; __arg)\n\t    : _M_value(std::__invoke(std::forward&lt;_Fn&gt;(__f._M_f),\n\t\t\t\t     std::forward&lt;_Arg&gt;(__arg)))\n\t    { }\n#endif\n\n\t  // User-provided destructor is needed when _Up has non-trivial dtor.\n\t  _GLIBCXX20_CONSTEXPR ~_Storage() { }\n\n\t  _Empty_byte _M_empty;\n\t  _Up _M_value;\n\t};\n\n      _Storage&lt;_Stored_type&gt; _M_payload;\n\n      bool _M_engaged = false;\n\n      template&lt;typename... _Args&gt;\n\tconstexpr void\n\t_M_construct(_Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Stored_type, _Args...&gt;)\n\t{\n\t  std::_Construct(std::__addressof(this-&gt;_M_payload._M_value),\n\t\t\t  std::forward&lt;_Args&gt;(__args)...);\n\t  this-&gt;_M_engaged = true;\n\t}\n\n      constexpr void\n      _M_destroy() noexcept\n      {\n\t_M_engaged = false;\n\t_M_payload._M_value.~_Stored_type();\n      }\n\n#if __cplusplus &gt;= 202002L\n      template&lt;typename _Fn, typename _Up&gt;\n\tconstexpr void\n\t_M_apply(_Optional_func&lt;_Fn&gt; __f, _Up&amp;&amp; __x)\n\t{\n\t  std::construct_at(std::__addressof(this-&gt;_M_payload),\n\t\t\t    __f, std::forward&lt;_Up&gt;(__x));\n\t  _M_engaged = true;\n\t}\n#endif\n\n      // The _M_get() operations have _M_engaged as a precondition.\n      // They exist to access the contained value with the appropriate\n      // const-qualification, because _M_payload has had the const removed.\n\n      constexpr _Tp&amp;\n      _M_get() noexcept\n      { return this-&gt;_M_payload._M_value; }\n\n      constexpr const _Tp&amp;\n      _M_get() const noexcept\n      { return this-&gt;_M_payload._M_value; }\n\n      // _M_reset is a &#x27;safe&#x27; operation with no precondition.\n      constexpr void\n      _M_reset() noexcept\n      {\n\tif (this-&gt;_M_engaged)\n\t  _M_destroy();\n\telse // This seems redundant but improves codegen, see PR 112480.\n\t  this-&gt;_M_engaged = false;\n      }\n    };\n\n  // Class template that manages the payload for optionals.\n  template &lt;typename _Tp,\n\t    bool /*_HasTrivialDestructor*/ =\n\t      is_trivially_destructible_v&lt;_Tp&gt;,\n\t    bool /*_HasTrivialCopy */ =\n\t      is_trivially_copy_assignable_v&lt;_Tp&gt;\n\t      &amp;&amp; is_trivially_copy_constructible_v&lt;_Tp&gt;,\n\t    bool /*_HasTrivialMove */ =\n\t      is_trivially_move_assignable_v&lt;_Tp&gt;\n\t      &amp;&amp; is_trivially_move_constructible_v&lt;_Tp&gt;&gt;\n    struct _Optional_payload;\n\n  // Payload for potentially-constexpr optionals (trivial copy/move/destroy).\n  template &lt;typename _Tp&gt;\n    struct _Optional_payload&lt;_Tp, true, true, true&gt;\n    : _Optional_payload_base&lt;_Tp&gt;\n    {\n      using _Optional_payload_base&lt;_Tp&gt;::_Optional_payload_base;\n\n      _Optional_payload() = default;\n    };\n\n  // Payload for optionals with non-trivial copy construction/assignment.\n  template &lt;typename _Tp&gt;\n    struct _Optional_payload&lt;_Tp, true, false, true&gt;\n    : _Optional_payload_base&lt;_Tp&gt;\n    {\n      using _Optional_payload_base&lt;_Tp&gt;::_Optional_payload_base;\n\n      _Optional_payload() = default;\n      ~_Optional_payload() = default;\n      _Optional_payload(const _Optional_payload&amp;) = default;\n      _Optional_payload(_Optional_payload&amp;&amp;) = default;\n      _Optional_payload&amp; operator=(_Optional_payload&amp;&amp;) = default;\n\n      // Non-trivial copy assignment.\n      constexpr\n      _Optional_payload&amp;\n      operator=(const _Optional_payload&amp; __other)\n      {\n\tthis-&gt;_M_copy_assign(__other);\n\treturn *this;\n      }\n    };\n\n  // Payload for optionals with non-trivial move construction/assignment.\n  template &lt;typename _Tp&gt;\n    struct _Optional_payload&lt;_Tp, true, true, false&gt;\n    : _Optional_payload_base&lt;_Tp&gt;\n    {\n      using _Optional_payload_base&lt;_Tp&gt;::_Optional_payload_base;\n\n      _Optional_payload() = default;\n      ~_Optional_payload() = default;\n      _Optional_payload(const _Optional_payload&amp;) = default;\n      _Optional_payload(_Optional_payload&amp;&amp;) = default;\n      _Optional_payload&amp; operator=(const _Optional_payload&amp;) = default;\n\n      // Non-trivial move assignment.\n      constexpr\n      _Optional_payload&amp;\n      operator=(_Optional_payload&amp;&amp; __other)\n      noexcept(__and_v&lt;is_nothrow_move_constructible&lt;_Tp&gt;,\n\t\t       is_nothrow_move_assignable&lt;_Tp&gt;&gt;)\n      {\n\tthis-&gt;_M_move_assign(std::move(__other));\n\treturn *this;\n      }\n    };\n\n  // Payload for optionals with non-trivial copy and move assignment.\n  template &lt;typename _Tp&gt;\n    struct _Optional_payload&lt;_Tp, true, false, false&gt;\n    : _Optional_payload_base&lt;_Tp&gt;\n    {\n      using _Optional_payload_base&lt;_Tp&gt;::_Optional_payload_base;\n\n      _Optional_payload() = default;\n      ~_Optional_payload() = default;\n      _Optional_payload(const _Optional_payload&amp;) = default;\n      _Optional_payload(_Optional_payload&amp;&amp;) = default;\n\n      // Non-trivial copy assignment.\n      constexpr\n      _Optional_payload&amp;\n      operator=(const _Optional_payload&amp; __other)\n      {\n\tthis-&gt;_M_copy_assign(__other);\n\treturn *this;\n      }\n\n      // Non-trivial move assignment.\n      constexpr\n      _Optional_payload&amp;\n      operator=(_Optional_payload&amp;&amp; __other)\n      noexcept(__and_v&lt;is_nothrow_move_constructible&lt;_Tp&gt;,\n\t\t       is_nothrow_move_assignable&lt;_Tp&gt;&gt;)\n      {\n\tthis-&gt;_M_move_assign(std::move(__other));\n\treturn *this;\n      }\n    };\n\n  // Payload for optionals with non-trivial destructors.\n  template &lt;typename _Tp, bool _Copy, bool _Move&gt;\n    struct _Optional_payload&lt;_Tp, false, _Copy, _Move&gt;\n    : _Optional_payload&lt;_Tp, true, false, false&gt;\n    {\n      // Base class implements all the constructors and assignment operators:\n      using _Optional_payload&lt;_Tp, true, false, false&gt;::_Optional_payload;\n      _Optional_payload() = default;\n      _Optional_payload(const _Optional_payload&amp;) = default;\n      _Optional_payload(_Optional_payload&amp;&amp;) = default;\n      _Optional_payload&amp; operator=(const _Optional_payload&amp;) = default;\n      _Optional_payload&amp; operator=(_Optional_payload&amp;&amp;) = default;\n\n      // Destructor needs to destroy the contained value:\n      _GLIBCXX20_CONSTEXPR ~_Optional_payload() { this-&gt;_M_reset(); }\n    };\n\n  // Common base class for _Optional_base&lt;T&gt; to avoid repeating these\n  // member functions in each specialization.\n  template&lt;typename _Tp, typename _Dp&gt;\n    class _Optional_base_impl\n    {\n    protected:\n      using _Stored_type = remove_const_t&lt;_Tp&gt;;\n\n      // The _M_construct operation has !_M_engaged as a precondition\n      // while _M_destruct has _M_engaged as a precondition.\n      template&lt;typename... _Args&gt;\n\tconstexpr void\n\t_M_construct(_Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Stored_type, _Args...&gt;)\n\t{\n\t  static_cast&lt;_Dp*&gt;(this)-&gt;_M_payload._M_construct(\n\t    std::forward&lt;_Args&gt;(__args)...);\n\t}\n\n      constexpr void\n      _M_destruct() noexcept\n      { static_cast&lt;_Dp*&gt;(this)-&gt;_M_payload._M_destroy(); }\n\n      // _M_reset is a &#x27;safe&#x27; operation with no precondition.\n      constexpr void\n      _M_reset() noexcept\n      { static_cast&lt;_Dp*&gt;(this)-&gt;_M_payload._M_reset(); }\n\n      constexpr bool _M_is_engaged() const noexcept\n      { return static_cast&lt;const _Dp*&gt;(this)-&gt;_M_payload._M_engaged; }\n\n      // The _M_get operations have _M_engaged as a precondition.\n      constexpr _Tp&amp;\n      _M_get() noexcept\n      {\n\t__glibcxx_assert(this-&gt;_M_is_engaged());\n\treturn static_cast&lt;_Dp*&gt;(this)-&gt;_M_payload._M_get();\n      }\n\n      constexpr const _Tp&amp;\n      _M_get() const noexcept\n      {\n\t__glibcxx_assert(this-&gt;_M_is_engaged());\n\treturn static_cast&lt;const _Dp*&gt;(this)-&gt;_M_payload._M_get();\n      }\n    };\n\n  /**\n    * @brief Class template that provides copy/move constructors of optional.\n    *\n    * Such a separate base class template is necessary in order to\n    * conditionally make copy/move constructors trivial.\n    *\n    * When the contained value is trivially copy/move constructible,\n    * the copy/move constructors of _Optional_base will invoke the\n    * trivial copy/move constructor of _Optional_payload. Otherwise,\n    * they will invoke _Optional_payload(bool, const _Optional_payload&amp;)\n    * or _Optional_payload(bool, _Optional_payload&amp;&amp;) to initialize\n    * the contained value, if copying/moving an engaged optional.\n    *\n    * Whether the other special members are trivial is determined by the\n    * _Optional_payload&lt;_Tp&gt; specialization used for the _M_payload member.\n    *\n    * @see optional, _Enable_special_members\n    */\n  template&lt;typename _Tp,\n\t   bool = is_trivially_copy_constructible_v&lt;_Tp&gt;,\n\t   bool = is_trivially_move_constructible_v&lt;_Tp&gt;&gt;\n    struct _Optional_base\n    : _Optional_base_impl&lt;_Tp, _Optional_base&lt;_Tp&gt;&gt;\n    {\n      // Constructors for disengaged optionals.\n      constexpr _Optional_base() = default;\n\n      // Constructors for engaged optionals.\n      template&lt;typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t, _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Up, typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp,\n\t\t\t\t\t      initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t      _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t,\n\t\t       initializer_list&lt;_Up&gt; __il,\n\t\t       _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, __il, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      // Copy and move constructors.\n      constexpr\n      _Optional_base(const _Optional_base&amp; __other)\n      : _M_payload(__other._M_payload._M_engaged, __other._M_payload)\n      { }\n\n      constexpr\n      _Optional_base(_Optional_base&amp;&amp; __other)\n      noexcept(is_nothrow_move_constructible_v&lt;_Tp&gt;)\n      : _M_payload(__other._M_payload._M_engaged,\n\t\t   std::move(__other._M_payload))\n      { }\n\n      // Assignment operators.\n      _Optional_base&amp; operator=(const _Optional_base&amp;) = default;\n      _Optional_base&amp; operator=(_Optional_base&amp;&amp;) = default;\n\n      _Optional_payload&lt;_Tp&gt; _M_payload;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct _Optional_base&lt;_Tp, false, true&gt;\n    : _Optional_base_impl&lt;_Tp, _Optional_base&lt;_Tp&gt;&gt;\n    {\n      // Constructors for disengaged optionals.\n      constexpr _Optional_base() = default;\n\n      // Constructors for engaged optionals.\n      template&lt;typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t, _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Up, typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp,\n\t\t\t\t\t      initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t      _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t,\n\t\t       initializer_list&lt;_Up&gt; __il,\n\t\t       _Args... __args)\n\t: _M_payload(in_place, __il, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      // Copy and move constructors.\n      constexpr _Optional_base(const _Optional_base&amp; __other)\n      : _M_payload(__other._M_payload._M_engaged, __other._M_payload)\n      { }\n\n      constexpr _Optional_base(_Optional_base&amp;&amp; __other) = default;\n\n      // Assignment operators.\n      _Optional_base&amp; operator=(const _Optional_base&amp;) = default;\n      _Optional_base&amp; operator=(_Optional_base&amp;&amp;) = default;\n\n      _Optional_payload&lt;_Tp&gt; _M_payload;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct _Optional_base&lt;_Tp, true, false&gt;\n    : _Optional_base_impl&lt;_Tp, _Optional_base&lt;_Tp&gt;&gt;\n    {\n      // Constructors for disengaged optionals.\n      constexpr _Optional_base() = default;\n\n      // Constructors for engaged optionals.\n      template&lt;typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t, _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Up, typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp,\n\t\t\t\t\t      initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t      _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t,\n\t\t       initializer_list&lt;_Up&gt; __il,\n\t\t       _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, __il, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      // Copy and move constructors.\n      constexpr _Optional_base(const _Optional_base&amp; __other) = default;\n\n      constexpr\n      _Optional_base(_Optional_base&amp;&amp; __other)\n      noexcept(is_nothrow_move_constructible_v&lt;_Tp&gt;)\n      : _M_payload(__other._M_payload._M_engaged,\n\t\t   std::move(__other._M_payload))\n      { }\n\n      // Assignment operators.\n      _Optional_base&amp; operator=(const _Optional_base&amp;) = default;\n      _Optional_base&amp; operator=(_Optional_base&amp;&amp;) = default;\n\n      _Optional_payload&lt;_Tp&gt; _M_payload;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct _Optional_base&lt;_Tp, true, true&gt;\n    : _Optional_base_impl&lt;_Tp, _Optional_base&lt;_Tp&gt;&gt;\n    {\n      // Constructors for disengaged optionals.\n      constexpr _Optional_base() = default;\n\n      // Constructors for engaged optionals.\n      template&lt;typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t, _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Up, typename... _Args,\n\t       enable_if_t&lt;is_constructible_v&lt;_Tp,\n\t\t\t\t\t      initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t      _Args...&gt;, bool&gt; = false&gt;\n\tconstexpr explicit\n\t_Optional_base(in_place_t,\n\t\t       initializer_list&lt;_Up&gt; __il,\n\t\t       _Args&amp;&amp;... __args)\n\t: _M_payload(in_place, __il, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      // Copy and move constructors.\n      constexpr _Optional_base(const _Optional_base&amp; __other) = default;\n      constexpr _Optional_base(_Optional_base&amp;&amp; __other) = default;\n\n      // Assignment operators.\n      _Optional_base&amp; operator=(const _Optional_base&amp;) = default;\n      _Optional_base&amp; operator=(_Optional_base&amp;&amp;) = default;\n\n      _Optional_payload&lt;_Tp&gt; _M_payload;\n    };\n\n  template&lt;typename _Tp&gt;\n  class optional;\n\n  template&lt;typename _Tp&gt;\n    inline constexpr bool __is_optional_v = false;\n  template&lt;typename _Tp&gt;\n    inline constexpr bool __is_optional_v&lt;optional&lt;_Tp&gt;&gt; = true;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __converts_from_optional =\n      __or_&lt;is_constructible&lt;_Tp, const optional&lt;_Up&gt;&amp;&gt;,\n\t    is_constructible&lt;_Tp, optional&lt;_Up&gt;&amp;&gt;,\n\t    is_constructible&lt;_Tp, const optional&lt;_Up&gt;&amp;&amp;&gt;,\n\t    is_constructible&lt;_Tp, optional&lt;_Up&gt;&amp;&amp;&gt;,\n\t    is_convertible&lt;const optional&lt;_Up&gt;&amp;, _Tp&gt;,\n\t    is_convertible&lt;optional&lt;_Up&gt;&amp;, _Tp&gt;,\n\t    is_convertible&lt;const optional&lt;_Up&gt;&amp;&amp;, _Tp&gt;,\n\t    is_convertible&lt;optional&lt;_Up&gt;&amp;&amp;, _Tp&gt;&gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __assigns_from_optional =\n      __or_&lt;is_assignable&lt;_Tp&amp;, const optional&lt;_Up&gt;&amp;&gt;,\n\t    is_assignable&lt;_Tp&amp;, optional&lt;_Up&gt;&amp;&gt;,\n\t    is_assignable&lt;_Tp&amp;, const optional&lt;_Up&gt;&amp;&amp;&gt;,\n\t    is_assignable&lt;_Tp&amp;, optional&lt;_Up&gt;&amp;&amp;&gt;&gt;;\n\n  /**\n    * @brief Class template for optional values.\n    */\n  template&lt;typename _Tp&gt;\n    class optional\n    : private _Optional_base&lt;_Tp&gt;,\n      private _Enable_copy_move&lt;\n\t// Copy constructor.\n\tis_copy_constructible_v&lt;_Tp&gt;,\n\t// Copy assignment.\n\t__and_v&lt;is_copy_constructible&lt;_Tp&gt;, is_copy_assignable&lt;_Tp&gt;&gt;,\n\t// Move constructor.\n\tis_move_constructible_v&lt;_Tp&gt;,\n\t// Move assignment.\n\t__and_v&lt;is_move_constructible&lt;_Tp&gt;, is_move_assignable&lt;_Tp&gt;&gt;,\n\t// Unique tag type.\n\toptional&lt;_Tp&gt;&gt;\n    {\n      static_assert(!is_same_v&lt;remove_cv_t&lt;_Tp&gt;, nullopt_t&gt;);\n      static_assert(!is_same_v&lt;remove_cv_t&lt;_Tp&gt;, in_place_t&gt;);\n      static_assert(is_object_v&lt;_Tp&gt; &amp;&amp; !is_array_v&lt;_Tp&gt;);\n\n    private:\n      using _Base = _Optional_base&lt;_Tp&gt;;\n\n      // SFINAE helpers\n      template&lt;typename _Up&gt;\n\tusing __not_self = __not_&lt;is_same&lt;optional, __remove_cvref_t&lt;_Up&gt;&gt;&gt;;\n      template&lt;typename _Up&gt;\n\tusing __not_tag = __not_&lt;is_same&lt;in_place_t, __remove_cvref_t&lt;_Up&gt;&gt;&gt;;\n      template&lt;typename... _Cond&gt;\n\tusing _Requires = enable_if_t&lt;__and_v&lt;_Cond...&gt;, bool&gt;;\n\n    public:\n      using value_type = _Tp;\n\n      constexpr optional() noexcept { }\n\n      constexpr optional(nullopt_t) noexcept { }\n\n      // Converting constructors for engaged optionals.\n      template&lt;typename _Up = _Tp,\n\t       _Requires&lt;__not_self&lt;_Up&gt;, __not_tag&lt;_Up&gt;,\n\t\t\t is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t is_convertible&lt;_Up, _Tp&gt;&gt; = true&gt;\n\tconstexpr\n\toptional(_Up&amp;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Up&gt;)\n\t: _Base(std::in_place, std::forward&lt;_Up&gt;(__t)) { }\n\n      template&lt;typename _Up = _Tp,\n\t       _Requires&lt;__not_self&lt;_Up&gt;, __not_tag&lt;_Up&gt;,\n\t\t\t is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t __not_&lt;is_convertible&lt;_Up, _Tp&gt;&gt;&gt; = false&gt;\n\texplicit constexpr\n\toptional(_Up&amp;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Up&gt;)\n\t: _Base(std::in_place, std::forward&lt;_Up&gt;(__t)) { }\n\n      template&lt;typename _Up,\n\t       _Requires&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t is_constructible&lt;_Tp, const _Up&amp;&gt;,\n\t\t\t is_convertible&lt;const _Up&amp;, _Tp&gt;,\n\t\t\t __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;&gt; = true&gt;\n\tconstexpr\n\toptional(const optional&lt;_Up&gt;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, const _Up&amp;&gt;)\n\t{\n\t  if (__t)\n\t    emplace(*__t);\n\t}\n\n      template&lt;typename _Up,\n\t       _Requires&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t is_constructible&lt;_Tp, const _Up&amp;&gt;,\n\t\t\t __not_&lt;is_convertible&lt;const _Up&amp;, _Tp&gt;&gt;,\n\t\t\t __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;&gt; = false&gt;\n\texplicit constexpr\n\toptional(const optional&lt;_Up&gt;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, const _Up&amp;&gt;)\n\t{\n\t  if (__t)\n\t    emplace(*__t);\n\t}\n\n      template&lt;typename _Up,\n\t       _Requires&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t is_convertible&lt;_Up, _Tp&gt;,\n\t\t\t __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;&gt; = true&gt;\n\tconstexpr\n\toptional(optional&lt;_Up&gt;&amp;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Up&gt;)\n\t{\n\t  if (__t)\n\t    emplace(std::move(*__t));\n\t}\n\n      template&lt;typename _Up,\n\t       _Requires&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t __not_&lt;is_convertible&lt;_Up, _Tp&gt;&gt;,\n\t\t\t __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;&gt; = false&gt;\n\texplicit constexpr\n\toptional(optional&lt;_Up&gt;&amp;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Up&gt;)\n\t{\n\t  if (__t)\n\t    emplace(std::move(*__t));\n\t}\n\n      template&lt;typename... _Args,\n\t       _Requires&lt;is_constructible&lt;_Tp, _Args...&gt;&gt; = false&gt;\n\texplicit constexpr\n\toptional(in_place_t, _Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Args...&gt;)\n\t: _Base(std::in_place, std::forward&lt;_Args&gt;(__args)...) { }\n\n      template&lt;typename _Up, typename... _Args,\n\t       _Requires&lt;is_constructible&lt;_Tp,\n\t\t\t\t\t  initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t  _Args...&gt;&gt; = false&gt;\n\texplicit constexpr\n\toptional(in_place_t, initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t    _Args...&gt;)\n\t: _Base(std::in_place, __il, std::forward&lt;_Args&gt;(__args)...) { }\n\n\n      // Assignment operators.\n      _GLIBCXX20_CONSTEXPR optional&amp;\n      operator=(nullopt_t) noexcept\n      {\n\tthis-&gt;_M_reset();\n\treturn *this;\n      }\n\n      template&lt;typename _Up = _Tp&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;__and_v&lt;__not_self&lt;_Up&gt;,\n\t\t\t    __not_&lt;__and_&lt;is_scalar&lt;_Tp&gt;,\n\t\t\t\t\t  is_same&lt;_Tp, decay_t&lt;_Up&gt;&gt;&gt;&gt;,\n\t\t\t    is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t    is_assignable&lt;_Tp&amp;, _Up&gt;&gt;,\n\t\t    optional&amp;&gt;\n\toperator=(_Up&amp;&amp; __u)\n\tnoexcept(__and_v&lt;is_nothrow_constructible&lt;_Tp, _Up&gt;,\n\t\t\t is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;)\n\t{\n\t  if (this-&gt;_M_is_engaged())\n\t    this-&gt;_M_get() = std::forward&lt;_Up&gt;(__u);\n\t  else\n\t    this-&gt;_M_construct(std::forward&lt;_Up&gt;(__u));\n\n\t  return *this;\n\t}\n\n      template&lt;typename _Up&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;__and_v&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t    is_constructible&lt;_Tp, const _Up&amp;&gt;,\n\t\t\t    is_assignable&lt;_Tp&amp;, const _Up&amp;&gt;,\n\t\t\t    __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;,\n\t\t\t    __not_&lt;__assigns_from_optional&lt;_Tp, _Up&gt;&gt;&gt;,\n\t\t    optional&amp;&gt;\n\toperator=(const optional&lt;_Up&gt;&amp; __u)\n\tnoexcept(__and_v&lt;is_nothrow_constructible&lt;_Tp, const _Up&amp;&gt;,\n\t\t\t is_nothrow_assignable&lt;_Tp&amp;, const _Up&amp;&gt;&gt;)\n\t{\n\t  if (__u)\n\t    {\n\t      if (this-&gt;_M_is_engaged())\n\t\tthis-&gt;_M_get() = *__u;\n\t      else\n\t\tthis-&gt;_M_construct(*__u);\n\t    }\n\t  else\n\t    {\n\t      this-&gt;_M_reset();\n\t    }\n\t  return *this;\n\t}\n\n      template&lt;typename _Up&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;__and_v&lt;__not_&lt;is_same&lt;_Tp, _Up&gt;&gt;,\n\t\t\t    is_constructible&lt;_Tp, _Up&gt;,\n\t\t\t    is_assignable&lt;_Tp&amp;, _Up&gt;,\n\t\t\t    __not_&lt;__converts_from_optional&lt;_Tp, _Up&gt;&gt;,\n\t\t\t    __not_&lt;__assigns_from_optional&lt;_Tp, _Up&gt;&gt;&gt;,\n\t\t    optional&amp;&gt;\n\toperator=(optional&lt;_Up&gt;&amp;&amp; __u)\n\tnoexcept(__and_v&lt;is_nothrow_constructible&lt;_Tp, _Up&gt;,\n\t\t\t is_nothrow_assignable&lt;_Tp&amp;, _Up&gt;&gt;)\n\t{\n\t  if (__u)\n\t    {\n\t      if (this-&gt;_M_is_engaged())\n\t\tthis-&gt;_M_get() = std::move(*__u);\n\t      else\n\t\tthis-&gt;_M_construct(std::move(*__u));\n\t    }\n\t  else\n\t    {\n\t      this-&gt;_M_reset();\n\t    }\n\n\t  return *this;\n\t}\n\n      template&lt;typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;, _Tp&amp;&gt;\n\templace(_Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, _Args...&gt;)\n\t{\n\t  this-&gt;_M_reset();\n\t  this-&gt;_M_construct(std::forward&lt;_Args&gt;(__args)...);\n\t  return this-&gt;_M_get();\n\t}\n\n      template&lt;typename _Up, typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;, _Args...&gt;,\n\t\t    _Tp&amp;&gt;\n\templace(initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t    _Args...&gt;)\n\t{\n\t  this-&gt;_M_reset();\n\t  this-&gt;_M_construct(__il, std::forward&lt;_Args&gt;(__args)...);\n\t  return this-&gt;_M_get();\n\t}\n\n      // Destructor is implicit, implemented in _Optional_base.\n\n      // Swap.\n      _GLIBCXX20_CONSTEXPR void\n      swap(optional&amp; __other)\n      noexcept(is_nothrow_move_constructible_v&lt;_Tp&gt;\n\t       &amp;&amp; is_nothrow_swappable_v&lt;_Tp&gt;)\n      {\n\tusing std::swap;\n\n\tif (this-&gt;_M_is_engaged() &amp;&amp; __other._M_is_engaged())\n\t  swap(this-&gt;_M_get(), __other._M_get());\n\telse if (this-&gt;_M_is_engaged())\n\t  {\n\t    __other._M_construct(std::move(this-&gt;_M_get()));\n\t    this-&gt;_M_destruct();\n\t  }\n\telse if (__other._M_is_engaged())\n\t  {\n\t    this-&gt;_M_construct(std::move(__other._M_get()));\n\t    __other._M_destruct();\n\t  }\n      }\n\n      // Observers.\n      constexpr const _Tp*\n      operator-&gt;() const noexcept\n      { return std::__addressof(this-&gt;_M_get()); }\n\n      constexpr _Tp*\n      operator-&gt;() noexcept\n      { return std::__addressof(this-&gt;_M_get()); }\n\n      constexpr const _Tp&amp;\n      operator*() const&amp; noexcept\n      { return this-&gt;_M_get(); }\n\n      constexpr _Tp&amp;\n      operator*()&amp; noexcept\n      { return this-&gt;_M_get(); }\n\n      constexpr _Tp&amp;&amp;\n      operator*()&amp;&amp; noexcept\n      { return std::move(this-&gt;_M_get()); }\n\n      constexpr const _Tp&amp;&amp;\n      operator*() const&amp;&amp; noexcept\n      { return std::move(this-&gt;_M_get()); }\n\n      constexpr explicit operator bool() const noexcept\n      { return this-&gt;_M_is_engaged(); }\n\n      constexpr bool has_value() const noexcept\n      { return this-&gt;_M_is_engaged(); }\n\n      constexpr const _Tp&amp;\n      value() const&amp;\n      {\n\tif (this-&gt;_M_is_engaged())\n\t  return this-&gt;_M_get();\n\t__throw_bad_optional_access();\n      }\n\n      constexpr _Tp&amp;\n      value()&amp;\n      {\n\tif (this-&gt;_M_is_engaged())\n\t  return this-&gt;_M_get();\n\t__throw_bad_optional_access();\n      }\n\n      constexpr _Tp&amp;&amp;\n      value()&amp;&amp;\n      {\n\tif (this-&gt;_M_is_engaged())\n\t  return std::move(this-&gt;_M_get());\n\t__throw_bad_optional_access();\n      }\n\n      constexpr const _Tp&amp;&amp;\n      value() const&amp;&amp;\n      {\n\tif (this-&gt;_M_is_engaged())\n\t  return std::move(this-&gt;_M_get());\n\t__throw_bad_optional_access();\n      }\n\n      template&lt;typename _Up&gt;\n\tconstexpr _Tp\n\tvalue_or(_Up&amp;&amp; __u) const&amp;\n\t{\n\t  static_assert(is_copy_constructible_v&lt;_Tp&gt;);\n\t  static_assert(is_convertible_v&lt;_Up&amp;&amp;, _Tp&gt;);\n\n\t  if (this-&gt;_M_is_engaged())\n\t    return this-&gt;_M_get();\n\t  else\n\t    return static_cast&lt;_Tp&gt;(std::forward&lt;_Up&gt;(__u));\n\t}\n\n      template&lt;typename _Up&gt;\n\tconstexpr _Tp\n\tvalue_or(_Up&amp;&amp; __u) &amp;&amp;\n\t{\n\t  static_assert(is_move_constructible_v&lt;_Tp&gt;);\n\t  static_assert(is_convertible_v&lt;_Up&amp;&amp;, _Tp&gt;);\n\n\t  if (this-&gt;_M_is_engaged())\n\t    return std::move(this-&gt;_M_get());\n\t  else\n\t    return static_cast&lt;_Tp&gt;(std::forward&lt;_Up&gt;(__u));\n\t}\n\n#if __cpp_lib_optional &gt;= 202110L\n      // [optional.monadic]\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\tand_then(_Fn&amp;&amp; __f) &amp;\n\t{\n\t  using _Up = remove_cvref_t&lt;invoke_result_t&lt;_Fn, _Tp&amp;&gt;&gt;;\n\t  static_assert(__is_optional_v&lt;remove_cvref_t&lt;_Up&gt;&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::and_then &quot;\n\t\t\t&quot;must return a std::optional&quot;);\n\t  if (has_value())\n\t    return std::__invoke(std::forward&lt;_Fn&gt;(__f), **this);\n\t  else\n\t    return _Up();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\tand_then(_Fn&amp;&amp; __f) const &amp;\n\t{\n\t  using _Up = remove_cvref_t&lt;invoke_result_t&lt;_Fn, const _Tp&amp;&gt;&gt;;\n\t  static_assert(__is_optional_v&lt;_Up&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::and_then &quot;\n\t\t\t&quot;must return a std::optional&quot;);\n\t  if (has_value())\n\t    return std::__invoke(std::forward&lt;_Fn&gt;(__f), **this);\n\t  else\n\t    return _Up();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\tand_then(_Fn&amp;&amp; __f) &amp;&amp;\n\t{\n\t  using _Up = remove_cvref_t&lt;invoke_result_t&lt;_Fn, _Tp&gt;&gt;;\n\t  static_assert(__is_optional_v&lt;remove_cvref_t&lt;_Up&gt;&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::and_then &quot;\n\t\t\t&quot;must return a std::optional&quot;);\n\t  if (has_value())\n\t    return std::__invoke(std::forward&lt;_Fn&gt;(__f), std::move(**this));\n\t  else\n\t    return _Up();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\tand_then(_Fn&amp;&amp; __f) const &amp;&amp;\n\t{\n\t  using _Up = remove_cvref_t&lt;invoke_result_t&lt;_Fn, const _Tp&gt;&gt;;\n\t  static_assert(__is_optional_v&lt;remove_cvref_t&lt;_Up&gt;&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::and_then &quot;\n\t\t\t&quot;must return a std::optional&quot;);\n\t  if (has_value())\n\t    return std::__invoke(std::forward&lt;_Fn&gt;(__f), std::move(**this));\n\t  else\n\t    return _Up();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\ttransform(_Fn&amp;&amp; __f) &amp;\n\t{\n\t  using _Up = remove_cv_t&lt;invoke_result_t&lt;_Fn, _Tp&amp;&gt;&gt;;\n\t  if (has_value())\n\t    return optional&lt;_Up&gt;(_Optional_func&lt;_Fn&gt;{__f}, **this);\n\t  else\n\t    return optional&lt;_Up&gt;();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\ttransform(_Fn&amp;&amp; __f) const &amp;\n\t{\n\t  using _Up = remove_cv_t&lt;invoke_result_t&lt;_Fn, const _Tp&amp;&gt;&gt;;\n\t  if (has_value())\n\t    return optional&lt;_Up&gt;(_Optional_func&lt;_Fn&gt;{__f}, **this);\n\t  else\n\t    return optional&lt;_Up&gt;();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\ttransform(_Fn&amp;&amp; __f) &amp;&amp;\n\t{\n\t  using _Up = remove_cv_t&lt;invoke_result_t&lt;_Fn, _Tp&gt;&gt;;\n\t  if (has_value())\n\t    return optional&lt;_Up&gt;(_Optional_func&lt;_Fn&gt;{__f}, std::move(**this));\n\t  else\n\t    return optional&lt;_Up&gt;();\n\t}\n\n      template&lt;typename _Fn&gt;\n\tconstexpr auto\n\ttransform(_Fn&amp;&amp; __f) const &amp;&amp;\n\t{\n\t  using _Up = remove_cv_t&lt;invoke_result_t&lt;_Fn, const _Tp&gt;&gt;;\n\t  if (has_value())\n\t    return optional&lt;_Up&gt;(_Optional_func&lt;_Fn&gt;{__f}, std::move(**this));\n\t  else\n\t    return optional&lt;_Up&gt;();\n\t}\n\n      template&lt;typename _Fn&gt; requires invocable&lt;_Fn&gt; &amp;&amp; copy_constructible&lt;_Tp&gt;\n\tconstexpr optional\n\tor_else(_Fn&amp;&amp; __f) const&amp;\n\t{\n\t  using _Up = invoke_result_t&lt;_Fn&gt;;\n\t  static_assert(is_same_v&lt;remove_cvref_t&lt;_Up&gt;, optional&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::or_else &quot;\n\t\t\t&quot;must return a std::optional&lt;T&gt;&quot;);\n\n\t  if (has_value())\n\t    return *this;\n\t  else\n\t    return std::forward&lt;_Fn&gt;(__f)();\n\t}\n\n      template&lt;typename _Fn&gt; requires invocable&lt;_Fn&gt; &amp;&amp; move_constructible&lt;_Tp&gt;\n\tconstexpr optional\n\tor_else(_Fn&amp;&amp; __f) &amp;&amp;\n\t{\n\t  using _Up = invoke_result_t&lt;_Fn&gt;;\n\t  static_assert(is_same_v&lt;remove_cvref_t&lt;_Up&gt;, optional&gt;,\n\t\t\t&quot;the function passed to std::optional&lt;T&gt;::or_else &quot;\n\t\t\t&quot;must return a std::optional&lt;T&gt;&quot;);\n\n\t  if (has_value())\n\t    return std::move(*this);\n\t  else\n\t    return std::forward&lt;_Fn&gt;(__f)();\n\t}\n#endif\n\n      _GLIBCXX20_CONSTEXPR void reset() noexcept { this-&gt;_M_reset(); }\n\n    private:\n#if __cplusplus &gt;= 202002L\n      template&lt;typename _Up&gt; friend class optional;\n\n      template&lt;typename _Fn, typename _Value&gt;\n\texplicit constexpr\n\toptional(_Optional_func&lt;_Fn&gt; __f, _Value&amp;&amp; __v)\n\t{\n\t  this-&gt;_M_payload._M_apply(__f, std::forward&lt;_Value&gt;(__v));\n\t}\n#endif\n    };\n\n  template&lt;typename _Tp&gt;\n    using __optional_relop_t =\n      enable_if_t&lt;is_convertible&lt;_Tp, bool&gt;::value, bool&gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_eq_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() == std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_ne_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() != std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_lt_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() &lt; std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_gt_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() &gt; std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_le_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() &lt;= std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  template&lt;typename _Tp, typename _Up&gt;\n    using __optional_ge_t = __optional_relop_t&lt;\n      decltype(std::declval&lt;const _Tp&amp;&gt;() &gt;= std::declval&lt;const _Up&amp;&gt;())\n      &gt;;\n\n  // Comparisons between optional values.\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator==(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_eq_t&lt;_Tp, _Up&gt;\n    {\n      return static_cast&lt;bool&gt;(__lhs) == static_cast&lt;bool&gt;(__rhs)\n\t     &amp;&amp; (!__lhs || *__lhs == *__rhs);\n    }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator!=(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_ne_t&lt;_Tp, _Up&gt;\n    {\n      return static_cast&lt;bool&gt;(__lhs) != static_cast&lt;bool&gt;(__rhs)\n\t|| (static_cast&lt;bool&gt;(__lhs) &amp;&amp; *__lhs != *__rhs);\n    }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_lt_t&lt;_Tp, _Up&gt;\n    {\n      return static_cast&lt;bool&gt;(__rhs) &amp;&amp; (!__lhs || *__lhs &lt; *__rhs);\n    }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_gt_t&lt;_Tp, _Up&gt;\n    {\n      return static_cast&lt;bool&gt;(__lhs) &amp;&amp; (!__rhs || *__lhs &gt; *__rhs);\n    }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;=(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_le_t&lt;_Tp, _Up&gt;\n    {\n      return !__lhs || (static_cast&lt;bool&gt;(__rhs) &amp;&amp; *__lhs &lt;= *__rhs);\n    }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;=(const optional&lt;_Tp&gt;&amp; __lhs, const optional&lt;_Up&gt;&amp; __rhs)\n    -&gt; __optional_ge_t&lt;_Tp, _Up&gt;\n    {\n      return !__rhs || (static_cast&lt;bool&gt;(__lhs) &amp;&amp; *__lhs &gt;= *__rhs);\n    }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, three_way_comparable_with&lt;_Tp&gt; _Up&gt;\n    constexpr compare_three_way_result_t&lt;_Tp, _Up&gt;\n    operator&lt;=&gt;(const optional&lt;_Tp&gt;&amp; __x, const optional&lt;_Up&gt;&amp; __y)\n    {\n      return __x &amp;&amp; __y ? *__x &lt;=&gt; *__y : bool(__x) &lt;=&gt; bool(__y);\n    }\n#endif\n\n  // Comparisons with nullopt.\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator==(const optional&lt;_Tp&gt;&amp; __lhs, nullopt_t) noexcept\n    { return !__lhs; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp&gt;\n    constexpr strong_ordering\n    operator&lt;=&gt;(const optional&lt;_Tp&gt;&amp; __x, nullopt_t) noexcept\n    { return bool(__x) &lt;=&gt; false; }\n#else\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator==(nullopt_t, const optional&lt;_Tp&gt;&amp; __rhs) noexcept\n    { return !__rhs; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator!=(const optional&lt;_Tp&gt;&amp; __lhs, nullopt_t) noexcept\n    { return static_cast&lt;bool&gt;(__lhs); }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator!=(nullopt_t, const optional&lt;_Tp&gt;&amp; __rhs) noexcept\n    { return static_cast&lt;bool&gt;(__rhs); }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&lt;(const optional&lt;_Tp&gt;&amp; /* __lhs */, nullopt_t) noexcept\n    { return false; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&lt;(nullopt_t, const optional&lt;_Tp&gt;&amp; __rhs) noexcept\n    { return static_cast&lt;bool&gt;(__rhs); }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&gt;(const optional&lt;_Tp&gt;&amp; __lhs, nullopt_t) noexcept\n    { return static_cast&lt;bool&gt;(__lhs); }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&gt;(nullopt_t, const optional&lt;_Tp&gt;&amp; /* __rhs */) noexcept\n    { return false; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&lt;=(const optional&lt;_Tp&gt;&amp; __lhs, nullopt_t) noexcept\n    { return !__lhs; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&lt;=(nullopt_t, const optional&lt;_Tp&gt;&amp; /* __rhs */) noexcept\n    { return true; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&gt;=(const optional&lt;_Tp&gt;&amp; /* __lhs */, nullopt_t) noexcept\n    { return true; }\n\n  template&lt;typename _Tp&gt;\n    constexpr bool\n    operator&gt;=(nullopt_t, const optional&lt;_Tp&gt;&amp; __rhs) noexcept\n    { return !__rhs; }\n#endif // three-way-comparison\n\n  // Comparisons with value type.\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator==(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_eq_t&lt;_Tp, _Up&gt;\n    { return __lhs &amp;&amp; *__lhs == __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator==(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_eq_t&lt;_Up, _Tp&gt;\n    { return __rhs &amp;&amp; __lhs == *__rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator!=(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_ne_t&lt;_Tp, _Up&gt;\n    { return !__lhs || *__lhs != __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator!=(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_ne_t&lt;_Up, _Tp&gt;\n    { return !__rhs || __lhs != *__rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_lt_t&lt;_Tp, _Up&gt;\n    { return !__lhs || *__lhs &lt; __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_lt_t&lt;_Up, _Tp&gt;\n    { return __rhs &amp;&amp; __lhs &lt; *__rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_gt_t&lt;_Tp, _Up&gt;\n    { return __lhs &amp;&amp; *__lhs &gt; __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_gt_t&lt;_Up, _Tp&gt;\n    { return !__rhs || __lhs &gt; *__rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;=(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_le_t&lt;_Tp, _Up&gt;\n    { return !__lhs || *__lhs &lt;= __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&lt;=(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_le_t&lt;_Up, _Tp&gt;\n    { return __rhs &amp;&amp; __lhs &lt;= *__rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;=(const optional&lt;_Tp&gt;&amp; __lhs, const _Up&amp; __rhs)\n    -&gt; __optional_ge_t&lt;_Tp, _Up&gt;\n    { return __lhs &amp;&amp; *__lhs &gt;= __rhs; }\n\n  template&lt;typename _Tp, typename _Up&gt;\n    constexpr auto\n    operator&gt;=(const _Up&amp; __lhs, const optional&lt;_Tp&gt;&amp; __rhs)\n    -&gt; __optional_ge_t&lt;_Up, _Tp&gt;\n    { return !__rhs || __lhs &gt;= *__rhs; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    requires (!__is_optional_v&lt;_Up&gt;)\n      &amp;&amp; three_way_comparable_with&lt;_Up, _Tp&gt;\n    constexpr compare_three_way_result_t&lt;_Tp, _Up&gt;\n    operator&lt;=&gt;(const optional&lt;_Tp&gt;&amp; __x, const _Up&amp; __v)\n    { return bool(__x) ? *__x &lt;=&gt; __v : strong_ordering::less; }\n#endif\n\n  // Swap and creation functions.\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2748. swappable traits for optionals\n  template&lt;typename _Tp&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline enable_if_t&lt;is_move_constructible_v&lt;_Tp&gt; &amp;&amp; is_swappable_v&lt;_Tp&gt;&gt;\n    swap(optional&lt;_Tp&gt;&amp; __lhs, optional&lt;_Tp&gt;&amp; __rhs)\n    noexcept(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n\n  template&lt;typename _Tp&gt;\n    enable_if_t&lt;!(is_move_constructible_v&lt;_Tp&gt; &amp;&amp; is_swappable_v&lt;_Tp&gt;)&gt;\n    swap(optional&lt;_Tp&gt;&amp;, optional&lt;_Tp&gt;&amp;) = delete;\n\n  template&lt;typename _Tp&gt;\n    constexpr\n    enable_if_t&lt;is_constructible_v&lt;decay_t&lt;_Tp&gt;, _Tp&gt;,\n\t\toptional&lt;decay_t&lt;_Tp&gt;&gt;&gt;\n    make_optional(_Tp&amp;&amp; __t)\n    noexcept(is_nothrow_constructible_v&lt;optional&lt;decay_t&lt;_Tp&gt;&gt;, _Tp&gt;)\n    { return optional&lt;decay_t&lt;_Tp&gt;&gt;{ std::forward&lt;_Tp&gt;(__t) }; }\n\n  template&lt;typename _Tp, typename... _Args&gt;\n    constexpr\n    enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;,\n\t\toptional&lt;_Tp&gt;&gt;\n    make_optional(_Args&amp;&amp;... __args)\n    noexcept(is_nothrow_constructible_v&lt;_Tp, _Args...&gt;)\n    { return optional&lt;_Tp&gt;{ in_place, std::forward&lt;_Args&gt;(__args)... }; }\n\n  template&lt;typename _Tp, typename _Up, typename... _Args&gt;\n    constexpr\n    enable_if_t&lt;is_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;, _Args...&gt;,\n\t\toptional&lt;_Tp&gt;&gt;\n    make_optional(initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)\n    noexcept(is_nothrow_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;, _Args...&gt;)\n    { return optional&lt;_Tp&gt;{ in_place, __il, std::forward&lt;_Args&gt;(__args)... }; }\n\n  // Hash.\n\n  template&lt;typename _Tp, typename _Up = remove_const_t&lt;_Tp&gt;,\n\t   bool = __poison_hash&lt;_Up&gt;::__enable_hash_call&gt;\n    struct __optional_hash_call_base\n    {\n      size_t\n      operator()(const optional&lt;_Tp&gt;&amp; __t) const\n      noexcept(noexcept(hash&lt;_Up&gt;{}(*__t)))\n      {\n\t// We pick an arbitrary hash for disengaged optionals which hopefully\n\t// usual values of _Tp won&#x27;t typically hash to.\n\tconstexpr size_t __magic_disengaged_hash = static_cast&lt;size_t&gt;(-3333);\n\treturn __t ? hash&lt;_Up&gt;{}(*__t) : __magic_disengaged_hash;\n      }\n    };\n\n  template&lt;typename _Tp, typename _Up&gt;\n    struct __optional_hash_call_base&lt;_Tp, _Up, false&gt; {};\n\n  template&lt;typename _Tp&gt;\n    struct hash&lt;optional&lt;_Tp&gt;&gt;\n    : private __poison_hash&lt;remove_const_t&lt;_Tp&gt;&gt;,\n      public __optional_hash_call_base&lt;_Tp&gt;\n    {\n      using result_type [[__deprecated__]] = size_t;\n      using argument_type [[__deprecated__]] = optional&lt;_Tp&gt;;\n    };\n\n  template&lt;typename _Tp&gt;\n    struct __is_fast_hash&lt;hash&lt;optional&lt;_Tp&gt;&gt;&gt; : __is_fast_hash&lt;hash&lt;_Tp&gt;&gt;\n    { };\n\n  /// @}\n\n#if __cpp_deduction_guides &gt;= 201606\n  template &lt;typename _Tp&gt; optional(_Tp) -&gt; optional&lt;_Tp&gt;;\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++17\n\n#endif // _GLIBCXX_OPTIONAL\n"}, "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant": {"id": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "filePath": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "content": "// &lt;variant&gt; -*- C++ -*-\n\n// Copyright (C) 2016-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file variant\n *  This is the `&lt;variant&gt;` C++ Library header.\n */\n\n#ifndef _GLIBCXX_VARIANT\n#define _GLIBCXX_VARIANT 1\n\n#pragma GCC system_header\n\n#if __cplusplus &gt;= 201703L\n\n#include &lt;initializer_list&gt;\n#include &lt;type_traits&gt;\n#include &lt;bits/enable_special_members.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/invoke.h&gt;\n#include &lt;bits/parse_numbers.h&gt;\n#include &lt;bits/stl_iterator_base_funcs.h&gt;\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/utility.h&gt; // in_place_index_t\n#if __cplusplus &gt;= 202002L\n# include &lt;compare&gt;\n#endif\n\n#if __cpp_concepts &gt;= 202002L &amp;&amp; __cpp_constexpr &gt;= 201811L\n// P2231R1 constexpr needs constexpr unions and constrained destructors.\n# define __cpp_lib_variant 202106L\n#else\n# include &lt;ext/aligned_buffer.h&gt; // Use __aligned_membuf instead of union.\n# define __cpp_lib_variant 202102L\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template&lt;typename... _Types&gt; class tuple;\n  template&lt;typename... _Types&gt; class variant;\n  template &lt;typename&gt; struct hash;\n\n  template&lt;typename _Variant&gt;\n    struct variant_size;\n\n  template&lt;typename _Variant&gt;\n    struct variant_size&lt;const _Variant&gt; : variant_size&lt;_Variant&gt; {};\n\n  template&lt;typename _Variant&gt;\n    struct variant_size&lt;volatile _Variant&gt; : variant_size&lt;_Variant&gt; {};\n\n  template&lt;typename _Variant&gt;\n    struct variant_size&lt;const volatile _Variant&gt; : variant_size&lt;_Variant&gt; {};\n\n  template&lt;typename... _Types&gt;\n    struct variant_size&lt;variant&lt;_Types...&gt;&gt;\n    : std::integral_constant&lt;size_t, sizeof...(_Types)&gt; {};\n\n  template&lt;typename _Variant&gt;\n    inline constexpr size_t variant_size_v = variant_size&lt;_Variant&gt;::value;\n\n  template&lt;typename... _Types&gt;\n    inline constexpr size_t\n    variant_size_v&lt;variant&lt;_Types...&gt;&gt; = sizeof...(_Types);\n\n  template&lt;typename... _Types&gt;\n    inline constexpr size_t\n    variant_size_v&lt;const variant&lt;_Types...&gt;&gt; = sizeof...(_Types);\n\n  template&lt;size_t _Np, typename _Variant&gt;\n    struct variant_alternative;\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    struct variant_alternative&lt;_Np, variant&lt;_Types...&gt;&gt;\n    {\n      static_assert(_Np &lt; sizeof...(_Types));\n\n      using type = typename _Nth_type&lt;_Np, _Types...&gt;::type;\n    };\n\n  template&lt;size_t _Np, typename _Variant&gt;\n    using variant_alternative_t =\n      typename variant_alternative&lt;_Np, _Variant&gt;::type;\n\n  template&lt;size_t _Np, typename _Variant&gt;\n    struct variant_alternative&lt;_Np, const _Variant&gt;\n    { using type = const variant_alternative_t&lt;_Np, _Variant&gt;; };\n\n  template&lt;size_t _Np, typename _Variant&gt;\n    struct variant_alternative&lt;_Np, volatile _Variant&gt;\n    { using type = volatile variant_alternative_t&lt;_Np, _Variant&gt;; };\n\n  template&lt;size_t _Np, typename _Variant&gt;\n    struct variant_alternative&lt;_Np, const volatile _Variant&gt;\n    { using type = const volatile variant_alternative_t&lt;_Np, _Variant&gt;; };\n\n  inline constexpr size_t variant_npos = -1;\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;\n    get(variant&lt;_Types...&gt;&amp;);\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;&amp;\n    get(variant&lt;_Types...&gt;&amp;&amp;);\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt; const&amp;\n    get(const variant&lt;_Types...&gt;&amp;);\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt; const&amp;&amp;\n    get(const variant&lt;_Types...&gt;&amp;&amp;);\n\n  template&lt;typename _Result_type, typename _Visitor, typename... _Variants&gt;\n    constexpr decltype(auto)\n    __do_visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants);\n\n  template &lt;typename... _Types, typename _Tp&gt;\n    _GLIBCXX20_CONSTEXPR\n    decltype(auto)\n    __variant_cast(_Tp&amp;&amp; __rhs)\n    {\n      if constexpr (is_lvalue_reference_v&lt;_Tp&gt;)\n\t{\n\t  if constexpr (is_const_v&lt;remove_reference_t&lt;_Tp&gt;&gt;)\n\t    return static_cast&lt;const variant&lt;_Types...&gt;&amp;&gt;(__rhs);\n\t  else\n\t    return static_cast&lt;variant&lt;_Types...&gt;&amp;&gt;(__rhs);\n\t}\n      else\n        return static_cast&lt;variant&lt;_Types...&gt;&amp;&amp;&gt;(__rhs);\n    }\n\nnamespace __detail\n{\nnamespace __variant\n{\n  // used for raw visitation\n  struct __variant_cookie {};\n  // used for raw visitation with indices passed in\n  struct __variant_idx_cookie { using type = __variant_idx_cookie; };\n  // Used to enable deduction (and same-type checking) for std::visit:\n  template&lt;typename _Tp&gt; struct __deduce_visit_result { using type = _Tp; };\n\n  // Visit variants that might be valueless.\n  template&lt;typename _Visitor, typename... _Variants&gt;\n    constexpr void\n    __raw_visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants)\n    {\n      std::__do_visit&lt;__variant_cookie&gt;(std::forward&lt;_Visitor&gt;(__visitor),\n\t\t\t\t        std::forward&lt;_Variants&gt;(__variants)...);\n    }\n\n  // Visit variants that might be valueless, passing indices to the visitor.\n  template&lt;typename _Visitor, typename... _Variants&gt;\n    constexpr void\n    __raw_idx_visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants)\n    {\n      std::__do_visit&lt;__variant_idx_cookie&gt;(std::forward&lt;_Visitor&gt;(__visitor),\n\t  std::forward&lt;_Variants&gt;(__variants)...);\n    }\n\n  // The __as function templates implement the exposition-only &quot;as-variant&quot;\n\n  template&lt;typename... _Types&gt;\n    constexpr std::variant&lt;_Types...&gt;&amp;\n    __as(std::variant&lt;_Types...&gt;&amp; __v) noexcept\n    { return __v; }\n\n  template&lt;typename... _Types&gt;\n    constexpr const std::variant&lt;_Types...&gt;&amp;\n    __as(const std::variant&lt;_Types...&gt;&amp; __v) noexcept\n    { return __v; }\n\n  template&lt;typename... _Types&gt;\n    constexpr std::variant&lt;_Types...&gt;&amp;&amp;\n    __as(std::variant&lt;_Types...&gt;&amp;&amp; __v) noexcept\n    { return std::move(__v); }\n\n  template&lt;typename... _Types&gt;\n    constexpr const std::variant&lt;_Types...&gt;&amp;&amp;\n    __as(const std::variant&lt;_Types...&gt;&amp;&amp; __v) noexcept\n    { return std::move(__v); }\n\n  // For C++17:\n  // _Uninitialized&lt;T&gt; is guaranteed to be a trivially destructible type,\n  // even if T is not.\n  // For C++20:\n  // _Uninitialized&lt;T&gt; is trivially destructible iff T is, so _Variant_union\n  // needs a constrained non-trivial destructor.\n  template&lt;typename _Type, bool = std::is_trivially_destructible_v&lt;_Type&gt;&gt;\n    struct _Uninitialized;\n\n  template&lt;typename _Type&gt;\n    struct _Uninitialized&lt;_Type, true&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tconstexpr\n\t_Uninitialized(in_place_index_t&lt;0&gt;, _Args&amp;&amp;... __args)\n\t: _M_storage(std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      constexpr const _Type&amp; _M_get() const &amp; noexcept\n      { return _M_storage; }\n\n      constexpr _Type&amp; _M_get() &amp; noexcept\n      { return _M_storage; }\n\n      constexpr const _Type&amp;&amp; _M_get() const &amp;&amp; noexcept\n      { return std::move(_M_storage); }\n\n      constexpr _Type&amp;&amp; _M_get() &amp;&amp; noexcept\n      { return std::move(_M_storage); }\n\n      _Type _M_storage;\n    };\n\n  template&lt;typename _Type&gt;\n    struct _Uninitialized&lt;_Type, false&gt;\n    {\n#if __cpp_lib_variant &gt;= 202106L\n      template&lt;typename... _Args&gt;\n\tconstexpr\n\t_Uninitialized(in_place_index_t&lt;0&gt;, _Args&amp;&amp;... __args)\n\t: _M_storage(std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      constexpr ~_Uninitialized() { }\n\n      _Uninitialized(const _Uninitialized&amp;) = default;\n      _Uninitialized(_Uninitialized&amp;&amp;) = default;\n      _Uninitialized&amp; operator=(const _Uninitialized&amp;) = default;\n      _Uninitialized&amp; operator=(_Uninitialized&amp;&amp;) = default;\n\n      constexpr const _Type&amp; _M_get() const &amp; noexcept\n      { return _M_storage; }\n\n      constexpr _Type&amp; _M_get() &amp; noexcept\n      { return _M_storage; }\n\n      constexpr const _Type&amp;&amp; _M_get() const &amp;&amp; noexcept\n      { return std::move(_M_storage); }\n\n      constexpr _Type&amp;&amp; _M_get() &amp;&amp; noexcept\n      { return std::move(_M_storage); }\n\n      struct _Empty_byte { };\n\n      union {\n\t_Empty_byte _M_empty;\n\t_Type _M_storage;\n      };\n#else\n      template&lt;typename... _Args&gt;\n\tconstexpr\n\t_Uninitialized(in_place_index_t&lt;0&gt;, _Args&amp;&amp;... __args)\n\t{\n\t  ::new ((void*)std::addressof(_M_storage))\n\t    _Type(std::forward&lt;_Args&gt;(__args)...);\n\t}\n\n      const _Type&amp; _M_get() const &amp; noexcept\n      { return *_M_storage._M_ptr(); }\n\n      _Type&amp; _M_get() &amp; noexcept\n      { return *_M_storage._M_ptr(); }\n\n      const _Type&amp;&amp; _M_get() const &amp;&amp; noexcept\n      { return std::move(*_M_storage._M_ptr()); }\n\n      _Type&amp;&amp; _M_get() &amp;&amp; noexcept\n      { return std::move(*_M_storage._M_ptr()); }\n\n      __gnu_cxx::__aligned_membuf&lt;_Type&gt; _M_storage;\n#endif\n    };\n\n  template&lt;size_t _Np, typename _Union&gt;\n    constexpr decltype(auto)\n    __get_n(_Union&amp;&amp; __u) noexcept\n    {\n      if constexpr (_Np == 0)\n\treturn std::forward&lt;_Union&gt;(__u)._M_first._M_get();\n      else if constexpr (_Np == 1)\n\treturn std::forward&lt;_Union&gt;(__u)._M_rest._M_first._M_get();\n      else if constexpr (_Np == 2)\n\treturn std::forward&lt;_Union&gt;(__u)._M_rest._M_rest._M_first._M_get();\n      else\n\treturn __variant::__get_n&lt;_Np - 3&gt;(\n\t\t std::forward&lt;_Union&gt;(__u)._M_rest._M_rest._M_rest);\n    }\n\n  // Returns the typed storage for __v.\n  template&lt;size_t _Np, typename _Variant&gt;\n    constexpr decltype(auto)\n    __get(_Variant&amp;&amp; __v) noexcept\n    { return __variant::__get_n&lt;_Np&gt;(std::forward&lt;_Variant&gt;(__v)._M_u); }\n\n  // Gets the _Uninitialized to construct into for __u.\n  template&lt;size_t _Np, typename _Union&gt;\n    constexpr decltype(auto)\n    __construct_n(_Union&amp; __u) noexcept\n    {\n      if constexpr (_Np == 0)\n\treturn &amp;__u._M_first;\n      else if constexpr (_Np == 1)\n\t{\n\t  std::_Construct(&amp;__u._M_rest);\n\t  return &amp;__u._M_rest._M_first;\n\t}\n      else if constexpr (_Np == 2)\n\t{\n\t  std::_Construct(&amp;__u._M_rest);\n\t  std::_Construct(&amp;__u._M_rest._M_rest);\n\t  return &amp;__u._M_rest._M_rest._M_first;\n\t}\n      else\n\t{\n\t  std::_Construct(&amp;__u._M_rest);\n\t  std::_Construct(&amp;__u._M_rest._M_rest);\n\t  std::_Construct(&amp;__u._M_rest._M_rest._M_rest);\n\t  return __variant::__construct_n&lt;_Np - 3&gt;(__u._M_rest._M_rest._M_rest);\n\t}\n    }\n\n  template&lt;typename... _Types&gt;\n    struct _Traits\n    {\n      static constexpr bool _S_default_ctor =\n\t  is_default_constructible_v&lt;typename _Nth_type&lt;0, _Types...&gt;::type&gt;;\n      static constexpr bool _S_copy_ctor =\n\t  (is_copy_constructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_move_ctor =\n\t  (is_move_constructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_copy_assign =\n\t  _S_copy_ctor\n\t  &amp;&amp; (is_copy_assignable_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_move_assign =\n\t  _S_move_ctor\n\t  &amp;&amp; (is_move_assignable_v&lt;_Types&gt; &amp;&amp; ...);\n\n      static constexpr bool _S_trivial_dtor =\n\t  (is_trivially_destructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_trivial_copy_ctor =\n\t  (is_trivially_copy_constructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_trivial_move_ctor =\n\t  (is_trivially_move_constructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_trivial_copy_assign =\n\t  _S_trivial_dtor &amp;&amp; _S_trivial_copy_ctor\n\t  &amp;&amp; (is_trivially_copy_assignable_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_trivial_move_assign =\n\t  _S_trivial_dtor &amp;&amp; _S_trivial_move_ctor\n\t  &amp;&amp; (is_trivially_move_assignable_v&lt;_Types&gt; &amp;&amp; ...);\n\n      // The following nothrow traits are for non-trivial SMFs. Trivial SMFs\n      // are always nothrow.\n      static constexpr bool _S_nothrow_default_ctor =\n\t  is_nothrow_default_constructible_v&lt;\n\t      typename _Nth_type&lt;0, _Types...&gt;::type&gt;;\n      static constexpr bool _S_nothrow_copy_ctor = false;\n      static constexpr bool _S_nothrow_move_ctor =\n\t  (is_nothrow_move_constructible_v&lt;_Types&gt; &amp;&amp; ...);\n      static constexpr bool _S_nothrow_copy_assign = false;\n      static constexpr bool _S_nothrow_move_assign =\n\t  _S_nothrow_move_ctor\n\t  &amp;&amp; (is_nothrow_move_assignable_v&lt;_Types&gt; &amp;&amp; ...);\n    };\n\n  // Defines members and ctors.\n  template&lt;typename... _Types&gt;\n    union _Variadic_union\n    {\n      _Variadic_union() = default;\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\t_Variadic_union(in_place_index_t&lt;_Np&gt;, _Args&amp;&amp;...) = delete;\n    };\n\n  template&lt;typename _First, typename... _Rest&gt;\n    union _Variadic_union&lt;_First, _Rest...&gt;\n    {\n      constexpr _Variadic_union() : _M_rest() { }\n\n      template&lt;typename... _Args&gt;\n\tconstexpr\n\t_Variadic_union(in_place_index_t&lt;0&gt;, _Args&amp;&amp;... __args)\n\t: _M_first(in_place_index&lt;0&gt;, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\tconstexpr\n\t_Variadic_union(in_place_index_t&lt;_Np&gt;, _Args&amp;&amp;... __args)\n\t: _M_rest(in_place_index&lt;_Np-1&gt;, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n#if __cpp_lib_variant &gt;= 202106L\n      _Variadic_union(const _Variadic_union&amp;) = default;\n      _Variadic_union(_Variadic_union&amp;&amp;) = default;\n      _Variadic_union&amp; operator=(const _Variadic_union&amp;) = default;\n      _Variadic_union&amp; operator=(_Variadic_union&amp;&amp;) = default;\n\n      ~_Variadic_union() = default;\n\n      constexpr ~_Variadic_union()\n\trequires (!__has_trivial_destructor(_First))\n\t      || (!__has_trivial_destructor(_Variadic_union&lt;_Rest...&gt;))\n      { }\n#endif\n\n      _Uninitialized&lt;_First&gt; _M_first;\n      _Variadic_union&lt;_Rest...&gt; _M_rest;\n    };\n\n  // _Never_valueless_alt is true for variant alternatives that can\n  // always be placed in a variant without it becoming valueless.\n\n  // For suitably-small, trivially copyable types we can create temporaries\n  // on the stack and then memcpy them into place.\n  template&lt;typename _Tp&gt;\n    struct _Never_valueless_alt\n    : __and_&lt;bool_constant&lt;sizeof(_Tp) &lt;= 256&gt;, is_trivially_copyable&lt;_Tp&gt;&gt;\n    { };\n\n  // Specialize _Never_valueless_alt for other types which have a\n  // non-throwing and cheap move construction and move assignment operator,\n  // so that emplacing the type will provide the strong exception-safety\n  // guarantee, by creating and moving a temporary.\n  // Whether _Never_valueless_alt&lt;T&gt; is true or not affects the ABI of a\n  // variant using that alternative, so we can&#x27;t change the value later!\n\n  // True if every alternative in _Types... can be emplaced in a variant\n  // without it becoming valueless. If this is true, variant&lt;_Types...&gt;\n  // can never be valueless, which enables some minor optimizations.\n  template &lt;typename... _Types&gt;\n    constexpr bool __never_valueless()\n    {\n      return _Traits&lt;_Types...&gt;::_S_move_assign\n\t&amp;&amp; (_Never_valueless_alt&lt;_Types&gt;::value &amp;&amp; ...);\n    }\n\n  // Defines index and the dtor, possibly trivial.\n  template&lt;bool __trivially_destructible, typename... _Types&gt;\n    struct _Variant_storage;\n\n  template &lt;typename... _Types&gt;\n    using __select_index =\n      typename __select_int::_Select_int_base&lt;sizeof...(_Types),\n\t\t\t\t\t      unsigned char,\n\t\t\t\t\t      unsigned short&gt;::type::value_type;\n\n  template&lt;typename... _Types&gt;\n    struct _Variant_storage&lt;false, _Types...&gt;\n    {\n      constexpr\n      _Variant_storage()\n      : _M_index(static_cast&lt;__index_type&gt;(variant_npos))\n      { }\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\tconstexpr\n\t_Variant_storage(in_place_index_t&lt;_Np&gt;, _Args&amp;&amp;... __args)\n\t: _M_u(in_place_index&lt;_Np&gt;, std::forward&lt;_Args&gt;(__args)...),\n\t_M_index{_Np}\n\t{ }\n\n      constexpr void\n      _M_reset()\n      {\n\tif (!_M_valid()) [[unlikely]]\n\t  return;\n\n\tstd::__do_visit&lt;void&gt;([](auto&amp;&amp; __this_mem) mutable\n\t  {\n\t    std::_Destroy(std::__addressof(__this_mem));\n\t  }, __variant_cast&lt;_Types...&gt;(*this));\n\n\t_M_index = static_cast&lt;__index_type&gt;(variant_npos);\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      ~_Variant_storage()\n      { _M_reset(); }\n\n      constexpr bool\n      _M_valid() const noexcept\n      {\n\tif constexpr (__variant::__never_valueless&lt;_Types...&gt;())\n\t  return true;\n\treturn this-&gt;_M_index != __index_type(variant_npos);\n      }\n\n      _Variadic_union&lt;_Types...&gt; _M_u;\n      using __index_type = __select_index&lt;_Types...&gt;;\n      __index_type _M_index;\n    };\n\n  template&lt;typename... _Types&gt;\n    struct _Variant_storage&lt;true, _Types...&gt;\n    {\n      constexpr\n      _Variant_storage()\n      : _M_index(static_cast&lt;__index_type&gt;(variant_npos))\n      { }\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\tconstexpr\n\t_Variant_storage(in_place_index_t&lt;_Np&gt;, _Args&amp;&amp;... __args)\n\t: _M_u(in_place_index&lt;_Np&gt;, std::forward&lt;_Args&gt;(__args)...),\n\t_M_index{_Np}\n\t{ }\n\n      constexpr void\n      _M_reset() noexcept\n      { _M_index = static_cast&lt;__index_type&gt;(variant_npos); }\n\n      constexpr bool\n      _M_valid() const noexcept\n      {\n\tif constexpr (__variant::__never_valueless&lt;_Types...&gt;())\n\t  return true;\n\t// It would be nice if we could just return true for -fno-exceptions.\n\t// It&#x27;s possible (but inadvisable) that a std::variant could become\n\t// valueless in a translation unit compiled with -fexceptions and then\n\t// be passed to functions compiled with -fno-exceptions. We would need\n\t// some #ifdef _GLIBCXX_NO_EXCEPTIONS_GLOBALLY property to elide all\n\t// checks for valueless_by_exception().\n\treturn this-&gt;_M_index != static_cast&lt;__index_type&gt;(variant_npos);\n      }\n\n      _Variadic_union&lt;_Types...&gt; _M_u;\n      using __index_type = __select_index&lt;_Types...&gt;;\n      __index_type _M_index;\n    };\n\n  // Implementation of v.emplace&lt;N&gt;(args...).\n  template&lt;size_t _Np, bool _Triv, typename... _Types, typename... _Args&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    __emplace(_Variant_storage&lt;_Triv, _Types...&gt;&amp; __v, _Args&amp;&amp;... __args)\n    {\n      __v._M_reset();\n      auto* __addr = __variant::__construct_n&lt;_Np&gt;(__v._M_u);\n      std::_Construct(__addr, in_place_index&lt;0&gt;,\n\t\t      std::forward&lt;_Args&gt;(__args)...);\n      // Construction didn&#x27;t throw, so can set the new index now:\n      __v._M_index = _Np;\n    }\n\n  template&lt;typename... _Types&gt;\n    using _Variant_storage_alias =\n\t_Variant_storage&lt;_Traits&lt;_Types...&gt;::_S_trivial_dtor, _Types...&gt;;\n\n  // The following are (Copy|Move) (ctor|assign) layers for forwarding\n  // triviality and handling non-trivial SMF behaviors.\n\n  template&lt;bool, typename... _Types&gt;\n    struct _Copy_ctor_base : _Variant_storage_alias&lt;_Types...&gt;\n    {\n      using _Base = _Variant_storage_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n\n      _GLIBCXX20_CONSTEXPR\n      _Copy_ctor_base(const _Copy_ctor_base&amp; __rhs)\n\t  noexcept(_Traits&lt;_Types...&gt;::_S_nothrow_copy_ctor)\n      {\n\t__variant::__raw_idx_visit(\n\t  [this](auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable\n\t  {\n\t    constexpr size_t __j = __rhs_index;\n\t    if constexpr (__j != variant_npos)\n\t      std::_Construct(std::__addressof(this-&gt;_M_u),\n\t\t\t      in_place_index&lt;__j&gt;, __rhs_mem);\n\t  }, __variant_cast&lt;_Types...&gt;(__rhs));\n\tthis-&gt;_M_index = __rhs._M_index;\n      }\n\n      _Copy_ctor_base(_Copy_ctor_base&amp;&amp;) = default;\n      _Copy_ctor_base&amp; operator=(const _Copy_ctor_base&amp;) = default;\n      _Copy_ctor_base&amp; operator=(_Copy_ctor_base&amp;&amp;) = default;\n    };\n\n  template&lt;typename... _Types&gt;\n    struct _Copy_ctor_base&lt;true, _Types...&gt; : _Variant_storage_alias&lt;_Types...&gt;\n    {\n      using _Base = _Variant_storage_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n    };\n\n  template&lt;typename... _Types&gt;\n    using _Copy_ctor_alias =\n\t_Copy_ctor_base&lt;_Traits&lt;_Types...&gt;::_S_trivial_copy_ctor, _Types...&gt;;\n\n  template&lt;bool, typename... _Types&gt;\n    struct _Move_ctor_base : _Copy_ctor_alias&lt;_Types...&gt;\n    {\n      using _Base = _Copy_ctor_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n\n      _GLIBCXX20_CONSTEXPR\n      _Move_ctor_base(_Move_ctor_base&amp;&amp; __rhs)\n\t  noexcept(_Traits&lt;_Types...&gt;::_S_nothrow_move_ctor)\n      {\n\t__variant::__raw_idx_visit(\n\t  [this](auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable\n\t  {\n\t    constexpr size_t __j = __rhs_index;\n\t    if constexpr (__j != variant_npos)\n\t      std::_Construct(std::__addressof(this-&gt;_M_u),\n\t\t\t      in_place_index&lt;__j&gt;,\n\t\t\t      std::forward&lt;decltype(__rhs_mem)&gt;(__rhs_mem));\n\t  }, __variant_cast&lt;_Types...&gt;(std::move(__rhs)));\n\tthis-&gt;_M_index = __rhs._M_index;\n      }\n\n      _Move_ctor_base(const _Move_ctor_base&amp;) = default;\n      _Move_ctor_base&amp; operator=(const _Move_ctor_base&amp;) = default;\n      _Move_ctor_base&amp; operator=(_Move_ctor_base&amp;&amp;) = default;\n    };\n\n  template&lt;typename... _Types&gt;\n    struct _Move_ctor_base&lt;true, _Types...&gt; : _Copy_ctor_alias&lt;_Types...&gt;\n    {\n      using _Base = _Copy_ctor_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n    };\n\n  template&lt;typename... _Types&gt;\n    using _Move_ctor_alias =\n\t_Move_ctor_base&lt;_Traits&lt;_Types...&gt;::_S_trivial_move_ctor, _Types...&gt;;\n\n  template&lt;bool, typename... _Types&gt;\n    struct _Copy_assign_base : _Move_ctor_alias&lt;_Types...&gt;\n    {\n      using _Base = _Move_ctor_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n\n      _GLIBCXX20_CONSTEXPR\n      _Copy_assign_base&amp;\n      operator=(const _Copy_assign_base&amp; __rhs)\n\t  noexcept(_Traits&lt;_Types...&gt;::_S_nothrow_copy_assign)\n      {\n\t__variant::__raw_idx_visit(\n\t  [this](auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable\n\t  {\n\t    constexpr size_t __j = __rhs_index;\n\t    if constexpr (__j == variant_npos)\n\t      this-&gt;_M_reset(); // Make *this valueless.\n\t    else if (this-&gt;_M_index == __j)\n\t      __variant::__get&lt;__j&gt;(*this) = __rhs_mem;\n\t    else\n\t      {\n\t\tusing _Tj = typename _Nth_type&lt;__j, _Types...&gt;::type;\n\t\tif constexpr (is_nothrow_copy_constructible_v&lt;_Tj&gt;\n\t\t\t      || !is_nothrow_move_constructible_v&lt;_Tj&gt;)\n\t\t  __variant::__emplace&lt;__j&gt;(*this, __rhs_mem);\n\t\telse\n\t\t  {\n\t\t    using _Variant = variant&lt;_Types...&gt;;\n\t\t    _Variant&amp; __self = __variant_cast&lt;_Types...&gt;(*this);\n\t\t    __self = _Variant(in_place_index&lt;__j&gt;, __rhs_mem);\n\t\t  }\n\t      }\n\t  }, __variant_cast&lt;_Types...&gt;(__rhs));\n\treturn *this;\n      }\n\n      _Copy_assign_base(const _Copy_assign_base&amp;) = default;\n      _Copy_assign_base(_Copy_assign_base&amp;&amp;) = default;\n      _Copy_assign_base&amp; operator=(_Copy_assign_base&amp;&amp;) = default;\n    };\n\n  template&lt;typename... _Types&gt;\n    struct _Copy_assign_base&lt;true, _Types...&gt; : _Move_ctor_alias&lt;_Types...&gt;\n    {\n      using _Base = _Move_ctor_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n    };\n\n  template&lt;typename... _Types&gt;\n    using _Copy_assign_alias =\n      _Copy_assign_base&lt;_Traits&lt;_Types...&gt;::_S_trivial_copy_assign, _Types...&gt;;\n\n  template&lt;bool, typename... _Types&gt;\n    struct _Move_assign_base : _Copy_assign_alias&lt;_Types...&gt;\n    {\n      using _Base = _Copy_assign_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n\n      _GLIBCXX20_CONSTEXPR\n      _Move_assign_base&amp;\n      operator=(_Move_assign_base&amp;&amp; __rhs)\n\t  noexcept(_Traits&lt;_Types...&gt;::_S_nothrow_move_assign)\n      {\n\t__variant::__raw_idx_visit(\n\t  [this](auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable\n\t  {\n\t    constexpr size_t __j = __rhs_index;\n\t    if constexpr (__j != variant_npos)\n\t      {\n\t\tif (this-&gt;_M_index == __j)\n\t\t  __variant::__get&lt;__j&gt;(*this) = std::move(__rhs_mem);\n\t\telse\n\t\t  {\n\t\t    using _Tj = typename _Nth_type&lt;__j, _Types...&gt;::type;\n\t\t    if constexpr (is_nothrow_move_constructible_v&lt;_Tj&gt;)\n\t\t      __variant::__emplace&lt;__j&gt;(*this, std::move(__rhs_mem));\n\t\t    else\n\t\t      {\n\t\t\tusing _Variant = variant&lt;_Types...&gt;;\n\t\t\t_Variant&amp; __self = __variant_cast&lt;_Types...&gt;(*this);\n\t\t\t__self.template emplace&lt;__j&gt;(std::move(__rhs_mem));\n\t\t      }\n\t\t  }\n\t      }\n\t    else\n\t      this-&gt;_M_reset();\n\t  }, __variant_cast&lt;_Types...&gt;(__rhs));\n\treturn *this;\n      }\n\n      _Move_assign_base(const _Move_assign_base&amp;) = default;\n      _Move_assign_base(_Move_assign_base&amp;&amp;) = default;\n      _Move_assign_base&amp; operator=(const _Move_assign_base&amp;) = default;\n    };\n\n  template&lt;typename... _Types&gt;\n    struct _Move_assign_base&lt;true, _Types...&gt; : _Copy_assign_alias&lt;_Types...&gt;\n    {\n      using _Base = _Copy_assign_alias&lt;_Types...&gt;;\n      using _Base::_Base;\n    };\n\n  template&lt;typename... _Types&gt;\n    using _Move_assign_alias =\n      _Move_assign_base&lt;_Traits&lt;_Types...&gt;::_S_trivial_move_assign, _Types...&gt;;\n\n  template&lt;typename... _Types&gt;\n    struct _Variant_base : _Move_assign_alias&lt;_Types...&gt;\n    {\n      using _Base = _Move_assign_alias&lt;_Types...&gt;;\n\n      constexpr\n      _Variant_base() noexcept(_Traits&lt;_Types...&gt;::_S_nothrow_default_ctor)\n      : _Variant_base(in_place_index&lt;0&gt;) { }\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\tconstexpr explicit\n\t_Variant_base(in_place_index_t&lt;_Np&gt; __i, _Args&amp;&amp;... __args)\n\t: _Base(__i, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      _Variant_base(const _Variant_base&amp;) = default;\n      _Variant_base(_Variant_base&amp;&amp;) = default;\n      _Variant_base&amp; operator=(const _Variant_base&amp;) = default;\n      _Variant_base&amp; operator=(_Variant_base&amp;&amp;) = default;\n    };\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    inline constexpr bool __exactly_once\n      = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;() &lt; sizeof...(_Types);\n\n  // Helper used to check for valid conversions that don&#x27;t involve narrowing.\n  template&lt;typename _Ti&gt; struct _Arr { _Ti _M_x[1]; };\n\n  // &quot;Build an imaginary function FUN(Ti) for each alternative type Ti&quot;\n  template&lt;size_t _Ind, typename _Tp, typename _Ti, typename = void&gt;\n    struct _Build_FUN\n    {\n      // This function means &#x27;using _Build_FUN&lt;I, T, Ti&gt;::_S_fun;&#x27; is valid,\n      // but only static functions will be considered in the call below.\n      void _S_fun() = delete;\n    };\n\n  // &quot;... for which Ti x[] = {std::forward&lt;T&gt;(t)}; is well-formed.&quot;\n  template&lt;size_t _Ind, typename _Tp, typename _Ti&gt;\n    struct _Build_FUN&lt;_Ind, _Tp, _Ti,\n\t\t      void_t&lt;decltype(_Arr&lt;_Ti&gt;{{std::declval&lt;_Tp&gt;()}})&gt;&gt;\n    {\n      // This is the FUN function for type _Ti, with index _Ind\n      static integral_constant&lt;size_t, _Ind&gt; _S_fun(_Ti);\n    };\n\n  template&lt;typename _Tp, typename _Variant,\n\t   typename = make_index_sequence&lt;variant_size_v&lt;_Variant&gt;&gt;&gt;\n    struct _Build_FUNs;\n\n  template&lt;typename _Tp, typename... _Ti, size_t... _Ind&gt;\n    struct _Build_FUNs&lt;_Tp, variant&lt;_Ti...&gt;, index_sequence&lt;_Ind...&gt;&gt;\n    : _Build_FUN&lt;_Ind, _Tp, _Ti&gt;...\n    {\n      using _Build_FUN&lt;_Ind, _Tp, _Ti&gt;::_S_fun...;\n    };\n\n  // The index j of the overload FUN(Tj) selected by overload resolution\n  // for FUN(std::forward&lt;_Tp&gt;(t))\n  template&lt;typename _Tp, typename _Variant&gt;\n    using _FUN_type\n      = decltype(_Build_FUNs&lt;_Tp, _Variant&gt;::_S_fun(std::declval&lt;_Tp&gt;()));\n\n  // The index selected for FUN(std::forward&lt;T&gt;(t)), or variant_npos if none.\n  template&lt;typename _Tp, typename _Variant, typename = void&gt;\n    inline constexpr size_t\n    __accepted_index = variant_npos;\n\n  template&lt;typename _Tp, typename _Variant&gt;\n    inline constexpr size_t\n    __accepted_index&lt;_Tp, _Variant, void_t&lt;_FUN_type&lt;_Tp, _Variant&gt;&gt;&gt;\n      = _FUN_type&lt;_Tp, _Variant&gt;::value;\n\n  template&lt;typename _Maybe_variant_cookie, typename _Variant,\n\t   typename = __remove_cvref_t&lt;_Variant&gt;&gt;\n    inline constexpr bool\n    __extra_visit_slot_needed = false;\n\n  template&lt;typename _Var, typename... _Types&gt;\n    inline constexpr bool\n    __extra_visit_slot_needed&lt;__variant_cookie, _Var, variant&lt;_Types...&gt;&gt;\n      = !__variant::__never_valueless&lt;_Types...&gt;();\n\n  template&lt;typename _Var, typename... _Types&gt;\n    inline constexpr bool\n    __extra_visit_slot_needed&lt;__variant_idx_cookie, _Var, variant&lt;_Types...&gt;&gt;\n      = !__variant::__never_valueless&lt;_Types...&gt;();\n\n  // Used for storing a multi-dimensional vtable.\n  template&lt;typename _Tp, size_t... _Dimensions&gt;\n    struct _Multi_array;\n\n  // Partial specialization with rank zero, stores a single _Tp element.\n  template&lt;typename _Tp&gt;\n    struct _Multi_array&lt;_Tp&gt;\n    {\n      template&lt;typename&gt;\n\tstruct __untag_result\n\t: false_type\n\t{ using element_type = _Tp; };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wignored-qualifiers&quot;\n      template &lt;typename... _Args&gt;\n\tstruct __untag_result&lt;const void(*)(_Args...)&gt;\n\t: false_type\n\t{ using element_type = void(*)(_Args...); };\n#pragma GCC diagnostic pop\n\n      template &lt;typename... _Args&gt;\n\tstruct __untag_result&lt;__variant_cookie(*)(_Args...)&gt;\n\t: false_type\n\t{ using element_type = void(*)(_Args...); };\n\n      template &lt;typename... _Args&gt;\n\tstruct __untag_result&lt;__variant_idx_cookie(*)(_Args...)&gt;\n\t: false_type\n\t{ using element_type = void(*)(_Args...); };\n\n      template &lt;typename _Res, typename... _Args&gt;\n\tstruct __untag_result&lt;__deduce_visit_result&lt;_Res&gt;(*)(_Args...)&gt;\n\t: true_type\n\t{ using element_type = _Res(*)(_Args...); };\n\n      using __result_is_deduced = __untag_result&lt;_Tp&gt;;\n\n      constexpr const typename __untag_result&lt;_Tp&gt;::element_type&amp;\n      _M_access() const\n      { return _M_data; }\n\n      typename __untag_result&lt;_Tp&gt;::element_type _M_data;\n    };\n\n  // Partial specialization with rank &gt;= 1.\n  template&lt;typename _Ret,\n\t   typename _Visitor,\n\t   typename... _Variants,\n\t   size_t __first, size_t... __rest&gt;\n    struct _Multi_array&lt;_Ret(*)(_Visitor, _Variants...), __first, __rest...&gt;\n    {\n      static constexpr size_t __index =\n\tsizeof...(_Variants) - sizeof...(__rest) - 1;\n\n      using _Variant = typename _Nth_type&lt;__index, _Variants...&gt;::type;\n\n      static constexpr int __do_cookie =\n\t__extra_visit_slot_needed&lt;_Ret, _Variant&gt; ? 1 : 0;\n\n      using _Tp = _Ret(*)(_Visitor, _Variants...);\n\n      template&lt;typename... _Args&gt;\n\tconstexpr decltype(auto)\n\t_M_access(size_t __first_index, _Args... __rest_indices) const\n        {\n\t  return _M_arr[__first_index + __do_cookie]\n\t    ._M_access(__rest_indices...);\n\t}\n\n      _Multi_array&lt;_Tp, __rest...&gt; _M_arr[__first + __do_cookie];\n    };\n\n  // Creates a multi-dimensional vtable recursively.\n  //\n  // For example,\n  // visit([](auto, auto){},\n  //       variant&lt;int, char&gt;(),  // typedef&#x27;ed as V1\n  //       variant&lt;float, double, long double&gt;())  // typedef&#x27;ed as V2\n  // will trigger instantiations of:\n  // __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;), 2, 3&gt;,\n  //                   tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;&gt;&gt;\n  //   __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;), 3&gt;,\n  //                     tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;0&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;0, 0&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;0, 1&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;0, 2&gt;&gt;\n  //   __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;), 3&gt;,\n  //                     tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;1&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;1, 0&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;1, 1&gt;&gt;\n  //     __gen_vtable_impl&lt;_Multi_array&lt;void(*)(V1&amp;&amp;, V2&amp;&amp;)&gt;,\n  //                       tuple&lt;V1&amp;&amp;, V2&amp;&amp;&gt;, std::index_sequence&lt;1, 2&gt;&gt;\n  // The returned multi-dimensional vtable can be fast accessed by the visitor\n  // using index calculation.\n  template&lt;typename _Array_type, typename _Index_seq&gt;\n    struct __gen_vtable_impl;\n\n  // Defines the _S_apply() member that returns a _Multi_array populated\n  // with function pointers that perform the visitation expressions e(m)\n  // for each valid pack of indexes into the variant types _Variants.\n  //\n  // This partial specialization builds up the index sequences by recursively\n  // calling _S_apply() on the next specialization of __gen_vtable_impl.\n  // The base case of the recursion defines the actual function pointers.\n  template&lt;typename _Result_type, typename _Visitor, size_t... __dimensions,\n\t   typename... _Variants, size_t... __indices&gt;\n    struct __gen_vtable_impl&lt;\n\t_Multi_array&lt;_Result_type (*)(_Visitor, _Variants...), __dimensions...&gt;,\n\tstd::index_sequence&lt;__indices...&gt;&gt;\n    {\n      using _Next =\n\t  remove_reference_t&lt;typename _Nth_type&lt;sizeof...(__indices),\n\t\t\t     _Variants...&gt;::type&gt;;\n      using _Array_type =\n\t  _Multi_array&lt;_Result_type (*)(_Visitor, _Variants...),\n\t\t       __dimensions...&gt;;\n\n      static constexpr _Array_type\n      _S_apply()\n      {\n\t_Array_type __vtable{};\n\t_S_apply_all_alts(\n\t  __vtable, make_index_sequence&lt;variant_size_v&lt;_Next&gt;&gt;());\n\treturn __vtable;\n      }\n\n      template&lt;size_t... __var_indices&gt;\n\tstatic constexpr void\n\t_S_apply_all_alts(_Array_type&amp; __vtable,\n\t\t\t  std::index_sequence&lt;__var_indices...&gt;)\n\t{\n\t  if constexpr (__extra_visit_slot_needed&lt;_Result_type, _Next&gt;)\n\t    (_S_apply_single_alt&lt;true, __var_indices&gt;(\n\t      __vtable._M_arr[__var_indices + 1],\n\t      &amp;(__vtable._M_arr[0])), ...);\n\t  else\n\t    (_S_apply_single_alt&lt;false, __var_indices&gt;(\n\t      __vtable._M_arr[__var_indices]), ...);\n\t}\n\n      template&lt;bool __do_cookie, size_t __index, typename _Tp&gt;\n\tstatic constexpr void\n\t_S_apply_single_alt(_Tp&amp; __element, _Tp* __cookie_element = nullptr)\n\t{\n\t  if constexpr (__do_cookie)\n\t    {\n\t      __element = __gen_vtable_impl&lt;\n\t\t_Tp,\n\t\tstd::index_sequence&lt;__indices..., __index&gt;&gt;::_S_apply();\n\t      *__cookie_element = __gen_vtable_impl&lt;\n\t\t_Tp,\n\t\tstd::index_sequence&lt;__indices..., variant_npos&gt;&gt;::_S_apply();\n\t    }\n\t  else\n\t    {\n\t      auto __tmp_element = __gen_vtable_impl&lt;\n\t\tremove_reference_t&lt;decltype(__element)&gt;,\n\t\tstd::index_sequence&lt;__indices..., __index&gt;&gt;::_S_apply();\n\t      static_assert(is_same_v&lt;_Tp, decltype(__tmp_element)&gt;,\n\t\t\t    &quot;std::visit requires the visitor to have the same &quot;\n\t\t\t    &quot;return type for all alternatives of a variant&quot;);\n\t      __element = __tmp_element;\n\t    }\n\t}\n    };\n\n  // This partial specialization is the base case for the recursion.\n  // It populates a _Multi_array element with the address of a function\n  // that invokes the visitor with the alternatives specified by __indices.\n  template&lt;typename _Result_type, typename _Visitor, typename... _Variants,\n\t   size_t... __indices&gt;\n    struct __gen_vtable_impl&lt;\n      _Multi_array&lt;_Result_type (*)(_Visitor, _Variants...)&gt;,\n\t\t   std::index_sequence&lt;__indices...&gt;&gt;\n    {\n      using _Array_type =\n\t  _Multi_array&lt;_Result_type (*)(_Visitor, _Variants...)&gt;;\n\n      template&lt;size_t __index, typename _Variant&gt;\n\tstatic constexpr decltype(auto)\n\t__element_by_index_or_cookie(_Variant&amp;&amp; __var) noexcept\n        {\n\t  if constexpr (__index != variant_npos)\n\t    return __variant::__get&lt;__index&gt;(std::forward&lt;_Variant&gt;(__var));\n\t  else\n\t    return __variant_cookie{};\n\t}\n\n      static constexpr decltype(auto)\n      __visit_invoke(_Visitor&amp;&amp; __visitor, _Variants... __vars)\n      {\n\tif constexpr (is_same_v&lt;_Result_type, __variant_idx_cookie&gt;)\n\t  // For raw visitation using indices, pass the indices to the visitor\n\t  // and discard the return value:\n\t  std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),\n\t      __element_by_index_or_cookie&lt;__indices&gt;(\n\t\tstd::forward&lt;_Variants&gt;(__vars))...,\n\t      integral_constant&lt;size_t, __indices&gt;()...);\n\telse if constexpr (is_same_v&lt;_Result_type, __variant_cookie&gt;)\n\t  // For raw visitation without indices, and discard the return value:\n\t  std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),\n\t      __element_by_index_or_cookie&lt;__indices&gt;(\n\t\tstd::forward&lt;_Variants&gt;(__vars))...);\n\telse if constexpr (_Array_type::__result_is_deduced::value)\n\t  // For the usual std::visit case deduce the return value:\n\t  return std::__invoke(std::forward&lt;_Visitor&gt;(__visitor),\n\t      __element_by_index_or_cookie&lt;__indices&gt;(\n\t\tstd::forward&lt;_Variants&gt;(__vars))...);\n\telse // for std::visit&lt;R&gt; use INVOKE&lt;R&gt;\n\t  return std::__invoke_r&lt;_Result_type&gt;(\n\t      std::forward&lt;_Visitor&gt;(__visitor),\n\t      __variant::__get&lt;__indices&gt;(std::forward&lt;_Variants&gt;(__vars))...);\n      }\n\n      static constexpr auto\n      _S_apply()\n      {\n\tif constexpr (_Array_type::__result_is_deduced::value)\n\t  {\n\t    constexpr bool __visit_ret_type_mismatch =\n\t      !is_same_v&lt;typename _Result_type::type,\n\t\t\t decltype(__visit_invoke(std::declval&lt;_Visitor&gt;(),\n\t\t\t\t    std::declval&lt;_Variants&gt;()...))&gt;;\n\t    if constexpr (__visit_ret_type_mismatch)\n\t      {\n\t\tstruct __cannot_match {};\n\t\treturn __cannot_match{};\n\t      }\n\t    else\n\t      return _Array_type{&amp;__visit_invoke};\n\t  }\n\telse\n\t  return _Array_type{&amp;__visit_invoke};\n      }\n    };\n\n  template&lt;typename _Result_type, typename _Visitor, typename... _Variants&gt;\n    struct __gen_vtable\n    {\n      using _Array_type =\n\t  _Multi_array&lt;_Result_type (*)(_Visitor, _Variants...),\n\t\t       variant_size_v&lt;remove_reference_t&lt;_Variants&gt;&gt;...&gt;;\n\n      static constexpr _Array_type _S_vtable\n\t= __gen_vtable_impl&lt;_Array_type, std::index_sequence&lt;&gt;&gt;::_S_apply();\n    };\n\n  template&lt;size_t _Np, typename _Tp&gt;\n    struct _Base_dedup : public _Tp { };\n\n  template&lt;typename _Variant, typename __indices&gt;\n    struct _Variant_hash_base;\n\n  template&lt;typename... _Types, size_t... __indices&gt;\n    struct _Variant_hash_base&lt;variant&lt;_Types...&gt;,\n\t\t\t      std::index_sequence&lt;__indices...&gt;&gt;\n    : _Base_dedup&lt;__indices, __poison_hash&lt;remove_const_t&lt;_Types&gt;&gt;&gt;... { };\n\n  // Equivalent to decltype(get&lt;_Np&gt;(as-variant(declval&lt;_Variant&gt;())))\n  template&lt;size_t _Np, typename _Variant,\n      typename _AsV = decltype(__variant::__as(std::declval&lt;_Variant&gt;())),\n      typename _Tp = variant_alternative_t&lt;_Np, remove_reference_t&lt;_AsV&gt;&gt;&gt;\n    using __get_t\n      = __conditional_t&lt;is_lvalue_reference_v&lt;_Variant&gt;, _Tp&amp;, _Tp&amp;&amp;&gt;;\n\n  // Return type of std::visit.\n  template&lt;typename _Visitor, typename... _Variants&gt;\n    using __visit_result_t\n      = invoke_result_t&lt;_Visitor, __get_t&lt;0, _Variants&gt;...&gt;;\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr inline bool __same_types = (is_same_v&lt;_Tp, _Types&gt; &amp;&amp; ...);\n\n  template &lt;typename _Visitor, typename _Variant, size_t... _Idxs&gt;\n    constexpr bool __check_visitor_results(std::index_sequence&lt;_Idxs...&gt;)\n    {\n      return __same_types&lt;\n\tinvoke_result_t&lt;_Visitor, __get_t&lt;_Idxs, _Variant&gt;&gt;...\n\t&gt;;\n    }\n\n} // namespace __variant\n} // namespace __detail\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr bool\n    holds_alternative(const variant&lt;_Types...&gt;&amp; __v) noexcept\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      return __v.index() == std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr _Tp&amp;\n    get(variant&lt;_Types...&gt;&amp; __v)\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get&lt;__n&gt;(__v);\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr _Tp&amp;&amp;\n    get(variant&lt;_Types...&gt;&amp;&amp; __v)\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get&lt;__n&gt;(std::move(__v));\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr const _Tp&amp;\n    get(const variant&lt;_Types...&gt;&amp; __v)\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get&lt;__n&gt;(__v);\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr const _Tp&amp;&amp;\n    get(const variant&lt;_Types...&gt;&amp;&amp; __v)\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get&lt;__n&gt;(std::move(__v));\n    }\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr add_pointer_t&lt;variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&gt;\n    get_if(variant&lt;_Types...&gt;* __ptr) noexcept\n    {\n      using _Alternative_type = variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;;\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      static_assert(!is_void_v&lt;_Alternative_type&gt;, &quot;_Tp must not be void&quot;);\n      if (__ptr &amp;&amp; __ptr-&gt;index() == _Np)\n\treturn std::addressof(__detail::__variant::__get&lt;_Np&gt;(*__ptr));\n      return nullptr;\n    }\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr\n    add_pointer_t&lt;const variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&gt;\n    get_if(const variant&lt;_Types...&gt;* __ptr) noexcept\n    {\n      using _Alternative_type = variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;;\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      static_assert(!is_void_v&lt;_Alternative_type&gt;, &quot;_Tp must not be void&quot;);\n      if (__ptr &amp;&amp; __ptr-&gt;index() == _Np)\n\treturn std::addressof(__detail::__variant::__get&lt;_Np&gt;(*__ptr));\n      return nullptr;\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr add_pointer_t&lt;_Tp&gt;\n    get_if(variant&lt;_Types...&gt;* __ptr) noexcept\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      static_assert(!is_void_v&lt;_Tp&gt;, &quot;_Tp must not be void&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get_if&lt;__n&gt;(__ptr);\n    }\n\n  template&lt;typename _Tp, typename... _Types&gt;\n    constexpr add_pointer_t&lt;const _Tp&gt;\n    get_if(const variant&lt;_Types...&gt;* __ptr) noexcept\n    {\n      static_assert(__detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;,\n\t\t    &quot;T must occur exactly once in alternatives&quot;);\n      static_assert(!is_void_v&lt;_Tp&gt;, &quot;_Tp must not be void&quot;);\n      constexpr size_t __n = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n      return std::get_if&lt;__n&gt;(__ptr);\n    }\n\n  struct monostate { };\n\n#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \\\n  template&lt;typename... _Types&gt; \\\n    constexpr bool operator __OP(const variant&lt;_Types...&gt;&amp; __lhs, \\\n\t\t\t\t const variant&lt;_Types...&gt;&amp; __rhs) \\\n    { \\\n      bool __ret = true; \\\n      __detail::__variant::__raw_idx_visit( \\\n        [&amp;__ret, &amp;__lhs] (auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable \\\n        { \\\n\t  if constexpr (__rhs_index != variant_npos) \\\n\t    { \\\n\t      if (__lhs.index() == __rhs_index) \\\n\t        { \\\n\t\t  auto&amp; __this_mem = std::get&lt;__rhs_index&gt;(__lhs);\t\\\n                  __ret = __this_mem __OP __rhs_mem; \\\n                } \\\n\t      else \\\n\t\t__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \\\n            } \\\n          else \\\n            __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \\\n\t}, __rhs); \\\n      return __ret; \\\n    }\n\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(&lt;, less)\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(&lt;=, less_equal)\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(&gt;=, greater_equal)\n  _VARIANT_RELATION_FUNCTION_TEMPLATE(&gt;, greater)\n\n#undef _VARIANT_RELATION_FUNCTION_TEMPLATE\n\n  constexpr bool operator==(monostate, monostate) noexcept { return true; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename... _Types&gt;\n    requires (three_way_comparable&lt;_Types&gt; &amp;&amp; ...)\n    constexpr\n    common_comparison_category_t&lt;compare_three_way_result_t&lt;_Types&gt;...&gt;\n    operator&lt;=&gt;(const variant&lt;_Types...&gt;&amp; __v, const variant&lt;_Types...&gt;&amp; __w)\n    {\n      common_comparison_category_t&lt;compare_three_way_result_t&lt;_Types&gt;...&gt; __ret\n\t= strong_ordering::equal;\n\n      __detail::__variant::__raw_idx_visit(\n\t[&amp;__ret, &amp;__v] (auto&amp;&amp; __w_mem, auto __w_index) mutable\n\t{\n\t  if constexpr (__w_index != variant_npos)\n\t    {\n\t      if (__v.index() == __w_index)\n\t\t{\n\t\t  auto&amp; __this_mem = std::get&lt;__w_index&gt;(__v);\n\t\t  __ret = __this_mem &lt;=&gt; __w_mem;\n\t\t  return;\n\t\t}\n\t    }\n\t  __ret = (__v.index() + 1) &lt;=&gt; (__w_index + 1);\n\t}, __w);\n      return __ret;\n    }\n\n  constexpr strong_ordering\n  operator&lt;=&gt;(monostate, monostate) noexcept { return strong_ordering::equal; }\n#else\n  constexpr bool operator!=(monostate, monostate) noexcept { return false; }\n  constexpr bool operator&lt;(monostate, monostate) noexcept { return false; }\n  constexpr bool operator&gt;(monostate, monostate) noexcept { return false; }\n  constexpr bool operator&lt;=(monostate, monostate) noexcept { return true; }\n  constexpr bool operator&gt;=(monostate, monostate) noexcept { return true; }\n#endif\n\n  template&lt;typename _Visitor, typename... _Variants&gt;\n    constexpr __detail::__variant::__visit_result_t&lt;_Visitor, _Variants...&gt;\n    visit(_Visitor&amp;&amp;, _Variants&amp;&amp;...);\n\n  template&lt;typename... _Types&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline enable_if_t&lt;(is_move_constructible_v&lt;_Types&gt; &amp;&amp; ...)\n\t\t\t&amp;&amp; (is_swappable_v&lt;_Types&gt; &amp;&amp; ...)&gt;\n    swap(variant&lt;_Types...&gt;&amp; __lhs, variant&lt;_Types...&gt;&amp; __rhs)\n    noexcept(noexcept(__lhs.swap(__rhs)))\n    { __lhs.swap(__rhs); }\n\n  template&lt;typename... _Types&gt;\n    enable_if_t&lt;!((is_move_constructible_v&lt;_Types&gt; &amp;&amp; ...)\n\t\t   &amp;&amp; (is_swappable_v&lt;_Types&gt; &amp;&amp; ...))&gt;\n    swap(variant&lt;_Types...&gt;&amp;, variant&lt;_Types...&gt;&amp;) = delete;\n\n  class bad_variant_access : public exception\n  {\n  public:\n    bad_variant_access() noexcept { }\n\n    const char* what() const noexcept override\n    { return _M_reason; }\n\n  private:\n    bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }\n\n    // Must point to a string with static storage duration:\n    const char* _M_reason = &quot;bad variant access&quot;;\n\n    friend void __throw_bad_variant_access(const char* __what);\n  };\n\n  // Must only be called with a string literal\n  inline void\n  __throw_bad_variant_access(const char* __what)\n  { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }\n\n  inline void\n  __throw_bad_variant_access(bool __valueless)\n  {\n    if (__valueless) [[__unlikely__]]\n      __throw_bad_variant_access(&quot;std::get: variant is valueless&quot;);\n    else\n      __throw_bad_variant_access(&quot;std::get: wrong index for variant&quot;);\n  }\n\n  template&lt;typename... _Types&gt;\n    class variant\n    : private __detail::__variant::_Variant_base&lt;_Types...&gt;,\n      private _Enable_default_constructor&lt;\n\t__detail::__variant::_Traits&lt;_Types...&gt;::_S_default_ctor,\n\t  variant&lt;_Types...&gt;&gt;,\n      private _Enable_copy_move&lt;\n\t__detail::__variant::_Traits&lt;_Types...&gt;::_S_copy_ctor,\n\t__detail::__variant::_Traits&lt;_Types...&gt;::_S_copy_assign,\n\t__detail::__variant::_Traits&lt;_Types...&gt;::_S_move_ctor,\n\t__detail::__variant::_Traits&lt;_Types...&gt;::_S_move_assign,\n\tvariant&lt;_Types...&gt;&gt;\n    {\n    private:\n      template &lt;typename... _UTypes, typename _Tp&gt;\n\tfriend _GLIBCXX20_CONSTEXPR decltype(auto)\n\t__variant_cast(_Tp&amp;&amp;);\n\n      static_assert(sizeof...(_Types) &gt; 0,\n\t\t    &quot;variant must have at least one alternative&quot;);\n      static_assert(!(std::is_reference_v&lt;_Types&gt; || ...),\n\t\t    &quot;variant must have no reference alternative&quot;);\n      static_assert(!(std::is_void_v&lt;_Types&gt; || ...),\n\t\t    &quot;variant must have no void alternative&quot;);\n\n      using _Base = __detail::__variant::_Variant_base&lt;_Types...&gt;;\n      using _Default_ctor_enabler =\n\t_Enable_default_constructor&lt;\n\t  __detail::__variant::_Traits&lt;_Types...&gt;::_S_default_ctor,\n\t    variant&lt;_Types...&gt;&gt;;\n\n      template&lt;typename _Tp&gt;\n\tstatic constexpr bool __not_self\n\t  = !is_same_v&lt;__remove_cvref_t&lt;_Tp&gt;, variant&gt;;\n\n      template&lt;typename _Tp&gt;\n\tstatic constexpr bool\n\t__exactly_once = __detail::__variant::__exactly_once&lt;_Tp, _Types...&gt;;\n\n      template&lt;typename _Tp&gt;\n\tstatic constexpr size_t __accepted_index\n\t  = __detail::__variant::__accepted_index&lt;_Tp, variant&gt;;\n\n      template&lt;size_t _Np, typename = enable_if_t&lt;(_Np &lt; sizeof...(_Types))&gt;&gt;\n\tusing __to_type = typename _Nth_type&lt;_Np, _Types...&gt;::type;\n\n      template&lt;typename _Tp, typename = enable_if_t&lt;__not_self&lt;_Tp&gt;&gt;&gt;\n\tusing __accepted_type = __to_type&lt;__accepted_index&lt;_Tp&gt;&gt;;\n\n      template&lt;typename _Tp&gt;\n\tstatic constexpr size_t __index_of\n\t  = std::__find_uniq_type_in_pack&lt;_Tp, _Types...&gt;();\n\n      using _Traits = __detail::__variant::_Traits&lt;_Types...&gt;;\n\n      template&lt;typename _Tp&gt;\n\tstruct __is_in_place_tag : false_type { };\n      template&lt;typename _Tp&gt;\n\tstruct __is_in_place_tag&lt;in_place_type_t&lt;_Tp&gt;&gt; : true_type { };\n      template&lt;size_t _Np&gt;\n\tstruct __is_in_place_tag&lt;in_place_index_t&lt;_Np&gt;&gt; : true_type { };\n\n      template&lt;typename _Tp&gt;\n\tstatic constexpr bool __not_in_place_tag\n\t  = !__is_in_place_tag&lt;__remove_cvref_t&lt;_Tp&gt;&gt;::value;\n\n    public:\n      variant() = default;\n      variant(const variant&amp; __rhs) = default;\n      variant(variant&amp;&amp;) = default;\n      variant&amp; operator=(const variant&amp;) = default;\n      variant&amp; operator=(variant&amp;&amp;) = default;\n      _GLIBCXX20_CONSTEXPR ~variant() = default;\n\n      template&lt;typename _Tp,\n\t       typename = enable_if_t&lt;sizeof...(_Types) != 0&gt;,\n\t       typename = enable_if_t&lt;__not_in_place_tag&lt;_Tp&gt;&gt;,\n\t       typename _Tj = __accepted_type&lt;_Tp&amp;&amp;&gt;,\n\t       typename = enable_if_t&lt;__exactly_once&lt;_Tj&gt;\n\t\t\t\t      &amp;&amp; is_constructible_v&lt;_Tj, _Tp&gt;&gt;&gt;\n\tconstexpr\n\tvariant(_Tp&amp;&amp; __t)\n\tnoexcept(is_nothrow_constructible_v&lt;_Tj, _Tp&gt;)\n\t: variant(in_place_index&lt;__accepted_index&lt;_Tp&gt;&gt;,\n\t\t  std::forward&lt;_Tp&gt;(__t))\n\t{ }\n\n      template&lt;typename _Tp, typename... _Args,\n\t       typename = enable_if_t&lt;__exactly_once&lt;_Tp&gt;\n\t\t\t\t      &amp;&amp; is_constructible_v&lt;_Tp, _Args...&gt;&gt;&gt;\n\tconstexpr explicit\n\tvariant(in_place_type_t&lt;_Tp&gt;, _Args&amp;&amp;... __args)\n\t: variant(in_place_index&lt;__index_of&lt;_Tp&gt;&gt;,\n\t\t  std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Tp, typename _Up, typename... _Args,\n\t       typename = enable_if_t&lt;__exactly_once&lt;_Tp&gt;\n\t\t\t\t      &amp;&amp; is_constructible_v&lt;_Tp,\n\t\t\t\t\t   initializer_list&lt;_Up&gt;&amp;, _Args...&gt;&gt;&gt;\n\tconstexpr explicit\n\tvariant(in_place_type_t&lt;_Tp&gt;, initializer_list&lt;_Up&gt; __il,\n\t\t_Args&amp;&amp;... __args)\n\t: variant(in_place_index&lt;__index_of&lt;_Tp&gt;&gt;, __il,\n\t\t  std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;size_t _Np, typename... _Args,\n\t       typename _Tp = __to_type&lt;_Np&gt;,\n\t       typename = enable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt;&gt;&gt;\n\tconstexpr explicit\n\tvariant(in_place_index_t&lt;_Np&gt;, _Args&amp;&amp;... __args)\n\t: _Base(in_place_index&lt;_Np&gt;, std::forward&lt;_Args&gt;(__args)...),\n\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n\t{ }\n\n      template&lt;size_t _Np, typename _Up, typename... _Args,\n\t       typename _Tp = __to_type&lt;_Np&gt;,\n\t       typename = enable_if_t&lt;is_constructible_v&lt;_Tp,\n\t\t\t\t\t\t\t initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t\t\t _Args...&gt;&gt;&gt;\n\tconstexpr explicit\n\tvariant(in_place_index_t&lt;_Np&gt;, initializer_list&lt;_Up&gt; __il,\n\t\t_Args&amp;&amp;... __args)\n\t: _Base(in_place_index&lt;_Np&gt;, __il, std::forward&lt;_Args&gt;(__args)...),\n\t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n\t{ }\n\n      template&lt;typename _Tp&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;__exactly_once&lt;__accepted_type&lt;_Tp&amp;&amp;&gt;&gt;\n\t\t    &amp;&amp; is_constructible_v&lt;__accepted_type&lt;_Tp&amp;&amp;&gt;, _Tp&gt;\n\t\t    &amp;&amp; is_assignable_v&lt;__accepted_type&lt;_Tp&amp;&amp;&gt;&amp;, _Tp&gt;,\n\t\t    variant&amp;&gt;\n\toperator=(_Tp&amp;&amp; __rhs)\n\tnoexcept(is_nothrow_assignable_v&lt;__accepted_type&lt;_Tp&amp;&amp;&gt;&amp;, _Tp&gt;\n\t\t &amp;&amp; is_nothrow_constructible_v&lt;__accepted_type&lt;_Tp&amp;&amp;&gt;, _Tp&gt;)\n\t{\n\t  constexpr auto __index = __accepted_index&lt;_Tp&gt;;\n\t  if (index() == __index)\n\t    std::get&lt;__index&gt;(*this) = std::forward&lt;_Tp&gt;(__rhs);\n\t  else\n\t    {\n\t      using _Tj = __accepted_type&lt;_Tp&amp;&amp;&gt;;\n\t      if constexpr (is_nothrow_constructible_v&lt;_Tj, _Tp&gt;\n\t\t\t    || !is_nothrow_move_constructible_v&lt;_Tj&gt;)\n\t\tthis-&gt;emplace&lt;__index&gt;(std::forward&lt;_Tp&gt;(__rhs));\n\t      else\n\t\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t\t// 3585. converting assignment with immovable alternative\n\t\tthis-&gt;emplace&lt;__index&gt;(_Tj(std::forward&lt;_Tp&gt;(__rhs)));\n\t    }\n\t  return *this;\n\t}\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;_Tp, _Args...&gt; &amp;&amp; __exactly_once&lt;_Tp&gt;,\n\t\t    _Tp&amp;&gt;\n\templace(_Args&amp;&amp;... __args)\n\t{\n\t  constexpr size_t __index = __index_of&lt;_Tp&gt;;\n\t  return this-&gt;emplace&lt;__index&gt;(std::forward&lt;_Args&gt;(__args)...);\n\t}\n\n      template&lt;typename _Tp, typename _Up, typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;_Tp, initializer_list&lt;_Up&gt;&amp;, _Args...&gt;\n\t\t    &amp;&amp; __exactly_once&lt;_Tp&gt;,\n\t\t    _Tp&amp;&gt;\n\templace(initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)\n\t{\n\t  constexpr size_t __index = __index_of&lt;_Tp&gt;;\n\t  return this-&gt;emplace&lt;__index&gt;(__il, std::forward&lt;_Args&gt;(__args)...);\n\t}\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;__to_type&lt;_Np&gt;, _Args...&gt;,\n\t\t    __to_type&lt;_Np&gt;&amp;&gt;\n\templace(_Args&amp;&amp;... __args)\n\t{\n\t  namespace __variant = std::__detail::__variant;\n\t  using type = typename _Nth_type&lt;_Np, _Types...&gt;::type;\n\t  // Provide the strong exception-safety guarantee when possible,\n\t  // to avoid becoming valueless.\n\t  if constexpr (is_nothrow_constructible_v&lt;type, _Args...&gt;)\n\t    {\n\t      __variant::__emplace&lt;_Np&gt;(*this, std::forward&lt;_Args&gt;(__args)...);\n\t    }\n\t  else if constexpr (is_scalar_v&lt;type&gt;)\n\t    {\n\t      // This might invoke a potentially-throwing conversion operator:\n\t      const type __tmp(std::forward&lt;_Args&gt;(__args)...);\n\t      // But this won&#x27;t throw:\n\t      __variant::__emplace&lt;_Np&gt;(*this, __tmp);\n\t    }\n\t  else if constexpr (__variant::_Never_valueless_alt&lt;type&gt;()\n\t      &amp;&amp; _Traits::_S_move_assign)\n\t    {\n\t      // This construction might throw:\n\t      variant __tmp(in_place_index&lt;_Np&gt;,\n\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n\t      // But _Never_valueless_alt&lt;type&gt; means this won&#x27;t:\n\t      *this = std::move(__tmp);\n\t    }\n\t  else\n\t    {\n\t      // This case only provides the basic exception-safety guarantee,\n\t      // i.e. the variant can become valueless.\n\t      __variant::__emplace&lt;_Np&gt;(*this, std::forward&lt;_Args&gt;(__args)...);\n\t    }\n\t  return std::get&lt;_Np&gt;(*this);\n\t}\n\n      template&lt;size_t _Np, typename _Up, typename... _Args&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tenable_if_t&lt;is_constructible_v&lt;__to_type&lt;_Np&gt;,\n\t\t\t\t       initializer_list&lt;_Up&gt;&amp;, _Args...&gt;,\n\t\t    __to_type&lt;_Np&gt;&amp;&gt;\n\templace(initializer_list&lt;_Up&gt; __il, _Args&amp;&amp;... __args)\n\t{\n\t  namespace __variant = std::__detail::__variant;\n\t  using type = typename _Nth_type&lt;_Np, _Types...&gt;::type;\n\t  // Provide the strong exception-safety guarantee when possible,\n\t  // to avoid becoming valueless.\n\t  if constexpr (is_nothrow_constructible_v&lt;type,\n\t\t\t\t\t\t   initializer_list&lt;_Up&gt;&amp;,\n\t\t\t\t\t\t   _Args...&gt;)\n\t    {\n\t      __variant::__emplace&lt;_Np&gt;(*this, __il,\n\t\t\t\t\tstd::forward&lt;_Args&gt;(__args)...);\n\t    }\n\t  else if constexpr (__variant::_Never_valueless_alt&lt;type&gt;()\n\t      &amp;&amp; _Traits::_S_move_assign)\n\t    {\n\t      // This construction might throw:\n\t      variant __tmp(in_place_index&lt;_Np&gt;, __il,\n\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n\t      // But _Never_valueless_alt&lt;type&gt; means this won&#x27;t:\n\t      *this = std::move(__tmp);\n\t    }\n\t  else\n\t    {\n\t      // This case only provides the basic exception-safety guarantee,\n\t      // i.e. the variant can become valueless.\n\t      __variant::__emplace&lt;_Np&gt;(*this, __il,\n\t\t\t\t\tstd::forward&lt;_Args&gt;(__args)...);\n\t    }\n\t  return std::get&lt;_Np&gt;(*this);\n\t}\n\n      template&lt;size_t _Np, typename... _Args&gt;\n\tenable_if_t&lt;!(_Np &lt; sizeof...(_Types))&gt; emplace(_Args&amp;&amp;...) = delete;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tenable_if_t&lt;!__exactly_once&lt;_Tp&gt;&gt; emplace(_Args&amp;&amp;...) = delete;\n\n      constexpr bool valueless_by_exception() const noexcept\n      { return !this-&gt;_M_valid(); }\n\n      constexpr size_t index() const noexcept\n      {\n\tusing __index_type = typename _Base::__index_type;\n\tif constexpr (__detail::__variant::__never_valueless&lt;_Types...&gt;())\n\t  return this-&gt;_M_index;\n\telse if constexpr (sizeof...(_Types) &lt;= __index_type(-1) / 2)\n\t  return make_signed_t&lt;__index_type&gt;(this-&gt;_M_index);\n\telse\n\t  return size_t(__index_type(this-&gt;_M_index + 1)) - 1;\n      }\n\n      _GLIBCXX20_CONSTEXPR\n      void\n      swap(variant&amp; __rhs)\n      noexcept((__is_nothrow_swappable&lt;_Types&gt;::value &amp;&amp; ...)\n\t       &amp;&amp; is_nothrow_move_constructible_v&lt;variant&gt;)\n      {\n\tstatic_assert((is_move_constructible_v&lt;_Types&gt; &amp;&amp; ...));\n\n\t// Handle this here to simplify the visitation.\n\tif (__rhs.valueless_by_exception()) [[__unlikely__]]\n\t  {\n\t    if (!this-&gt;valueless_by_exception()) [[__likely__]]\n\t      __rhs.swap(*this);\n\t    return;\n\t  }\n\n\tnamespace __variant = __detail::__variant;\n\n\t__variant::__raw_idx_visit(\n\t  [this, &amp;__rhs](auto&amp;&amp; __rhs_mem, auto __rhs_index) mutable\n\t  {\n\t    constexpr size_t __j = __rhs_index;\n\t    if constexpr (__j != variant_npos)\n\t      {\n\t\tif (this-&gt;index() == __j)\n\t\t  {\n\t\t    using std::swap;\n\t\t    swap(std::get&lt;__j&gt;(*this), __rhs_mem);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    auto __tmp(std::move(__rhs_mem));\n\n\t\t    if constexpr (_Traits::_S_trivial_move_assign)\n\t\t      __rhs = std::move(*this);\n\t\t    else\n\t\t      __variant::__raw_idx_visit(\n\t\t\t[&amp;__rhs](auto&amp;&amp; __this_mem, auto __this_index) mutable\n\t\t\t{\n\t\t\t  constexpr size_t __k = __this_index;\n\t\t\t  if constexpr (__k != variant_npos)\n\t\t\t    __variant::__emplace&lt;__k&gt;(__rhs,\n\t\t\t\t\t\t      std::move(__this_mem));\n\t\t\t}, *this);\n\n\t\t    __variant::__emplace&lt;__j&gt;(*this, std::move(__tmp));\n\t\t  }\n\t      }\n\t  }, __rhs);\n      }\n\n#if defined(__clang__) &amp;&amp; __clang_major__ &lt;= 7\n    public:\n      using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852\n#endif\n\n    private:\n      template&lt;size_t _Np, typename _Vp&gt;\n\tfriend constexpr decltype(auto)\n\t__detail::__variant::__get(_Vp&amp;&amp; __v) noexcept;\n\n#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \\\n      template&lt;typename... _Tp&gt; \\\n\tfriend constexpr bool \\\n\toperator __OP(const variant&lt;_Tp...&gt;&amp; __lhs, \\\n\t\t      const variant&lt;_Tp...&gt;&amp; __rhs);\n\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(&lt;)\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(&lt;=)\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(==)\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(!=)\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(&gt;=)\n      _VARIANT_RELATION_FUNCTION_TEMPLATE(&gt;)\n\n#undef _VARIANT_RELATION_FUNCTION_TEMPLATE\n    };\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;\n    get(variant&lt;_Types...&gt;&amp; __v)\n    {\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      if (__v.index() != _Np)\n\t__throw_bad_variant_access(__v.valueless_by_exception());\n      return __detail::__variant::__get&lt;_Np&gt;(__v);\n    }\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;&amp;\n    get(variant&lt;_Types...&gt;&amp;&amp; __v)\n    {\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      if (__v.index() != _Np)\n\t__throw_bad_variant_access(__v.valueless_by_exception());\n      return __detail::__variant::__get&lt;_Np&gt;(std::move(__v));\n    }\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr const variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;\n    get(const variant&lt;_Types...&gt;&amp; __v)\n    {\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      if (__v.index() != _Np)\n\t__throw_bad_variant_access(__v.valueless_by_exception());\n      return __detail::__variant::__get&lt;_Np&gt;(__v);\n    }\n\n  template&lt;size_t _Np, typename... _Types&gt;\n    constexpr const variant_alternative_t&lt;_Np, variant&lt;_Types...&gt;&gt;&amp;&amp;\n    get(const variant&lt;_Types...&gt;&amp;&amp; __v)\n    {\n      static_assert(_Np &lt; sizeof...(_Types),\n\t\t    &quot;The index must be in [0, number of alternatives)&quot;);\n      if (__v.index() != _Np)\n\t__throw_bad_variant_access(__v.valueless_by_exception());\n      return __detail::__variant::__get&lt;_Np&gt;(std::move(__v));\n    }\n\n  /// @cond undocumented\n  template&lt;typename _Result_type, typename _Visitor, typename... _Variants&gt;\n    constexpr decltype(auto)\n    __do_visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants)\n    {\n      // Get the silly case of visiting no variants out of the way first.\n      if constexpr (sizeof...(_Variants) == 0)\n\t{\n\t  if constexpr (is_void_v&lt;_Result_type&gt;)\n\t    return (void) std::forward&lt;_Visitor&gt;(__visitor)();\n\t  else\n\t    return std::forward&lt;_Visitor&gt;(__visitor)();\n\t}\n      else\n\t{\n\t  constexpr size_t __max = 11; // &quot;These go to eleven.&quot;\n\n\t  // The type of the first variant in the pack.\n\t  using _V0 = typename _Nth_type&lt;0, _Variants...&gt;::type;\n\t  // The number of alternatives in that first variant.\n\t  constexpr auto __n = variant_size_v&lt;remove_reference_t&lt;_V0&gt;&gt;;\n\n\t  if constexpr (sizeof...(_Variants) &gt; 1 || __n &gt; __max)\n\t    {\n\t      // Use a jump table for the general case.\n\t      constexpr auto&amp; __vtable = __detail::__variant::__gen_vtable&lt;\n\t\t_Result_type, _Visitor&amp;&amp;, _Variants&amp;&amp;...&gt;::_S_vtable;\n\n\t      auto __func_ptr = __vtable._M_access(__variants.index()...);\n\t      return (*__func_ptr)(std::forward&lt;_Visitor&gt;(__visitor),\n\t\t\t\t   std::forward&lt;_Variants&gt;(__variants)...);\n\t    }\n\t  else // We have a single variant with a small number of alternatives.\n\t    {\n\t      // A name for the first variant in the pack.\n\t      _V0&amp; __v0\n\t\t= [](_V0&amp; __v, ...) -&gt; _V0&amp; { return __v; }(__variants...);\n\n\t      using __detail::__variant::_Multi_array;\n\t      using __detail::__variant::__gen_vtable_impl;\n\t      using _Ma = _Multi_array&lt;_Result_type (*)(_Visitor&amp;&amp;, _V0&amp;&amp;)&gt;;\n\n#ifdef _GLIBCXX_DEBUG\n# define _GLIBCXX_VISIT_UNREACHABLE __builtin_trap\n#else\n# define _GLIBCXX_VISIT_UNREACHABLE __builtin_unreachable\n#endif\n\n#define _GLIBCXX_VISIT_CASE(N)\t\t\t\t\t\t\\\n  case N:\t\t\t\t\t\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    if constexpr (N &lt; __n)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\treturn __gen_vtable_impl&lt;_Ma, index_sequence&lt;N&gt;&gt;::\t\t\\\n\t  __visit_invoke(std::forward&lt;_Visitor&gt;(__visitor),\t\t\\\n\t\t\t std::forward&lt;_V0&gt;(__v0));\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    else _GLIBCXX_VISIT_UNREACHABLE();\t\t\t\t\t\\\n  }\n\n\t      switch (__v0.index())\n\t\t{\n\t\t  _GLIBCXX_VISIT_CASE(0)\n\t\t  _GLIBCXX_VISIT_CASE(1)\n\t\t  _GLIBCXX_VISIT_CASE(2)\n\t\t  _GLIBCXX_VISIT_CASE(3)\n\t\t  _GLIBCXX_VISIT_CASE(4)\n\t\t  _GLIBCXX_VISIT_CASE(5)\n\t\t  _GLIBCXX_VISIT_CASE(6)\n\t\t  _GLIBCXX_VISIT_CASE(7)\n\t\t  _GLIBCXX_VISIT_CASE(8)\n\t\t  _GLIBCXX_VISIT_CASE(9)\n\t\t  _GLIBCXX_VISIT_CASE(10)\n\t\tcase variant_npos:\n\t\t  using __detail::__variant::__variant_idx_cookie;\n\t\t  using __detail::__variant::__variant_cookie;\n\t\t  if constexpr (is_same_v&lt;_Result_type, __variant_idx_cookie&gt;\n\t\t\t\t|| is_same_v&lt;_Result_type, __variant_cookie&gt;)\n\t\t    {\n\t\t      using _Npos = index_sequence&lt;variant_npos&gt;;\n\t\t      return __gen_vtable_impl&lt;_Ma, _Npos&gt;::\n\t\t\t__visit_invoke(std::forward&lt;_Visitor&gt;(__visitor),\n\t\t\t\t       std::forward&lt;_V0&gt;(__v0));\n\t\t    }\n\t\t  else\n\t\t    _GLIBCXX_VISIT_UNREACHABLE();\n\t\tdefault:\n\t\t  _GLIBCXX_VISIT_UNREACHABLE();\n\t\t}\n#undef _GLIBCXX_VISIT_CASE\n#undef _GLIBCXX_VISIT_UNREACHABLE\n\t    }\n\t}\n    }\n  /// @endcond\n\n  template&lt;typename _Visitor, typename... _Variants&gt;\n    constexpr __detail::__variant::__visit_result_t&lt;_Visitor, _Variants...&gt;\n    visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants)\n    {\n      namespace __variant = std::__detail::__variant;\n\n      if ((__variant::__as(__variants).valueless_by_exception() || ...))\n\t__throw_bad_variant_access(&quot;std::visit: variant is valueless&quot;);\n\n      using _Result_type\n\t= __detail::__variant::__visit_result_t&lt;_Visitor, _Variants...&gt;;\n\n      using _Tag = __detail::__variant::__deduce_visit_result&lt;_Result_type&gt;;\n\n      if constexpr (sizeof...(_Variants) == 1)\n\t{\n\t  using _Vp = decltype(__variant::__as(std::declval&lt;_Variants&gt;()...));\n\n\t  constexpr bool __visit_rettypes_match = __detail::__variant::\n\t    __check_visitor_results&lt;_Visitor, _Vp&gt;(\n\t      make_index_sequence&lt;variant_size_v&lt;remove_reference_t&lt;_Vp&gt;&gt;&gt;());\n\t  if constexpr (!__visit_rettypes_match)\n\t    {\n\t      static_assert(__visit_rettypes_match,\n\t\t\t  &quot;std::visit requires the visitor to have the same &quot;\n\t\t\t  &quot;return type for all alternatives of a variant&quot;);\n\t      return;\n\t    }\n\t  else\n\t    return std::__do_visit&lt;_Tag&gt;(\n\t      std::forward&lt;_Visitor&gt;(__visitor),\n\t      static_cast&lt;_Vp&gt;(__variants)...);\n\t}\n      else\n\treturn std::__do_visit&lt;_Tag&gt;(\n\t  std::forward&lt;_Visitor&gt;(__visitor),\n\t  __variant::__as(std::forward&lt;_Variants&gt;(__variants))...);\n    }\n\n#if __cplusplus &gt; 201703L\n  template&lt;typename _Res, typename _Visitor, typename... _Variants&gt;\n    constexpr _Res\n    visit(_Visitor&amp;&amp; __visitor, _Variants&amp;&amp;... __variants)\n    {\n      namespace __variant = std::__detail::__variant;\n\n      if ((__variant::__as(__variants).valueless_by_exception() || ...))\n\t__throw_bad_variant_access(&quot;std::visit&lt;R&gt;: variant is valueless&quot;);\n\n      return std::__do_visit&lt;_Res&gt;(std::forward&lt;_Visitor&gt;(__visitor),\n\t  __variant::__as(std::forward&lt;_Variants&gt;(__variants))...);\n    }\n#endif\n\n  /// @cond undocumented\n  template&lt;bool, typename... _Types&gt;\n    struct __variant_hash_call_base_impl\n    {\n      size_t\n      operator()(const variant&lt;_Types...&gt;&amp; __t) const\n      noexcept((is_nothrow_invocable_v&lt;hash&lt;decay_t&lt;_Types&gt;&gt;, _Types&gt; &amp;&amp; ...))\n      {\n\tsize_t __ret;\n\t__detail::__variant::__raw_visit(\n\t  [&amp;__t, &amp;__ret](auto&amp;&amp; __t_mem) mutable\n\t  {\n\t    using _Type = __remove_cvref_t&lt;decltype(__t_mem)&gt;;\n\t    if constexpr (!is_same_v&lt;_Type,\n\t\t\t             __detail::__variant::__variant_cookie&gt;)\n\t      __ret = std::hash&lt;size_t&gt;{}(__t.index())\n\t\t      + std::hash&lt;_Type&gt;{}(__t_mem);\n\t    else\n\t      __ret = std::hash&lt;size_t&gt;{}(__t.index());\n\t  }, __t);\n\treturn __ret;\n      }\n    };\n\n  template&lt;typename... _Types&gt;\n    struct __variant_hash_call_base_impl&lt;false, _Types...&gt; {};\n\n  template&lt;typename... _Types&gt;\n    using __variant_hash_call_base =\n    __variant_hash_call_base_impl&lt;(__poison_hash&lt;remove_const_t&lt;_Types&gt;&gt;::\n\t\t\t\t   __enable_hash_call &amp;&amp;...), _Types...&gt;;\n  /// @endcond\n\n  template&lt;typename... _Types&gt;\n    struct hash&lt;variant&lt;_Types...&gt;&gt;\n    : private __detail::__variant::_Variant_hash_base&lt;\n\tvariant&lt;_Types...&gt;, std::index_sequence_for&lt;_Types...&gt;&gt;,\n      public __variant_hash_call_base&lt;_Types...&gt;\n    {\n      using result_type [[__deprecated__]] = size_t;\n      using argument_type [[__deprecated__]] = variant&lt;_Types...&gt;;\n    };\n\n  template&lt;&gt;\n    struct hash&lt;monostate&gt;\n    {\n      using result_type [[__deprecated__]] = size_t;\n      using argument_type [[__deprecated__]] = monostate;\n\n      size_t\n      operator()(const monostate&amp;) const noexcept\n      {\n\tconstexpr size_t __magic_monostate_hash = -7777;\n\treturn __magic_monostate_hash;\n      }\n    };\n\n  template&lt;typename... _Types&gt;\n    struct __is_fast_hash&lt;hash&lt;variant&lt;_Types...&gt;&gt;&gt;\n    : bool_constant&lt;(__is_fast_hash&lt;_Types&gt;::value &amp;&amp; ...)&gt;\n    { };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++17\n\n#endif // _GLIBCXX_VARIANT\n"}, "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "content": "// Implementation of INVOKE -*- C++ -*-\n\n// Copyright (C) 2016-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file include/bits/invoke.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{functional}\n */\n\n#ifndef _GLIBCXX_INVOKE_H\n#define _GLIBCXX_INVOKE_H 1\n\n#pragma GCC system_header\n\n#if __cplusplus &lt; 201103L\n# include &lt;bits/c++0x_warning.h&gt;\n#else\n\n#include &lt;type_traits&gt;\n#include &lt;bits/move.h&gt; // forward\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n  // Used by __invoke_impl instead of std::forward&lt;_Tp&gt; so that a\n  // reference_wrapper is converted to an lvalue-reference.\n  template&lt;typename _Tp, typename _Up = typename __inv_unwrap&lt;_Tp&gt;::type&gt;\n    constexpr _Up&amp;&amp;\n    __invfwd(typename remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept\n    { return static_cast&lt;_Up&amp;&amp;&gt;(__t); }\n\n  template&lt;typename _Res, typename _Fn, typename... _Args&gt;\n    constexpr _Res\n    __invoke_impl(__invoke_other, _Fn&amp;&amp; __f, _Args&amp;&amp;... __args)\n    { return std::forward&lt;_Fn&gt;(__f)(std::forward&lt;_Args&gt;(__args)...); }\n\n  template&lt;typename _Res, typename _MemFun, typename _Tp, typename... _Args&gt;\n    constexpr _Res\n    __invoke_impl(__invoke_memfun_ref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; __t,\n\t\t  _Args&amp;&amp;... __args)\n    { return (__invfwd&lt;_Tp&gt;(__t).*__f)(std::forward&lt;_Args&gt;(__args)...); }\n\n  template&lt;typename _Res, typename _MemFun, typename _Tp, typename... _Args&gt;\n    constexpr _Res\n    __invoke_impl(__invoke_memfun_deref, _MemFun&amp;&amp; __f, _Tp&amp;&amp; __t,\n\t\t  _Args&amp;&amp;... __args)\n    {\n      return ((*std::forward&lt;_Tp&gt;(__t)).*__f)(std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Res, typename _MemPtr, typename _Tp&gt;\n    constexpr _Res\n    __invoke_impl(__invoke_memobj_ref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; __t)\n    { return __invfwd&lt;_Tp&gt;(__t).*__f; }\n\n  template&lt;typename _Res, typename _MemPtr, typename _Tp&gt;\n    constexpr _Res\n    __invoke_impl(__invoke_memobj_deref, _MemPtr&amp;&amp; __f, _Tp&amp;&amp; __t)\n    { return (*std::forward&lt;_Tp&gt;(__t)).*__f; }\n\n  /// Invoke a callable object.\n  template&lt;typename _Callable, typename... _Args&gt;\n    constexpr typename __invoke_result&lt;_Callable, _Args...&gt;::type\n    __invoke(_Callable&amp;&amp; __fn, _Args&amp;&amp;... __args)\n    noexcept(__is_nothrow_invocable&lt;_Callable, _Args...&gt;::value)\n    {\n      using __result = __invoke_result&lt;_Callable, _Args...&gt;;\n      using __type = typename __result::type;\n      using __tag = typename __result::__invoke_type;\n      return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),\n\t\t\t\t\tstd::forward&lt;_Args&gt;(__args)...);\n    }\n\n#if __cplusplus &gt;= 201703L\n  // INVOKE&lt;R&gt;: Invoke a callable object and convert the result to R.\n  template&lt;typename _Res, typename _Callable, typename... _Args&gt;\n    constexpr enable_if_t&lt;is_invocable_r_v&lt;_Res, _Callable, _Args...&gt;, _Res&gt;\n    __invoke_r(_Callable&amp;&amp; __fn, _Args&amp;&amp;... __args)\n    noexcept(is_nothrow_invocable_r_v&lt;_Res, _Callable, _Args...&gt;)\n    {\n      using __result = __invoke_result&lt;_Callable, _Args...&gt;;\n      using __type = typename __result::type;\n      using __tag = typename __result::__invoke_type;\n      if constexpr (is_void_v&lt;_Res&gt;)\n\tstd::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),\n\t\t\t\t\tstd::forward&lt;_Args&gt;(__args)...);\n      else\n\treturn std::__invoke_impl&lt;__type&gt;(__tag{},\n\t\t\t\t\t  std::forward&lt;_Callable&gt;(__fn),\n\t\t\t\t\t  std::forward&lt;_Args&gt;(__args)...);\n    }\n#else // C++11 or C++14\n  // This is a non-SFINAE-friendly std::invoke_r&lt;R&gt;(fn, args...) for C++11/14.\n  // It&#x27;s used in std::function, std::bind, and std::packaged_task. Only\n  // std::function is constrained on is_invocable_r, but that is checked on\n  // construction so doesn&#x27;t need to be checked again when calling __invoke_r.\n  // Consequently, these __invoke_r overloads do not check for invocable\n  // arguments, nor check that the invoke result is convertible to R.\n\n  // INVOKE&lt;R&gt;: Invoke a callable object and convert the result to R.\n  template&lt;typename _Res, typename _Callable, typename... _Args&gt;\n    constexpr __enable_if_t&lt;!is_void&lt;_Res&gt;::value, _Res&gt;\n    __invoke_r(_Callable&amp;&amp; __fn, _Args&amp;&amp;... __args)\n    {\n      using __result = __invoke_result&lt;_Callable, _Args...&gt;;\n      using __type = typename __result::type;\n#if __has_builtin(__reference_converts_from_temporary)\n      static_assert(!__reference_converts_from_temporary(_Res, __type),\n\t\t    &quot;INVOKE&lt;R&gt; must not create a dangling reference&quot;);\n#endif\n      using __tag = typename __result::__invoke_type;\n      return std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),\n\t\t\t\t\tstd::forward&lt;_Args&gt;(__args)...);\n    }\n\n  // INVOKE&lt;R&gt; when R is cv void\n  template&lt;typename _Res, typename _Callable, typename... _Args&gt;\n    _GLIBCXX14_CONSTEXPR __enable_if_t&lt;is_void&lt;_Res&gt;::value, _Res&gt;\n    __invoke_r(_Callable&amp;&amp; __fn, _Args&amp;&amp;... __args)\n    {\n      using __result = __invoke_result&lt;_Callable, _Args...&gt;;\n      using __type = typename __result::type;\n      using __tag = typename __result::__invoke_type;\n      std::__invoke_impl&lt;__type&gt;(__tag{}, std::forward&lt;_Callable&gt;(__fn),\n\t\t\t\t std::forward&lt;_Args&gt;(__args)...);\n    }\n#endif // C++11 or C++14\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++11\n\n#endif // _GLIBCXX_INVOKE_H\n"}, "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "content": "// nonstandard construct and destroy functions -*- C++ -*-\n\n// Copyright (C) 2001-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/*\n *\n * Copyright (c) 1994\n * Hewlett-Packard Company\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Hewlett-Packard Company makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided &quot;as is&quot; without express or implied warranty.\n *\n *\n * Copyright (c) 1996,1997\n * Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, distribute and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appear in all copies and\n * that both that copyright notice and this permission notice appear\n * in supporting documentation.  Silicon Graphics makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided &quot;as is&quot; without express or implied warranty.\n */\n\n/** @file bits/stl_construct.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _STL_CONSTRUCT_H\n#define _STL_CONSTRUCT_H 1\n\n#include &lt;new&gt;\n#include &lt;bits/move.h&gt;\n#include &lt;bits/stl_iterator_base_types.h&gt; // for iterator_traits\n#include &lt;bits/stl_iterator_base_funcs.h&gt; // for advance\n\n/* This file provides the C++17 functions std::destroy_at, std::destroy, and\n * std::destroy_n, and the C++20 function std::construct_at.\n * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions\n * which are defined in all standard modes and so can be used in C++98-14 code.\n * The _Destroy functions will dispatch to destroy_at during constant\n * evaluation, because calls to that function are intercepted by the compiler\n * to allow use in constant expressions.\n */\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201703L\n  template &lt;typename _Tp&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy_at(_Tp* __location)\n    {\n      if constexpr (__cplusplus &gt; 201703L &amp;&amp; is_array_v&lt;_Tp&gt;)\n\t{\n\t  for (auto&amp; __x : *__location)\n\t    std::destroy_at(std::__addressof(__x));\n\t}\n      else\n\t__location-&gt;~_Tp();\n    }\n\n#if __cplusplus &gt;= 202002L\n  template&lt;typename _Tp, typename... _Args&gt;\n    constexpr auto\n    construct_at(_Tp* __location, _Args&amp;&amp;... __args)\n    noexcept(noexcept(::new((void*)0) _Tp(std::declval&lt;_Args&gt;()...)))\n    -&gt; decltype(::new((void*)0) _Tp(std::declval&lt;_Args&gt;()...))\n    { return ::new((void*)__location) _Tp(std::forward&lt;_Args&gt;(__args)...); }\n#endif // C++20\n#endif// C++17\n\n  /**\n   * Constructs an object in existing memory by invoking an allocated\n   * object&#x27;s constructor with an initializer.\n   */\n#if __cplusplus &gt;= 201103L\n  template&lt;typename _Tp, typename... _Args&gt;\n    _GLIBCXX20_CONSTEXPR\n    inline void\n    _Construct(_Tp* __p, _Args&amp;&amp;... __args)\n    {\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\t{\n\t  // Allow std::_Construct to be used in constant expressions.\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n\t  return;\n\t}\n#endif\n      ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n    }\n#else\n  template&lt;typename _T1, typename _T2&gt;\n    inline void\n    _Construct(_T1* __p, const _T2&amp; __value)\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_]allocator::construct\n      ::new(static_cast&lt;void*&gt;(__p)) _T1(__value);\n    }\n#endif\n\n  template&lt;typename _T1&gt;\n    inline void\n    _Construct_novalue(_T1* __p)\n    { ::new((void*)__p) _T1; }\n\n  template&lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last);\n\n  /**\n   * Destroy the object pointed to by a pointer type.\n   */\n  template&lt;typename _Tp&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    _Destroy(_Tp* __pointer)\n    {\n#if __cplusplus &gt; 201703L\n      std::destroy_at(__pointer);\n#else\n      __pointer-&gt;~_Tp();\n#endif\n    }\n\n  template&lt;bool&gt;\n    struct _Destroy_aux\n    {\n      template&lt;typename _ForwardIterator&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\t__destroy(_ForwardIterator __first, _ForwardIterator __last)\n\t{\n\t  for (; __first != __last; ++__first)\n\t    std::_Destroy(std::__addressof(*__first));\n\t}\n    };\n\n  template&lt;&gt;\n    struct _Destroy_aux&lt;true&gt;\n    {\n      template&lt;typename _ForwardIterator&gt;\n        static void\n        __destroy(_ForwardIterator, _ForwardIterator) { }\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects&#x27; destructors must be invoked.\n   */\n  template&lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type\n                       _Value_type;\n#if __cplusplus &gt;= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible&lt;_Value_type&gt;::value,\n\t\t    &quot;value type is destructible&quot;);\n#endif\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\treturn std::_Destroy_aux&lt;false&gt;::__destroy(__first, __last);\n#endif\n      std::_Destroy_aux&lt;__has_trivial_destructor(_Value_type)&gt;::\n\t__destroy(__first, __last);\n    }\n\n  template&lt;bool&gt;\n    struct _Destroy_n_aux\n    {\n      template&lt;typename _ForwardIterator, typename _Size&gt;\n\tstatic _GLIBCXX20_CONSTEXPR _ForwardIterator\n\t__destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  for (; __count &gt; 0; (void)++__first, --__count)\n\t    std::_Destroy(std::__addressof(*__first));\n\t  return __first;\n\t}\n    };\n\n  template&lt;&gt;\n    struct _Destroy_n_aux&lt;true&gt;\n    {\n      template&lt;typename _ForwardIterator, typename _Size&gt;\n        static _ForwardIterator\n        __destroy_n(_ForwardIterator __first, _Size __count)\n\t{\n\t  std::advance(__first, __count);\n\t  return __first;\n\t}\n    };\n\n  /**\n   * Destroy a range of objects.  If the value_type of the object has\n   * a trivial destructor, the compiler should optimize all of this\n   * away, otherwise the objects&#x27; destructors must be invoked.\n   */\n  template&lt;typename _ForwardIterator, typename _Size&gt;\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    _Destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type\n                       _Value_type;\n#if __cplusplus &gt;= 201103L\n      // A deleted destructor is trivial, this ensures we reject such types:\n      static_assert(is_destructible&lt;_Value_type&gt;::value,\n\t\t    &quot;value type is destructible&quot;);\n#endif\n#if __cplusplus &gt;= 202002L\n      if (std::__is_constant_evaluated())\n\treturn std::_Destroy_n_aux&lt;false&gt;::__destroy_n(__first, __count);\n#endif\n      return std::_Destroy_n_aux&lt;__has_trivial_destructor(_Value_type)&gt;::\n\t__destroy_n(__first, __count);\n    }\n\n#if __cplusplus &gt;= 201703L\n  template &lt;typename _ForwardIterator&gt;\n    _GLIBCXX20_CONSTEXPR inline void\n    destroy(_ForwardIterator __first, _ForwardIterator __last)\n    {\n      std::_Destroy(__first, __last);\n    }\n\n  template &lt;typename _ForwardIterator, typename _Size&gt;\n    _GLIBCXX20_CONSTEXPR inline _ForwardIterator\n    destroy_n(_ForwardIterator __first, _Size __count)\n    {\n      return std::_Destroy_n(__first, __count);\n    }\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif /* _STL_CONSTRUCT_H */\n"}, "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "content": "// Implementation of std::function -*- C++ -*-\n\n// Copyright (C) 2004-2023 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file include/bits/std_function.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{functional}\n */\n\n#ifndef _GLIBCXX_STD_FUNCTION_H\n#define _GLIBCXX_STD_FUNCTION_H 1\n\n#pragma GCC system_header\n\n#if __cplusplus &lt; 201103L\n# include &lt;bits/c++0x_warning.h&gt;\n#else\n\n#include &lt;new&gt;                // placement new\n#include &lt;typeinfo&gt;           // typeid\n#include &lt;bits/invoke.h&gt;      // __invoke_r\n#include &lt;bits/refwrap.h&gt;     // ref wrapper, _Maybe_unary_or_binary_function\n#include &lt;bits/functexcept.h&gt; // __throw_bad_function_call\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief Exception class thrown when class template function&#x27;s\n   *  operator() is called with an empty target.\n   *  @ingroup exceptions\n   */\n  class bad_function_call : public std::exception\n  {\n  public:\n    virtual ~bad_function_call() noexcept;\n\n    const char* what() const noexcept;\n  };\n\n  /**\n   *  Trait identifying &quot;location-invariant&quot; types, meaning that the\n   *  address of the object (or any of its members) will not escape.\n   *  Trivially copyable types are location-invariant and users can\n   *  specialize this trait for other types.\n   */\n  template&lt;typename _Tp&gt;\n    struct __is_location_invariant\n    : is_trivially_copyable&lt;_Tp&gt;::type\n    { };\n\n  class _Undefined_class;\n\n  union _Nocopy_types\n  {\n    void*       _M_object;\n    const void* _M_const_object;\n    void (*_M_function_pointer)();\n    void (_Undefined_class::*_M_member_pointer)();\n  };\n\n  union [[gnu::may_alias]] _Any_data\n  {\n    void*       _M_access()       noexcept { return &amp;_M_pod_data[0]; }\n    const void* _M_access() const noexcept { return &amp;_M_pod_data[0]; }\n\n    template&lt;typename _Tp&gt;\n      _Tp&amp;\n      _M_access() noexcept\n      { return *static_cast&lt;_Tp*&gt;(_M_access()); }\n\n    template&lt;typename _Tp&gt;\n      const _Tp&amp;\n      _M_access() const noexcept\n      { return *static_cast&lt;const _Tp*&gt;(_M_access()); }\n\n    _Nocopy_types _M_unused;\n    char _M_pod_data[sizeof(_Nocopy_types)];\n  };\n\n  enum _Manager_operation\n  {\n    __get_type_info,\n    __get_functor_ptr,\n    __clone_functor,\n    __destroy_functor\n  };\n\n  template&lt;typename _Signature&gt;\n    class function;\n\n  /// Base class of all polymorphic function object wrappers.\n  class _Function_base\n  {\n  public:\n    static const size_t _M_max_size = sizeof(_Nocopy_types);\n    static const size_t _M_max_align = __alignof__(_Nocopy_types);\n\n    template&lt;typename _Functor&gt;\n      class _Base_manager\n      {\n      protected:\n\tstatic const bool __stored_locally =\n\t(__is_location_invariant&lt;_Functor&gt;::value\n\t &amp;&amp; sizeof(_Functor) &lt;= _M_max_size\n\t &amp;&amp; __alignof__(_Functor) &lt;= _M_max_align\n\t &amp;&amp; (_M_max_align % __alignof__(_Functor) == 0));\n\n\tusing _Local_storage = integral_constant&lt;bool, __stored_locally&gt;;\n\n\t// Retrieve a pointer to the function object\n\tstatic _Functor*\n\t_M_get_pointer(const _Any_data&amp; __source) noexcept\n\t{\n\t  if _GLIBCXX17_CONSTEXPR (__stored_locally)\n\t    {\n\t      const _Functor&amp; __f = __source._M_access&lt;_Functor&gt;();\n\t      return const_cast&lt;_Functor*&gt;(std::__addressof(__f));\n\t    }\n\t  else // have stored a pointer\n\t    return __source._M_access&lt;_Functor*&gt;();\n\t}\n\n      private:\n\t// Construct a location-invariant function object that fits within\n\t// an _Any_data structure.\n\ttemplate&lt;typename _Fn&gt;\n\t  static void\n\t  _M_create(_Any_data&amp; __dest, _Fn&amp;&amp; __f, true_type)\n\t  {\n\t    ::new (__dest._M_access()) _Functor(std::forward&lt;_Fn&gt;(__f));\n\t  }\n\n\t// Construct a function object on the heap and store a pointer.\n\ttemplate&lt;typename _Fn&gt;\n\t  static void\n\t  _M_create(_Any_data&amp; __dest, _Fn&amp;&amp; __f, false_type)\n\t  {\n\t    __dest._M_access&lt;_Functor*&gt;()\n\t      = new _Functor(std::forward&lt;_Fn&gt;(__f));\n\t  }\n\n\t// Destroy an object stored in the internal buffer.\n\tstatic void\n\t_M_destroy(_Any_data&amp; __victim, true_type)\n\t{\n\t  __victim._M_access&lt;_Functor&gt;().~_Functor();\n\t}\n\n\t// Destroy an object located on the heap.\n\tstatic void\n\t_M_destroy(_Any_data&amp; __victim, false_type)\n\t{\n\t  delete __victim._M_access&lt;_Functor*&gt;();\n\t}\n\n      public:\n\tstatic bool\n\t_M_manager(_Any_data&amp; __dest, const _Any_data&amp; __source,\n\t\t   _Manager_operation __op)\n\t{\n\t  switch (__op)\n\t    {\n\t    case __get_type_info:\n#if __cpp_rtti\n\t      __dest._M_access&lt;const type_info*&gt;() = &amp;typeid(_Functor);\n#else\n\t      __dest._M_access&lt;const type_info*&gt;() = nullptr;\n#endif\n\t      break;\n\n\t    case __get_functor_ptr:\n\t      __dest._M_access&lt;_Functor*&gt;() = _M_get_pointer(__source);\n\t      break;\n\n\t    case __clone_functor:\n\t      _M_init_functor(__dest,\n\t\t  *const_cast&lt;const _Functor*&gt;(_M_get_pointer(__source)));\n\t      break;\n\n\t    case __destroy_functor:\n\t      _M_destroy(__dest, _Local_storage());\n\t      break;\n\t    }\n\t  return false;\n\t}\n\n\ttemplate&lt;typename _Fn&gt;\n\t  static void\n\t  _M_init_functor(_Any_data&amp; __functor, _Fn&amp;&amp; __f)\n\t  noexcept(__and_&lt;_Local_storage,\n\t\t\t  is_nothrow_constructible&lt;_Functor, _Fn&gt;&gt;::value)\n\t  {\n\t    _M_create(__functor, std::forward&lt;_Fn&gt;(__f), _Local_storage());\n\t  }\n\n\ttemplate&lt;typename _Signature&gt;\n\t  static bool\n\t  _M_not_empty_function(const function&lt;_Signature&gt;&amp; __f) noexcept\n\t  { return static_cast&lt;bool&gt;(__f); }\n\n\ttemplate&lt;typename _Tp&gt;\n\t  static bool\n\t  _M_not_empty_function(_Tp* __fp) noexcept\n\t  { return __fp != nullptr; }\n\n\ttemplate&lt;typename _Class, typename _Tp&gt;\n\t  static bool\n\t  _M_not_empty_function(_Tp _Class::* __mp) noexcept\n\t  { return __mp != nullptr; }\n\n\ttemplate&lt;typename _Tp&gt;\n\t  static bool\n\t  _M_not_empty_function(const _Tp&amp;) noexcept\n\t  { return true; }\n      };\n\n    _Function_base() = default;\n\n    ~_Function_base()\n    {\n      if (_M_manager)\n\t_M_manager(_M_functor, _M_functor, __destroy_functor);\n    }\n\n    bool _M_empty() const { return !_M_manager; }\n\n    using _Manager_type\n      = bool (*)(_Any_data&amp;, const _Any_data&amp;, _Manager_operation);\n\n    _Any_data     _M_functor{};\n    _Manager_type _M_manager{};\n  };\n\n  template&lt;typename _Signature, typename _Functor&gt;\n    class _Function_handler;\n\n  template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;\n    class _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt;\n    : public _Function_base::_Base_manager&lt;_Functor&gt;\n    {\n      using _Base = _Function_base::_Base_manager&lt;_Functor&gt;;\n\n    public:\n      static bool\n      _M_manager(_Any_data&amp; __dest, const _Any_data&amp; __source,\n\t\t _Manager_operation __op)\n      {\n\tswitch (__op)\n\t  {\n#if __cpp_rtti\n\t  case __get_type_info:\n\t    __dest._M_access&lt;const type_info*&gt;() = &amp;typeid(_Functor);\n\t    break;\n#endif\n\t  case __get_functor_ptr:\n\t    __dest._M_access&lt;_Functor*&gt;() = _Base::_M_get_pointer(__source);\n\t    break;\n\n\t  default:\n\t    _Base::_M_manager(__dest, __source, __op);\n\t  }\n\treturn false;\n      }\n\n      static _Res\n      _M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)\n      {\n\treturn std::__invoke_r&lt;_Res&gt;(*_Base::_M_get_pointer(__functor),\n\t\t\t\t     std::forward&lt;_ArgTypes&gt;(__args)...);\n      }\n\n      template&lt;typename _Fn&gt;\n\tstatic constexpr bool\n\t_S_nothrow_init() noexcept\n\t{\n\t  return __and_&lt;typename _Base::_Local_storage,\n\t\t\tis_nothrow_constructible&lt;_Functor, _Fn&gt;&gt;::value;\n\t}\n    };\n\n  // Specialization for invalid types\n  template&lt;&gt;\n    class _Function_handler&lt;void, void&gt;\n    {\n    public:\n      static bool\n      _M_manager(_Any_data&amp;, const _Any_data&amp;, _Manager_operation)\n      { return false; }\n    };\n\n  // Avoids instantiating ill-formed specializations of _Function_handler\n  // in std::function&lt;_Signature&gt;::target&lt;_Functor&gt;().\n  // e.g. _Function_handler&lt;Sig, void()&gt; and _Function_handler&lt;Sig, void&gt;\n  // would be ill-formed.\n  template&lt;typename _Signature, typename _Functor,\n\t   bool __valid = is_object&lt;_Functor&gt;::value&gt;\n    struct _Target_handler\n    : _Function_handler&lt;_Signature, typename remove_cv&lt;_Functor&gt;::type&gt;\n    { };\n\n  template&lt;typename _Signature, typename _Functor&gt;\n    struct _Target_handler&lt;_Signature, _Functor, false&gt;\n    : _Function_handler&lt;void, void&gt;\n    { };\n\n  /**\n   *  @brief Polymorphic function wrapper.\n   *  @ingroup functors\n   *  @since C++11\n   */\n  template&lt;typename _Res, typename... _ArgTypes&gt;\n    class function&lt;_Res(_ArgTypes...)&gt;\n    : public _Maybe_unary_or_binary_function&lt;_Res, _ArgTypes...&gt;,\n      private _Function_base\n    {\n      // Equivalent to std::decay_t except that it produces an invalid type\n      // if the decayed type is the current specialization of std::function.\n      template&lt;typename _Func,\n\t       bool _Self = is_same&lt;__remove_cvref_t&lt;_Func&gt;, function&gt;::value&gt;\n\tusing _Decay_t\n\t  = typename __enable_if_t&lt;!_Self, decay&lt;_Func&gt;&gt;::type;\n\n      template&lt;typename _Func,\n\t       typename _DFunc = _Decay_t&lt;_Func&gt;,\n\t       typename _Res2 = __invoke_result&lt;_DFunc&amp;, _ArgTypes...&gt;&gt;\n\tstruct _Callable\n\t: __is_invocable_impl&lt;_Res2, _Res&gt;::type\n\t{ };\n\n      template&lt;typename _Cond, typename _Tp = void&gt;\n\tusing _Requires = __enable_if_t&lt;_Cond::value, _Tp&gt;;\n\n      template&lt;typename _Functor&gt;\n\tusing _Handler\n\t  = _Function_handler&lt;_Res(_ArgTypes...), __decay_t&lt;_Functor&gt;&gt;;\n\n    public:\n      typedef _Res result_type;\n\n      // [3.7.2.1] construct/copy/destroy\n\n      /**\n       *  @brief Default construct creates an empty function call wrapper.\n       *  @post `!(bool)*this`\n       */\n      function() noexcept\n      : _Function_base() { }\n\n      /**\n       *  @brief Creates an empty function call wrapper.\n       *  @post @c !(bool)*this\n       */\n      function(nullptr_t) noexcept\n      : _Function_base() { }\n\n      /**\n       *  @brief %Function copy constructor.\n       *  @param __x A %function object with identical call signature.\n       *  @post `bool(*this) == bool(__x)`\n       *\n       *  The newly-created %function contains a copy of the target of\n       *  `__x` (if it has one).\n       */\n      function(const function&amp; __x)\n      : _Function_base()\n      {\n\tif (static_cast&lt;bool&gt;(__x))\n\t  {\n\t    __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n\t    _M_invoker = __x._M_invoker;\n\t    _M_manager = __x._M_manager;\n\t  }\n      }\n\n      /**\n       *  @brief %Function move constructor.\n       *  @param __x A %function object rvalue with identical call signature.\n       *\n       *  The newly-created %function contains the target of `__x`\n       *  (if it has one).\n       */\n      function(function&amp;&amp; __x) noexcept\n      : _Function_base(), _M_invoker(__x._M_invoker)\n      {\n\tif (static_cast&lt;bool&gt;(__x))\n\t  {\n\t    _M_functor = __x._M_functor;\n\t    _M_manager = __x._M_manager;\n\t    __x._M_manager = nullptr;\n\t    __x._M_invoker = nullptr;\n\t  }\n      }\n\n      /**\n       *  @brief Builds a %function that targets a copy of the incoming\n       *  function object.\n       *  @param __f A %function object that is callable with parameters of\n       *  type `ArgTypes...` and returns a value convertible to `Res`.\n       *\n       *  The newly-created %function object will target a copy of\n       *  `__f`. If `__f` is `reference_wrapper&lt;F&gt;`, then this function\n       *  object will contain a reference to the function object `__f.get()`.\n       *  If `__f` is a null function pointer, null pointer-to-member, or\n       *  empty `std::function`, the newly-created object will be empty.\n       *\n       *  If `__f` is a non-null function pointer or an object of type\n       *  `reference_wrapper&lt;F&gt;`, this function will not throw.\n       */\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2774. std::function construction vs assignment\n      template&lt;typename _Functor,\n\t       typename _Constraints = _Requires&lt;_Callable&lt;_Functor&gt;&gt;&gt;\n\tfunction(_Functor&amp;&amp; __f)\n\tnoexcept(_Handler&lt;_Functor&gt;::template _S_nothrow_init&lt;_Functor&gt;())\n\t: _Function_base()\n\t{\n\t  static_assert(is_copy_constructible&lt;__decay_t&lt;_Functor&gt;&gt;::value,\n\t      &quot;std::function target must be copy-constructible&quot;);\n\t  static_assert(is_constructible&lt;__decay_t&lt;_Functor&gt;, _Functor&gt;::value,\n\t      &quot;std::function target must be constructible from the &quot;\n\t      &quot;constructor argument&quot;);\n\n\t  using _My_handler = _Handler&lt;_Functor&gt;;\n\n\t  if (_My_handler::_M_not_empty_function(__f))\n\t    {\n\t      _My_handler::_M_init_functor(_M_functor,\n\t\t\t\t\t   std::forward&lt;_Functor&gt;(__f));\n\t      _M_invoker = &amp;_My_handler::_M_invoke;\n\t      _M_manager = &amp;_My_handler::_M_manager;\n\t    }\n\t}\n\n      /**\n       *  @brief Function assignment operator.\n       *  @param __x A %function with identical call signature.\n       *  @post `(bool)*this == (bool)x`\n       *  @returns `*this`\n       *\n       *  The target of `__x` is copied to `*this`. If `__x` has no\n       *  target, then `*this` will be empty.\n       *\n       *  If `__x` targets a function pointer or a reference to a function\n       *  object, then this operation will not throw an exception.\n       */\n      function&amp;\n      operator=(const function&amp; __x)\n      {\n\tfunction(__x).swap(*this);\n\treturn *this;\n      }\n\n      /**\n       *  @brief Function move-assignment operator.\n       *  @param __x A %function rvalue with identical call signature.\n       *  @returns `*this`\n       *\n       *  The target of `__x` is moved to `*this`. If `__x` has no\n       *  target, then `*this` will be empty.\n       *\n       *  If `__x` targets a function pointer or a reference to a function\n       *  object, then this operation will not throw an exception.\n       */\n      function&amp;\n      operator=(function&amp;&amp; __x) noexcept\n      {\n\tfunction(std::move(__x)).swap(*this);\n\treturn *this;\n      }\n\n      /**\n       *  @brief Function assignment to empty.\n       *  @post `!(bool)*this`\n       *  @returns `*this`\n       *\n       *  The target of `*this` is deallocated, leaving it empty.\n       */\n      function&amp;\n      operator=(nullptr_t) noexcept\n      {\n\tif (_M_manager)\n\t  {\n\t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n\t    _M_manager = nullptr;\n\t    _M_invoker = nullptr;\n\t  }\n\treturn *this;\n      }\n\n      /**\n       *  @brief Function assignment to a new target.\n       *  @param __f  A function object that is callable with parameters of\n       *              type  `_ArgTypes...` and returns a value convertible\n       *              to `_Res`.\n       *  @return `*this`\n       *  @since C++11\n       *\n       *  This function object wrapper will target a copy of `__f`. If `__f`\n       *  is `reference_wrapper&lt;F&gt;`, then this function object will contain\n       *  a reference to the function object `__f.get()`. If `__f` is a null\n       *  function pointer or null pointer-to-member, this object will be\n       *  empty.\n       *\n       *  If `__f` is a non-null function pointer or an object of type\n       *  `reference_wrapper&lt;F&gt;`, this function will not throw.\n       */\n      template&lt;typename _Functor&gt;\n\t_Requires&lt;_Callable&lt;_Functor&gt;, function&amp;&gt;\n\toperator=(_Functor&amp;&amp; __f)\n\tnoexcept(_Handler&lt;_Functor&gt;::template _S_nothrow_init&lt;_Functor&gt;())\n\t{\n\t  function(std::forward&lt;_Functor&gt;(__f)).swap(*this);\n\t  return *this;\n\t}\n\n      /// @overload\n      template&lt;typename _Functor&gt;\n\tfunction&amp;\n\toperator=(reference_wrapper&lt;_Functor&gt; __f) noexcept\n\t{\n\t  function(__f).swap(*this);\n\t  return *this;\n\t}\n\n      // [3.7.2.2] function modifiers\n\n      /**\n       *  @brief Swap the targets of two %function objects.\n       *  @param __x A %function with identical call signature.\n       *\n       *  Swap the targets of `this` function object and `__f`.\n       *  This function will not throw exceptions.\n       */\n      void swap(function&amp; __x) noexcept\n      {\n\tstd::swap(_M_functor, __x._M_functor);\n\tstd::swap(_M_manager, __x._M_manager);\n\tstd::swap(_M_invoker, __x._M_invoker);\n      }\n\n      // [3.7.2.3] function capacity\n\n      /**\n       *  @brief Determine if the %function wrapper has a target.\n       *\n       *  @return `true` when this function object contains a target,\n       *  or `false` when it is empty.\n       *\n       *  This function will not throw exceptions.\n       */\n      explicit operator bool() const noexcept\n      { return !_M_empty(); }\n\n      // [3.7.2.4] function invocation\n\n      /**\n       *  @brief Invokes the function targeted by `*this`.\n       *  @returns the result of the target.\n       *  @throws `bad_function_call` when `!(bool)*this`\n       *\n       *  The function call operator invokes the target function object\n       *  stored by `this`.\n       */\n      _Res\n      operator()(_ArgTypes... __args) const\n      {\n\tif (_M_empty())\n\t  __throw_bad_function_call();\n\treturn _M_invoker(_M_functor, std::forward&lt;_ArgTypes&gt;(__args)...);\n      }\n\n#if __cpp_rtti\n      // [3.7.2.5] function target access\n      /**\n       *  @brief Determine the type of the target of this function object\n       *  wrapper.\n       *\n       *  @returns the type identifier of the target function object, or\n       *  `typeid(void)` if `!(bool)*this`.\n       *\n       *  This function will not throw exceptions.\n       */\n      const type_info&amp;\n      target_type() const noexcept\n      {\n\tif (_M_manager)\n\t  {\n\t    _Any_data __typeinfo_result;\n\t    _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n\t    if (auto __ti =  __typeinfo_result._M_access&lt;const type_info*&gt;())\n\t      return *__ti;\n\t  }\n\treturn typeid(void);\n      }\n#endif\n\n      /**\n       *  @brief Access the stored target function object.\n       *\n       *  @return Returns a pointer to the stored target function object,\n       *  if `typeid(_Functor).equals(target_type())`; otherwise, a null\n       *  pointer.\n       *\n       * This function does not throw exceptions.\n       *\n       * @{\n       */\n      template&lt;typename _Functor&gt;\n\t_Functor*\n\ttarget() noexcept\n\t{\n\t  const function* __const_this = this;\n\t  const _Functor* __func = __const_this-&gt;template target&lt;_Functor&gt;();\n\t  // If is_function_v&lt;_Functor&gt; is true then const_cast&lt;_Functor*&gt;\n\t  // would be ill-formed, so use *const_cast&lt;_Functor**&gt; instead.\n\t  return *const_cast&lt;_Functor**&gt;(&amp;__func);\n\t}\n\n      template&lt;typename _Functor&gt;\n\tconst _Functor*\n\ttarget() const noexcept\n\t{\n\t  if _GLIBCXX17_CONSTEXPR (is_object&lt;_Functor&gt;::value)\n\t    {\n\t      // For C++11 and C++14 if-constexpr is not used above, so\n\t      // _Target_handler avoids ill-formed _Function_handler types.\n\t      using _Handler = _Target_handler&lt;_Res(_ArgTypes...), _Functor&gt;;\n\n\t      if (_M_manager == &amp;_Handler::_M_manager\n#if __cpp_rtti\n\t\t  || (_M_manager &amp;&amp; typeid(_Functor) == target_type())\n#endif\n\t\t )\n\t\t{\n\t\t  _Any_data __ptr;\n\t\t  _M_manager(__ptr, _M_functor, __get_functor_ptr);\n\t\t  return __ptr._M_access&lt;const _Functor*&gt;();\n\t\t}\n\t    }\n\t  return nullptr;\n\t}\n      /// @}\n\n    private:\n      using _Invoker_type = _Res (*)(const _Any_data&amp;, _ArgTypes&amp;&amp;...);\n      _Invoker_type _M_invoker = nullptr;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename&gt;\n    struct __function_guide_helper\n    { };\n\n  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;\n    struct __function_guide_helper&lt;\n      _Res (_Tp::*) (_Args...) noexcept(_Nx)\n    &gt;\n    { using type = _Res(_Args...); };\n\n  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;\n    struct __function_guide_helper&lt;\n      _Res (_Tp::*) (_Args...) &amp; noexcept(_Nx)\n    &gt;\n    { using type = _Res(_Args...); };\n\n  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;\n    struct __function_guide_helper&lt;\n      _Res (_Tp::*) (_Args...) const noexcept(_Nx)\n    &gt;\n    { using type = _Res(_Args...); };\n\n  template&lt;typename _Res, typename _Tp, bool _Nx, typename... _Args&gt;\n    struct __function_guide_helper&lt;\n      _Res (_Tp::*) (_Args...) const &amp; noexcept(_Nx)\n    &gt;\n    { using type = _Res(_Args...); };\n\n#if __cpp_static_call_operator &gt;= 202207L &amp;&amp; __cpp_concepts &gt;= 202002L\n  template&lt;typename _StaticCallOp&gt;\n    struct __function_guide_static_helper\n    { };\n\n  template&lt;typename _Res, bool _Nx, typename... _Args&gt;\n    struct __function_guide_static_helper&lt;_Res (*) (_Args...) noexcept(_Nx)&gt;\n    { using type = _Res(_Args...); };\n\n  template&lt;typename _Fn, typename _Op&gt;\n    using __function_guide_t = typename __conditional_t&lt;\n      requires (_Fn&amp; __f) { (void) __f.operator(); },\n      __function_guide_static_helper&lt;_Op&gt;,\n      __function_guide_helper&lt;_Op&gt;&gt;::type;\n#else\n  template&lt;typename _Fn, typename _Op&gt;\n    using __function_guide_t = typename __function_guide_helper&lt;_Op&gt;::type;\n#endif\n\n  template&lt;typename _Res, typename... _ArgTypes&gt;\n    function(_Res(*)(_ArgTypes...)) -&gt; function&lt;_Res(_ArgTypes...)&gt;;\n\n  template&lt;typename _Fn, typename _Signature\n\t     = __function_guide_t&lt;_Fn, decltype(&amp;_Fn::operator())&gt;&gt;\n    function(_Fn) -&gt; function&lt;_Signature&gt;;\n#endif\n\n  // [20.7.15.2.6] null pointer comparisons\n\n  /**\n   *  @brief Test whether a polymorphic function object wrapper is empty.\n   *  @returns `true` if the wrapper has no target, `false` otherwise\n   *\n   *  This function will not throw exceptions.\n   */\n  template&lt;typename _Res, typename... _Args&gt;\n    inline bool\n    operator==(const function&lt;_Res(_Args...)&gt;&amp; __f, nullptr_t) noexcept\n    { return !static_cast&lt;bool&gt;(__f); }\n\n#if __cpp_impl_three_way_comparison &lt; 201907L\n  /// @overload\n  template&lt;typename _Res, typename... _Args&gt;\n    inline bool\n    operator==(nullptr_t, const function&lt;_Res(_Args...)&gt;&amp; __f) noexcept\n    { return !static_cast&lt;bool&gt;(__f); }\n\n  /**\n   *  @brief Test whether a polymorphic function object wrapper is non-empty.\n   *  @returns `false` if the wrapper has no target, `true` otherwise\n   *\n   *  This function will not throw exceptions.\n   */\n  template&lt;typename _Res, typename... _Args&gt;\n    inline bool\n    operator!=(const function&lt;_Res(_Args...)&gt;&amp; __f, nullptr_t) noexcept\n    { return static_cast&lt;bool&gt;(__f); }\n\n  /// @overload\n  template&lt;typename _Res, typename... _Args&gt;\n    inline bool\n    operator!=(nullptr_t, const function&lt;_Res(_Args...)&gt;&amp; __f) noexcept\n    { return static_cast&lt;bool&gt;(__f); }\n#endif\n\n  // [20.7.15.2.7] specialized algorithms\n\n  /**\n   *  @brief Swap the targets of two polymorphic function object wrappers.\n   *\n   *  This function will not throw exceptions.\n   */\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2062. Effect contradictions w/o no-throw guarantee of std::function swaps\n  template&lt;typename _Res, typename... _Args&gt;\n    inline void\n    swap(function&lt;_Res(_Args...)&gt;&amp; __x, function&lt;_Res(_Args...)&gt;&amp; __y) noexcept\n    { __x.swap(__y); }\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // function into a variant.\n    template&lt;typename _Signature&gt;\n      struct _Never_valueless_alt&lt;std::function&lt;_Signature&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++11\n#endif // _GLIBCXX_STD_FUNCTION_H\n"}, "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h": {"id": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "filePath": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "content": "// Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/\n\n#pragma once\n\n#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;nx/utils/log/assert.h&gt;\n\nnamespace nx {\n\n/**\n * Move-only analogue of std::function.\n * Can be used to store lambda which has std::unique_ptr as its capture.\n */\ntemplate&lt;class F&gt;\nclass MoveOnlyFunc:\n    private std::function&lt;F&gt;\n{\n    using base_type = std::function&lt;F&gt;;\n\n    template&lt;class Func&gt;\n    class MoveOnlyFuncWrapper\n    {\n    private:\n        Func m_func;\n\n    public:\n        MoveOnlyFuncWrapper(Func p):\n            m_func(std::move(p))\n        {\n        }\n\n        MoveOnlyFuncWrapper(const MoveOnlyFuncWrapper&amp; rhs):\n            m_func(std::move(const_cast&lt;MoveOnlyFuncWrapper&amp;&gt;(rhs).m_func))\n        {\n            NX_ASSERT(false);\n        }\n\n        MoveOnlyFuncWrapper&amp; operator=(const MoveOnlyFuncWrapper&amp;)\n        {\n            NX_ASSERT(false);\n            return *this;\n        }\n\n        MoveOnlyFuncWrapper(MoveOnlyFuncWrapper&amp;&amp; rhs) noexcept(\n            std::is_nothrow_move_constructible_v&lt;Func&gt;)\n            :\n            m_func(std::move(rhs.m_func))\n        {\n        }\n\n        MoveOnlyFuncWrapper&amp; operator=(MoveOnlyFuncWrapper&amp;&amp; rhs)\n        {\n            if (&amp;rhs == this)\n                return *this;\n            m_func = std::move(rhs.m_func);\n            return *this;\n        }\n\n        template&lt;class... Args&gt;\n        auto operator() (Args&amp;&amp;... args)\n            -&gt; decltype(m_func(std::forward&lt;Args&gt;(args)...))\n        {\n            return m_func(std::forward&lt;Args&gt;(args)...);\n        }\n    };\n\npublic:\n    using result_type = typename std::function&lt;F&gt;::result_type;\n\n    MoveOnlyFunc() = default;\n\n    MoveOnlyFunc(std::function&lt;F&gt; func):\n        std::function&lt;F&gt;(std::move(func))\n    {\n    }\n\n    MoveOnlyFunc(std::nullptr_t val):\n        std::function&lt;F&gt;(val)\n    {\n    }\n\n    MoveOnlyFunc(MoveOnlyFunc&amp;&amp;) = default;\n    MoveOnlyFunc&amp; operator=(MoveOnlyFunc&amp;&amp;) = default;\n    MoveOnlyFunc(const MoveOnlyFunc&amp;) = delete;\n    MoveOnlyFunc&amp; operator=(const MoveOnlyFunc&amp;) = delete;\n\n    template&lt;class _Func&gt;\n    MoveOnlyFunc(_Func func):\n        std::function&lt;F&gt;(MoveOnlyFuncWrapper&lt;_Func&gt;(std::move(func)))\n    {\n    }\n\n    MoveOnlyFunc&amp; operator=(std::nullptr_t val)\n    {\n        std::function&lt;F&gt;::operator=(val);\n        return *this;\n    }\n\n    using base_type::operator();\n\n    bool operator==(std::nullptr_t) const\n    {\n        return static_cast&lt;const base_type&amp;&gt;(*this) == nullptr;\n    }\n\n    bool operator!=(std::nullptr_t) const\n    {\n        return !(*this == nullptr);\n    }\n\n    void swap(MoveOnlyFunc&amp; other)\n    {\n        base_type::swap(static_cast&lt;base_type&amp;&gt;(other));\n    }\n\n    using std::function&lt;F&gt;::operator bool;\n};\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid moveAndCall(Function&amp; function, Args&amp;&amp; ... args)\n{\n    const auto handler = std::move(function);\n    function = nullptr;\n    handler(std::forward&lt;Args&gt;(args) ...);\n}\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid moveAndCallOptional(Function&amp; function, Args&amp;&amp; ... args)\n{\n    if (!function)\n        return;\n\n    moveAndCall(function, std::forward&lt;Args&gt;(args) ...);\n}\n\ntemplate&lt;typename Function, typename ... Args&gt;\nvoid swapAndCall(Function&amp; function, Args&amp;&amp; ... args)\n{\n    Function functionLocal;\n    function.swap(functionLocal);\n    functionLocal(std::forward&lt;Args&gt;(args) ...);\n}\n\n} // namespace nx\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "reportHash": "69e4cbdef115ccdb18ef14a2ffb03ced", "checker": {"name": "unix.Malloc", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#unix-malloc-c"}, "analyzerName": "clangsa", "line": 270, "column": 13, "message": "Use of memory after it is freed", "events": [{"message": "Calling implicit destructor for 'expected<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, nx::network::rest::Result>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1631, "column": 7}, {"message": "Calling implicit destructor for 'optional<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1631, "column": 7}, {"message": "Calling implicit destructor for '_Optional_base<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, false, false>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1631, "column": 7}, {"message": "Calling '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1631, "column": 7}, {"message": "Entered call from destructor for '_Optional_base<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 7}, {"message": "Calling '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Entered call from '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 314, "column": 7}, {"message": "Assuming field '_M_engaged' is true", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 317, "column": 6}, {"message": "Calling '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Entered call from '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 283, "column": 7}, {"message": "Calling defaulted destructor for 'variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Calling implicit destructor for '_Variant_base<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Move_assign_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Copy_assign_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Move_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Copy_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling '~_Variant_storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Entered call from destructor for '_Copy_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 504, "column": 7}, {"message": "Calling '_Variant_storage::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 506, "column": 9}, {"message": "Entered call from '~_Variant_storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 490, "column": 7}, {"message": "Calling '__do_visit<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>> &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 496, "column": 2}, {"message": "Entered call from '_Variant_storage::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1755, "column": 5}, {"message": "Calling '__gen_vtable_impl::__visit_invoke'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1815, "column": 5}, {"message": "Entered call from '__do_visit<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>> &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1043, "column": 7}, {"message": "Calling '__invoke_r<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1064, "column": 11}, {"message": "Entered call from '__gen_vtable_impl::__visit_invoke'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 103, "column": 5}, {"message": "Calling '__invoke_impl<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 111, "column": 2}, {"message": "Entered call from '__invoke_r<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 59, "column": 5}, {"message": "Calling 'operator()'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 61, "column": 14}, {"message": "Entered call from '__invoke_impl<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 496, "column": 46}, {"message": "Calling '_Destroy<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 498, "column": 6}, {"message": "Entered call from 'operator()'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 145, "column": 5}, {"message": "Calling 'destroy_at<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 149, "column": 7}, {"message": "Entered call from '_Destroy<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 79, "column": 5}, {"message": "Calling implicit destructor for 'Response'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling implicit destructor for 'optional<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling implicit destructor for '_Optional_base<rapidjson::MemoryPoolAllocator<>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Entered call from destructor for '_Optional_base<rapidjson::MemoryPoolAllocator<>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 7}, {"message": "Calling '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Entered call from '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 314, "column": 7}, {"message": "Assuming field '_M_engaged' is true", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 317, "column": 6}, {"message": "Calling '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Entered call from '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 283, "column": 7}, {"message": "Calling '~MemoryPoolAllocator'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Entered call from '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 265, "column": 5}, {"message": "Assuming field 'shared_' is non-null", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 266, "column": 13}, {"message": "Assuming field 'refcount' is <= 1", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 270, "column": 13}, {"message": "Assuming field 'ownBuffer' is true", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 276, "column": 13}, {"message": "Calling 'CrtAllocator::Free'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 277, "column": 13}, {"message": "Entered call from '~MemoryPoolAllocator'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 106, "column": 5}, {"message": "Memory is released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 106, "column": 54}, {"message": "Returning; memory was released via 1st parameter", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 277, "column": 13}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Calling defaulted destructor for '_Optional_payload<rapidjson::MemoryPoolAllocator<>, true, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 69}, {"message": "Calling defaulted destructor for '_Optional_payload_base<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 402, "column": 36}, {"message": "Calling '~_Storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 121, "column": 41}, {"message": "Entered call from destructor for '_Optional_payload_base<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 263, "column": 4}, {"message": "Calling '~MemoryPoolAllocator'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 263, "column": 39}, {"message": "Entered call from '~_Storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 265, "column": 5}, {"message": "Use of memory after it is freed", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 270, "column": 13}], "macros": [{"message": "std ::free (ptr )", "name": "RAPIDJSON_FREE(ptr)", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 106, "column": 54}], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "reportHash": "37514457edd52b279aa39297df4bdc49", "checker": {"name": "cplusplus.NewDelete", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdelete-c"}, "analyzerName": "clangsa", "line": 279, "column": 9, "message": "Attempt to free released memory", "events": [{"message": "Calling '__invoke_r<void, nx::MoveOnlyFunc<void (std::unique_ptr<rest::BaseResultContext>, long long)>::MoveOnlyFuncWrapper<(lambda at /home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp:1776:9)> &, std::unique_ptr<rest::BaseResultContext>, long long>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 290, "column": 9}, {"message": "Entered call from '_Function_handler::_M_invoke'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 103, "column": 5}, {"message": "Calling '__invoke_impl<void, nx::MoveOnlyFunc<void (std::unique_ptr<rest::BaseResultContext>, long long)>::MoveOnlyFuncWrapper<(lambda at /home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp:1776:9)> &, std::unique_ptr<rest::BaseResultContext>, long long>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 111, "column": 2}, {"message": "Entered call from '__invoke_r<void, nx::MoveOnlyFunc<void (std::unique_ptr<rest::BaseResultContext>, long long)>::MoveOnlyFuncWrapper<(lambda at /home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp:1776:9)> &, std::unique_ptr<rest::BaseResultContext>, long long>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 59, "column": 5}, {"message": "Calling 'MoveOnlyFuncWrapper::operator()'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 61, "column": 14}, {"message": "Entered call from '__invoke_impl<void, nx::MoveOnlyFunc<void (std::unique_ptr<rest::BaseResultContext>, long long)>::MoveOnlyFuncWrapper<(lambda at /home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp:1776:9)> &, std::unique_ptr<rest::BaseResultContext>, long long>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 62, "column": 9}, {"message": "Calling 'operator()'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 65, "column": 20}, {"message": "Entered call from 'MoveOnlyFuncWrapper::operator()'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1777, "column": 82}, {"message": "Calling implicit destructor for 'expected<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, nx::network::rest::Result>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1780, "column": 82}, {"message": "Calling implicit destructor for 'optional<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1780, "column": 82}, {"message": "Calling implicit destructor for '_Optional_base<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, false, false>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1780, "column": 82}, {"message": "Calling '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1780, "column": 82}, {"message": "Entered call from destructor for '_Optional_base<std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 7}, {"message": "Calling '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Entered call from '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 314, "column": 7}, {"message": "Assuming field '_M_engaged' is true", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 317, "column": 6}, {"message": "Calling '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Entered call from '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 283, "column": 7}, {"message": "Calling defaulted destructor for 'variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Calling implicit destructor for '_Variant_base<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Move_assign_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Copy_assign_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Move_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling implicit destructor for '_Copy_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Calling '~_Variant_storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1432, "column": 47}, {"message": "Entered call from destructor for '_Copy_ctor_base<false, nx::json_rpc::Response, std::vector<nx::json_rpc::Response>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 504, "column": 7}, {"message": "Calling '_Variant_storage::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 506, "column": 9}, {"message": "Entered call from '~_Variant_storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 490, "column": 7}, {"message": "Calling '__do_visit<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>> &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 496, "column": 2}, {"message": "Entered call from '_Variant_storage::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1755, "column": 5}, {"message": "Calling '__gen_vtable_impl::__visit_invoke'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1815, "column": 5}, {"message": "Entered call from '__do_visit<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), std::variant<nx::json_rpc::Response, std::vector<nx::json_rpc::Response>> &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1043, "column": 7}, {"message": "Calling '__invoke_r<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 1064, "column": 11}, {"message": "Entered call from '__gen_vtable_impl::__visit_invoke'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 103, "column": 5}, {"message": "Calling '__invoke_impl<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 111, "column": 2}, {"message": "Entered call from '__invoke_r<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 59, "column": 5}, {"message": "Calling 'operator()'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/invoke.h", "line": 61, "column": 14}, {"message": "Entered call from '__invoke_impl<void, (lambda at /home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/lib/gcc/x86_64-linux-gnu/13.3.0/../../../../x86_64-linux-gnu/include/c++/13.3.0/variant:496:24), nx::json_rpc::Response &>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 496, "column": 46}, {"message": "Calling '_Destroy<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/variant", "line": 498, "column": 6}, {"message": "Entered call from 'operator()'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 145, "column": 5}, {"message": "Calling 'destroy_at<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 149, "column": 7}, {"message": "Entered call from '_Destroy<nx::json_rpc::Response>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 79, "column": 5}, {"message": "Calling implicit destructor for 'Response'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling implicit destructor for 'optional<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling implicit destructor for '_Optional_base<rapidjson::MemoryPoolAllocator<>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Calling '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/stl_construct.h", "line": 88, "column": 2}, {"message": "Entered call from destructor for '_Optional_base<rapidjson::MemoryPoolAllocator<>, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 7}, {"message": "Calling '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Entered call from '~_Optional_payload'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 314, "column": 7}, {"message": "Assuming field '_M_engaged' is true", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 317, "column": 6}, {"message": "Calling '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Entered call from '_Optional_payload_base::_M_reset'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 283, "column": 7}, {"message": "Calling '~MemoryPoolAllocator'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Entered call from '_Optional_payload_base::_M_destroy'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 265, "column": 5}, {"message": "Assuming field 'shared_' is non-null", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 266, "column": 13}, {"message": "Assuming field 'refcount' is <= 1", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 270, "column": 13}, {"message": "Assuming field 'ownBuffer' is false", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 276, "column": 13}, {"message": "Memory is released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 279, "column": 9}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 287, "column": 2}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 318, "column": 4}, {"message": "Returning; memory was released", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 51}, {"message": "Calling defaulted destructor for '_Optional_payload<rapidjson::MemoryPoolAllocator<>, true, false, false>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 441, "column": 69}, {"message": "Calling defaulted destructor for '_Optional_payload_base<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 402, "column": 36}, {"message": "Calling '~_Storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 121, "column": 41}, {"message": "Entered call from destructor for '_Optional_payload_base<rapidjson::MemoryPoolAllocator<>>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 263, "column": 4}, {"message": "Calling '~MemoryPoolAllocator'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/optional", "line": 263, "column": 39}, {"message": "Entered call from '~_Storage'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 265, "column": 5}, {"message": "Assuming field 'refcount' is <= 1", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 270, "column": 13}, {"message": "Attempt to free released memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 279, "column": 9}], "macros": [{"message": "delete a ", "name": "RAPIDJSON_DELETE(a)", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 279, "column": 9}, {"message": "delete a ", "name": "RAPIDJSON_DELETE(a)", "fileId": "/home/misha/nika/nx_open/build/.conan/data/rapidjson/cci.20230929/_/_/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/rapidjson/allocators.h", "line": 279, "column": 9}], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "bfcbaf15d3b8c875066ce49485844162", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 817, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 820, "column": 9}, {"message": "Entered call from 'ServerConnection::getOverlappedIds'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 820, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 817, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "e80da0242d8dc0e2408385613b3d99b7", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 842, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 847, "column": 9}, {"message": "Entered call from 'ServerConnection::setOverlappedId'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 847, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 842, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "e286e69162b941af3f5d6e2d7e63a5ec", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 1360, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling 'extractJsonResult<nx::vms::api::analytics::EngineSettingsResponse>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1363, "column": 9}, {"message": "Entered call from 'ServerConnection::setEngineAnalyticsSettings'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 84, "column": 1}, {"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Entered call from 'extractJsonResult<nx::vms::api::analytics::EngineSettingsResponse>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1363, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1360, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "ee2b088f73dbe5d3da31f159841f205b", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 1384, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling 'extractJsonResult<nx::vms::api::analytics::EngineActiveSettingChangedResponse>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1387, "column": 9}, {"message": "Entered call from 'ServerConnection::engineAnalyticsActiveSettingsChanged'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 84, "column": 1}, {"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Entered call from 'extractJsonResult<nx::vms::api::analytics::EngineActiveSettingChangedResponse>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1387, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1384, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "7f33ca36e32afd976abb65747ce6e115", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 1471, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling 'extractJsonResult<nx::vms::api::analytics::DeviceAgentActiveSettingChangedResponse>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1474, "column": 9}, {"message": "Entered call from 'ServerConnection::deviceAnalyticsActiveSettingsChanged'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 84, "column": 1}, {"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Entered call from 'extractJsonResult<nx::vms::api::analytics::DeviceAgentActiveSettingChangedResponse>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 88, "column": 9}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1474, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 1471, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}, {"fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "reportHash": "fd2730c6d0fa3367d17dede1e5c7e68a", "checker": {"name": "cplusplus.NewDeleteLeaks", "url": "https://clang.llvm.org/docs/analyzer/checkers.html#cplusplus-newdeleteleaks-c"}, "analyzerName": "clangsa", "line": 2487, "column": 5, "message": "Potential memory leak", "events": [{"message": "Calling constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 2490, "column": 9}, {"message": "Entered call from 'ServerConnection::getExtendedPluginInformation'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 90, "column": 5}, {"message": "Calling constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Entered call from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 435, "column": 2}, {"message": "Calling '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Entered call from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 210, "column": 4}, {"message": "Calling '_Base_manager::_M_create'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Entered call from '_Base_manager::_M_init_functor'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 157, "column": 4}, {"message": "Memory is allocated", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 161, "column": 10}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 215, "column": 6}, {"message": "Returned allocated memory", "fileId": "/home/misha/nika/nx_open/build/.conan/data/gcc-toolchain/13.3/_/_/package/5f672a39ea96f91a8badf2fd1665d812f1b79335/x86_64-linux-gnu/include/c++/13.3.0/bits/std_function.h", "line": 449, "column": 8}, {"message": "Returning from constructor for 'function<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/libs/nx_utils/src/nx/utils/move_only_func.h", "line": 91, "column": 9}, {"message": "Returning from constructor for 'MoveOnlyFunc<void (bool, long long, nx::network::rest::JsonResult)>'", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 2490, "column": 9}, {"message": "Potential memory leak", "fileId": "/home/misha/nika/nx_open/vms/libs/nx_vms_common/src/api/server_rest_connection.cpp", "line": 2487, "column": 5}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "HIGH"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
