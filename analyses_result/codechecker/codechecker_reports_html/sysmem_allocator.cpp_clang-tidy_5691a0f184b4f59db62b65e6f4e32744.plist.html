<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/include/sysmem_allocator.h": {"id": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/include/sysmem_allocator.h", "filePath": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/include/sysmem_allocator.h", "content": "/******************************************************************************\\\nCopyright (c) 2005-2019, Intel Corporation\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis sample was distributed or derived from the Intel&#x27;s Media Samples package.\nThe original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio\nor https://software.intel.com/en-us/media-client-solutions-support.\n\\**********************************************************************************/\n\n#ifndef __SYSMEM_ALLOCATOR_H__\n#define __SYSMEM_ALLOCATOR_H__\n\n#include &lt;stdlib.h&gt;\n#include &quot;base_allocator.h&quot;\n#include &lt;set&gt;\n\n#define MSDK_ALIGN32(X) (((mfxU32)((X)+31)) &amp; (~ (mfxU32)31))\n\nstruct sBuffer\n{\n    mfxU32      id;\n    mfxU32      nbytes;\n    mfxU16      type;\n};\n\nstruct sFrame\n{\n    mfxU32          id;\n    mfxFrameInfo    info;\n};\n\nclass SysMemFrameAllocator: public BaseFrameAllocator\n{\npublic:\n    virtual ~SysMemFrameAllocator();\n\n    virtual mfxStatus Close();\n    virtual mfxStatus LockFrame(mfxMemId mid, mfxFrameData *ptr);\n    virtual mfxStatus UnlockFrame(mfxMemId mid, mfxFrameData *ptr);\n    virtual mfxStatus GetFrameHDL(mfxMemId mid, mfxHDL *handle);\n\nprotected:\n    virtual mfxStatus CheckRequestType(mfxFrameAllocRequest *request);\n    virtual mfxStatus ReleaseResponse(mfxFrameAllocResponse *response);\n    virtual mfxStatus AllocImpl(mfxFrameAllocRequest *request, mfxFrameAllocResponse *response);\n    virtual mfxStatus ReallocImpl(mfxMemId midIn, const mfxFrameInfo *info, mfxU16 memType, mfxMemId *midOut);\n\n    std::set&lt;mfxFrameAllocResponse *&gt; m_vResp;\n    mfxMemId *GetMidHolder(mfxMemId mid);\n};\n\nmfxU32 GetSurfaceSize(mfxU32 FourCC, mfxU32 Width2, mfxU32 Height2);\n\n#endif // __SYSMEM_ALLOCATOR_H__\n"}, "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp": {"id": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "filePath": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "content": "/******************************************************************************\\\nCopyright (c) 2005-2019, Intel Corporation\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis sample was distributed or derived from the Intel&#x27;s Media Samples package.\nThe original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio\nor https://software.intel.com/en-us/media-client-solutions-support.\n\\**********************************************************************************/\n\n#include &quot;sysmem_allocator.h&quot;\n\n#define ID_BUFFER MFX_MAKEFOURCC(&#x27;B&#x27;,&#x27;U&#x27;,&#x27;F&#x27;,&#x27;F&#x27;)\n#define ID_FRAME  MFX_MAKEFOURCC(&#x27;F&#x27;,&#x27;R&#x27;,&#x27;M&#x27;,&#x27;E&#x27;)\n\nmfxStatus AllocBuffer(mfxU32 nbytes, mfxU16 type, mfxMemId *mid);\nmfxStatus LockBuffer(mfxMemId mid, mfxU8 **ptr);\nmfxStatus UnlockBuffer(mfxMemId mid);\nmfxStatus FreeBuffer(mfxMemId mid);\n\nSysMemFrameAllocator::~SysMemFrameAllocator()\n{\n    Close();\n}\n\nmfxStatus SysMemFrameAllocator::Close()\n{\n    return BaseFrameAllocator::Close();\n}\n\nmfxStatus SysMemFrameAllocator::LockFrame(mfxMemId mid, mfxFrameData *ptr)\n{\n    if (!ptr)\n        return MFX_ERR_NULL_PTR;\n\n    // If allocator uses pointers instead of mids, no further action is required\n    if (!mid &amp;&amp; ptr-&gt;Y)\n        return MFX_ERR_NONE;\n\n    sFrame *fs = 0;\n    mfxStatus sts = LockBuffer(mid,(mfxU8 **)&amp;fs);\n\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    if (ID_FRAME != fs-&gt;id)\n    {\n        UnlockBuffer(mid);\n        return MFX_ERR_INVALID_HANDLE;\n    }\n\n    mfxU16 Width2 = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width);\n    mfxU16 Height2 = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Height);\n    ptr-&gt;B = ptr-&gt;Y = (mfxU8 *)fs + MSDK_ALIGN32(sizeof(sFrame));\n\n    switch (fs-&gt;info.FourCC)\n    {\n    case MFX_FOURCC_NV12:\n        ptr-&gt;U = ptr-&gt;Y + Width2 * Height2;\n        ptr-&gt;V = ptr-&gt;U + 1;\n        ptr-&gt;PitchHigh = 0;\n        ptr-&gt;PitchLow = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width);\n        break;\n    case MFX_FOURCC_NV16:\n        ptr-&gt;U = ptr-&gt;Y + Width2 * Height2;\n        ptr-&gt;V = ptr-&gt;U + 1;\n        ptr-&gt;PitchHigh = 0;\n        ptr-&gt;PitchLow = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width);\n        break;\n    case MFX_FOURCC_YV12:\n        ptr-&gt;V = ptr-&gt;Y + Width2 * Height2;\n        ptr-&gt;U = ptr-&gt;V + (Width2 &gt;&gt; 1) * (Height2 &gt;&gt; 1);\n        ptr-&gt;PitchHigh = 0;\n        ptr-&gt;PitchLow = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width);\n        break;\n    case MFX_FOURCC_UYVY:\n        ptr-&gt;U = ptr-&gt;Y;\n        ptr-&gt;Y = ptr-&gt;U + 1;\n        ptr-&gt;V = ptr-&gt;U + 2;\n        ptr-&gt;PitchHigh = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n    case MFX_FOURCC_YUY2:\n        ptr-&gt;U = ptr-&gt;Y + 1;\n        ptr-&gt;V = ptr-&gt;Y + 3;\n        ptr-&gt;PitchHigh = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#if (MFX_VERSION &gt;= 1028)\n    case MFX_FOURCC_RGB565:\n        ptr-&gt;G = ptr-&gt;B;\n        ptr-&gt;R = ptr-&gt;B;\n        ptr-&gt;PitchHigh = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#endif\n    case MFX_FOURCC_RGB3:\n        ptr-&gt;G = ptr-&gt;B + 1;\n        ptr-&gt;R = ptr-&gt;B + 2;\n        ptr-&gt;PitchHigh = (mfxU16)((3 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((3 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#if !(defined(_WIN32) || defined(_WIN64))\n    case MFX_FOURCC_RGBP:\n        ptr-&gt;G = ptr-&gt;B + Width2 * Height2;\n        ptr-&gt;R = ptr-&gt;B + Width2 * Height2 * 2;\n        ptr-&gt;PitchHigh = (mfxU16)((MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#endif\n    case MFX_FOURCC_RGB4:\n    case MFX_FOURCC_A2RGB10:\n        ptr-&gt;G = ptr-&gt;B + 1;\n        ptr-&gt;R = ptr-&gt;B + 2;\n        ptr-&gt;A = ptr-&gt;B + 3;\n        ptr-&gt;PitchHigh = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n    case MFX_FOURCC_R16:\n        ptr-&gt;Y16 = (mfxU16 *)ptr-&gt;B;\n        ptr-&gt;PitchHigh = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((2 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n    case MFX_FOURCC_P010:\n        ptr-&gt;U = ptr-&gt;Y + Width2 * Height2 * 2;\n        ptr-&gt;V = ptr-&gt;U + 2;\n        ptr-&gt;PitchHigh = 0;\n        ptr-&gt;PitchLow = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width * 2);\n        break;\n    case MFX_FOURCC_P210:\n        ptr-&gt;U = ptr-&gt;Y + Width2 * Height2 * 2;\n        ptr-&gt;V = ptr-&gt;U + 2;\n        ptr-&gt;PitchHigh = 0;\n        ptr-&gt;PitchLow = (mfxU16)MSDK_ALIGN32(fs-&gt;info.Width * 2);\n        break;\n    case MFX_FOURCC_AYUV:\n        ptr-&gt;V = ptr-&gt;B;\n        ptr-&gt;U = ptr-&gt;V + 1;\n        ptr-&gt;Y = ptr-&gt;V + 2;\n        ptr-&gt;A = ptr-&gt;V + 3;\n        ptr-&gt;PitchHigh = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#if (MFX_VERSION &gt;= 1027)\n    case MFX_FOURCC_Y210:\n        ptr-&gt;Y16 = (mfxU16 *)ptr-&gt;B;\n        ptr-&gt;U16 = ptr-&gt;Y16 + 1;\n        ptr-&gt;V16 = ptr-&gt;Y16 + 3;\n        //4 words per macropixel -&gt; 2 words per pixel -&gt; 4 bytes per pixel\n        ptr-&gt;PitchHigh = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n    case MFX_FOURCC_Y410:\n        ptr-&gt;U = ptr-&gt;V = ptr-&gt;A = ptr-&gt;Y;\n        ptr-&gt;PitchHigh = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) / (1 &lt;&lt; 16));\n        ptr-&gt;PitchLow = (mfxU16)((4 * MSDK_ALIGN32(fs-&gt;info.Width)) % (1 &lt;&lt; 16));\n        break;\n#endif\n\n    default:\n        return MFX_ERR_UNSUPPORTED;\n    }\n\n    return MFX_ERR_NONE;\n}\n\nmfxStatus SysMemFrameAllocator::UnlockFrame(mfxMemId mid, mfxFrameData *ptr)\n{\n    // If allocator uses pointers instead of mids, no further action is required\n    if (!mid &amp;&amp; ptr-&gt;Y)\n        return MFX_ERR_NONE;\n\n    mfxStatus sts = UnlockBuffer(mid);\n\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    if (NULL != ptr)\n    {\n        ptr-&gt;Pitch = 0;\n        ptr-&gt;Y     = 0;\n        ptr-&gt;U     = 0;\n        ptr-&gt;V     = 0;\n        ptr-&gt;A     = 0;\n    }\n\n    return MFX_ERR_NONE;\n}\n\nmfxStatus SysMemFrameAllocator::GetFrameHDL(mfxMemId /*mid*/, mfxHDL* /*handle*/)\n{\n    return MFX_ERR_UNSUPPORTED;\n}\n\nmfxStatus SysMemFrameAllocator::CheckRequestType(mfxFrameAllocRequest *request)\n{\n    mfxStatus sts = BaseFrameAllocator::CheckRequestType(request);\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    if ((request-&gt;Type &amp; MFX_MEMTYPE_SYSTEM_MEMORY) != 0)\n        return MFX_ERR_NONE;\n    else\n        return MFX_ERR_UNSUPPORTED;\n}\n\nmfxMemId *SysMemFrameAllocator::GetMidHolder(mfxMemId mid)\n{\n    for (auto resp : m_vResp)\n    {\n        mfxMemId *it = std::find(resp-&gt;mids, resp-&gt;mids + resp-&gt;NumFrameActual, mid);\n        if (it != resp-&gt;mids + resp-&gt;NumFrameActual)\n            return it;\n    }\n    return nullptr;\n}\n\nmfxU32 GetSurfaceSize(mfxU32 FourCC, mfxU32 Width2, mfxU32 Height2)\n{\n    mfxU32 nbytes = 0;\n\n    switch (FourCC)\n    {\n    case MFX_FOURCC_YV12:\n    case MFX_FOURCC_NV12:\n        nbytes = Width2*Height2 + (Width2&gt;&gt;1)*(Height2&gt;&gt;1) + (Width2&gt;&gt;1)*(Height2&gt;&gt;1);\n        break;\n    case MFX_FOURCC_NV16:\n        nbytes = Width2*Height2 + (Width2&gt;&gt;1)*(Height2) + (Width2&gt;&gt;1)*(Height2);\n        break;\n#if (MFX_VERSION &gt;= 1028)\n    case MFX_FOURCC_RGB565:\n        nbytes = 2*Width2*Height2;\n        break;\n#endif\n#if !(defined(_WIN32) || defined(_WIN64))\n    case MFX_FOURCC_RGBP:\n#endif\n    case MFX_FOURCC_RGB3:\n        nbytes = Width2*Height2 + Width2*Height2 + Width2*Height2;\n        break;\n    case MFX_FOURCC_RGB4:\n    case MFX_FOURCC_AYUV:\n#if (MFX_VERSION &gt;= 1027)\n    case MFX_FOURCC_Y410:\n#endif\n        nbytes = Width2*Height2 + Width2*Height2 + Width2*Height2 + Width2*Height2;\n        break;\n    case MFX_FOURCC_UYVY:\n    case MFX_FOURCC_YUY2:\n        nbytes = Width2*Height2 + (Width2&gt;&gt;1)*(Height2) + (Width2&gt;&gt;1)*(Height2);\n        break;\n    case MFX_FOURCC_R16:\n        nbytes = 2*Width2*Height2;\n        break;\n    case MFX_FOURCC_P010:\n        nbytes = Width2*Height2 + (Width2&gt;&gt;1)*(Height2&gt;&gt;1) + (Width2&gt;&gt;1)*(Height2&gt;&gt;1);\n        nbytes *= 2;\n        break;\n    case MFX_FOURCC_A2RGB10:\n        nbytes = Width2*Height2*4; // 4 bytes per pixel\n        break;\n    case MFX_FOURCC_P210:\n#if (MFX_VERSION &gt;= 1027)\n    case MFX_FOURCC_Y210:\n#endif\n        nbytes = Width2*Height2 + (Width2&gt;&gt;1)*(Height2) + (Width2&gt;&gt;1)*(Height2);\n        nbytes *= 2; // 16bits\n        break;\n\n\n    default:\n        break;\n    }\n\n    return nbytes;\n}\n\nmfxStatus SysMemFrameAllocator::ReallocImpl(mfxMemId mid, const mfxFrameInfo *info, mfxU16 /*memType*/, mfxMemId *midOut)\n{\n    if (!info || !midOut)\n        return MFX_ERR_NULL_PTR;\n\n    mfxU32 nbytes = GetSurfaceSize(info-&gt;FourCC, MSDK_ALIGN32(info-&gt;Width), MSDK_ALIGN32(info-&gt;Height));\n    if(!nbytes)\n        return MFX_ERR_UNSUPPORTED;\n\n    // pointer to the record in m_mids structure\n    mfxMemId *pmid = GetMidHolder(mid);\n    if (!pmid)\n        return MFX_ERR_MEMORY_ALLOC;\n\n    mfxStatus sts = FreeBuffer(*pmid);\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    sts = AllocBuffer(\n        MSDK_ALIGN32(nbytes) + MSDK_ALIGN32(sizeof(sFrame)), MFX_MEMTYPE_SYSTEM_MEMORY, pmid);\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    sFrame *fs;\n    sts = LockBuffer(*pmid, (mfxU8 **)&amp;fs);\n    if (MFX_ERR_NONE != sts)\n        return sts;\n\n    fs-&gt;id = ID_FRAME;\n    fs-&gt;info = *info;\n    UnlockBuffer(*pmid);\n\n    *midOut = *pmid;\n    return MFX_ERR_NONE;\n}\n\nmfxStatus SysMemFrameAllocator::AllocImpl(mfxFrameAllocRequest *request, mfxFrameAllocResponse *response)\n{\n    mfxU32 numAllocated = 0;\n\n    mfxU32 nbytes = GetSurfaceSize(request-&gt;Info.FourCC, MSDK_ALIGN32(request-&gt;Info.Width), MSDK_ALIGN32(request-&gt;Info.Height));\n    if(!nbytes)\n        return MFX_ERR_UNSUPPORTED;\n\n    std::unique_ptr&lt;mfxMemId[]&gt; mids(new mfxMemId[request-&gt;NumFrameSuggested]);\n\n    // allocate frames\n    for (numAllocated = 0; numAllocated &lt; request-&gt;NumFrameSuggested; numAllocated ++)\n    {\n        mfxStatus sts = AllocBuffer(nbytes + MSDK_ALIGN32(sizeof(sFrame)), request-&gt;Type, &amp;(mids[numAllocated]));\n\n        if (MFX_ERR_NONE != sts)\n            break;\n\n        sFrame *fs;\n        sts = LockBuffer(mids[numAllocated], (mfxU8 **)&amp;fs);\n\n        if (MFX_ERR_NONE != sts)\n            break;\n\n        fs-&gt;id = ID_FRAME;\n        fs-&gt;info = request-&gt;Info;\n        sts = UnlockBuffer(mids[numAllocated]);\n\n        if (MFX_ERR_NONE != sts)\n            break;\n    }\n\n    // check the number of allocated frames\n    if (numAllocated &lt; request-&gt;NumFrameSuggested)\n    {\n        return MFX_ERR_MEMORY_ALLOC;\n    }\n\n    response-&gt;NumFrameActual = (mfxU16) numAllocated;\n    response-&gt;mids = mids.release();\n\n    m_vResp.insert(response);\n    return MFX_ERR_NONE;\n}\n\nmfxStatus SysMemFrameAllocator::ReleaseResponse(mfxFrameAllocResponse *response)\n{\n    if (!response)\n        return MFX_ERR_NULL_PTR;\n\n    mfxStatus sts = MFX_ERR_NONE;\n\n    if (response-&gt;mids)\n    {\n        for (mfxU32 i = 0; i &lt; response-&gt;NumFrameActual; i++)\n        {\n            if (response-&gt;mids[i])\n            {\n                sts = FreeBuffer(response-&gt;mids[i]);\n                if (MFX_ERR_NONE != sts)\n                    return sts;\n            }\n        }\n    }\n    m_vResp.erase(response);\n    delete [] response-&gt;mids;\n    response-&gt;mids = 0;\n\n    return sts;\n}\n\nmfxStatus AllocBuffer(mfxU32 nbytes, mfxU16 type, mfxMemId *mid)\n{\n    if (!mid)\n        return MFX_ERR_NULL_PTR;\n\n    if (0 == (type &amp; MFX_MEMTYPE_SYSTEM_MEMORY))\n        return MFX_ERR_UNSUPPORTED;\n\n    mfxU32 header_size = MSDK_ALIGN32(sizeof(sBuffer));\n    mfxU8 *buffer_ptr = (mfxU8 *)calloc(header_size + nbytes + 32, 1);\n\n    if (!buffer_ptr)\n        return MFX_ERR_MEMORY_ALLOC;\n\n    sBuffer *bs = (sBuffer *)buffer_ptr;\n    bs-&gt;id = ID_BUFFER;\n    bs-&gt;type = type;\n    bs-&gt;nbytes = nbytes;\n    *mid = (mfxHDL) bs;\n    return MFX_ERR_NONE;\n}\n\nmfxStatus LockBuffer(mfxMemId mid, mfxU8 **ptr)\n{\n    if (!ptr)\n        return MFX_ERR_NULL_PTR;\n\n    sBuffer *bs = (sBuffer *)mid;\n\n    if (!bs)\n        return MFX_ERR_INVALID_HANDLE;\n    if (ID_BUFFER != bs-&gt;id)\n        return MFX_ERR_INVALID_HANDLE;\n\n    *ptr = (mfxU8*)((size_t)((mfxU8 *)bs+MSDK_ALIGN32(sizeof(sBuffer))+31)&amp;(~((size_t)31)));\n    return MFX_ERR_NONE;\n}\n\nmfxStatus UnlockBuffer(mfxMemId mid)\n{\n    sBuffer *bs = (sBuffer *)mid;\n\n    if (!bs || ID_BUFFER != bs-&gt;id)\n        return MFX_ERR_INVALID_HANDLE;\n\n    return MFX_ERR_NONE;\n}\n\nmfxStatus FreeBuffer(mfxMemId mid)\n{\n    sBuffer *bs = (sBuffer *)mid;\n    if (!bs || ID_BUFFER != bs-&gt;id)\n        return MFX_ERR_INVALID_HANDLE;\n\n    free(bs);\n    return MFX_ERR_NONE;\n}\n"}, "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxstructures.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxstructures.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxstructures.h", "content": "/*############################################################################\n  # Copyright Intel Corporation\n  #\n  # SPDX-License-Identifier: MIT\n  ############################################################################*/\n\n#ifndef __MFXSTRUCTURES_H__\n#define __MFXSTRUCTURES_H__\n#include &quot;mfxcommon.h&quot;\n\n#if !defined (__GNUC__)\n#pragma warning(disable: 4201)\n#endif\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\n/* Frame ID for MVC */\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Describes the view and layer of a frame picture. */\ntypedef struct {\n    mfxU16      TemporalId;  /*!&lt; The temporal identifier as defined in the annex H of the ITU*-T H.264 specification. */\n    mfxU16      PriorityId;  /*!&lt; Reserved and must be zero. */\n    union {\n        struct {\n            mfxU16  DependencyId; /*!&lt; Reserved for future use. */\n            mfxU16  QualityId;    /*!&lt; Reserved for future use. */\n        };\n        struct {\n            mfxU16  ViewId; /*!&lt; The view identifier as defined in the annex H of the ITU-T H.264 specification. */\n        };\n    };\n} mfxFrameId;\nMFX_PACK_END()\n\n/* This struct has 4-byte alignment for binary compatibility with previously released versions of API. */\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies properties of video frames. See also &quot;Configuration Parameter Constraints&quot; chapter. */\ntypedef struct {\n    mfxU32  reserved[4]; /*!&lt; Reserved for future use. */\n    /*! The unique ID of each VPP channel set by application. It&#x27;s required that during Init/Reset application fills ChannelId for\n        each mfxVideoChannelParam provided by the application and the SDK sets it back to the correspondent\n        mfxSurfaceArray::mfxFrameSurface1 to distinguish different channels. It&#x27;s expected that surfaces for some channels might be\n        returned with some delay so application has to use mfxFrameInfo::ChannelId to distinguish what returned surface belongs to\n        what VPP channel. Decoder&#x27;s initialization parameters are always sent through channel with mfxFrameInfo::ChannelId equals to\n        zero. It&#x27;s allowed to skip setting of decoder&#x27;s parameters for simplified decoding procedure */\n    mfxU16  ChannelId;\n    /*! Number of bits used to represent luma samples.\n        @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU16  BitDepthLuma;\n    /*! Number of bits used to represent chroma samples.\n        @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU16  BitDepthChroma;\n    /*! When the value is not zero, indicates that values of luma and chroma samples are shifted. Use BitDepthLuma and BitDepthChroma to calculate\n        shift size. Use zero value to indicate absence of shift. See example data alignment below.\n\n        @note Not all codecs and implementations support this value. Use the Query API  function to check if this feature is supported.\n    */\n    mfxU16  Shift;\n    mfxFrameId FrameId; /*!&lt; Describes the view and layer of a frame picture. */\n    mfxU32  FourCC;     /*!&lt; FourCC code of the color format. See the ColorFourCC enumerator for details. */\n    union {\n        struct { /* Frame parameters */\n            /*! Width of the video frame in pixels. Must be a multiple of 16. \n                In case of fused operation of decode plus VPP it can be set to zero to signalize that scaling operation is not requested. */\n            mfxU16  Width;  \n            /*! Height of the video frame in pixels. Must be a multiple of 16 for progressive frame sequence and a multiple of 32 otherwise. \n                In case of fused operation of decode plus VPP it can be set to zero to signalize that scaling operation is not requested. */\n            mfxU16  Height; \n\n            /*! @{\n             @name ROI\n             The region of interest of the frame. Specify the display width and height in mfxVideoParam. */\n            /*! X coordinate.\n                In case of fused operation of decode plus VPP it can be set to zero to signalize that cropping operation is not requested. */\n            mfxU16  CropX; \n            /*! Y coordinate.\n                In case of fused operation of decode plus VPP it can be set to zero to signalize that cropping operation is not requested. */\n            mfxU16  CropY; \n            /*! Width in pixels. \n                In case of fused operation of decode plus VPP it can be set to zero to signalize that cropping operation is not requested. */\n            mfxU16  CropW; \n            /*! Height in pixels. \n                In case of fused operation of decode plus VPP it can be set to zero to signalize that cropping operation is not requested. */\n            mfxU16  CropH; \n            /*! @} */\n        };\n        struct { /* Buffer parameters (for plain formats like P8) */\n            mfxU64 BufferSize; /*!&lt; Size of frame buffer in bytes. Valid only for plain formats (when FourCC is P8). In this case, Width, Height, and crop values are invalid. */\n            mfxU32 reserved5;\n        };\n    };\n\n    /*! @{\n        @name FrameRate\n        Specify the frame rate with the following formula: FrameRateExtN / FrameRateExtD.\n\n        For encoding, frame rate must be specified. For decoding, frame rate may be unspecified (FrameRateExtN and FrameRateExtD\n        are all zeros.) In this case, the frame rate is defaulted to 30 frames per second.\n    */\n    mfxU32  FrameRateExtN; /*!&lt; Frame rate numerator. */\n    mfxU32  FrameRateExtD; /*!&lt; Frame rate denominator. */\n    /*! @} */\n    mfxU16  reserved3;\n\n    /*! @{\n        @name AspectRatio\n        AspectRatioW and AspectRatioH are used to specify the sample aspect ratio. If sample aspect ratio is explicitly defined by the standards (see\n        Table 6-3 in the MPEG-2 specification or Table E-1 in the H.264 specification), AspectRatioW and AspectRatioH should be the defined values.\n        Otherwise, the sample aspect ratio can be derived as follows:\n\n        @li @c AspectRatioW=display_aspect_ratio_width*display_height\n\n        @li @c AspectRatioH=display_aspect_ratio_height*display_width\n\n        For MPEG-2, the above display aspect ratio must be one of the defined values in Table 6-3 in the MPEG-2 specification. For H.264, there is no restriction\n        on display aspect ratio values.\n\n        If both parameters are zero, the encoder uses the default value of sample aspect ratio.\n    */\n    mfxU16  AspectRatioW; /*!&lt; Aspect Ratio for width. */\n    mfxU16  AspectRatioH; /*!&lt; Aspect Ratio for height. */\n    /*! @} */\n\n    mfxU16  PicStruct;    /*!&lt; Picture type as specified in the PicStruct enumerator. */\n    mfxU16  ChromaFormat; /*!&lt; Color sampling method. Value is the same as that of ChromaFormatIdc.\n                               ChromaFormat is not defined if FourCC is zero.*/\n    mfxU16  reserved2;\n} mfxFrameInfo;\nMFX_PACK_END()\n\n/*! The ColorFourCC enumerator itemizes color formats. */\nenum {\n    MFX_FOURCC_NV12         = MFX_MAKEFOURCC(&#x27;N&#x27;,&#x27;V&#x27;,&#x27;1&#x27;,&#x27;2&#x27;),   /*!&lt; NV12 color planes. Native format for 4:2:0/8b Gen hardware implementation. */\n    MFX_FOURCC_YV12         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;V&#x27;,&#x27;1&#x27;,&#x27;2&#x27;),   /*!&lt; YV12 color planes. */\n    MFX_FOURCC_NV16         = MFX_MAKEFOURCC(&#x27;N&#x27;,&#x27;V&#x27;,&#x27;1&#x27;,&#x27;6&#x27;),   /*!&lt; 4:2:2 color format with similar to NV12 layout. */\n    MFX_FOURCC_YUY2         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;U&#x27;,&#x27;Y&#x27;,&#x27;2&#x27;),   /*!&lt; YUY2 color planes. */\n    MFX_FOURCC_RGB565       = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;B&#x27;,&#x27;2&#x27;),   /*!&lt; 2 bytes per pixel, uint16 in little-endian format, where 0-4 bits are blue, bits 5-10 are green and bits 11-15 are red. */\n    /*! RGB 24 bit planar layout (3 separate channels, 8-bits per sample each). This format should be mapped to D3DFMT_R8G8B8 or VA_FOURCC_RGBP. */\n    MFX_FOURCC_RGBP         = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;B&#x27;,&#x27;P&#x27;),\n    MFX_DEPRECATED_ENUM_FIELD_INSIDE(MFX_FOURCC_RGB3)         = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;B&#x27;,&#x27;3&#x27;),   /* Deprecated. */\n    MFX_FOURCC_RGB4         = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;B&#x27;,&#x27;4&#x27;),   /*!&lt; RGB4 (RGB32) color planes. BGRA is the order, &#x27;B&#x27; is 8 MSBs, then 8 bits for &#x27;G&#x27; channel, then &#x27;R&#x27; and &#x27;A&#x27; channels. */\n    /*!\n       Internal color format. The application should use the following functions to create a surface that corresponds to the Direct3D* version in use.\n\n       For Direct3D* 9: IDirectXVideoDecoderService::CreateSurface()\n\n       For Direct3D* 11: ID3D11Device::CreateBuffer()\n    */\n    MFX_FOURCC_P8           = 41,\n    /*!\n       Internal color format. The application should use the following functions to create a surface that corresponds to the Direct3D* version in use.\n\n       For Direct3D 9: IDirectXVideoDecoderService::CreateSurface()\n\n       For Direct3D 11: ID3D11Device::CreateTexture2D()\n    */\n    MFX_FOURCC_P8_TEXTURE   = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;8&#x27;,&#x27;M&#x27;,&#x27;B&#x27;),\n    MFX_FOURCC_P010         = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;), /*!&lt; P010 color format. This is 10 bit per sample format with similar to NV12 layout. This format should be mapped to DXGI_FORMAT_P010. */\n    MFX_FOURCC_P016         = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;6&#x27;), /*!&lt; P016 color format. This is 16 bit per sample format with similar to NV12 layout. This format should be mapped to DXGI_FORMAT_P016. */\n    MFX_FOURCC_P210         = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;0&#x27;), /*!&lt; 10 bit per sample 4:2:2 color format with similar to NV12 layout. */\n    MFX_FOURCC_BGR4         = MFX_MAKEFOURCC(&#x27;B&#x27;,&#x27;G&#x27;,&#x27;R&#x27;,&#x27;4&#x27;), /*!&lt; RGBA color format. It is similar to MFX_FOURCC_RGB4 but with different order of channels. &#x27;R&#x27; is 8 MSBs, then 8 bits for &#x27;G&#x27; channel, then &#x27;B&#x27; and &#x27;A&#x27; channels. */\n    MFX_FOURCC_A2RGB10      = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;1&#x27;,&#x27;0&#x27;), /*!&lt; 10 bits ARGB color format packed in 32 bits. &#x27;A&#x27; channel is two MSBs, then &#x27;R&#x27;, then &#x27;G&#x27; and then &#x27;B&#x27; channels. This format should be mapped to DXGI_FORMAT_R10G10B10A2_UNORM or D3DFMT_A2R10G10B10. */\n    MFX_FOURCC_ARGB16       = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;G&#x27;,&#x27;1&#x27;,&#x27;6&#x27;), /*!&lt; 10 bits ARGB color format packed in 64 bits. &#x27;A&#x27; channel is 16 MSBs, then &#x27;R&#x27;, then &#x27;G&#x27; and then &#x27;B&#x27; channels. This format should be mapped to DXGI_FORMAT_R16G16B16A16_UINT or D3DFMT_A16B16G16R16 formats. */\n    MFX_FOURCC_ABGR16       = MFX_MAKEFOURCC(&#x27;B&#x27;,&#x27;G&#x27;,&#x27;1&#x27;,&#x27;6&#x27;), /*!&lt; 10 bits ABGR color format packed in 64 bits. &#x27;A&#x27; channel is 16 MSBs, then &#x27;B&#x27;, then &#x27;G&#x27; and then &#x27;R&#x27; channels. This format should be mapped to DXGI_FORMAT_R16G16B16A16_UINT or D3DFMT_A16B16G16R16 formats. */\n    MFX_FOURCC_R16          = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;1&#x27;,&#x27;6&#x27;,&#x27;U&#x27;), /*!&lt; 16 bits single channel color format. This format should be mapped to DXGI_FORMAT_R16_TYPELESS or D3DFMT_R16F. */\n    MFX_FOURCC_AYUV         = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;Y&#x27;,&#x27;U&#x27;,&#x27;V&#x27;), /*!&lt; YUV 4:4:4, AYUV color format. This format should be mapped to DXGI_FORMAT_AYUV. */\n    MFX_FOURCC_AYUV_RGB4    = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;V&#x27;,&#x27;U&#x27;,&#x27;Y&#x27;), /*!&lt; RGB4 stored in AYUV surface. This format should be mapped to DXGI_FORMAT_AYUV. */\n    MFX_FOURCC_UYVY         = MFX_MAKEFOURCC(&#x27;U&#x27;,&#x27;Y&#x27;,&#x27;V&#x27;,&#x27;Y&#x27;), /*!&lt; UYVY color planes. Same as YUY2 except the byte order is reversed. */\n    MFX_FOURCC_Y210         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;0&#x27;), /*!&lt; 10 bit per sample 4:2:2 packed color format with similar to YUY2 layout. This format should be mapped to DXGI_FORMAT_Y210. */\n    MFX_FOURCC_Y410         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;0&#x27;), /*!&lt; 10 bit per sample 4:4:4 packed color format. This format should be mapped to DXGI_FORMAT_Y410. */\n    MFX_FOURCC_Y216         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;2&#x27;,&#x27;1&#x27;,&#x27;6&#x27;), /*!&lt; 16 bit per sample 4:2:2 packed color format with similar to YUY2 layout. This format should be mapped to DXGI_FORMAT_Y216. */\n    MFX_FOURCC_Y416         = MFX_MAKEFOURCC(&#x27;Y&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;6&#x27;), /*!&lt; 16 bit per sample 4:4:4 packed color format. This format should be mapped to DXGI_FORMAT_Y416. */\n    MFX_FOURCC_NV21         = MFX_MAKEFOURCC(&#x27;N&#x27;, &#x27;V&#x27;, &#x27;2&#x27;, &#x27;1&#x27;), /*!&lt; Same as NV12 but with weaved V and U values. */\n    MFX_FOURCC_IYUV         = MFX_MAKEFOURCC(&#x27;I&#x27;, &#x27;Y&#x27;, &#x27;U&#x27;, &#x27;V&#x27;), /*!&lt; Same as  YV12 except that the U and V plane order is reversed. */\n    MFX_FOURCC_I010         = MFX_MAKEFOURCC(&#x27;I&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;0&#x27;), /*!&lt; 10-bit YUV 4:2:0, each component has its own plane. */\n    MFX_FOURCC_I210         = MFX_MAKEFOURCC(&#x27;I&#x27;, &#x27;2&#x27;, &#x27;1&#x27;, &#x27;0&#x27;), /*!&lt; 10-bit YUV 4:2:2, each component has its own plane. */\n    MFX_FOURCC_I420         = MFX_FOURCC_IYUV,                 /*!&lt; Alias for the IYUV color format. */\n    MFX_FOURCC_I422         = MFX_MAKEFOURCC(&#x27;I&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;2&#x27;), /*!&lt; Same as YV16 except that the U and V plane order is reversed */\n    MFX_FOURCC_BGRA         = MFX_FOURCC_RGB4,                 /*!&lt; Alias for the RGB4 color format. */\n    /*! BGR 24 bit planar layout (3 separate channels, 8-bits per sample each). This format should be mapped to VA_FOURCC_BGRP. */\n    MFX_FOURCC_BGRP         = MFX_MAKEFOURCC(&#x27;B&#x27;,&#x27;G&#x27;,&#x27;R&#x27;,&#x27;P&#x27;),\n    /*! 8bit per sample 4:4:4 format packed in 32 bits, X=unused/undefined, &#x27;X&#x27; channel is 8 MSBs, then &#x27;Y&#x27;, then &#x27;U&#x27;, and then &#x27;V&#x27; channels. This format should be mapped to VA_FOURCC_XYUV. */\n    MFX_FOURCC_XYUV         = MFX_MAKEFOURCC(&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;U&#x27;,&#x27;V&#x27;),\n    MFX_FOURCC_ABGR16F      = MFX_MAKEFOURCC(&#x27;B&#x27;, &#x27;G&#x27;, &#x27;R&#x27;, &#x27;F&#x27;),  /*!&lt; 16 bits float point ABGR color format packed in 64 bits. &#x27;A&#x27; channel is 16 MSBs, then &#x27;B&#x27;, then &#x27;G&#x27; and then &#x27;R&#x27; channels. This format should be mapped to DXGI_FORMAT_R16G16B16A16_FLOAT or D3DFMT_A16B16G16R16F formats.. */\n};\n\n/* PicStruct */\nenum {\n    MFX_PICSTRUCT_UNKNOWN       =0x00,  /*!&lt; Unspecified or mixed progressive/interlaced/field pictures. */\n    MFX_PICSTRUCT_PROGRESSIVE   =0x01,  /*!&lt; Progressive picture. */\n    MFX_PICSTRUCT_FIELD_TFF     =0x02,  /*!&lt; Top field in first interlaced picture.  */\n    MFX_PICSTRUCT_FIELD_BFF     =0x04,  /*!&lt; Bottom field in first interlaced picture.  */\n\n    MFX_PICSTRUCT_FIELD_REPEATED=0x10,  /*!&lt; First field repeated: pic_struct=5 or 6 in H.264. */\n    MFX_PICSTRUCT_FRAME_DOUBLING=0x20,  /*!&lt; Double the frame for display: pic_struct=7 in H.264. */\n    MFX_PICSTRUCT_FRAME_TRIPLING=0x40,  /*!&lt; Triple the frame for display: pic_struct=8 in H.264. */\n\n    MFX_PICSTRUCT_FIELD_SINGLE      =0x100, /*!&lt; Single field in a picture. */\n    MFX_PICSTRUCT_FIELD_TOP         =MFX_PICSTRUCT_FIELD_SINGLE | MFX_PICSTRUCT_FIELD_TFF, /*!&lt; Top field in a picture: pic_struct = 1 in H.265. */\n    MFX_PICSTRUCT_FIELD_BOTTOM      =MFX_PICSTRUCT_FIELD_SINGLE | MFX_PICSTRUCT_FIELD_BFF, /*!&lt; Bottom field in a picture: pic_struct = 2 in H.265. */\n    MFX_PICSTRUCT_FIELD_PAIRED_PREV =0x200, /*!&lt; Paired with previous field: pic_struct = 9 or 10 in H.265. */\n    MFX_PICSTRUCT_FIELD_PAIRED_NEXT =0x400, /*!&lt; Paired with next field: pic_struct = 11 or 12 in H.265 */\n};\n\n/* The ChromaFormatIdc enumerator itemizes color-sampling formats. */\nenum {\n    MFX_CHROMAFORMAT_MONOCHROME =0, /*!&lt; Monochrome. */\n    MFX_CHROMAFORMAT_YUV420     =1, /*!&lt; 4:2:0 color. */\n    MFX_CHROMAFORMAT_YUV422     =2, /*!&lt; 4:2:2 color. */\n    MFX_CHROMAFORMAT_YUV444     =3, /*!&lt; 4:4:4 color. */\n    MFX_CHROMAFORMAT_YUV400     = MFX_CHROMAFORMAT_MONOCHROME, /*!&lt; Equal to monochrome. */\n    MFX_CHROMAFORMAT_YUV411     = 4, /*!&lt; 4:1:1 color. */\n    MFX_CHROMAFORMAT_YUV422H    = MFX_CHROMAFORMAT_YUV422, /*!&lt; 4:2:2 color, horizontal sub-sampling. It is equal to 4:2:2 color. */\n    MFX_CHROMAFORMAT_YUV422V    = 5, /*!&lt; 4:2:2 color, vertical sub-sampling. */\n    MFX_CHROMAFORMAT_RESERVED1  = 6  /*!&lt; Reserved. */\n};\n\nenum {\n    MFX_TIMESTAMP_UNKNOWN = -1 /*!&lt; Indicates that time stamp is unknown for this frame/bitstream portion. */\n};\n\nenum {\n    MFX_FRAMEORDER_UNKNOWN = -1 /*!&lt; Unused entry or API functions that generate the frame output do not use this frame. */\n};\n\n/* The FrameDataFlag enumerator itemizes DataFlag value in mfxFrameData. */\nenum {\n    MFX_FRAMEDATA_TIMESTAMP_UNKNOWN  = 0x0000,/*!&lt; Indicates the time stamp of this frame is unknown and will be calculated by SDK. */\n    MFX_FRAMEDATA_ORIGINAL_TIMESTAMP = 0x0001 /*!&lt; Indicates the time stamp of this frame is not calculated and is a pass-through of the original time stamp. */\n};\n\n/* Corrupted in mfxFrameData */\nenum {\n    MFX_CORRUPTION_NO              = 0x0000, /*!&lt; No corruption. */\n    MFX_CORRUPTION_MINOR           = 0x0001, /*!&lt; Minor corruption in decoding certain macro-blocks. */\n    MFX_CORRUPTION_MAJOR           = 0x0002, /*!&lt; Major corruption in decoding the frame - incomplete data, for example. */\n    MFX_CORRUPTION_ABSENT_TOP_FIELD           = 0x0004, /*!&lt; Top field of frame is absent in bitstream. Only bottom field has been decoded. */\n    MFX_CORRUPTION_ABSENT_BOTTOM_FIELD           = 0x0008, /*!&lt; Bottom field of frame is absent in bitstream. Only top filed has been decoded. */\n    MFX_CORRUPTION_REFERENCE_FRAME = 0x0010, /*!&lt; Decoding used a corrupted reference frame. A corrupted reference frame was used for decoding this\n                                                frame. For example, if the frame uses a reference frame that was decoded with minor/major corruption flag, then this\n                                                frame is also marked with a reference corruption flag. */\n    MFX_CORRUPTION_REFERENCE_LIST  = 0x0020, /*!&lt; The reference list information of this frame does not match what is specified in the Reference Picture Marking\n                                                  Repetition SEI message. (ITU-T H.264 D.1.8 dec_ref_pic_marking_repetition) */\n#ifdef ONEVPL_EXPERIMENTAL\n    MFX_CORRUPTION_HW_RESET        = 0x0040  /*!&lt; The hardware reset is reported from media driver. */\n#endif\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies &quot;pixel&quot; in Y410 color format. */\ntypedef struct\n{\n    mfxU32 U : 10; /*!&lt; U component. */\n    mfxU32 Y : 10; /*!&lt; Y component. */\n    mfxU32 V : 10; /*!&lt; V component. */\n    mfxU32 A :  2; /*!&lt; A component. */\n} mfxY410;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies &quot;pixel&quot; in Y416 color format. */\ntypedef struct\n{\n    mfxU32 U : 16; /*!&lt; U component. */\n    mfxU32 Y : 16; /*!&lt; Y component. */\n    mfxU32 V : 16; /*!&lt; V component. */\n    mfxU32 A : 16; /*!&lt; A component. */\n} mfxY416;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies &quot;pixel&quot; in A2RGB10 color format */\ntypedef struct\n{\n    mfxU32 B : 10; /*!&lt; B component. */\n    mfxU32 G : 10; /*!&lt; G component. */\n    mfxU32 R : 10; /*!&lt; R component. */\n    mfxU32 A :  2; /*!&lt; A component. */\n} mfxA2RGB10;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies &quot;pixel&quot; in ABGR 16 bit half float point color format */\ntypedef struct\n{\n    mfxFP16 R; /*!&lt; R component. */\n    mfxFP16 G; /*!&lt; G component. */\n    mfxFP16 B; /*!&lt; B component. */\n    mfxFP16 A; /*!&lt; A component. */\n} mfxABGR16FP;\nMFX_PACK_END()\n\n/*! Describes frame buffer pointers. */\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\ntypedef struct {\n    /*!  @name Extension Buffers */\n    /*! @{ */\n    union {\n        mfxExtBuffer **ExtParam; /*!&lt; Points to an array of pointers to the extra configuration structures. See the ExtendedBufferID\n                                      enumerator for a list of extended configurations. */\n        mfxU64       reserved2;\n    };\n    mfxU16  NumExtParam; /*!&lt; The number of extra configuration structures attached to this structure. */\n    /*! @} */\n\n    /*!  @name General members */\n    /*! @{ */\n    mfxU16      reserved[9]; /*!&lt; Reserved for future use. */\n    mfxU16      MemType;     /*!&lt; Allocated memory type. See the ExtMemFrameType enumerator for details. Used for better integration of\n                                  3rd party plugins into the pipeline. */\n    mfxU16      PitchHigh;   /*!&lt; Distance in bytes between the start of two consecutive rows in a frame. */\n\n    mfxU64      TimeStamp;   /*!&lt; Time stamp of the video frame in units of 90KHz. Divide TimeStamp by 90,000 (90 KHz) to obtain the time in seconds.\n                                  A value of MFX_TIMESTAMP_UNKNOWN indicates that there is no time stamp. */\n    mfxU32      FrameOrder;  /*!&lt; Current frame counter for the top field of the current frame. An invalid value of MFX_FRAMEORDER_UNKNOWN indicates that\n                            API functions that generate the frame output do not use this frame. */\n    mfxU16      Locked;      /*!&lt; Counter flag for the application. If Locked is greater than zero then the application locks the frame or field pair.\n                                  Do not move, alter or delete the frame. */\n    union{\n        mfxU16  Pitch;\n        mfxU16  PitchLow;    /*!&lt; Distance in bytes between the start of two consecutive rows in a frame. */\n    };\n    /*! @} */\n\n    /*!\n        @name Color Planes\n        Data pointers to corresponding color channels (planes). The frame buffer pointers must be 16-byte aligned. The application has to specify pointers to\n        all color channels even for packed formats. For example, for YUY2 format the application must specify Y, U, and V pointers.\n        For RGB32 format, the application must specify R, G, B, and A pointers.\n    */\n    /*! @{ */\n    union {\n        mfxU8   *Y; /*!&lt; Y channel. */\n        mfxU16  *Y16; /*!&lt; Y16 channel. */\n        mfxU8   *R; /*!&lt; R channel. */\n    };\n    union {\n        mfxU8   *UV;    /*!&lt; UV channel for UV merged formats. */\n        mfxU8   *VU;    /*!&lt; YU channel for VU merged formats. */\n        mfxU8   *CbCr;  /*!&lt; CbCr channel for CbCr merged formats. */\n        mfxU8   *CrCb;  /*!&lt; CrCb channel for CrCb merged formats. */\n        mfxU8   *Cb;    /*!&lt; Cb channel. */\n        mfxU8   *U;     /*!&lt; U channel. */\n        mfxU16  *U16;   /*!&lt; U16 channel. */\n        mfxU8   *G;     /*!&lt; G channel. */\n        mfxY410 *Y410;  /*!&lt; T410 channel for Y410 format (merged AVYU). */\n        mfxY416 *Y416;  /*!&lt; This format is a packed 16-bit representation that includes 16 bits of alpha. */\n    };\n    union {\n        mfxU8   *Cr;    /*!&lt; Cr channel. */\n        mfxU8   *V;     /*!&lt; V channel. */\n        mfxU16  *V16;   /*!&lt; V16 channel. */\n        mfxU8   *B;     /*!&lt; B channel. */\n        mfxA2RGB10 *A2RGB10; /*!&lt; A2RGB10 channel for A2RGB10 format (merged ARGB). */\n        mfxABGR16FP* ABGRFP16; /*!&lt; ABGRFP16 channel for half float ARGB format (use this merged one due to no separate FP16 Alpha Channel). */\n    };\n    mfxU8       *A;     /*!&lt; A channel. */\n    mfxMemId    MemId;  /*!&lt; Memory ID of the data buffers. Ignored if any of the preceding data pointers is non-zero. */\n    /*! @} */\n\n    /*!\n        @name Additional Flags\n    */\n    /*! @{ */\n    mfxU16  Corrupted; /*!&lt; Some part of the frame or field pair is corrupted. See the Corruption enumerator for details. */\n    mfxU16  DataFlag;  /*!&lt; Additional flags to indicate frame data properties. See the FrameDataFlag enumerator for details. */\n    /*! @} */\n} mfxFrameData;\nMFX_PACK_END()\n\n/*! The mfxHandleType enumerator itemizes system handle types that implementations might use. */\ntypedef enum {\n    MFX_HANDLE_DIRECT3D_DEVICE_MANAGER9         = 1,  /*!&lt; Pointer to the IDirect3DDeviceManager9 interface. See Working with Microsoft* DirectX* Applications for more details on how to use this handle. */\n    MFX_HANDLE_D3D9_DEVICE_MANAGER              = MFX_HANDLE_DIRECT3D_DEVICE_MANAGER9, /*!&lt; Pointer to the IDirect3DDeviceManager9 interface. See Working with Microsoft* DirectX* Applications for more details on how to use this handle. */\n    MFX_HANDLE_RESERVED1                        = 2,  /* Reserved.  */\n    MFX_HANDLE_D3D11_DEVICE                     = 3,  /*!&lt; Pointer to the ID3D11Device interface. See Working with Microsoft* DirectX* Applications for more details on how to use this handle. */\n    MFX_HANDLE_VA_DISPLAY                       = 4,  /*!&lt; VADisplay interface. See Working with VA-API Applications for more details on how to use this handle. */\n    MFX_HANDLE_RESERVED3                        = 5,  /* Reserved.  */\n    MFX_HANDLE_VA_CONFIG_ID                     = 6,  /*!&lt; Pointer to VAConfigID interface. It represents external VA config for Common Encryption usage model. */\n    MFX_HANDLE_VA_CONTEXT_ID                    = 7,  /*!&lt; Pointer to VAContextID interface. It represents external VA context for Common Encryption usage model. */\n    MFX_HANDLE_CM_DEVICE                        = 8,  /*!&lt; Pointer to CmDevice interface ( Intel(r) C for Metal Runtime ). */\n    MFX_HANDLE_HDDLUNITE_WORKLOADCONTEXT        = 9,  /*!&lt; Pointer to HddlUnite::WorkloadContext interface. */\n    MFX_HANDLE_PXP_CONTEXT                      = 10, /*!&lt; Pointer to PXP context for protected content support. */\n\n#ifdef ONEVPL_EXPERIMENTAL\n    MFX_HANDLE_CONFIG_INTERFACE                 = 1000,  /*!&lt; Pointer to interface of type mfxConfigInterface. */\n    MFX_HANDLE_MEMORY_INTERFACE                 = 1001,  /*!&lt; Pointer to interface of type mfxMemoryInterface. */\n#endif\n} mfxHandleType;\n\n/*! The mfxMemoryFlags enumerator specifies memory access mode. */\ntypedef enum\n{\n    MFX_MAP_READ  = 0x1, /*!&lt; The surface is mapped for reading. */\n    MFX_MAP_WRITE = 0x2, /*!&lt; The surface is mapped for writing. */\n    MFX_MAP_READ_WRITE = MFX_MAP_READ|MFX_MAP_WRITE, /*!&lt; The surface is mapped for reading and writing.  */\n    /*!\n     * The mapping would be done immediately without any implicit synchronizations.\n     * \\attention This flag is optional.\n     */\n    MFX_MAP_NOWAIT = 0x10\n} mfxMemoryFlags;\n\n#define MFX_FRAMESURFACE1_VERSION MFX_STRUCT_VERSION(1, 1)\n\n/* Frame Surface */\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*! Defines the uncompressed frames surface information and data buffers.\n    The frame surface is in the frame or complementary field pairs of pixels up to four color-channels, in two parts:\n    mfxFrameInfo and mfxFrameData.\n*/\ntypedef struct {\n    union\n    {\n        struct mfxFrameSurfaceInterface*  FrameInterface;       /*!&lt; Specifies interface to work with surface. */\n        mfxU32  reserved[2];\n    };\n    mfxStructVersion Version; /* Specifies version of mfxFrameSurface1 structure. */\n    mfxU16          reserved1[3];\n    mfxFrameInfo    Info; /*!&lt; Specifies surface properties. */\n    mfxFrameData    Data; /*!&lt; Describes the actual frame buffer. */\n} mfxFrameSurface1;\nMFX_PACK_END()\n\n#ifdef ONEVPL_EXPERIMENTAL\n\n/*! The mfxSurfaceType enumerator specifies the surface type described by mfxSurfaceHeader. */\ntypedef enum {\n    MFX_SURFACE_TYPE_UNKNOWN               = 0,      /*!&lt; Unknown surface type. */\n\n    MFX_SURFACE_TYPE_D3D11_TEX2D           = 2,      /*!&lt; D3D11 surface of type ID3D11Texture2D. */\n    MFX_SURFACE_TYPE_VAAPI                 = 3,      /*!&lt; VA-API surface. */\n    MFX_SURFACE_TYPE_OPENCL_IMG2D          = 4,      /*!&lt; OpenCL 2D image (cl_mem). */\n} mfxSurfaceType;\n\n/*! This enumerator specifies the sharing modes which are allowed for importing or exporting shared surfaces. */\nenum {\n    MFX_SURFACE_FLAG_DEFAULT          = 0x0000,      /*!&lt; Default is SHARED import or export. */\n\n    MFX_SURFACE_FLAG_IMPORT_SHARED    = 0x0010,      /*!&lt; Import frames directly by mapping a shared native handle from an application-provided surface to an internally-allocated surface. */\n    MFX_SURFACE_FLAG_IMPORT_COPY      = 0x0020,      /*!&lt; Import frames by copying data from an application-provided surface to an internally-allocated surface. */\n\n    MFX_SURFACE_FLAG_EXPORT_SHARED    = 0x0100,      /*!&lt; Export frames directly by mapping a shared native handle from an internally-allocated surface to an application-provided surface. */\n    MFX_SURFACE_FLAG_EXPORT_COPY      = 0x0200,      /*!&lt; Export frames by copying data from an internally-allocated surface to an application-provided surface. */\n};\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\ntypedef struct {\n    mfxSurfaceType SurfaceType;     /*!&lt; Set to the MFX_SURFACE_TYPE enum corresponding to the specific structure. */\n    mfxU32         SurfaceFlags;    /*!&lt; Set to the MFX_SURFACE_FLAG enum (or combination) corresponding to the allowed import / export mode(s). Multiple flags may be combined with OR. \n                                         Upon a successful Import or Export operation, this field will indicate the actual mode used.*/\n\n    mfxU32         StructSize;      /*!&lt; Size in bytes of the complete mfxSurfaceXXX structure. */\n\n    mfxU16         NumExtParam;     /*!&lt; The number of extra configuration structures attached to the structure. */\n    mfxExtBuffer** ExtParam;        /*!&lt; Points to an array of pointers to the extra configuration structures; see the ExtendedBufferID enumerator for a list of extended configurations. */\n\n    mfxU32 reserved[6];\n} mfxSurfaceHeader;\nMFX_PACK_END()\n\n\n#define MFX_SURFACEINTERFACE_VERSION MFX_STRUCT_VERSION(1, 0)\n\n/*!\n   Contains mfxSurfaceHeader and the callback functions AddRef, Release and GetRefCounter\n   that the application may use to manage access to exported surfaces.\n   These interfaces are only valid for surfaces obtained by mfxFrameSurfaceInterface::Export.\n   They are not used for surface descriptions passed to function mfxMemoryInterface::ImportFrameSurface.\n*/\nMFX_PACK_BEGIN_STRUCT_W_PTR()\ntypedef struct mfxSurfaceInterface {\n    mfxSurfaceHeader Header;  /*!&lt; Exported surface header. Contains description of current surface. */\n\n    mfxStructVersion Version; /*!&lt; The version of the structure. */\n\n    mfxHDL           Context; /*!&lt; The context of the exported surface interface. User should not touch (change, set, null) this pointer. */\n\n    /*! @brief\n    Increments the internal reference counter of the surface. The surface is not destroyed until the surface is released using the mfxSurfaceInterface::Release function.\n    mfxSurfaceInterface::AddRef should be used each time a new link to the surface is created (for example, copy structure) for proper surface management.\n\n    @param[in]  surface  Valid surface.\n\n    @return\n     MFX_ERR_NONE              If no error. \\n\n     MFX_ERR_NULL_PTR          If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE    If mfxSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN           Any internal error.\n\n    */\n    mfxStatus           (MFX_CDECL *AddRef)(struct mfxSurfaceInterface* surface);\n\n    /*! @brief\n    Decrements the internal reference counter of the surface. mfxSurfaceInterface::Release should be called after using the\n    mfxSurfaceInterface::AddRef function to add a surface or when allocation logic requires it. For example, call\n    mfxSurfaceInterface::Release to release a surface obtained with the mfxFrameSurfaceInterface::Export function.\n\n    @param[in]  surface  Valid surface.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNDEFINED_BEHAVIOR If Reference Counter of surface is zero before call. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Release)(struct mfxSurfaceInterface* surface);\n\n    /*! @brief\n    Returns current reference counter of exported surface.\n\n    @param[in]   surface  Valid surface.\n    @param[out]  counter  Sets counter to the current reference counter value.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface or counter is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *GetRefCounter)(struct mfxSurfaceInterface* surface, mfxU32* counter);\n\n    /*! @brief\n    This function is only valuable for surfaces which were exported in sharing mode (without a copy).\n    Guarantees readiness of both the data (pixels) and any original mfxFrameSurface1 frame&#x27;s meta information (for example corruption flags) after a function completes.\n\n    Instead of MFXVideoCORE_SyncOperation, users may directly call the mfxSurfaceInterface::Synchronize function after the corresponding\n    Decode or VPP function calls (MFXVideoDECODE_DecodeFrameAsync or MFXVideoVPP_RunFrameVPPAsync).\n    The prerequisites to call the functions are:\n\n    @li The main processing functions return MFX_ERR_NONE.\n    @li A valid surface object.\n\n    @param[in]   surface  Valid surface.\n    @param[out]  wait  Wait time in milliseconds.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If any of surface is not valid object . \\n\n     MFX_WRN_IN_EXECUTION       If the given timeout is expired and the surface is not ready. \\n\n     MFX_ERR_ABORTED            If the specified asynchronous function aborted due to data dependency on a previous asynchronous function that did not complete. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Synchronize)(struct mfxSurfaceInterface* surface, mfxU32 wait);\n\n    mfxHDL reserved[11];\n} mfxSurfaceInterface;\nMFX_PACK_END()\n\n#endif\n\n#ifdef ONEVPL_EXPERIMENTAL\n#define MFX_FRAMESURFACEINTERFACE_VERSION MFX_STRUCT_VERSION(1, 1)\n#else\n#define MFX_FRAMESURFACEINTERFACE_VERSION MFX_STRUCT_VERSION(1, 0)\n#endif\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/* Specifies frame surface interface. */\ntypedef struct mfxFrameSurfaceInterface {\n    mfxHDL              Context; /*!&lt; The context of the memory interface. User should not touch (change, set, null) this pointer. */\n    mfxStructVersion    Version; /*!&lt; The version of the structure. */\n    mfxU16              reserved1[3];\n\n    /*! @brief\n    Increments the internal reference counter of the surface. The surface is not destroyed until the surface is released using the mfxFrameSurfaceInterface::Release function.\n    mfxFrameSurfaceInterface::AddRef should be used each time a new link to the surface is created (for example, copy structure) for proper surface management.\n\n    @param[in]  surface  Valid surface.\n\n    @return\n     MFX_ERR_NONE              If no error. \\n\n     MFX_ERR_NULL_PTR          If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE    If mfxFrameSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN           Any internal error.\n\n    */\n    mfxStatus           (MFX_CDECL *AddRef)(mfxFrameSurface1* surface);\n\n    /*! @brief\n    Decrements the internal reference counter of the surface. mfxFrameSurfaceInterface::Release should be called after using the\n    mfxFrameSurfaceInterface::AddRef function to add a surface or when allocation logic requires it. For example, call\n    mfxFrameSurfaceInterface::Release to release a surface obtained with the GetSurfaceForXXX function.\n\n    @param[in]  surface  Valid surface.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxFrameSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNDEFINED_BEHAVIOR If Reference Counter of surface is zero before call. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Release)(mfxFrameSurface1* surface);\n\n    /*! @brief\n    Returns current reference counter of mfxFrameSurface1 structure.\n\n    @param[in]   surface  Valid surface.\n    @param[out]  counter  Sets counter to the current reference counter value.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface or counter is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxFrameSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *GetRefCounter)(mfxFrameSurface1* surface, mfxU32* counter);\n\n    /*! @brief\n    Sets pointers of surface-&gt;Info.Data to actual pixel data, providing read-write access.\n\n    In case of video memory, the surface with data in video memory becomes mapped to system memory.\n    An application can map a surface for read access with any value of mfxFrameSurface1::Data::Locked, but can map a surface for write access only when mfxFrameSurface1::Data::Locked equals to 0.\n\n    Note: A surface allows shared read access, but exclusive write access. Consider the following cases:\n    @li Map with Write or Read|Write flags. A request during active another read or write access returns MFX_ERR_LOCK_MEMORY error immediately, without waiting.\n    MFX_MAP_NOWAIT does not impact behavior. This type of request does not lead to any implicit synchronizations.\n    @li Map with Read flag. A request during active write access will wait for resource to become free,\n    or exits immediately with error if MFX_MAP_NOWAIT flag was set. This request may lead to the implicit synchronization (with same logic as Synchronize call)\n    waiting for surface to become ready to use (all dependencies should be resolved and upstream components finished writing to this surface).\n\n    It is guaranteed that read access will be acquired right after synchronization without allowing another thread to acquire this surface for writing.\n\n    If MFX_MAP_NOWAIT was set and the surface is not ready yet (for example the surface has unresolved data dependencies or active processing), the read access request exits immediately with error.\n\n    Read-write access with MFX_MAP_READ_WRITE provides exclusive simultaneous reading and writing access.\n\n    @note Bitwise copying of mfxFrameSurface1 object between map / unmap calls may result in having dangling data pointers in copies.\n\n    @param[in]   surface  Valid surface.\n    @param[out]  flags  Specify mapping mode.\n    @param[out]  surface-&gt;Info.Data Pointers set to actual pixel data.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxFrameSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNSUPPORTED        If flags are invalid. \\n\n     MFX_ERR_LOCK_MEMORY        If user wants to map the surface for write and surface-&gt;Data.Locked does not equal to 0. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Map)(mfxFrameSurface1* surface, mfxU32 flags);\n\n    /*! @brief\n    Invalidates pointers of surface-&gt;Info.Data and sets them to NULL.\n    In case of video memory, the underlying texture becomes unmapped after last reader or writer unmap.\n\n\n    @param[in]   surface  Valid surface.\n    @param[out]  surface-&gt;Info.Data  Pointers set to NULL.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxFrameSurfaceInterface-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNSUPPORTED        If surface is already unmapped. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Unmap)(mfxFrameSurface1* surface);\n\n    /*! @brief\n    Returns a native resource&#x27;s handle and type. The handle is returned *as-is*, meaning that the reference counter of base resources is not incremented.\n    The native resource is not detached from surface and the library still owns the resource. User must not destroy\n    the native resource or assume that the resource will be alive after mfxFrameSurfaceInterface::Release.\n\n\n\n    @param[in]   surface  Valid surface.\n    @param[out]  resource Pointer is set to the native handle of the resource.\n    @param[out]  resource_type Type of native resource. See mfxResourceType enumeration).\n\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If any of surface, resource or resource_type is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If any of surface, resource or resource_type is not valid object (no native resource was allocated). \\n\n     MFX_ERR_UNSUPPORTED        If surface is in system memory. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *GetNativeHandle)(mfxFrameSurface1* surface, mfxHDL* resource, mfxResourceType* resource_type);\n\n    /*! @brief\n    Returns a device abstraction that was used to create that resource.\n    The handle is returned *as-is*, meaning that the reference counter for the device abstraction is not incremented.\n    The native resource is not detached from the surface and the library still has a reference to the resource.\n    User must not destroy the device or assume that the device will be alive after mfxFrameSurfaceInterface::Release.\n\n\n    @param[in]   surface  Valid surface.\n    @param[out]  device_handle Pointer is set to the device which created the resource\n    @param[out]  device_type Type of device (see mfxHandleType enumeration).\n\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If any of surface, device_handle or device_type is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If any of surface, resource or resource_type is not valid object (no native resource was allocated). \\n\n     MFX_ERR_UNSUPPORTED        If surface is in system memory. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *GetDeviceHandle)(mfxFrameSurface1* surface, mfxHDL* device_handle, mfxHandleType* device_type);\n\n    /*! @brief\n    Guarantees readiness of both the data (pixels) and any frame&#x27;s meta information (for example corruption flags) after a function completes.\n\n    Instead of MFXVideoCORE_SyncOperation, users may directly call the mfxFrameSurfaceInterface::Synchronize function after the corresponding\n    Decode or VPP function calls (MFXVideoDECODE_DecodeFrameAsync or MFXVideoVPP_RunFrameVPPAsync).\n    The prerequisites to call the functions are:\n\n    @li The main processing functions return MFX_ERR_NONE.\n    @li A valid mfxFrameSurface1 object.\n\n\n\n    @param[in]   surface  Valid surface.\n    @param[out]  wait  Wait time in milliseconds.\n\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If any of surface is not valid object . \\n\n     MFX_WRN_IN_EXECUTION       If the given timeout is expired and the surface is not ready. \\n\n     MFX_ERR_ABORTED            If the specified asynchronous function aborted due to data dependency on a previous asynchronous function that did not complete. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *Synchronize)(mfxFrameSurface1* surface, mfxU32 wait);\n\n    /*! @brief\n    The library calls the function after complete of associated video operation\n    notifying the application that frame surface is ready.\n\n    @attention This is callback function and intended to be called by\n               the library only.\n\n    @note The library calls this callback only when this surface is used as the output surface. \n\n    It is expected that the function is low-intrusive designed otherwise it may\n    impact performance.\n\n    @param[in] sts  The status of completed operation.\n\n    */\n    void               (MFX_CDECL *OnComplete)(mfxStatus sts);\n\n   /*! @brief\n    Returns an interface defined by the GUID. If the returned interface is a reference \n    counted object the caller should release the obtained interface to avoid memory leaks.\n\n    @param[in]  surface   Valid surface.\n    @param[in]  guid      GUID of the requested interface.\n    @param[out] iface     Interface.\n\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If interface or surface is NULL. \\n\n     MFX_ERR_UNSUPPORTED        If requested interface is not supported. \\n\n     MFX_ERR_NOT_IMPLEMENTED    If requested interface is not implemented. \\n\n     MFX_ERR_NOT_INITIALIZED    If requested interface is not available (not created or already deleted). \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus           (MFX_CDECL *QueryInterface)(mfxFrameSurface1* surface, mfxGUID guid, mfxHDL* iface);\n\n#ifdef ONEVPL_EXPERIMENTAL\n    /*! @brief\n     If successful returns an exported surface, which is a refcounted object allocated by runtime. It could be exported with or without copy, depending\n     on export flags and the possibility of such export. Exported surface is valid throughout the session, as long as the original mfxFrameSurface1 \n     object is not closed and the refcount of exported surface is not zero.\n\n     @param[in]  surface              Valid surface.\n     @param[in]  export_header        Description of export: caller should fill in SurfaceType (type to export to) and SurfaceFlags (allowed export modes).\n     @param[out] exported_surface     Exported surface, allocated by runtime, user needs to decrement refcount after usage for object release.\n                                      After successful export, the value of mfxSurfaceHeader::SurfaceFlags will contain the actual export mode.\n\n\n     @return\n      MFX_ERR_NONE               If no error. \\n\n      MFX_ERR_NULL_PTR           If export surface or surface is NULL. \\n\n      MFX_ERR_UNSUPPORTED        If requested export is not supported. \\n\n      MFX_ERR_NOT_IMPLEMENTED    If requested export is not implemented. \\n\n      MFX_ERR_UNKNOWN            Any internal error.\n     */\n\n     /* For reference with Import flow please search for mfxMemoryInterface::ImportFrameSurface. */\n    mfxStatus           (MFX_CDECL *Export)(mfxFrameSurface1* surface, mfxSurfaceHeader export_header, mfxSurfaceHeader** exported_surface);\n\n    mfxHDL              reserved2[1];\n#else\n    mfxHDL              reserved2[2];\n#endif\n} mfxFrameSurfaceInterface;\nMFX_PACK_END()\n\n/*! The TimeStampCalc enumerator itemizes time-stamp calculation methods. */\nenum {\n    /*! The time stamp calculation is based on the input frame rate if time stamp is not explicitly specified. */\n    MFX_TIMESTAMPCALC_UNKNOWN = 0,\n    /*! Adjust time stamp to 29.97fps on 24fps progressively encoded sequences if telecine attributes are available in the bitstream and\n    time stamp is not explicitly specified. The input frame rate must be specified. */\n    MFX_TIMESTAMPCALC_TELECINE = 1,\n};\n\n/* Transcoding Info */\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies configurations for decoding, encoding, and transcoding processes.\n    A zero value in any of these fields indicates that the field is not explicitly specified. */\ntypedef struct {\n    mfxU32  reserved[7]; /*!&lt; Reserved for future use. */\n\n    /*! Hint to enable low power consumption mode for encoders. See the CodingOptionValue enumerator for values\n        of this option. Use the Query API function to check if this feature is supported. */\n    mfxU16  LowPower;\n    /*! Specifies a multiplier for bitrate control parameters. Affects the following variables: InitialDelayInKB, BufferSizeInKB,\n        TargetKbps, MaxKbps. If this value is not equal to zero, the encoder calculates BRC parameters as ``value * BRCParamMultiplier``. */\n    mfxU16  BRCParamMultiplier;\n\n    mfxFrameInfo    FrameInfo; /*!&lt; mfxFrameInfo structure that specifies frame parameters. */\n    mfxU32  CodecId;           /*!&lt; Specifies the codec format identifier in the FourCC code; see the CodecFormatFourCC enumerator for details.\n                                    This is a mandated input parameter for the QueryIOSurf and Init API functions. */\n    mfxU16  CodecProfile;      /*!&lt; Specifies the codec profile; see the CodecProfile enumerator for details. Specify the codec profile explicitly or the API functions will determine\n                                    the correct profile from other sources, such as resolution and bitrate. */\n    mfxU16  CodecLevel;        /*!&lt; Codec level; see the CodecLevel enumerator for details. Specify the codec level explicitly or the functions will determine the correct level from other sources,\n                                    such as resolution and bitrate. */\n    mfxU16  NumThread;\n\n    union {\n        struct {   /* Encoding Options */\n            mfxU16  TargetUsage; /*!&lt; Target usage model that guides the encoding process; see the TargetUsage enumerator for details. */\n\n            /*! Number of pictures within the current GOP (Group of Pictures); if GopPicSize = 0, then the GOP size is unspecified. If GopPicSize = 1, only I-frames are used.\n                The following pseudo-code that shows how the library uses this parameter:\n                @code\n                   mfxU16 get_gop_sequence (...) {\n                      pos=display_frame_order;\n                      if (pos == 0)\n                          return MFX_FRAMETYPE_I | MFX_FRAMETYPE_IDR | MFX_FRAMETYPE_REF;\n\n                      If (GopPicSize == 1) // Only I-frames\n                          return MFX_FRAMETYPE_I | MFX_FRAMETYPE_REF;\n\n                      if (GopPicSize == 0)\n                                  frameInGOP = pos;    //Unlimited GOP\n                              else\n                                  frameInGOP = pos%GopPicSize;\n\n                      if (frameInGOP == 0)\n                          return MFX_FRAMETYPE_I | MFX_FRAMETYPE_REF;\n\n                      if (GopRefDist == 1 || GopRefDist == 0)    // Only I,P frames\n                                  return MFX_FRAMETYPE_P | MFX_FRAMETYPE_REF;\n\n                      frameInPattern = (frameInGOP-1)%GopRefDist;\n                      if (frameInPattern == GopRefDist - 1)\n                          return MFX_FRAMETYPE_P | MFX_FRAMETYPE_REF;\n\n                      return MFX_FRAMETYPE_B;\n                    }\n                @endcode */\n            mfxU16  GopPicSize;\n            /*! Distance between I- or P (or GPB) - key frames; if it is zero, the GOP structure is unspecified. Note: If GopRefDist = 1,\n                there are no regular B-frames used (only P or GPB); if mfxExtCodingOption3::GPB is ON, GPB frames (B without backward\n                references) are used instead of P. */\n            mfxU16  GopRefDist;\n            /*! ORs of the GopOptFlag enumerator indicate the additional flags for the GOP specification. */\n            mfxU16  GopOptFlag;\n            /*! For H.264, specifies IDR-frame interval in terms of I-frames.\n                For example:\n                @li If IdrInterval = 0, then every I-frame is an IDR-frame.\n                @li If IdrInterval = 1, then every other I-frame is an IDR-frame.\n\n                For HEVC, if IdrInterval = 0, then only first I-frame is an IDR-frame. For example:\n                @li If IdrInterval = 1, then every I-frame is an IDR-frame.\n                @li If IdrInterval = 2, then every other I-frame is an IDR-frame.\n\n                For MPEG2, IdrInterval defines sequence header interval in terms of I-frames. For example:\n                @li If IdrInterval = 0 (default), then the sequence header is inserted once at the beginning of the stream.\n                @li If IdrInterval = N, then the sequence header is inserted before every Nth I-frame.\n\n\n                If GopPicSize or GopRefDist is zero, IdrInterval is undefined. */\n            mfxU16  IdrInterval;\n\n            mfxU16  RateControlMethod; /*! Rate control method; see the RateControlMethod enumerator for details. */\n            union {\n                /*! Initial size of the Video Buffering Verifier (VBV) buffer.\n                    @note In this context, KB is 1000 bytes and Kbps is 1000 bps. */\n                mfxU16  InitialDelayInKB;\n                /*! Quantization Parameter (QP) for I-frames for constant QP mode (CQP). Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPI might be clipped to supported QPI range.\n                    @note In the HEVC design, a further adjustment to QPs can occur based on bit depth.\n                    Adjusted QPI value = QPI - (6 * (BitDepthLuma - 8)) for BitDepthLuma in the range [8,14].\n                    For HEVC_MAIN10, we minus (6*(10-8)=12) on our side and continue.\n                    @note Default QPI value is implementation dependent and subject to change without additional notice in this document. */\n                mfxU16  QPI;\n                mfxU16  Accuracy; /*!&lt; Specifies accuracy range in the unit of tenth of percent. */\n            };\n            mfxU16  BufferSizeInKB; /*!&lt; Represents the maximum possible size of any compressed frames. */\n            union {\n                /*! Constant bitrate TargetKbps. Used to estimate the targeted frame size by dividing the frame rate by the bitrate. */\n                mfxU16  TargetKbps;\n                /*! Quantization Parameter (QP) for P-frames for constant QP mode (CQP). Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPP might be clipped to supported QPI range.\n                    @note In the HEVC design, a further adjustment to QPs can occur based on bit depth.\n                    Adjusted QPP value = QPP - (6 * (BitDepthLuma - 8)) for BitDepthLuma in the range [8,14].\n                    For HEVC_MAIN10, we minus (6*(10-8)=12) on our side and continue.\n                    @note Default QPP value is implementation dependent and subject to change without additional notice in this document. */\n                mfxU16  QPP;\n                mfxU16  ICQQuality; /*!&lt; Used by the Intelligent Constant Quality (ICQ) bitrate control algorithm. Values are in the 1 to 51 range, where 1 corresponds the best quality. */\n            };\n            union {\n                /*! The maximum bitrate at which the encoded data enters the Video Buffering Verifier (VBV) buffer. */\n                mfxU16  MaxKbps;\n                /*! Quantization Parameter (QP) for B-frames for constant QP mode (CQP). Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPI might be clipped to supported QPB range.\n                    @note In the HEVC design, a further adjustment to QPs can occur based on bit depth.\n                    Adjusted QPB value = QPB - (6 * (BitDepthLuma - 8)) for BitDepthLuma in the range [8,14].\n                    For HEVC_MAIN10, we minus (6*(10-8)=12) on our side and continue.\n                    @note Default QPB value is implementation dependent and subject to change without additional notice in this document. */\n                mfxU16  QPB;\n                mfxU16  Convergence; /*!&lt; Convergence period in the unit of 100 frames. */\n            };\n\n            /*! Number of slices in each video frame. Each slice contains one or more macro-block rows. If NumSlice equals zero, the encoder may choose any slice partitioning\n                allowed by the codec standard. See also mfxExtCodingOption2::NumMbPerSlice. */\n            mfxU16  NumSlice;\n            /*! Max number of all available reference frames (for AVC/HEVC, NumRefFrame defines DPB size). If NumRefFrame = 0, this parameter is not specified.\n                See also NumRefActiveP, NumRefActiveBL0, and NumRefActiveBL1 in the mfxExtCodingOption3 structure, which set a number of active references. */\n            mfxU16  NumRefFrame;\n            /*! If not zero, specifies that ENCODE takes the input surfaces in the encoded order and uses explicit frame type control.\n                The application must still provide GopRefDist and mfxExtCodingOption2::BRefType so the library can pack headers and build reference\n                lists correctly. */\n            mfxU16  EncodedOrder;\n        };\n        struct {   /* Decoding Options */\n            /*! For AVC and HEVC, used to instruct the decoder to return output frames in the decoded order. Must be zero for all other decoders.\n                When enabled, correctness of mfxFrameData::TimeStamp and FrameOrder for output surface is not guaranteed, the application should ignore them. */\n            mfxU16  DecodedOrder;\n            /*! Instructs DECODE to output extended picture structure values for additional display attributes. See the PicStruct description for details. */\n            mfxU16  ExtendedPicStruct;\n            /*! Time stamp calculation method. See the TimeStampCalc description for details. */\n            mfxU16  TimeStampCalc;\n            /*! Nonzero value indicates that slice groups are present in the bitstream. Used only by AVC decoder. */\n            mfxU16  SliceGroupsPresent;\n            /*! Nonzero value specifies the maximum required size of the decoded picture buffer in frames for AVC and HEVC decoders. */\n            mfxU16  MaxDecFrameBuffering;\n            /*! For decoders supporting dynamic resolution change (VP9), set this option to ON to allow MFXVideoDECODE_DecodeFrameAsync\n                return MFX_ERR_REALLOC_SURFACE. See the CodingOptionValue enumerator for values of this option. Use the Query API\n                function to check if this feature is supported. */\n            mfxU16  EnableReallocRequest;\n            /*! Special parameter for AV1 decoder. Indicates presence/absence of film grain parameters in bitstream.\n                Also controls decoding behavior for streams with film grain parameters. MFXVideoDECODE_DecodeHeader returns nonzero FilmGrain\n                for streams with film grain parameters and zero for streams w/o them. Decoding with film grain requires additional output surfaces.\n                If FilmGrain` is non-zero then MFXVideoDECODE_QueryIOSurf will request more surfaces in case of external allocated video memory at decoder output.\n                FilmGrain is passed to MFXVideoDECODE_Init function to control decoding operation for AV1 streams with film grain parameters.\n                If FilmGrain is nonzero decoding of each frame require two output surfaces (one for reconstructed frame and one for output frame with film grain applied).\n                The decoder returns MFX_ERR_MORE_SURFACE from MFXVideoDECODE_DecodeFrameAsync if it has insufficient output surfaces to decode frame.\n                Application can forcibly disable the feature passing zero value of `FilmGrain` to `MFXVideoDECODE_Init`.\n                In this case the decoder will output reconstructed frames w/o film grain applied.\n                Application can retrieve film grain parameters for a frame by attaching extended buffer mfxExtAV1FilmGrainParam to mfxFrameSurface1.\n                If stream has no film grain parameters `FilmGrain` passed to `MFXVideoDECODE_Init` is ignored by the decoder. */\n            mfxU16  FilmGrain;\n            /*! If not zero, it forces SDK to attempt to decode bitstream even if a decoder may not support all features associated with given CodecLevel. Decoder may produce visual artifacts. Only AVC decoder supports this field. */\n            mfxU16  IgnoreLevelConstrain;\n            /*! This flag is used to disable output of main decoding channel. When it&#x27;s ON SkipOutput = MFX_CODINGOPTION_ON decoder outputs only video processed channels. For pure decode this flag should be always disabled. */\n            mfxU16  SkipOutput;\n            mfxU16  reserved2[4];\n        };\n        struct {   /* JPEG Decoding Options */\n            /*! Specify the chroma sampling format that has been used to encode a JPEG picture. See the ChromaFormat enumerator for details. */\n            mfxU16  JPEGChromaFormat;\n            /*! Rotation option of the output JPEG picture. See the Rotation enumerator for details. */\n            mfxU16  Rotation;\n            /*! Specify the color format that has been used to encode a JPEG picture. See the JPEGColorFormat enumerator for details. */\n            mfxU16  JPEGColorFormat;\n            /*! Specify JPEG scan type for decoder. See the JPEGScanType enumerator for details. */\n            mfxU16  InterleavedDec;\n            mfxU8   SamplingFactorH[4]; /*!&lt; Horizontal sampling factor. */\n            mfxU8   SamplingFactorV[4]; /*!&lt; Vertical sampling factor. */\n            mfxU16  reserved3[5];\n        };\n        struct {   /* JPEG Encoding Options */\n            /*! Specify interleaved or non-interleaved scans. If it is equal to MFX_SCANTYPE_INTERLEAVED then the image is encoded as interleaved,\n                all components are encoded in one scan. See the JPEG Scan Type enumerator for details. */\n            mfxU16  Interleaved;\n            /*! Specifies the image quality if the application does not specified quantization table.\n                The value is from 1 to 100 inclusive. &quot;100&quot; is the best quality. */\n            mfxU16  Quality;\n            /*! Specifies the number of MCU in the restart interval. &quot;0&quot; means no restart interval. */\n            mfxU16  RestartInterval;\n            mfxU16  reserved5[10];\n        };\n    };\n} mfxInfoMFX;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Specifies configurations for video processing. A zero value in any of the fields indicates\n   that the corresponding field is not explicitly specified. */\ntypedef struct {\n    mfxU32  reserved[8];\n    mfxFrameInfo    In;  /*!&lt; Input format for video processing. */\n    mfxFrameInfo    Out; /*!&lt; Output format for video processing. */\n} mfxInfoVPP;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! Configuration parameters for encoding, decoding, transcoding, and video processing. */\ntypedef struct {\n    /*! Unique component ID that will be passed by the library to mfxFrameAllocRequest. Useful in pipelines where several\n        components of the same type share the same allocator. */\n    mfxU32  AllocId;\n    mfxU32  reserved[2];\n    mfxU16  reserved3;\n    /*! Specifies how many asynchronous operations an application performs before the application explicitly synchronizes the result.\n        If zero, the value is not specified. */\n    mfxU16  AsyncDepth;\n\n    union {\n        mfxInfoMFX  mfx; /*!&lt; Configurations related to encoding, decoding, and transcoding. See the definition of the mfxInfoMFX structure for details. */\n        mfxInfoVPP  vpp; /*!&lt; Configurations related to video processing. See the definition of the mfxInfoVPP structure for details. */\n    };\n    /*! Specifies the content protection mechanism. See the Protected enumerator for a list of supported protection schemes. */\n    mfxU16  Protected;\n    /*! Input and output memory access types for functions. See the enumerator IOPattern for details.\n        The Query API functions return the natively supported IOPattern if the Query input argument is NULL.\n        This parameter is a mandated input for QueryIOSurf and Init API functions. The output pattern must be specified for DECODE.\n        The input pattern must be specified for ENCODE. Both input and output pattern must be specified for VPP. */\n    mfxU16  IOPattern;\n    mfxExtBuffer** ExtParam; /*!&lt; Points to an array of pointers to the extra configuration structures. See the ExtendedBufferID enumerator\n                                  for a list of extended configurations.\n                                  The list of extended buffers should not contain duplicated entries, such as entries of the same type.\n                                  If the  mfxVideoParam structure is used to query library capability, then the list of extended buffers attached to the input\n                                  and output mfxVideoParam structure should be equal, that is, it should contain the same number of extended\n                                  buffers of the same type. */\n    mfxU16  NumExtParam;     /*!&lt; The number of extra configuration structures attached to this structure. */\n    mfxU16  reserved2;\n} mfxVideoParam;\nMFX_PACK_END()\n\n/*! The IOPattern enumerator itemizes memory access patterns for API functions. Use bit-ORed values to specify an input access\n    pattern and an output access pattern. */\nenum {\n    MFX_IOPATTERN_IN_VIDEO_MEMORY   = 0x01, /*!&lt; Input to functions is a video memory surface. */\n    MFX_IOPATTERN_IN_SYSTEM_MEMORY  = 0x02, /*!&lt; Input to functions is a linear buffer directly in system memory or in system memory through an external allocator. */\n    MFX_IOPATTERN_OUT_VIDEO_MEMORY  = 0x10, /*!&lt; Output to functions is a video memory surface.  */\n    MFX_IOPATTERN_OUT_SYSTEM_MEMORY = 0x20 /*!&lt; Output to functions is a linear buffer directly in system memory or in system memory through an external allocator.  */\n};\n\n/*! The CodecFormatFourCC enumerator itemizes codecs in the FourCC format. */\nenum {\n    MFX_CODEC_AVC         =MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;V&#x27;,&#x27;C&#x27;,&#x27; &#x27;), /*!&lt; AVC, H.264, or MPEG-4, part 10 codec. */\n    MFX_CODEC_HEVC        =MFX_MAKEFOURCC(&#x27;H&#x27;,&#x27;E&#x27;,&#x27;V&#x27;,&#x27;C&#x27;), /*!&lt; HEVC codec. */\n    MFX_CODEC_MPEG2       =MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;P&#x27;,&#x27;G&#x27;,&#x27;2&#x27;), /*!&lt; MPEG-2 codec. */\n    MFX_CODEC_VC1         =MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;C&#x27;,&#x27;1&#x27;,&#x27; &#x27;), /*!&lt; VC-1 codec. */\n    MFX_CODEC_CAPTURE     =MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;A&#x27;,&#x27;P&#x27;,&#x27;T&#x27;), /*!&lt;  */\n    MFX_CODEC_VP9         =MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;P&#x27;,&#x27;9&#x27;,&#x27; &#x27;), /*!&lt; VP9 codec. */\n    MFX_CODEC_AV1         =MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;V&#x27;,&#x27;1&#x27;,&#x27; &#x27;)  /*!&lt; AV1 codec. */\n};\n\n/*!\nThe CodecProfile enumerator itemizes codec profiles for all codecs.\nCodecLevel\n*/\nenum {\n    MFX_PROFILE_UNKNOWN                     =0, /*!&lt; Unspecified profile. */\n    MFX_LEVEL_UNKNOWN                       =0, /*!&lt; Unspecified level. */\n\n    /*! @{ */\n    /* Combined with H.264 profile these flags impose additional constrains. See H.264 specification for the list of constrains. */\n    MFX_PROFILE_AVC_CONSTRAINT_SET0     = (0x100 &lt;&lt; 0),\n    MFX_PROFILE_AVC_CONSTRAINT_SET1     = (0x100 &lt;&lt; 1),\n    MFX_PROFILE_AVC_CONSTRAINT_SET2     = (0x100 &lt;&lt; 2),\n    MFX_PROFILE_AVC_CONSTRAINT_SET3     = (0x100 &lt;&lt; 3),\n    MFX_PROFILE_AVC_CONSTRAINT_SET4     = (0x100 &lt;&lt; 4),\n    MFX_PROFILE_AVC_CONSTRAINT_SET5     = (0x100 &lt;&lt; 5),\n    /*! @} */\n\n    /*! @{ */\n    /* H.264 Profiles. */\n    MFX_PROFILE_AVC_BASELINE                =66,\n    MFX_PROFILE_AVC_MAIN                    =77,\n    MFX_PROFILE_AVC_EXTENDED                =88,\n    MFX_PROFILE_AVC_HIGH                    =100,\n    MFX_PROFILE_AVC_HIGH10                  =110,\n    MFX_PROFILE_AVC_HIGH_422                =122,\n    MFX_PROFILE_AVC_CONSTRAINED_BASELINE    =MFX_PROFILE_AVC_BASELINE + MFX_PROFILE_AVC_CONSTRAINT_SET1,\n    MFX_PROFILE_AVC_CONSTRAINED_HIGH        =MFX_PROFILE_AVC_HIGH     + MFX_PROFILE_AVC_CONSTRAINT_SET4\n                                                                      + MFX_PROFILE_AVC_CONSTRAINT_SET5,\n    MFX_PROFILE_AVC_PROGRESSIVE_HIGH        =MFX_PROFILE_AVC_HIGH     + MFX_PROFILE_AVC_CONSTRAINT_SET4,\n    /*! @} */\n\n    /*! @{ */\n    /* H.264 level 1-1.3 */\n    MFX_LEVEL_AVC_1                         =10,\n    MFX_LEVEL_AVC_1b                        =9,\n    MFX_LEVEL_AVC_11                        =11,\n    MFX_LEVEL_AVC_12                        =12,\n    MFX_LEVEL_AVC_13                        =13,\n    /*! @} */\n    /*! @{ */\n    /* H.264 level 2-2.2 */\n    MFX_LEVEL_AVC_2                         =20,\n    MFX_LEVEL_AVC_21                        =21,\n    MFX_LEVEL_AVC_22                        =22,\n    /*! @} */\n    /*! @{ */\n    /* H.264 level 3-3.2 */\n    MFX_LEVEL_AVC_3                         =30,\n    MFX_LEVEL_AVC_31                        =31,\n    MFX_LEVEL_AVC_32                        =32,\n    /*! @} */\n    /*! @{ */\n    /* H.264 level 4-4.2 */\n    MFX_LEVEL_AVC_4                         =40,\n    MFX_LEVEL_AVC_41                        =41,\n    MFX_LEVEL_AVC_42                        =42,\n    /*! @} */\n    /*! @{ */\n    /* H.264 level 5-5.2 */\n    MFX_LEVEL_AVC_5                         =50,\n    MFX_LEVEL_AVC_51                        =51,\n    MFX_LEVEL_AVC_52                        =52,\n    /*! @} */\n    /*! @{ */\n    /* H.264 level 6-6.2 */\n    MFX_LEVEL_AVC_6                         =60,\n    MFX_LEVEL_AVC_61                        =61,\n    MFX_LEVEL_AVC_62                        =62,\n    /*! @} */\n\n    /*! @{ */\n    /* MPEG2 Profiles. */\n    MFX_PROFILE_MPEG2_SIMPLE                =0x50,\n    MFX_PROFILE_MPEG2_MAIN                  =0x40,\n    MFX_PROFILE_MPEG2_HIGH                  =0x10,\n    /*! @} */\n\n    /*! @{ */\n    /* MPEG2 Levels. */\n    MFX_LEVEL_MPEG2_LOW                     =0xA,\n    MFX_LEVEL_MPEG2_MAIN                    =0x8,\n    MFX_LEVEL_MPEG2_HIGH                    =0x4,\n    MFX_LEVEL_MPEG2_HIGH1440                =0x6,\n    /*! @} */\n\n    /*! @{ */\n    /* VC-1 Profiles. */\n    MFX_PROFILE_VC1_SIMPLE                  =(0+1),\n    MFX_PROFILE_VC1_MAIN                    =(4+1),\n    MFX_PROFILE_VC1_ADVANCED                =(12+1),\n    /*! @} */\n\n    /*! @{ */\n    /* VC-1 Level Low (simple &amp; main profiles) */\n    MFX_LEVEL_VC1_LOW                       =(0+1),\n    MFX_LEVEL_VC1_MEDIAN                    =(2+1),\n    MFX_LEVEL_VC1_HIGH                      =(4+1),\n    /*! @} */\n\n    /*! @{ */\n    /* VC-1 advanced profile levels */\n    MFX_LEVEL_VC1_0                         =(0x00+1),\n    MFX_LEVEL_VC1_1                         =(0x01+1),\n    MFX_LEVEL_VC1_2                         =(0x02+1),\n    MFX_LEVEL_VC1_3                         =(0x03+1),\n    MFX_LEVEL_VC1_4                         =(0x04+1),\n    /*! @} */\n\n    /*! @{ */\n    /* HEVC profiles */\n    MFX_PROFILE_HEVC_MAIN             =1,\n    MFX_PROFILE_HEVC_MAIN10           =2,\n    MFX_PROFILE_HEVC_MAINSP           =3,\n    MFX_PROFILE_HEVC_REXT             =4,\n    MFX_PROFILE_HEVC_SCC              =9,\n    /*! @} */\n\n    /*! @{ */\n    /* HEVC levels */\n    MFX_LEVEL_HEVC_1   = 10,\n    MFX_LEVEL_HEVC_2   = 20,\n    MFX_LEVEL_HEVC_21  = 21,\n    MFX_LEVEL_HEVC_3   = 30,\n    MFX_LEVEL_HEVC_31  = 31,\n    MFX_LEVEL_HEVC_4   = 40,\n    MFX_LEVEL_HEVC_41  = 41,\n    MFX_LEVEL_HEVC_5   = 50,\n    MFX_LEVEL_HEVC_51  = 51,\n    MFX_LEVEL_HEVC_52  = 52,\n    MFX_LEVEL_HEVC_6   = 60,\n    MFX_LEVEL_HEVC_61  = 61,\n    MFX_LEVEL_HEVC_62  = 62,\n    /*! @} */\n\n    /*! @{ */\n    /* HEVC tiers */\n    MFX_TIER_HEVC_MAIN  = 0,\n    MFX_TIER_HEVC_HIGH  = 0x100,\n    /*! @} */\n\n    /*! @{ */\n    /* VP9 Profiles */\n    MFX_PROFILE_VP9_0                       = 1,\n    MFX_PROFILE_VP9_1                       = 2,\n    MFX_PROFILE_VP9_2                       = 3,\n    MFX_PROFILE_VP9_3                       = 4,\n    /*! @} */\n\n    /*! @{ */\n    /* AV1 Profiles */\n    MFX_PROFILE_AV1_MAIN                    = 1,\n    MFX_PROFILE_AV1_HIGH                    = 2,\n    MFX_PROFILE_AV1_PRO                     = 3,\n    /*! @} */\n\n    /*! @{ */\n    /* AV1 Levels */\n    MFX_LEVEL_AV1_2                         = 20,\n    MFX_LEVEL_AV1_21                        = 21,\n    MFX_LEVEL_AV1_22                        = 22,\n    MFX_LEVEL_AV1_23                        = 23,\n    MFX_LEVEL_AV1_3                         = 30,\n    MFX_LEVEL_AV1_31                        = 31,\n    MFX_LEVEL_AV1_32                        = 32,\n    MFX_LEVEL_AV1_33                        = 33,\n    MFX_LEVEL_AV1_4                         = 40,\n    MFX_LEVEL_AV1_41                        = 41,\n    MFX_LEVEL_AV1_42                        = 42,\n    MFX_LEVEL_AV1_43                        = 43,\n    MFX_LEVEL_AV1_5                         = 50,\n    MFX_LEVEL_AV1_51                        = 51,\n    MFX_LEVEL_AV1_52                        = 52,\n    MFX_LEVEL_AV1_53                        = 53,\n    MFX_LEVEL_AV1_6                         = 60,\n    MFX_LEVEL_AV1_61                        = 61,\n    MFX_LEVEL_AV1_62                        = 62,\n    MFX_LEVEL_AV1_63                        = 63,\n    MFX_LEVEL_AV1_7                         = 70,\n    MFX_LEVEL_AV1_71                        = 71,\n    MFX_LEVEL_AV1_72                        = 72,\n    MFX_LEVEL_AV1_73                        = 73,\n    /*! @} */\n};\n\n/*! The GopOptFlag enumerator itemizes special properties in the GOP (Group of Pictures) sequence. */\nenum {\n    /*!\n       The encoder generates closed GOP if this flag is set. Frames in this GOP do not use frames in previous GOP as reference.\n\n       The encoder generates open GOP if this flag is not set. In this GOP frames prior to the first frame of GOP in display order may use\n       frames from previous GOP as reference. Frames subsequent to the first frame of GOP in display order do not use frames from previous\n       GOP as reference.\n\n       The AVC encoder ignores this flag if IdrInterval in mfxInfoMFX structure is set to 0, i.e. if every GOP starts from IDR frame.\n       In this case, GOP is encoded as closed.\n\n       This flag does not affect long-term reference frames.\n    */\n    MFX_GOP_CLOSED          =1,\n    /*!\n       The encoder must strictly follow the given GOP structure as defined by parameter GopPicSize, GopRefDist etc in the mfxVideoParam structure.\n       Otherwise, the encoder can adapt the GOP structure for better efficiency, whose range is constrained by parameter GopPicSize and\n       GopRefDist etc. See also description of AdaptiveI and AdaptiveB fields in the mfxExtCodingOption2 structure.\n    */\n    MFX_GOP_STRICT          =2\n};\n\n/*! The TargetUsage enumerator itemizes a range of numbers from MFX_TARGETUSAGE_1, best quality, to MFX_TARGETUSAGE_7, best speed.\n    It indicates trade-offs between quality and speed. The application can use any number in the range. The actual number of supported\n    target usages depends on implementation. If specified target usage is not supported, the encoder will use the closest supported value. */\nenum {\n    MFX_TARGETUSAGE_1    =1, /*!&lt; Best quality */\n    MFX_TARGETUSAGE_2    =2,\n    MFX_TARGETUSAGE_3    =3,\n    MFX_TARGETUSAGE_4    =4, /*!&lt; Balanced quality and speed. */\n    MFX_TARGETUSAGE_5    =5,\n    MFX_TARGETUSAGE_6    =6,\n    MFX_TARGETUSAGE_7    =7, /*!&lt; Best speed */\n\n    MFX_TARGETUSAGE_UNKNOWN         =0, /*!&lt; Unspecified target usage. */\n    MFX_TARGETUSAGE_BEST_QUALITY    =MFX_TARGETUSAGE_1, /*!&lt; Best quality. */\n    MFX_TARGETUSAGE_BALANCED        =MFX_TARGETUSAGE_4, /*!&lt; Balanced quality and speed. */\n    MFX_TARGETUSAGE_BEST_SPEED      =MFX_TARGETUSAGE_7  /*!&lt; Best speed. */\n};\n\n/*! The RateControlMethod enumerator itemizes bitrate control methods. */\nenum {\n    MFX_RATECONTROL_CBR       =1, /*!&lt; Use the constant bitrate control algorithm. */\n    MFX_RATECONTROL_VBR       =2, /*!&lt; Use the variable bitrate control algorithm. */\n    MFX_RATECONTROL_CQP       =3, /*!&lt; Use the constant quantization parameter algorithm. */\n    MFX_RATECONTROL_AVBR      =4, /*!&lt; Use the average variable bitrate control algorithm. */\n    MFX_RATECONTROL_RESERVED1 =5,\n    MFX_RATECONTROL_RESERVED2 =6,\n    MFX_RATECONTROL_RESERVED3 =100,\n    MFX_RATECONTROL_RESERVED4 =7,\n    /*!\n       Use the VBR algorithm with look ahead. It is a special bitrate control mode in the AVC encoder that has been designed\n       to improve encoding quality. It works by performing extensive analysis of several dozen frames before the actual encoding and as a side\n       effect significantly increases encoding delay and memory consumption.\n\n       The only available rate control parameter in this mode is mfxInfoMFX::TargetKbps. Two other parameters, MaxKbps and InitialDelayInKB,\n       are ignored. To control LA depth the application can use mfxExtCodingOption2::LookAheadDepth parameter.\n\n       This method is not HRD compliant.\n    */\n    MFX_RATECONTROL_LA        =8,\n    /*!\n       Use the Intelligent Constant Quality algorithm. This algorithm improves subjective video quality of encoded stream. Depending on content,\n       it may or may not decrease objective video quality. Only one control parameter is used - quality factor, specified by mfxInfoMFX::ICQQuality.\n    */\n    MFX_RATECONTROL_ICQ       =9,\n    /*!\n       Use the Video Conferencing Mode algorithm. This algorithm is similar to the VBR and uses the same set of parameters mfxInfoMFX::InitialDelayInKB,\n       TargetKbpsandMaxKbps. It is tuned for IPPP GOP pattern and streams with strong temporal correlation between frames.\n       It produces better objective and subjective video quality in these conditions than other bitrate control algorithms.\n       It does not support interlaced content, B-frames and produced stream is not HRD compliant.\n    */\n    MFX_RATECONTROL_VCM       =10,\n    /*!\n       Use Intelligent Constant Quality algorithm with look ahead. Quality factor is specified by mfxInfoMFX::ICQQuality.\n       To control LA depth the application can use mfxExtCodingOption2::LookAheadDepth parameter.\n\n       This method is not HRD compliant.\n    */\n    MFX_RATECONTROL_LA_ICQ    =11,\n    /*!\n       MFX_RATECONTROL_LA_EXT has been removed\n    */\n\n    /*! Use HRD compliant look ahead rate control algorithm. */\n    MFX_RATECONTROL_LA_HRD    =13,\n    /*!\n       Use the variable bitrate control algorithm with constant quality. This algorithm trying to achieve the target subjective quality with\n       the minimum number of bits, while the bitrate constraint and HRD compliance are satisfied. It uses the same set of parameters\n       as VBR and quality factor specified by mfxExtCodingOption3::QVBRQuality.\n    */\n    MFX_RATECONTROL_QVBR      =14,\n};\n\n/*!\n   The TrellisControl enumerator is used to control trellis quantization in AVC encoder. The application can turn it on\n   or off for any combination of I-, P- and B-frames by combining different enumerator values. For example, MFX_TRELLIS_I | MFX_TRELLIS_B\n   turns it on for I- and B-frames.\n\n   @note Due to performance reason on some target usages trellis quantization is always turned off and this control is ignored by the encoder.\n*/\nenum {\n    MFX_TRELLIS_UNKNOWN =0,    /*!&lt; Default value, it is up to the encoder to turn trellis quantization on or off. */\n    MFX_TRELLIS_OFF     =0x01, /*!&lt; Turn trellis quantization off for all frame types. */\n    MFX_TRELLIS_I       =0x02, /*!&lt; Turn trellis quantization on for I-frames. */\n    MFX_TRELLIS_P       =0x04, /*!&lt; Turn trellis quantization on for P-frames. */\n    MFX_TRELLIS_B       =0x08  /*!&lt; Turn trellis quantization on for B-frames. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Specifies additional options for encoding.\n\n   The application can attach this extended buffer to the mfxVideoParam structure to configure initialization.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CODING_OPTION. */\n\n    mfxU16      reserved1;\n    mfxU16      RateDistortionOpt;      /*!&lt; Set this flag if rate distortion optimization is needed. See the CodingOptionValue enumerator for values of this option. */\n    mfxU16      MECostType;             /*!&lt; Motion estimation cost type. This value is reserved and must be zero. */\n    mfxU16      MESearchType;           /*!&lt; Motion estimation search algorithm. This value is reserved and must be zero. */\n    mfxI16Pair  MVSearchWindow;         /*!&lt; Rectangular size of the search window for motion estimation. This parameter is reserved and must be (0, 0). */\n    MFX_DEPRECATED mfxU16      EndOfSequence;          /* Deprecated */\n    mfxU16      FramePicture;           /*!&lt; Set this flag to encode interlaced fields as interlaced frames. This flag does not affect progressive input frames. See the CodingOptionValue enumerator for values of this option. */\n\n    mfxU16      CAVLC;                  /*!&lt; If set, CAVLC is used; if unset, CABAC is used for encoding. See the CodingOptionValue enumerator for values of this option. */\n    mfxU16      reserved2[2];\n    /*!\n       Set this flag to insert the recovery point SEI message at the beginning of every intra refresh cycle. See the description of\n       IntRefType in mfxExtCodingOption2 structure for details on how to enable and configure intra refresh.\n\n       If intra refresh is not enabled then this flag is ignored.\n\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      RecoveryPointSEI;\n    /*!\n       Set this flag to instruct the MVC encoder to output each view in separate bitstream buffer. See the CodingOptionValue enumerator\n       for values of this option and the Multi-View Video Coding section for more details about usage of this flag.\n    */\n    mfxU16      ViewOutput;\n    /*!\n       If this option is turned ON, then AVC encoder produces an HRD conformant bitstream. If it is turned OFF, then the AVC encoder may (but not necessarily) violate HRD conformance. That is, this option can force the encoder to produce an HRD conformant stream, but\n       cannot force it to produce a non-conformant stream.\n\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      NalHrdConformance;\n    /*!\n       If set, encoder puts all SEI messages in the singe NAL unit. It includes messages provided by application and created\n       by encoder. It is a three-states option. See CodingOptionValue enumerator for values of this option. The three states are:\n\n       @li UNKNOWN Put each SEI in its own NAL unit.\n\n       @li ON Put all SEI messages in the same NAL unit.\n\n       @li OFF The same as unknown.\n    */\n    mfxU16      SingleSeiNalUnit;\n    /*!\n       If set and VBR rate control method is used, then VCL HRD parameters are written in bitstream with values identical to the values of the NAL HRD parameters.\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      VuiVclHrdParameters;\n\n    mfxU16      RefPicListReordering;   /*!&lt; Set this flag to activate reference picture list reordering. This value is reserved and must be zero. */\n    mfxU16      ResetRefList;           /*!&lt; Set this flag to reset the reference list to non-IDR I-frames of a GOP sequence. See the CodingOptionValue enumerator for values of this option. */\n    /*!\n       Set this flag to write the reference picture marking repetition SEI message into the output bitstream.\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      RefPicMarkRep;\n    /*!\n       Set this flag to instruct the AVC encoder to output bitstreams immediately after the encoder encodes a field,\n       in the field-encoding mode. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      FieldOutput;\n\n    mfxU16      IntraPredBlockSize;   /*!&lt; Minimum block size of intra-prediction. This value is reserved and must be zero. */\n    mfxU16      InterPredBlockSize;   /*!&lt; Minimum block size of inter-prediction. This value is reserved and must be zero. */\n    mfxU16      MVPrecision;          /*!&lt; Specify the motion estimation precision. This parameter is reserved and must be zero. */\n    mfxU16      MaxDecFrameBuffering; /*!&lt; Specifies the maximum number of frames buffered in a DPB. A value of zero means unspecified. */\n\n    mfxU16      AUDelimiter;            /*!&lt; Set this flag to insert the Access Unit Delimiter NAL. See the CodingOptionValue enumerator for values of this option. */\n    MFX_DEPRECATED mfxU16      EndOfStream;            /* Deprecated */\n    /*!\n       Set this flag to insert the picture timing SEI with pic_struct syntax element. See sub-clauses D.1.2 and D.2.2 of the ISO/IEC 14496-10\n       specification for the definition of this syntax element. See the CodingOptionValue enumerator for values of this option.\n       The default value is ON.\n    */\n    mfxU16      PicTimingSEI;\n    mfxU16      VuiNalHrdParameters;  /*!&lt; Set this flag to insert NAL HRD parameters in the VUI header. See the CodingOptionValue enumerator for values of this option. */\n} mfxExtCodingOption;\nMFX_PACK_END()\n\n/*! The BRefControl enumerator is used to control usage of B-frames as reference in AVC encoder. */\nenum {\n    MFX_B_REF_UNKNOWN = 0, /*!&lt; Default value, it is up to the encoder to use B-frames as reference. */\n    MFX_B_REF_OFF     = 1, /*!&lt; Do not use B-frames as reference. */\n    MFX_B_REF_PYRAMID = 2  /*!&lt; Arrange B-frames in so-called &quot;B pyramid&quot; reference structure. */\n};\n\n/*! The LookAheadDownSampling enumerator is used to control down sampling in look ahead bitrate control mode in AVC encoder. */\nenum {\n    MFX_LOOKAHEAD_DS_UNKNOWN = 0, /*!&lt; Default value, it is up to the encoder what down sampling value to use. */\n    MFX_LOOKAHEAD_DS_OFF     = 1, /*!&lt; Do not use down sampling, perform estimation on original size frames. This is the slowest setting that produces the best quality. */\n    MFX_LOOKAHEAD_DS_2x      = 2, /*!&lt; Down sample frames two times before estimation. */\n    MFX_LOOKAHEAD_DS_4x      = 3  /*!&lt; Down sample frames four times before estimation. This option may significantly degrade quality. */\n};\n\n/*! The BPSEIControl enumerator is used to control insertion of buffering period SEI in the encoded bitstream. */\nenum {\n    MFX_BPSEI_DEFAULT = 0x00, /*!&lt; encoder decides when to insert BP SEI. */\n    MFX_BPSEI_IFRAME  = 0x01  /*!&lt; BP SEI should be inserted with every I-frame */\n};\n\n/*! The SkipFrame enumerator is used to define usage of mfxEncodeCtrl::SkipFrame parameter. */\nenum {\n    MFX_SKIPFRAME_NO_SKIP         = 0, /*!&lt; Frame skipping is disabled, mfxEncodeCtrl::SkipFrame is ignored. */\n    MFX_SKIPFRAME_INSERT_DUMMY    = 1, /*!&lt; Skipping is allowed, when mfxEncodeCtrl::SkipFrame is set encoder inserts into bitstream frame\n                                            where all macroblocks are encoded as skipped. Only non-reference P- and B-frames can be skipped.\n                                            If GopRefDist = 1 and mfxEncodeCtrl::SkipFrame is set for reference P-frame, it will be encoded\n                                            as non-reference. */\n    MFX_SKIPFRAME_INSERT_NOTHING  = 2, /*!&lt; Similar to MFX_SKIPFRAME_INSERT_DUMMY, but when mfxEncodeCtrl::SkipFrame is set encoder inserts nothing into bitstream. */\n    MFX_SKIPFRAME_BRC_ONLY        = 3, /*!&lt; mfxEncodeCtrl::SkipFrame indicates number of missed frames before the current frame. Affects only BRC, current frame will be encoded as usual. */\n};\n\n/*! The IntraRefreshTypes enumerator itemizes types of intra refresh. */\nenum {\n        MFX_REFRESH_NO             = 0, /*!&lt; Encode without refresh. */\n        MFX_REFRESH_VERTICAL       = 1, /*!&lt; Vertical refresh, by column of MBs. */\n        MFX_REFRESH_HORIZONTAL     = 2, /*!&lt; Horizontal refresh, by rows of MBs. */\n        MFX_REFRESH_SLICE          = 3  /*!&lt; Horizontal refresh by slices without overlapping. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used with the mfxExtCodingOption structure to specify additional options for encoding.\n\n   The application can attach this extended buffer to the mfxVideoParam structure to configure initialization and to the mfxEncodeCtrl during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CODING_OPTION2. */\n\n    /*!\n       Specifies intra refresh type. See the IntraRefreshTypes. The major goal of intra refresh is improvement of error resilience without\n       significant impact on encoded bitstream size caused by I-frames. The  encoder achieves this by encoding part of each frame in the refresh\n       cycle using intra MBs.\n\n       This parameter is valid during initialization and\n       runtime. When used with temporal scalability, intra refresh applied only to base layer.\n\n       MFX_REFRESH_NO No refresh.\n\n       MFX_REFRESH_VERTICAL Vertical refresh, by column of MBs.\n\n       MFX_REFRESH_HORIZONTAL Horizontal refresh, by rows of MBs.\n\n       MFX_REFRESH_SLICE Horizontal refresh by slices without overlapping.\n\n       MFX_REFRESH_SLICE Library ignores IntRefCycleSize (size of refresh cycle equals number slices).\n    */\n    mfxU16      IntRefType;\n    /*!\n       Specifies number of pictures within refresh cycle starting from 2. 0 and 1 are invalid values. This parameter is valid only during initialization.\n    */\n    mfxU16      IntRefCycleSize;\n    /*!\n       Specifies QP difference for inserted intra MBs. Signed values are in the -51 to 51 range. This parameter is valid during initialization and runtime.\n    */\n    mfxI16      IntRefQPDelta;\n\n    /*!\n       Specify maximum encoded frame size in byte. This parameter is used in VBR based bitrate control modes and ignored in others.\n       The encoder tries to keep frame size below specified limit but minor overshoots are possible to preserve visual quality.\n       This parameter is valid during initialization and runtime. It is recommended to set MaxFrameSize to 5x-10x target frame size\n       ((TargetKbps*1000)/(8* FrameRateExtN/FrameRateExtD)) for I-frames and 2x-4x target frame size for P- and B-frames.\n    */\n    mfxU32      MaxFrameSize;\n    /*!\n       Specify maximum slice size in bytes. If this parameter is specified other controls over number of slices are ignored.\n\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU32      MaxSliceSize;\n\n    /*!\n       Modifies bitrate to be in the range imposed by the encoder. The default value is ON, that is, bitrate is limited. Setting this flag to OFF may lead to violation of HRD conformance.Specifying bitrate below the encoder range might significantly affect quality.\n\n       If set to ON, this option takes effect in non CQP modes:\n       if TargetKbps is not in the range imposed by the encoder, it will be changed to be in the range.\n\n       This parameter is valid only during initialization. Flag works with MFX_CODEC_AVC only, it is ignored with other codecs.\n       See the CodingOptionValue\n       enumerator for values of this option.\n\n       @deprecated Deprecated in API version 2.9\n    */\n    MFX_DEPRECATED mfxU16      BitrateLimit; /* Deprecated */\n    /*!\n       Setting this flag enables macroblock level bitrate control that generally improves subjective visual quality. Enabling this flag may\n       have negative impact on performance and objective visual quality metric. See the CodingOptionValue enumerator for values of this option.\n       The default value depends on target usage settings.\n    */\n    mfxU16      MBBRC;\n    /*!\n       Set this option to ON to enable external BRC. See the CodingOptionValue enumerator for values of this option.\n       Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      ExtBRC;\n    /*!\n       Specifies the depth of the look ahead rate control algorithm. The depth value is the number of frames that the encoder analyzes before encoding. Values are in the 10 to 100 range, inclusive.\n       To instruct the encoder to use the default value the application should zero this field.\n    */\n    mfxU16      LookAheadDepth;\n    /*!\n       Used to control trellis quantization in AVC encoder. See TrellisControl enumerator for values of this option.\n       This parameter is valid only during initialization.\n    */\n    mfxU16      Trellis;\n    /*!\n       Controls picture parameter set repetition in AVC encoder. Set this flag to ON to repeat PPS with each frame.\n       See the CodingOptionValue enumerator for values of this option. The default value is ON. This parameter is valid only during initialization.\n    */\n    mfxU16      RepeatPPS;\n    /*!\n       Controls usage of B-frames as reference. See BRefControl enumerator for values of this option.\n       This parameter is valid only during initialization.\n    */\n    mfxU16      BRefType;\n    /*!\n       Controls insertion of I-frames by the encoder. Set this flag to ON to allow changing of frame type from P and B to I.\n       This option is ignored if GopOptFlag in mfxInfoMFX structure is equal to MFX_GOP_STRICT. See the CodingOptionValue enumerator\n       for values of this option. This parameter is valid only during initialization.\n    */\n    mfxU16      AdaptiveI;\n    /*!\n       Controls changing of frame type from B to P. Set this flag to ON enable changing of frame type from B to P. This option is ignored if\n       GopOptFlag in mfxInfoMFX structure is equal to MFX_GOP_STRICT. See the CodingOptionValue enumerator for values of this option.\n       This parameter is valid only during initialization.\n    */\n    mfxU16      AdaptiveB;\n    /*!\n       Controls down sampling in look ahead bitrate control mode. See LookAheadDownSampling enumerator for values\n       of this option. This parameter is valid only during initialization.\n    */\n    mfxU16      LookAheadDS;\n    /*!\n       Specifies suggested slice size in number of macroblocks. The library can adjust this number based on platform capability.\n       If this option is specified, that is, if it is not equal to zero, the library ignores mfxInfoMFX::NumSlice parameter.\n    */\n    mfxU16      NumMbPerSlice;\n    /*!\n       Enables usage of mfxEncodeCtrl::SkipFrame parameter. See the SkipFrame enumerator for values of this option.\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      SkipFrame;\n    mfxU8       MinQPI; /*!&lt; Minimum allowed QP value for I-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU8       MaxQPI; /*!&lt; Maximum allowed QP value for I-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU8       MinQPP; /*!&lt; Minimum allowed QP value for P-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU8       MaxQPP; /*!&lt; Maximum allowed QP value for P-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU8       MinQPB; /*!&lt; Minimum allowed QP value for B-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    mfxU8       MaxQPB; /*!&lt; Maximum allowed QP value for B-frame types. Valid range is 1 to 51 inclusive. Zero means default value, that is, no limitations on QP.\n                             @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported. */\n    /*!\n       Sets fixed_frame_rate_flag in VUI.\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      FixedFrameRate;\n    /*! Disables deblocking.\n        @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      DisableDeblockingIdc;\n    /*!\n       Completely disables VUI in the output bitstream.\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      DisableVUI;\n    /*!\n       Controls insertion of buffering period SEI in the encoded bitstream. It should be one of the following values:\n\n       MFX_BPSEI_DEFAULT   Encoder decides when to insert BP SEI,\n\n       MFX_BPSEI_IFRAME    BP SEI should be inserted with every I-frame.\n    */\n    mfxU16      BufferingPeriodSEI;\n    /*!\n       Set this flag to ON to enable per-frame reporting of Mean Absolute Difference. This parameter is valid only during initialization.\n    */\n    mfxU16      EnableMAD;\n    /*!\n       Set this flag to ON to use raw frames for reference instead of reconstructed frames. This parameter is valid during\n       initialization and runtime (only if was turned ON during initialization).\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      UseRawRef;\n} mfxExtCodingOption2;\nMFX_PACK_END()\n\n/*! The WeightedPred enumerator itemizes weighted prediction modes. */\nenum {\n    MFX_WEIGHTED_PRED_UNKNOWN  = 0, /*!&lt; Allow encoder to decide. */\n    MFX_WEIGHTED_PRED_DEFAULT  = 1, /*!&lt; Use default weighted prediction. */\n    MFX_WEIGHTED_PRED_EXPLICIT = 2, /*!&lt; Use explicit weighted prediction. */\n    MFX_WEIGHTED_PRED_IMPLICIT = 3  /*!&lt; Use implicit weighted prediction (for B-frames only). */\n};\n\n/*! The ScenarioInfo enumerator itemizes scenarios for the encoding session. */\nenum {\n    MFX_SCENARIO_UNKNOWN             = 0,\n    MFX_SCENARIO_DISPLAY_REMOTING    = 1,\n    MFX_SCENARIO_VIDEO_CONFERENCE    = 2,\n    MFX_SCENARIO_ARCHIVE             = 3,\n    MFX_SCENARIO_LIVE_STREAMING      = 4,\n    MFX_SCENARIO_CAMERA_CAPTURE      = 5,\n    MFX_SCENARIO_VIDEO_SURVEILLANCE  = 6,\n    MFX_SCENARIO_GAME_STREAMING      = 7,\n    MFX_SCENARIO_REMOTE_GAMING       = 8\n};\n\n/*! The ContentInfo enumerator itemizes content types for the encoding session. */\nenum {\n    MFX_CONTENT_UNKNOWN              = 0,\n    MFX_CONTENT_FULL_SCREEN_VIDEO    = 1,\n    MFX_CONTENT_NON_VIDEO_SCREEN     = 2,\n    MFX_CONTENT_NOISY_VIDEO          = 3\n};\n\n/*! The PRefType enumerator itemizes models of reference list construction and DPB management when GopRefDist=1. */\nenum {\n    MFX_P_REF_DEFAULT = 0, /*!&lt; Allow encoder to decide. */\n    MFX_P_REF_SIMPLE  = 1, /*!&lt; Regular sliding window used for DPB removal process. */\n    MFX_P_REF_PYRAMID = 2  /*!&lt; Let N be the max reference list&#x27;s size. Encoder treats each N&#x27;s frame as a &#x27;strong&#x27;\n                                reference and the others as &#x27;weak&#x27; references. The encoder uses a &#x27;weak&#x27; reference only for\n                                prediction of the next frame and removes it from DPB immediately after use. &#x27;Strong&#x27; references are removed from\n                                DPB by a sliding window. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used with mfxExtCodingOption and mfxExtCodingOption2 structures to specify additional options for encoding.\n   The application can attach this extended buffer to the mfxVideoParam structure to configure initialization and to the mfxEncodeCtrl during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CODING_OPTION3. */\n\n    mfxU16      NumSliceI; /*!&lt; The number of slices for I-frames.\n                                @note Not all codecs and implementations support these values. Use the Query API function to check if this feature is supported */\n    mfxU16      NumSliceP; /*!&lt; The number of slices for P-frames.\n                                @note Not all codecs and implementations support these values. Use the Query API function to check if this feature is supported */\n    mfxU16      NumSliceB; /*!&lt; The number of slices for B-frames.\n                                @note Not all codecs and implementations support these values. Use the Query API function to check if this feature is supported */\n\n    /*!\n       When rate control method is MFX_RATECONTROL_VBR, MFX_RATECONTROL_LA, MFX_RATECONTROL_LA_HRD, or MFX_RATECONTROL_QVBR this parameter\n       specifies the maximum bitrate averaged over a sliding window specified by WinBRCSize. For MFX_RATECONTROL_CBR this parameter is ignored and\n       equals TargetKbps.\n    */\n    mfxU16      WinBRCMaxAvgKbps;\n    /*!\n       When rate control method is MFX_RATECONTROL_CBR, MFX_RATECONTROL_VBR, MFX_RATECONTROL_LA, MFX_RATECONTROL_LA_HRD, or MFX_RATECONTROL_QVBR\n       this parameter specifies sliding window size in frames. Set this parameter to zero to disable sliding window.\n    */\n    mfxU16      WinBRCSize;\n\n    /*! When rate control method is MFX_RATECONTROL_QVBR, this parameter specifies quality factor.\n        Values are in the 1 to 51 range, where 1 corresponds to the best quality.\n    */\n    mfxU16      QVBRQuality;\n    /*!\n       Set this flag to ON to enable per-macroblock QP control. Rate control method must be MFX_RATECONTROL_CQP. See the CodingOptionValue\n       enumerator for values of this option. This parameter is valid only during initialization.\n    */\n    mfxU16      EnableMBQP;\n    /*!\n       Distance between the beginnings of the intra-refresh cycles in frames. Zero means no distance between cycles.\n    */\n    mfxU16      IntRefCycleDist;\n    /*!\n       Set this flag to ON to enable the ENC mode decision algorithm to bias to fewer B Direct/Skip types. Applies only to B-frames,\n       all other frames will ignore this setting. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      DirectBiasAdjustment;\n    /*!\n       Enables global motion bias. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      GlobalMotionBiasAdjustment;\n    /*!\n       Values are:\n\n       @li 0: Set MV cost to be 0.\n\n       @li 1: Scale MV cost to be 1/2 of the default value.\n\n       @li 2: Scale MV cost to be 1/4 of the default value.\n\n       @li 3: Scale MV cost to be 1/8 of the default value.\n    */\n    mfxU16      MVCostScalingFactor;\n    /*!\n       Set this flag to ON to enable usage of mfxExtMBDisableSkipMap. See the CodingOptionValue enumerator for values of this option.\n       This parameter is valid only during initialization.\n    */\n    mfxU16      MBDisableSkipMap;\n\n    mfxU16      WeightedPred;   /*!&lt; Weighted prediction mode. See the WeightedPred enumerator for values of these options. */\n    mfxU16      WeightedBiPred; /*!&lt; Weighted prediction mode. See the WeightedPred enumerator for values of these options. */\n\n    /*!\n       Instructs encoder whether aspect ratio info should present in VUI parameters. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      AspectRatioInfoPresent;\n    /*!\n       Instructs encoder whether overscan info should present in VUI parameters. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      OverscanInfoPresent;\n    /*!\n       ON indicates that the cropped decoded pictures output are suitable for display using overscan. OFF indicates that the cropped decoded\n       pictures output contain visually important information in the entire region out to the edges of the cropping rectangle of the picture.\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      OverscanAppropriate;\n    /*!\n       Instructs encoder whether frame rate info should present in VUI parameters. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      TimingInfoPresent;\n    /*!\n       Instructs encoder whether bitstream restriction info should present in VUI parameters. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      BitstreamRestriction;\n    /*!\n       Corresponds to AVC syntax element low_delay_hrd_flag (VUI). See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      LowDelayHrd;\n    /*!\n       When set to OFF, no sample outside the picture boundaries and no sample at a fractional sample position for which the sample value\n       is derived using one or more samples outside the picture boundaries is used for inter prediction of any sample.\n\n       When set to ON, one or more samples outside picture boundaries may be used in inter prediction.\n\n       See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      MotionVectorsOverPicBoundaries;\n    mfxU16      reserved1[2];\n\n    mfxU16      ScenarioInfo; /*!&lt; Provides a hint to encoder about the scenario for the encoding session. See the ScenarioInfo enumerator for values of this option. */\n    mfxU16      ContentInfo;  /*!&lt; Provides a hint to encoder about the content for the encoding session. See the ContentInfo enumerator for values of this option. */\n\n    mfxU16      PRefType;     /*!&lt; When GopRefDist=1, specifies the model of reference list construction and DPB management. See the PRefType enumerator for values of this option. */\n    /*!\n       Instructs encoder whether internal fade detection algorithm should be used for calculation of weigh/offset values for pred_weight_table\n       unless application provided mfxExtPredWeightTable for this frame. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      FadeDetection;\n    mfxU16      reserved2[2];\n    /*!\n       Set this flag to OFF to make HEVC encoder use regular P-frames instead of GPB. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      GPB;\n\n    /*!\n       Same as mfxExtCodingOption2::MaxFrameSize but affects only I-frames. MaxFrameSizeI must be set if MaxFrameSizeP is set.\n       If MaxFrameSizeI is not specified or greater than spec limitation, spec limitation will be applied to the sizes of I-frames.\n    */\n    mfxU32      MaxFrameSizeI;\n    /*!\n       Same as mfxExtCodingOption2::MaxFrameSize but affects only P/B-frames. If MaxFrameSizeP equals 0, the library sets MaxFrameSizeP\n       equal to MaxFrameSizeI. If MaxFrameSizeP is not specified or greater than spec limitation, spec limitation will be applied to the\n       sizes of P/B-frames.\n    */\n    mfxU32      MaxFrameSizeP;\n    mfxU32      reserved3[3];\n\n    /*!\n       Enables QPOffset control. See the CodingOptionValue enumerator for values of this option.\n    */\n    mfxU16      EnableQPOffset;\n    /*!\n       Specifies QP offset per pyramid layer when EnableQPOffset is set to ON and RateControlMethod is CQP.\n\n       For B-pyramid, B-frame QP = QPB + QPOffset[layer].\n\n       For P-pyramid, P-frame QP = QPP + QPOffset[layer].\n    */\n    mfxI16      QPOffset[8];              /* FrameQP = QPX + QPOffset[pyramid_layer]; QPX = QPB for B-pyramid, QPP for P-pyramid */\n\n\n    mfxU16      NumRefActiveP[8];   /*!&lt; Max number of active references for P-frames. Array index is pyramid layer. */\n    mfxU16      NumRefActiveBL0[8]; /*!&lt; Max number of active references for B-frames in reference picture list 0. Array index is pyramid layer. */\n    mfxU16      NumRefActiveBL1[8]; /*!&lt; Max number of active references for B-frames in reference picture list 1. Array index is pyramid layer. */\n\n    mfxU16      reserved6;\n    /*!\n       For HEVC if this option is turned ON, the transform_skip_enabled_flag will be set to 1 in PPS. OFF specifies that transform_skip_enabled_flag will be set to 0.\n    */\n    mfxU16      TransformSkip;\n    /*!\n       Minus 1 specifies target encoding chroma format (see ChromaFormatIdc enumerator). May differ from the source format.\n       TargetChromaFormatPlus1 = 0 specifies the default target chroma format which is equal to source (mfxVideoParam::mfx::FrameInfo::ChromaFormat + 1),\n       except RGB4 source format. In case of RGB4 source format default target , chroma format is 4:2:0 (instead of 4:4:4)\n       for the purpose of backward compatibility.\n    */\n    mfxU16      TargetChromaFormatPlus1;\n    /*!\n       Target encoding bit-depth for luma samples. May differ from source bit-depth. 0 specifies a default target bit-depth that is equal to\n       source (mfxVideoParam::mfx::FrameInfo::BitDepthLuma).\n    */\n    mfxU16      TargetBitDepthLuma;\n    /*!\n       Target encoding bit-depth for chroma samples. May differ from source bit-depth. 0 specifies a default target bit-depth that is equal to\n       source (mfxVideoParam::mfx::FrameInfo::BitDepthChroma).\n    */\n    mfxU16      TargetBitDepthChroma;\n    mfxU16      BRCPanicMode; /*!&lt; Controls panic mode in AVC and MPEG2 encoders. */\n\n    /*!\n       When rate control method is MFX_RATECONTROL_VBR, MFX_RATECONTROL_QVBR or MFX_RATECONTROL_VCM this parameter specifies frame size\n       tolerance. Set this parameter to MFX_CODINGOPTION_ON to allow strictly obey average frame size set by MaxKbps, for example cases when\n       MaxFrameSize == (MaxKbps*1000)/(8* FrameRateExtN/FrameRateExtD). Also MaxFrameSizeI and MaxFrameSizeP can be set separately.\n    */\n    mfxU16      LowDelayBRC;\n    /*!\n       Set this flag to ON to enable usage of mfxExtMBForceIntra for AVC encoder. See the CodingOptionValue enumerator\n       for values of this option. This parameter is valid only during initialization.\n    */\n    mfxU16      EnableMBForceIntra;\n    /*!\n       If this flag is set to ON, BRC may decide a larger P- or B-frame size than what MaxFrameSizeP dictates when the scene change is detected.\n       It may benefit the video quality. AdaptiveMaxFrameSize feature is not supported with LowPower ON or if the value of MaxFrameSizeP = 0.\n    */\n    mfxU16      AdaptiveMaxFrameSize;\n\n    /*!\n       Controls AVC encoder attempts to predict from small partitions. Default value allows encoder to choose preferred mode.\n       MFX_CODINGOPTION_ON forces encoder to favor quality and MFX_CODINGOPTION_OFF forces encoder to favor performance.\n    */\n    mfxU16      RepartitionCheckEnable;\n    mfxU16      reserved5[3];\n    mfxU16      EncodedUnitsInfo;          /*!&lt; Set this flag to ON to make encoded units info available in mfxExtEncodedUnitsInfo. */\n    /*!\n       If this flag is set to ON, the HEVC encoder uses the NAL unit type provided by the application in the mfxEncodeCtrl::MfxNalUnitType field.\n       This parameter is valid only during initialization.\n       @note Not all codecs and implementations support this value. Use the Query API function to check if this feature is supported.\n    */\n    mfxU16      EnableNalUnitType;\n\n    union {\n        MFX_DEPRECATED mfxU16      ExtBrcAdaptiveLTR; /* Deprecated */\n\n        /*!\n            If this flag is set to ON, encoder will mark, modify, or remove LTR frames based on encoding parameters and content\n            properties. Turn OFF to prevent Adaptive marking of Long Term Reference Frames. \n        */\n        mfxU16      AdaptiveLTR;\n    };\n    /*!\n       If this flag is set to ON, encoder adaptively selects one of implementation-defined quantization matrices for each frame.\n       Non-default quantization matrices aim to improve subjective visual quality under certain conditions.\n       Their number and definitions are API implementation specific.\n       If this flag is set to OFF, default quantization matrix is used for all frames.\n       This parameter is valid only during initialization.\n    */\n    mfxU16      AdaptiveCQM;\n    /*!\n       If this flag is set to ON, encoder adaptively selects list of reference frames to improve encoding quality.\n       Enabling of the flag can increase computation complexity and introduce additional delay.\n       If this flag is set to OFF, regular reference frames are used for encoding.\n    */\n    mfxU16      AdaptiveRef;\n \n    mfxU16      reserved[161];\n  \n} mfxExtCodingOption3;\nMFX_PACK_END()\n\n/*! IntraPredBlockSize/InterPredBlockSize specifies the minimum block size of inter-prediction. */\nenum {\n    MFX_BLOCKSIZE_UNKNOWN   = 0, /*!&lt; Unspecified. */\n    MFX_BLOCKSIZE_MIN_16X16 = 1, /*!&lt; 16x16 minimum block size.              */\n    MFX_BLOCKSIZE_MIN_8X8   = 2, /*!&lt; 8x8 minimum block size. May be 16x16 or 8x8.         */\n    MFX_BLOCKSIZE_MIN_4X4   = 3  /*!&lt; 4x4 minimum block size. May be 16x16, 8x8, or 4x4.    */\n};\n\n/*! The MVPrecision enumerator specifies the motion estimation precision. */\nenum {\n    MFX_MVPRECISION_UNKNOWN    = 0,\n    MFX_MVPRECISION_INTEGER    = (1 &lt;&lt; 0),\n    MFX_MVPRECISION_HALFPEL    = (1 &lt;&lt; 1),\n    MFX_MVPRECISION_QUARTERPEL = (1 &lt;&lt; 2)\n};\n\n/*! The CodingOptionValue enumerator defines a three-state coding option setting. */\nenum {\n    MFX_CODINGOPTION_UNKNOWN    =0,    /*!&lt; Unspecified. */\n    MFX_CODINGOPTION_ON         =0x10, /*!&lt; Coding option set. */\n    MFX_CODINGOPTION_OFF        =0x20, /*!&lt; Coding option not set. */\n    MFX_CODINGOPTION_ADAPTIVE   =0x30  /*!&lt; Reserved. */\n};\n\n/*! The BitstreamDataFlag enumerator uses bit-ORed values to itemize additional information about the bitstream buffer. */\nenum {\n    MFX_BITSTREAM_NO_FLAG           = 0x0000, /*!&lt; The bitstream doesn&#x27;t contain any flags. */\n    /*!\n       The bitstream buffer contains a complete frame or complementary field pair of data for the bitstream. For decoding, this means\n       that the decoder can proceed with this buffer without waiting for the start of the next frame, which effectively reduces decoding latency.\n       If this flag is set, but the bitstream buffer contains incomplete frame or pair of field, then decoder will produce corrupted output.\n    */\n    MFX_BITSTREAM_COMPLETE_FRAME    = 0x0001,\n    /*!\n       The bitstream buffer contains the end of the stream. For decoding,\n       this means that the application does not have any additional bitstream data to send to decoder.\n    */\n    MFX_BITSTREAM_EOS               = 0x0002\n};\n/*! The ExtendedBufferID enumerator itemizes and defines identifiers (BufferId) for extended buffers or video processing algorithm identifiers. */\nenum {\n    /*!\n       This extended buffer defines additional encoding controls. See the mfxExtCodingOption structure for details.\n       The application can attach this buffer to the structure for encoding initialization.\n    */\n    MFX_EXTBUFF_CODING_OPTION                   = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;D&#x27;,&#x27;O&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer defines sequence header and picture header for encoders and decoders. See the mfxExtCodingOptionSPSPPS\n       structure for details. The application can attach this buffer to the mfxVideoParam structure for encoding initialization,\n       and for obtaining raw headers from the decoders and encoders.\n    */\n    MFX_EXTBUFF_CODING_OPTION_SPSPPS            = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;O&#x27;,&#x27;S&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer defines a list of VPP algorithms that applications should not use. See the mfxExtVPPDoNotUse structure\n       for details. The application can attach this buffer to the mfxVideoParam structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_DONOTUSE                    = MFX_MAKEFOURCC(&#x27;N&#x27;,&#x27;U&#x27;,&#x27;S&#x27;,&#x27;E&#x27;),\n    /*!\n       This extended buffer defines auxiliary information at the VPP output. See the mfxExtVppAuxData structure for details. The application\n       can attach this buffer to the mfxEncodeCtrl structure for per-frame encoding control.\n    */\n    MFX_EXTBUFF_VPP_AUXDATA                     = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;U&#x27;,&#x27;X&#x27;,&#x27;D&#x27;),\n    /*!\n       The extended buffer defines control parameters for the VPP denoise filter algorithm. See the mfxExtVPPDenoise2 structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_DENOISE2                    = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;N&#x27;,&#x27;I&#x27;,&#x27;2&#x27;),\n    MFX_DEPRECATED_ENUM_FIELD_INSIDE(MFX_EXTBUFF_VPP_DENOISE)                     = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;N&#x27;,&#x27;I&#x27;,&#x27;S&#x27;), /*!&lt; Deprecated in 2.2 API version.*/\n    MFX_EXTBUFF_VPP_SCENE_ANALYSIS              = MFX_MAKEFOURCC(&#x27;S&#x27;,&#x27;C&#x27;,&#x27;L&#x27;,&#x27;Y&#x27;), /*!&lt; Reserved for future use. */\n    MFX_DEPRECATED_ENUM_FIELD_INSIDE(MFX_EXTBUFF_VPP_SCENE_CHANGE)                = MFX_EXTBUFF_VPP_SCENE_ANALYSIS, /* Deprecated. */\n    /*!\n       The extended buffer defines control parameters for the VPP ProcAmp filter algorithm. See the mfxExtVPPProcAmp structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for video processing initialization or to the mfxFrameData\n       structure in the mfxFrameSurface1 structure of output surface for per-frame processing configuration.\n    */\n    MFX_EXTBUFF_VPP_PROCAMP                     = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;A&#x27;,&#x27;M&#x27;,&#x27;P&#x27;),\n    /*!\n       The extended buffer defines control parameters for the VPP detail filter algorithm. See the mfxExtVPPDetail structure for details.\n       The application can attach this buffer to the structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_DETAIL                      = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;E&#x27;,&#x27;T&#x27;,&#x27; &#x27;),\n    /*!\n       This extended buffer defines video signal type. See the mfxExtVideoSignalInfo structure for details. The application can attach this\n       buffer to the mfxVideoParam structure for encoding initialization, and for retrieving such information from the decoders. If video\n       signal info changes per frame, the application can attach this buffer to the mfxFrameData structure for video processing.\n    */\n    MFX_EXTBUFF_VIDEO_SIGNAL_INFO               = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;S&#x27;,&#x27;I&#x27;,&#x27;N&#x27;),\n    /*!\n       This extended buffer defines video signal type. See the mfxExtVideoSignalInfo structure for details. The application can attach this\n       buffer to the mfxVideoParam structure for the input of video processing if the input video signal information changes in sequence\n       base.\n    */\n    MFX_EXTBUFF_VIDEO_SIGNAL_INFO_IN            = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;S&#x27;,&#x27;I&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer defines video signal type. See the mfxExtVideoSignalInfo structure for details. The application can attach this\n       buffer to the mfxVideoParam structure for the output of video processing if the output video signal information changes in sequence\n       base.\n    */\n    MFX_EXTBUFF_VIDEO_SIGNAL_INFO_OUT           = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;S&#x27;,&#x27;I&#x27;,&#x27;O&#x27;),\n    /*!\n       This extended buffer defines a list of VPP algorithms that applications should use. See the mfxExtVPPDoUse structure for details.\n       The application can attach this buffer to the structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_DOUSE                       = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;U&#x27;,&#x27;S&#x27;,&#x27;E&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls for reference list. See the mfxExtAVCRefListCtrl structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding &amp; decoding initialization, or the mfxEncodeCtrl\n       structure for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_AVC_REFLIST_CTRL                = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;L&#x27;,&#x27;S&#x27;,&#x27;T&#x27;),\n    /*!\n       This extended buffer defines control parameters for the VPP frame rate conversion algorithm. See the mfxExtVPPFrameRateConversion structure\n       for details. The application can attach this buffer to the mfxVideoParam structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_FRAME_RATE_CONVERSION       = MFX_MAKEFOURCC(&#x27;F&#x27;,&#x27;R&#x27;,&#x27;C&#x27;,&#x27; &#x27;),\n    /*!\n       This extended buffer configures the H.264 picture timing SEI message. See the mfxExtPictureTimingSEI structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding initialization, or the mfxEncodeCtrl structure\n       for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_PICTURE_TIMING_SEI              = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;T&#x27;,&#x27;S&#x27;,&#x27;E&#x27;),\n    /*!\n       This extended buffer configures the structure of temporal layers inside the encoded H.264 bitstream. See the mfxExtAvcTemporalLayers\n       structure for details. The application can attach this buffer to the mfxVideoParam structure for encoding initialization.\n    */\n    MFX_EXTBUFF_AVC_TEMPORAL_LAYERS             = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;T&#x27;,&#x27;M&#x27;,&#x27;L&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls. See the mfxExtCodingOption2 structure for details.\n       The application can attach this buffer to the structure for encoding initialization.\n    */\n    MFX_EXTBUFF_CODING_OPTION2                  = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;D&#x27;,&#x27;O&#x27;,&#x27;2&#x27;),\n    /*!\n       This extended buffer defines control parameters for the VPP image stabilization filter algorithm. See the mfxExtVPPImageStab structure\n       for details. The application can attach this buffer to the mfxVideoParam structure for video processing initialization.\n    */\n    MFX_EXTBUFF_VPP_IMAGE_STABILIZATION         = MFX_MAKEFOURCC(&#x27;I&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;B&#x27;),\n    /*!\n       This extended buffer is used to retrieve encoder capability. See the mfxExtEncoderCapability structure for details.\n       The application can attach this buffer to the mfxVideoParam structure before calling MFXVideoENCODE_Query function.\n    */\n    MFX_EXTBUFF_ENCODER_CAPABILITY              = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;N&#x27;,&#x27;C&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer is used to control encoder reset behavior and also to query possible encoder reset outcome.\n       See the mfxExtEncoderResetOption structure for details. The application can attach this buffer to the mfxVideoParam structure\n       before calling MFXVideoENCODE_Query or MFXVideoENCODE_Reset functions.\n    */\n    MFX_EXTBUFF_ENCODER_RESET_OPTION            = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;N&#x27;,&#x27;R&#x27;,&#x27;O&#x27;),\n    /*!\n       This extended buffer is used by the encoder to report additional information about encoded picture.\n       See the mfxExtAVCEncodedFrameInfo structure for details. The application can attach this buffer to the mfxBitstream structure\n       before calling MFXVideoENCODE_EncodeFrameAsync function.\n    */\n    MFX_EXTBUFF_ENCODED_FRAME_INFO              = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;N&#x27;,&#x27;F&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer is used to control composition of several input surfaces in the one output. In this mode,\n       the VPP skips any other filters. The VPP returns error if any mandatory filter is specified and filter skipped warning\n       for optional filter. The only supported filters are deinterlacing and interlaced scaling.\n    */\n    MFX_EXTBUFF_VPP_COMPOSITE                   = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;C&#x27;,&#x27;M&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer is used to control transfer matrix and nominal range of YUV frames.\n       The application should provide it during initialization.\n    */\n    MFX_EXTBUFF_VPP_VIDEO_SIGNAL_INFO           = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;V&#x27;,&#x27;S&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer is used by the application to specify different Region Of Interests during encoding.\n       The application should provide it at initialization or at runtime.\n    */\n    MFX_EXTBUFF_ENCODER_ROI                     = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;R&#x27;,&#x27;O&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer is used by the application to specify different deinterlacing algorithms.\n    */\n    MFX_EXTBUFF_VPP_DEINTERLACING               = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;P&#x27;,&#x27;D&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer specifies reference lists for the encoder.\n    */\n    MFX_EXTBUFF_AVC_REFLISTS                    = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;L&#x27;,&#x27;T&#x27;,&#x27;S&#x27;),\n    /*!\n       See the mfxExtDecVideoProcessing structure for details.\n    */\n    MFX_EXTBUFF_DEC_VIDEO_PROCESSING            = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;E&#x27;,&#x27;C&#x27;,&#x27;V&#x27;),\n    /*!\n       The extended buffer defines control parameters for the VPP field-processing algorithm. See the mfxExtVPPFieldProcessing\n       structure for details. The application can attach this buffer to the mfxVideoParam structure for video processing initialization\n       or to the mfxFrameData structure during runtime.\n    */\n    MFX_EXTBUFF_VPP_FIELD_PROCESSING            = MFX_MAKEFOURCC(&#x27;F&#x27;,&#x27;P&#x27;,&#x27;R&#x27;,&#x27;O&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls. See the mfxExtCodingOption3 structure for details.\n       The application can attach this buffer to the structure for encoding initialization.\n    */\n    MFX_EXTBUFF_CODING_OPTION3                  = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;D&#x27;,&#x27;O&#x27;,&#x27;3&#x27;),\n    /*!\n       This extended buffer defines chroma samples location information. See the mfxExtChromaLocInfo structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding initialization.\n    */\n    MFX_EXTBUFF_CHROMA_LOC_INFO                 = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;L&#x27;,&#x27;I&#x27;,&#x27;N&#x27;),\n    /*!\n       This extended buffer defines per-macroblock QP. See the mfxExtMBQP structure for details.\n       The application can attach this buffer to the mfxEncodeCtrl structure for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_MBQP                            = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;B&#x27;,&#x27;Q&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer defines per-macroblock force intra flag. See the mfxExtMBForceIntra structure for details.\n       The application can attach this buffer to the mfxEncodeCtrl structure for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_MB_FORCE_INTRA                  = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;B&#x27;,&#x27;F&#x27;,&#x27;I&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls for HEVC tiles. See the mfxExtHEVCTiles structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding initialization.\n    */\n    MFX_EXTBUFF_HEVC_TILES                      = MFX_MAKEFOURCC(&#x27;2&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;T&#x27;),\n    /*!\n       This extended buffer defines macroblock map for current frame which forces specified macroblocks to be non skip. See the\n       mfxExtMBDisableSkipMap structure for details. The application can attach this buffer to the mfxEncodeCtrl structure for\n       per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_MB_DISABLE_SKIP_MAP             = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;D&#x27;,&#x27;S&#x27;,&#x27;M&#x27;),\n    /*!\n       See the mfxExtHEVCParam structure for details.\n    */\n    MFX_EXTBUFF_HEVC_PARAM                      = MFX_MAKEFOURCC(&#x27;2&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;P&#x27;),\n    /*!\n       This extended buffer is used by decoders to report additional information about decoded frame. See the\n       mfxExtDecodedFrameInfo structure for more details.\n    */\n    MFX_EXTBUFF_DECODED_FRAME_INFO              = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;I&#x27;),\n    /*!\n       See the mfxExtTimeCode structure for more details.\n    */\n    MFX_EXTBUFF_TIME_CODE                       = MFX_MAKEFOURCC(&#x27;T&#x27;,&#x27;M&#x27;,&#x27;C&#x27;,&#x27;D&#x27;),\n    /*!\n       This extended buffer specifies the region to encode. The application can attach this buffer to the\n       mfxVideoParam structure during HEVC encoder initialization.\n    */\n    MFX_EXTBUFF_HEVC_REGION                     = MFX_MAKEFOURCC(&#x27;2&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;R&#x27;),\n    /*!\n       See the mfxExtPredWeightTable structure for details.\n    */\n    MFX_EXTBUFF_PRED_WEIGHT_TABLE               = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;P&#x27;,&#x27;W&#x27;,&#x27;T&#x27;),\n    /*!\n       See the mfxExtDirtyRect structure for details.\n    */\n    MFX_EXTBUFF_DIRTY_RECTANGLES                = MFX_MAKEFOURCC(&#x27;D&#x27;,&#x27;R&#x27;,&#x27;O&#x27;,&#x27;I&#x27;),\n    /*!\n       See the mfxExtMoveRect structure for details.\n    */\n    MFX_EXTBUFF_MOVING_RECTANGLES               = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;R&#x27;,&#x27;O&#x27;,&#x27;I&#x27;),\n    /*!\n       See the mfxExtCodingOptionVPS structure for details.\n    */\n    MFX_EXTBUFF_CODING_OPTION_VPS               = MFX_MAKEFOURCC(&#x27;C&#x27;,&#x27;O&#x27;,&#x27;V&#x27;,&#x27;P&#x27;),\n    /*!\n       See the mfxExtVPPRotation structure for details.\n    */\n    MFX_EXTBUFF_VPP_ROTATION                    = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;O&#x27;,&#x27;T&#x27;,&#x27; &#x27;),\n    /*!\n       See the mfxExtEncodedSlicesInfo structure for details.\n    */\n    MFX_EXTBUFF_ENCODED_SLICES_INFO             = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;N&#x27;,&#x27;S&#x27;,&#x27;I&#x27;),\n    /*!\n       See the mfxExtVPPScaling structure for details.\n    */\n    MFX_EXTBUFF_VPP_SCALING                     = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;S&#x27;,&#x27;C&#x27;,&#x27;L&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls for reference list. See the mfxExtAVCRefListCtrl structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding &amp; decoding initialization, or\n       the mfxEncodeCtrl structure for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_HEVC_REFLIST_CTRL               = MFX_EXTBUFF_AVC_REFLIST_CTRL,\n    /*!\n       This extended buffer specifies reference lists for the encoder.\n    */\n    MFX_EXTBUFF_HEVC_REFLISTS                   = MFX_EXTBUFF_AVC_REFLISTS,\n    /*!\n       This extended buffer configures the structure of temporal layers inside the encoded H.264 bitstream. See the mfxExtAvcTemporalLayers\n       structure for details. The application can attach this buffer to the mfxVideoParam structure for encoding initialization.\n    */\n    MFX_EXTBUFF_HEVC_TEMPORAL_LAYERS            = MFX_EXTBUFF_AVC_TEMPORAL_LAYERS,\n    /*!\n       See the mfxExtVPPMirroring structure for details.\n    */\n    MFX_EXTBUFF_VPP_MIRRORING                   = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;I&#x27;,&#x27;R&#x27;,&#x27;R&#x27;),\n    /*!\n       See the mfxExtMVOverPicBoundaries structure for details.\n    */\n    MFX_EXTBUFF_MV_OVER_PIC_BOUNDARIES          = MFX_MAKEFOURCC(&#x27;M&#x27;,&#x27;V&#x27;,&#x27;P&#x27;,&#x27;B&#x27;),\n    /*!\n       See the mfxExtVPPColorFill structure for details.\n    */\n    MFX_EXTBUFF_VPP_COLORFILL                   = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;C&#x27;,&#x27;L&#x27;,&#x27;F&#x27;),\n    /*!\n       This extended buffer is used by decoders to report error information before frames get decoded.\n       See the mfxExtDecodeErrorReport structure for more details.\n    */\n    MFX_EXTBUFF_DECODE_ERROR_REPORT             = MFX_MAKEFOURCC(&#x27;D&#x27;, &#x27;E&#x27;, &#x27;R&#x27;, &#x27;R&#x27;),\n    /*!\n       See the mfxExtColorConversion structure for details.\n    */\n    MFX_EXTBUFF_VPP_COLOR_CONVERSION            = MFX_MAKEFOURCC(&#x27;V&#x27;, &#x27;C&#x27;, &#x27;S&#x27;, &#x27;C&#x27;),\n    /*!\n       This extended buffer configures HDR SEI message. See the mfxExtContentLightLevelInfo structure for details.\n    */\n    MFX_EXTBUFF_CONTENT_LIGHT_LEVEL_INFO        = MFX_MAKEFOURCC(&#x27;L&#x27;, &#x27;L&#x27;, &#x27;I&#x27;, &#x27;S&#x27;),\n    /*!\n       This extended buffer configures HDR SEI message. See the mfxExtMasteringDisplayColourVolume structure for details. If color volume changes\n       per frame, the application can attach this buffer to the mfxFrameData structure for video processing.\n    */\n    MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME = MFX_MAKEFOURCC(&#x27;D&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, &#x27;S&#x27;),\n    /*!\n       This extended buffer configures HDR SEI message. See the mfxExtMasteringDisplayColourVolume structure for details. The application can\n       attach this buffer to the mfxVideoParam structure for the input of video processing if the mastering display color volume changes per\n       sequence. In this case, this buffer should be together with MFX_EXTBUFF_CONTENT_LIGHT_LEVEL_INFO to indicate the light level and mastering\n       color volume of the input of video processing. If color Volume changes per frame instead of per sequence, the application can attach\n       MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME to mfxFrameData for frame based processing.\n    */\n    MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME_IN         = MFX_MAKEFOURCC(&#x27;D&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, &#x27;I&#x27;),\n    /*!\n       This extended buffer configures HDR SEI message. See the mfxExtMasteringDisplayColourVolume structure for details. The application can\n       attach this buffer to the mfxVideoParam structure for the output of video processing if the mastering display color volume changes per\n       sequence. If color volume changes per frame instead of per sequence, the application can attach the buffer with MFX_EXTBUFF_MASTERING_\n       DISPLAY_COLOUR_VOLUME to mfxFrameData for frame based processing.\n    */\n    MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME_OUT        = MFX_MAKEFOURCC(&#x27;D&#x27;, &#x27;C&#x27;, &#x27;V&#x27;, &#x27;O&#x27;),\n    /*!\n       See the mfxExtEncodedUnitsInfo structure for details.\n    */\n    MFX_EXTBUFF_ENCODED_UNITS_INFO              = MFX_MAKEFOURCC(&#x27;E&#x27;, &#x27;N&#x27;, &#x27;U&#x27;, &#x27;I&#x27;),\n    /*!\n       This video processing algorithm identifier is used to enable MCTF via mfxExtVPPDoUse and together with mfxExtVppMctf\n    */\n    MFX_EXTBUFF_VPP_MCTF                        = MFX_MAKEFOURCC(&#x27;M&#x27;, &#x27;C&#x27;, &#x27;T&#x27;, &#x27;F&#x27;),\n    /*!\n       Extends mfxVideoParam structure with VP9 segmentation parameters. See the mfxExtVP9Segmentation structure for details.\n    */\n    MFX_EXTBUFF_VP9_SEGMENTATION                = MFX_MAKEFOURCC(&#x27;9&#x27;, &#x27;S&#x27;, &#x27;E&#x27;, &#x27;G&#x27;),\n    /*!\n       Extends mfxVideoParam structure with parameters for VP9 temporal scalability. See the mfxExtVP9TemporalLayers structure for details.\n    */\n    MFX_EXTBUFF_VP9_TEMPORAL_LAYERS             = MFX_MAKEFOURCC(&#x27;9&#x27;, &#x27;T&#x27;, &#x27;M&#x27;, &#x27;L&#x27;),\n    /*!\n       Extends mfxVideoParam structure with VP9-specific parameters. See the mfxExtVP9Param structure for details.\n    */\n    MFX_EXTBUFF_VP9_PARAM                       = MFX_MAKEFOURCC(&#x27;9&#x27;, &#x27;P&#x27;, &#x27;A&#x27;, &#x27;R&#x27;),\n    /*!\n       See the mfxExtAVCRoundingOffset structure for details.\n    */\n    MFX_EXTBUFF_AVC_ROUNDING_OFFSET             = MFX_MAKEFOURCC(&#x27;R&#x27;,&#x27;N&#x27;,&#x27;D&#x27;,&#x27;O&#x27;),\n    /*!\n       See the mfxExtPartialBitstreamParam structure for details.\n    */\n    MFX_EXTBUFF_PARTIAL_BITSTREAM_PARAM         = MFX_MAKEFOURCC(&#x27;P&#x27;,&#x27;B&#x27;,&#x27;O&#x27;,&#x27;P&#x27;),\n\n    /*!\n       See the mfxExtEncoderIPCMArea structure for details.\n    */\n    MFX_EXTBUFF_ENCODER_IPCM_AREA  = MFX_MAKEFOURCC(&#x27;P&#x27;, &#x27;C&#x27;, &#x27;M&#x27;, &#x27;R&#x27;),\n    /*!\n       See the mfxExtInsertHeaders structure for details.\n    */\n    MFX_EXTBUFF_INSERT_HEADERS  = MFX_MAKEFOURCC(&#x27;S&#x27;, &#x27;P&#x27;, &#x27;R&#x27;, &#x27;E&#x27;),\n\n    /*!\n       See the mfxExtDeviceAffinityMask structure for details.\n    */\n    MFX_EXTBUFF_DEVICE_AFFINITY_MASK = MFX_MAKEFOURCC(&#x27;D&#x27;, &#x27;A&#x27;, &#x27;F&#x27;, &#x27;M&#x27;),\n\n    /*!\n       See the mfxExtInCrops structure for details.\n    */\n    MFX_EXTBUFF_CROPS = MFX_MAKEFOURCC(&#x27;C&#x27;, &#x27;R&#x27;, &#x27;O&#x27;, &#x27;P&#x27;),\n\n    /*!\n        See the mfxExtAV1BitstreamParam structure for more details.\n    */\n    MFX_EXTBUFF_AV1_BITSTREAM_PARAM             = MFX_MAKEFOURCC(&#x27;A&#x27;, &#x27;1&#x27;, &#x27;B&#x27;, &#x27;S&#x27;),\n\n    /*!\n        See the mfxExtAV1ResolutionParam structure for more details.\n    */\n    MFX_EXTBUFF_AV1_RESOLUTION_PARAM            = MFX_MAKEFOURCC(&#x27;A&#x27;, &#x27;1&#x27;, &#x27;R&#x27;, &#x27;S&#x27;),\n\n    /*!\n        See the mfxExtAV1TileParam structure for more details.\n    */\n    MFX_EXTBUFF_AV1_TILE_PARAM                  = MFX_MAKEFOURCC(&#x27;A&#x27;, &#x27;1&#x27;, &#x27;T&#x27;, &#x27;L&#x27;),\n\n    /*!\n        See the mfxExtAV1Segmentation structure for more details.\n    */\n    MFX_EXTBUFF_AV1_SEGMENTATION                = MFX_MAKEFOURCC(&#x27;1&#x27;, &#x27;S&#x27;, &#x27;E&#x27;, &#x27;G&#x27;),\n\n    /*!\n       See the mfxExtAV1FilmGrainParam structure for more details.\n    */\n    MFX_EXTBUFF_AV1_FILM_GRAIN_PARAM = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;1&#x27;,&#x27;F&#x27;,&#x27;G&#x27;),\n\n    /*!\n       See the mfxExtHyperModeParam structure for more details.\n    */\n    MFX_EXTBUFF_HYPER_MODE_PARAM = MFX_MAKEFOURCC(&#x27;H&#x27;, &#x27;Y&#x27;, &#x27;P&#x27;, &#x27;M&#x27;),\n    /*!\n       See the mfxExtTemporalLayers structure for more details.\n    */\n    MFX_EXTBUFF_UNIVERSAL_TEMPORAL_LAYERS = MFX_MAKEFOURCC(&#x27;U&#x27;, &#x27;T&#x27;, &#x27;M&#x27;, &#x27;P&#x27;),\n    /*!\n       This extended buffer defines additional encoding controls for reference list. See the mfxExtRefListCtrl structure for details.\n       The application can attach this buffer to the mfxVideoParam structure for encoding &amp; decoding initialization, or\n       the mfxEncodeCtrl structure for per-frame encoding configuration.\n    */\n    MFX_EXTBUFF_UNIVERSAL_REFLIST_CTRL = MFX_EXTBUFF_AVC_REFLIST_CTRL,\n#ifdef ONEVPL_EXPERIMENTAL    \n    /*!\n       See the mfxExtEncodeStats structure for details.\n    */\n    MFX_EXTBUFF_ENCODESTATS                   = MFX_MAKEFOURCC(&#x27;E&#x27;,&#x27;N&#x27;,&#x27;S&#x27;,&#x27;B&#x27;),\n#endif\n    /*!\n       See the mfxExtVPP3DLut structure for more details.\n    */\n    MFX_EXTBUFF_VPP_3DLUT = MFX_MAKEFOURCC(&#x27;T&#x27;,&#x27;D&#x27;,&#x27;L&#x27;,&#x27;T&#x27;),\n\n    /*!\n       See the mfxExtAllocationHints structure for more details.\n    */\n    MFX_EXTBUFF_ALLOCATION_HINTS = MFX_MAKEFOURCC(&#x27;A&#x27;,&#x27;L&#x27;,&#x27;C&#x27;,&#x27;H&#x27;),\n    \n#ifdef ONEVPL_EXPERIMENTAL\n    /*!\n       See the mfxExtSyncSubmission structure for more details.\n    */\n    MFX_EXTBUFF_SYNCSUBMISSION = MFX_MAKEFOURCC(&#x27;S&#x27;,&#x27;Y&#x27;,&#x27;N&#x27;,&#x27;C&#x27;),\n\n    /*!\n       See the mfxExtVPPPercEncPrefilter structure for details.\n    */\n    MFX_EXTBUFF_VPP_PERC_ENC_PREFILTER        = MFX_MAKEFOURCC(&#x27;V&#x27;,&#x27;P&#x27;,&#x27;E&#x27;,&#x27;F&#x27;),\n    /*!\n       See the mfxExtTuneEncodeQuality structure for details.\n    */\n    MFX_EXTBUFF_TUNE_ENCODE_QUALITY           = MFX_MAKEFOURCC(&#x27;T&#x27;,&#x27;U&#x27;,&#x27;N&#x27;,&#x27;E&#x27;),\n    /*!\n    See the mfxExtSurfaceOpenCLImg2DExportDescription structure for more details.\n    */\n    MFX_EXTBUFF_EXPORT_SHARING_DESC_OCL = MFX_MAKEFOURCC(&#x27;E&#x27;, &#x27;O&#x27;, &#x27;C&#x27;, &#x27;L&#x27;),\n#endif\n};\n\n/* VPP Conf: Do not use certain algorithms  */\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Tells the VPP not to use certain filters in pipeline. See &quot;Configurable VPP filters&quot; table for complete\n   list of configurable filters. The user can attach this structure to the mfxVideoParam structure when initializing video processing.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;  /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DONOTUSE. */\n    mfxU32          NumAlg;  /*!&lt; Number of filters (algorithms) not to use */\n    mfxU32*         AlgList; /*!&lt; Pointer to a list of filters (algorithms) not to use */\n} mfxExtVPPDoNotUse;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   A hint structure that configures the VPP denoise filter algorithm.\n   @deprecated Deprecated in API version 2.5. Use mfxExtVPPDenoise2 instead.\n*/\nMFX_DEPRECATED typedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DENOISE. */\n    mfxU16  DenoiseFactor;  /*!&lt; Indicates the level of noise to remove. Value range of 0 to 100 (inclusive).  */\n} mfxExtVPPDenoise;\nMFX_PACK_END()\n\n/*! The mfxDenoiseMode enumerator specifies the mode of denoise. */\ntypedef enum {\n    MFX_DENOISE_MODE_DEFAULT    = 0,     /*!&lt; Default denoise mode. The library selects the most appropriate denoise mode. */\n    MFX_DENOISE_MODE_VENDOR     = 1000,  /*!&lt; The enumeration to separate common denoise mode above and vendor specific. */\n\n    MFX_DENOISE_MODE_INTEL_HVS_AUTO_BDRATE     = MFX_DENOISE_MODE_VENDOR + 1,  /*!&lt; Indicates auto BD rate improvement in pre-processing before video encoding,\n                                                                                    ignore Strength.*/\n    MFX_DENOISE_MODE_INTEL_HVS_AUTO_SUBJECTIVE = MFX_DENOISE_MODE_VENDOR + 2,  /*!&lt; Indicates auto subjective quality improvement in pre-processing before video encoding,\n                                                                                    ignore Strength.*/\n    MFX_DENOISE_MODE_INTEL_HVS_AUTO_ADJUST     = MFX_DENOISE_MODE_VENDOR + 3,  /*!&lt; Indicates auto adjust subjective quality in post-processing (after decoding) for video playback,\n                                                                                    ignore Strength.*/\n    MFX_DENOISE_MODE_INTEL_HVS_PRE_MANUAL      = MFX_DENOISE_MODE_VENDOR + 4,  /*!&lt; Indicates manual mode for pre-processing before video encoding,\n                                                                                    allow to adjust the denoise strength manually.*/\n    MFX_DENOISE_MODE_INTEL_HVS_POST_MANUAL     = MFX_DENOISE_MODE_VENDOR + 5,  /*!&lt; Indicates manual mode for post-processing for video playback,\n                                                                                    allow to adjust the denoise strength manually.*/\n} mfxDenoiseMode;\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   A hint structure that configures the VPP denoise filter algorithm.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DENOISE2. */\n    mfxDenoiseMode  Mode;   /*!&lt; Indicates the mode of denoise. mfxDenoiseMode enumerator.  */\n    mfxU16  Strength;       /*!&lt; Denoise strength in manual mode. Value of 0-100 (inclusive) indicates the strength of denoise.\n                                 The strength of denoise controls degree of possible changes of pixel values; the bigger the strength\n                                 the larger the change is.  */\n    mfxU16  reserved[15];\n} mfxExtVPPDenoise2;\nMFX_PACK_END()\n\n/*! The mfx3DLutChannelMapping enumerator specifies the channel mapping of 3DLUT. */\ntypedef enum {\n    MFX_3DLUT_CHANNEL_MAPPING_DEFAULT            = 0,   /*!&lt; Default 3DLUT channel mapping. The library selects the most appropriate 3DLUT channel mapping. */\n    MFX_3DLUT_CHANNEL_MAPPING_RGB_RGB            = 1,   /*!&lt; 3DLUT RGB channels map to RGB channels. */\n    MFX_3DLUT_CHANNEL_MAPPING_YUV_RGB            = 2,   /*!&lt; 3DLUT YUV channels map to RGB channels. */\n    MFX_3DLUT_CHANNEL_MAPPING_VUY_RGB            = 3,   /*!&lt; 3DLUT VUY channels map to RGB channels. */\n} mfx3DLutChannelMapping;\n\n/*! The mfx3DLutMemoryLayout enumerator specifies the memory layout of 3DLUT. */\ntypedef enum {\n    MFX_3DLUT_MEMORY_LAYOUT_DEFAULT                        = 0,          /*!&lt; Default 3DLUT memory layout. The library selects the most appropriate 3DLUT memory layout.*/\n\n    MFX_3DLUT_MEMORY_LAYOUT_VENDOR                         = 0x1000,     /*!&lt; The enumeration to separate default above and vendor specific.*/\n    /*!\n       Intel specific memory layout. The enumerator indicates the attributes and memory layout of 3DLUT.\n       3DLUT size is 17(the number of elements per dimension), 4 channels(3 valid channels, 1 channel is reserved), every channel must be 16-bit unsigned integer.\n       3DLUT contains 17x17x32 entries with holes that are not filled. Take RGB as example, the nodes RxGx17 to RxGx31 are not filled, are &quot;don&#x27;t care&quot; bits, and not accessed for the 17x17x17 nodes.\n    */\n    MFX_3DLUT_MEMORY_LAYOUT_INTEL_17LUT                    = MFX_3DLUT_MEMORY_LAYOUT_VENDOR + 1,\n    /*!\n       Intel specific memory layout. The enumerator indicates the attributes and memory layout of 3DLUT.\n       3DLUT size is 33(the number of elements per dimension), 4 channels(3 valid channels, 1 channel is reserved), every channel must be 16-bit unsigned integer.\n       3DLUT contains 33x33x64 entries with holes that are not filled. Take RGB as example, the nodes RxGx33 to RxGx63 are not filled, are &quot;don&#x27;t care&quot; bits, and not accessed for the 33x33x33 nodes.\n    */\n    MFX_3DLUT_MEMORY_LAYOUT_INTEL_33LUT                    = MFX_3DLUT_MEMORY_LAYOUT_VENDOR + 2,\n    /*!\n       Intel specific memory layout. The enumerator indicates the attributes and memory layout of 3DLUT.\n       3DLUT size is 65(the number of elements per dimension), 4 channels(3 valid channels, 1 channel is reserved), every channel must be 16-bit unsigned integer.\n       3DLUT contains 65x65x128 entries with holes that are not filled. Take RGB as example, the nodes RxGx65 to RxGx127 are not filled, are &quot;don&#x27;t care&quot; bits, and not accessed for the 65x65x65 nodes.\n    */\n    MFX_3DLUT_MEMORY_LAYOUT_INTEL_65LUT                    = MFX_3DLUT_MEMORY_LAYOUT_VENDOR + 3,\n} mfx3DLutMemoryLayout;\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n    A hint structure that configures the data channel.\n*/\ntypedef struct {\n    mfxDataType  DataType;                /*!&lt; Data type, mfxDataType enumerator.*/\n    mfxU32       Size;                    /*!&lt; Size of Look up table, the number of elements per dimension.*/\n    union\n    {\n        mfxU8*     Data;                  /*!&lt; The pointer to 3DLUT data, 8 bit unsigned integer.*/\n        mfxU16*    Data16;                /*!&lt; The pointer to 3DLUT data, 16 bit unsigned integer.*/\n    };\n    mfxU32       reserved[4];             /*!&lt; Reserved for future extension.*/\n} mfxChannel;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n    A hint structure that configures 3DLUT system buffer.\n*/\ntypedef struct {\n    mfxChannel           Channel[3];        /*!&lt; 3 Channels, can be RGB or YUV, mfxChannel structure.*/\n    mfxU32               reserved[8];       /*!&lt; Reserved for future extension.*/\n} mfx3DLutSystemBuffer;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n    A hint structure that configures 3DLUT video buffer.\n*/\ntypedef struct {\n    mfxDataType                DataType;       /*!&lt; Data type, mfxDataType enumerator.*/\n    mfx3DLutMemoryLayout       MemLayout;      /*!&lt; Indicates 3DLUT memory layout. mfx3DLutMemoryLayout enumerator.*/\n    mfxMemId                   MemId;          /*!&lt; Memory ID for holding the lookup table data. One MemID is dedicated for one instance of VPP.*/\n    mfxU32                     reserved[8];    /*!&lt; Reserved for future extension.*/\n} mfx3DLutVideoBuffer;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n    A hint structure that configures 3DLUT filter.\n*/\ntypedef struct {\n    mfxExtBuffer             Header;           /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_3DLUT..*/\n    mfx3DLutChannelMapping   ChannelMapping;   /*!&lt; Indicates 3DLUT channel mapping. mfx3DLutChannelMapping enumerator.*/\n    mfxResourceType          BufferType;       /*!&lt; Indicates 3DLUT buffer type. mfxResourceType enumerator, can be system memory, VA surface, DX11 texture/buffer etc.*/\n    union\n    {\n        mfx3DLutSystemBuffer SystemBuffer;     /*!&lt; The 3DLUT system buffer. mfx3DLutSystemBuffer structure describes the details of the buffer.*/\n        mfx3DLutVideoBuffer  VideoBuffer;      /*!&lt; The 3DLUT video buffer. mfx3DLutVideoBuffer describes the details of 3DLUT video buffer.*/\n    };\n    mfxU32                   reserved[4];      /*!&lt; Reserved for future extension.*/\n} mfxExtVPP3DLut;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   A hint structure that configures the VPP detail/edge enhancement filter algorithm.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DETAIL. */\n    mfxU16  DetailFactor;   /*!&lt; Indicates the level of details to be enhanced. Value range of 0 to 100 (inclusive).  */\n} mfxExtVPPDetail;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   A hint structure that configures the VPP ProcAmp filter algorithm.\n   The structure parameters will be clipped to their corresponding range and rounded by their corresponding increment.\n   @note There are no default values for fields in this structure, all settings must be explicitly specified every time this\n         buffer is submitted for processing.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_PROCAMP. */\n    mfxF64   Brightness;    /*!&lt; The brightness parameter is in the range of -100.0F to 100.0F, in increments of 0.1F.\n                                 Setting this field to 0.0F will disable brightness adjustment. */\n    mfxF64   Contrast;      /*!&lt; The contrast parameter in the range of 0.0F to 10.0F, in increments of 0.01F, is used for manual\n                                 contrast adjustment. Setting this field to 1.0F will disable contrast adjustment. If the parameter\n                                 is negative, contrast will be adjusted automatically. */\n    mfxF64   Hue;           /*!&lt; The hue parameter is in the range of -180F to 180F, in increments of 0.1F. Setting this field to 0.0F\n                                 will disable hue adjustment. */\n    mfxF64   Saturation;    /*!&lt; The saturation parameter is in the range of 0.0F to 10.0F, in increments of 0.01F.\n                                 Setting this field to 1.0F will disable saturation adjustment. */\n} mfxExtVPPProcAmp;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Returns statistics collected during encoding.\n*/\ntypedef struct {\n    mfxU32  reserved[16];\n    mfxU32  NumFrame;       /*!&lt; Number of encoded frames. */\n    mfxU64  NumBit;         /*!&lt; Number of bits for all encoded frames. */\n    mfxU32  NumCachedFrame; /*!&lt; Number of internally cached frames. */\n} mfxEncodeStat;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Returns statistics collected during decoding.\n*/\ntypedef struct {\n    mfxU32  reserved[16];\n    mfxU32  NumFrame;        /*!&lt; Number of total decoded frames. */\n    mfxU32  NumSkippedFrame; /*!&lt; Number of skipped frames. */\n    mfxU32  NumError;        /*!&lt; Number of errors recovered. */\n    mfxU32  NumCachedFrame;  /*!&lt; Number of internally cached frames. */\n} mfxDecodeStat;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Returns statistics collected during video processing.\n*/\ntypedef struct {\n    mfxU32  reserved[16];\n    mfxU32  NumFrame;       /*!&lt; Total number of frames processed. */\n    mfxU32  NumCachedFrame; /*!&lt; Number of internally cached frames. */\n} mfxVPPStat;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Returns auxiliary data generated by the video processing pipeline.\n   The encoding process may use the auxiliary data by attaching this structure to the mfxEncodeCtrl structure.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_AUXDATA. */\n\n    union{\n        struct{\n            MFX_DEPRECATED mfxU32  SpatialComplexity; /* Deprecated */\n            MFX_DEPRECATED mfxU32  TemporalComplexity; /* Deprecated */\n        };\n        struct{\n            /*!\n               Detected picture structure - top field first, bottom field first, progressive or unknown if video processor cannot\n               detect picture structure. See the PicStruct enumerator for definition of these values.\n\n            */\n            mfxU16  PicStruct;\n            mfxU16  reserved[3];\n        };\n    };\n    MFX_DEPRECATED  mfxU16          SceneChangeRate; /* Deprecated */\n    mfxU16          RepeatedFrame;   /*!&lt; The flag signalizes that the frame is identical to the previous one. */\n} mfxExtVppAuxData;\nMFX_PACK_END()\n\n/*! The PayloadCtrlFlags enumerator itemizes additional payload properties. */\nenum {\n    MFX_PAYLOAD_CTRL_SUFFIX = 0x00000001 /*!&lt; Insert this payload into HEVC Suffix SEI NAL-unit. */\n};\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Describes user data payload in MPEG-2 or SEI message payload in H.264.\n\n   For encoding, these payloads can be\n   inserted into the bitstream. The payload buffer must contain a valid formatted payload.\n\n   For H.264, this is the sei_message() as\n   specified in the section 7.3.2.3.1 &#x27;Supplemental enhancement information message syntax&#x27; of the ISO/IEC 14496-10 specification.\n\n   For MPEG-2,\n   this is the section 6.2.2.2.2 &#x27;User data&#x27; of the ISO/IEC 13818-2 specification, excluding the user data start_code.\n\n   For decoding,\n   these payloads can be retrieved as the decoder parses the bitstream and caches them in an internal buffer.\n\n   @internal\n   +-----------+-------------------------------------------+\n   | **Codec** | **Supported Types**                       |\n   +===========+===========================================+\n   | MPEG2     | 0x01B2 //User Data                        |\n   +-----------+-------------------------------------------+\n   | AVC       | 02 //pan_scan_rect                        |\n   |           | 03 //filler_payload                       |\n   |           | 04 //user_data_registered_itu_t_t35       |\n   |           | 05 //user_data_unregistered               |\n   |           | 06 //recovery_point                       |\n   |           | 09 //scene_info                           |\n   |           | 13 //full_frame_freeze                    |\n   |           | 14 //full_frame_freeze_release            |\n   |           | 15 //full_frame_snapshot                  |\n   |           | 16 //progressive_refinement_segment_start |\n   |           | 17 //progressive_refinement_segment_end   |\n   |           | 19 //film_grain_characteristics           |\n   |           | 20 //deblocking_filter_display_preference |\n   |           | 21 //stereo_video_info                    |\n   |           | 45 //frame_packing_arrangement            |\n   +-----------+-------------------------------------------+\n   | HEVC      | All                                       |\n   +-----------+-------------------------------------------+\n   @endinternal\n\n*/\ntypedef struct {\n    mfxU32      CtrlFlags;  /*!&lt; Additional payload properties. See the PayloadCtrlFlags enumerator for details. */\n    mfxU32      reserved[3];\n    mfxU8       *Data;      /*!&lt; Pointer to the actual payload data buffer. */\n    mfxU32      NumBit;     /*!&lt; Number of bits in the payload data */\n    mfxU16      Type;       /*!&lt; MPEG-2 user data start code or H.264 SEI message type. */\n    mfxU16      BufSize;    /*!&lt; Payload buffer size in bytes. */\n} mfxPayload;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Contains parameters for per-frame based encoding control.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; This extension buffer doesn&#x27;t have assigned buffer ID. Ignored. */\n    mfxU32  reserved[4];\n    mfxU16  reserved1;\n    /*!\n       Type of NAL unit that contains encoding frame. All supported values are defined by MfxNalUnitType enumerator. Other values\n       defined in ITU-T H.265 specification are not supported.\n\n       The encoder uses this field only if application sets mfxExtCodingOption3::EnableNalUnitType option to ON during encoder initialization.\n\n       @note Only encoded order is supported. If application specifies this value in display order or uses value inappropriate for current frame or\n             invalid value, then the encoder silently ignores it.\n    */\n    mfxU16  MfxNalUnitType;\n    mfxU16  SkipFrame; /*!&lt; Indicates that current frame should be skipped or the number of missed frames before the current frame. See mfxExtCodingOption2::SkipFrame for details. */\n\n    mfxU16  QP;        /*!&lt; If nonzero, this value overwrites the global QP value for the current frame in the constant QP mode. */\n\n    /*!\n       Encoding frame type. See the FrameType enumerator for details. If the encoder works in the encoded order, the application must\n       specify the frame type. If the encoder works in the display order, only key frames are enforceable.\n    */\n    mfxU16  FrameType;\n    mfxU16  NumExtParam; /*!&lt; Number of extra control buffers. */\n    mfxU16  NumPayload;  /*!&lt; Number of payload records to insert into the bitstream. */\n    mfxU16  reserved2;\n\n    /*!\n       Pointer to an array of pointers to external buffers that provide additional information or control to the encoder for this\n       frame or field pair. A typical use is to pass the VPP auxiliary data generated by the video processing pipeline to the encoder.\n       See the ExtendedBufferID for the list of extended buffers.\n    */\n    mfxExtBuffer    **ExtParam;\n    /*!\n       Pointer to an array of pointers to user data (MPEG-2) or SEI messages (H.264) for insertion into the bitstream. For field pictures,\n       odd payloads are associated with the first field and even payloads are associated with the second field. See the mfxPayload structure\n       for payload definitions.\n    */\n    mfxPayload      **Payload;\n} mfxEncodeCtrl;\nMFX_PACK_END()\n\n/*! The ExtMemBufferType enumerator specifies the buffer type. It is a bit-ORed value of the following. */\nenum {\n    MFX_MEMTYPE_PERSISTENT_MEMORY   =0x0002 /*!&lt; Memory page for persistent use. */\n};\n\n/* Frame Memory Types */\n#define MFX_MEMTYPE_BASE(x) (0x90ff &amp; (x))\n\n/*!\n   The ExtMemFrameType enumerator specifies the memory type of frame. It is a bit-ORed value of the following.\n    \\verbatim embed:rst\n    For information on working with video memory surfaces, see the :ref:`Working with Hardware Acceleration section&lt;hw-acceleration&gt;`.\n    \\endverbatim\n*/\nenum {\n    MFX_MEMTYPE_DXVA2_DECODER_TARGET       =0x0010, /*!&lt; Frames are in video memory and belong to video decoder render targets. */\n    MFX_MEMTYPE_DXVA2_PROCESSOR_TARGET     =0x0020, /*!&lt; Frames are in video memory and belong to video processor render targets. */\n    MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET   = MFX_MEMTYPE_DXVA2_DECODER_TARGET,  /*!&lt; Frames are in video memory and belong to video decoder render targets. */\n    MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET = MFX_MEMTYPE_DXVA2_PROCESSOR_TARGET,/*!&lt; Frames are in video memory and belong to video processor render targets. */\n    MFX_MEMTYPE_SYSTEM_MEMORY              =0x0040, /*!&lt; The frames are in system memory. */\n    MFX_MEMTYPE_RESERVED1                  =0x0080, /*!&lt;  */\n\n    MFX_MEMTYPE_FROM_ENCODE     = 0x0100, /*!&lt; Allocation request comes from an ENCODE function */\n    MFX_MEMTYPE_FROM_DECODE     = 0x0200, /*!&lt; Allocation request comes from a DECODE function */\n    MFX_MEMTYPE_FROM_VPPIN      = 0x0400, /*!&lt; Allocation request comes from a VPP function for input frame allocation */\n    MFX_MEMTYPE_FROM_VPPOUT     = 0x0800, /*!&lt; Allocation request comes from a VPP function for output frame allocation */\n    MFX_MEMTYPE_FROM_ENC        = 0x2000, /*!&lt; Allocation request comes from an ENC function */\n    MFX_MEMTYPE_FROM_PAK        = 0x4000, /* Reserved */\n\n    MFX_MEMTYPE_INTERNAL_FRAME  = 0x0001, /*!&lt; Allocation request for internal frames */\n    MFX_MEMTYPE_EXTERNAL_FRAME  = 0x0002, /*!&lt; Allocation request for I/O frames */\n    MFX_MEMTYPE_EXPORT_FRAME    = 0x0008, /*!&lt; Application requests frame handle export to some associated object. For Linux frame handle can be\n                                               considered to be exported to DRM Prime FD, DRM FLink or DRM FrameBuffer Handle. Specifics of export\n                                               types and export procedure depends on external frame allocator implementation */\n    MFX_MEMTYPE_SHARED_RESOURCE = MFX_MEMTYPE_EXPORT_FRAME, /*!&lt; For DX11 allocation use shared resource bind flag. */\n    MFX_MEMTYPE_VIDEO_MEMORY_ENCODER_TARGET = 0x1000 /*!&lt; Frames are in video memory and belong to video encoder render targets. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Describes multiple frame allocations when initializing encoders, decoders, and video preprocessors.\n   A range specifies the number of video frames. Applications are free to allocate additional frames. In all cases, the minimum number of\n   frames must be at least NumFrameMin or the called API function will return an error.\n*/\ntypedef struct {\n    union {\n        mfxU32  AllocId;       /*!&lt; Unique (within the session) ID of component requested the allocation. */\n        mfxU32  reserved[1];\n    };\n    mfxU32  reserved3[3];\n    mfxFrameInfo    Info;      /*!&lt; Describes the properties of allocated frames. */\n    mfxU16  Type;              /*!&lt; Allocated memory type. See the ExtMemFrameType enumerator for details. */\n    mfxU16  NumFrameMin;       /*!&lt; Minimum number of allocated frames. */\n    mfxU16  NumFrameSuggested; /*!&lt; Suggested number of allocated frames. */\n    mfxU16  reserved2;\n} mfxFrameAllocRequest;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Describes the response to multiple frame allocations. The calling API function returns the number of\n   video frames actually allocated and pointers to their memory IDs.\n*/\ntypedef struct {\n    mfxU32      AllocId;        /*!&lt; Unique (within the session) ID of component requested the allocation. */\n    mfxU32      reserved[3];\n    mfxMemId    *mids;          /*!&lt; Pointer to the array of the returned memory IDs. The application allocates or frees this array. */\n    mfxU16      NumFrameActual; /*!&lt; Number of frames actually allocated. */\n    mfxU16      reserved2;\n} mfxFrameAllocResponse;\nMFX_PACK_END()\n\n/*! The FrameType enumerator itemizes frame types. Use bit-ORed values to specify all that apply. */\nenum {\n    MFX_FRAMETYPE_UNKNOWN       =0x0000, /*!&lt; Frame type is unspecified. */\n\n    MFX_FRAMETYPE_I             =0x0001, /*!&lt; This frame or the first field is encoded as an I-frame/field. */\n    MFX_FRAMETYPE_P             =0x0002, /*!&lt; This frame or the first field is encoded as an P-frame/field. */\n    MFX_FRAMETYPE_B             =0x0004, /*!&lt; This frame or the first field is encoded as an B-frame/field. */\n    MFX_FRAMETYPE_S             =0x0008, /*!&lt; This frame or the first field is either an SI- or SP-frame/field. */\n\n    MFX_FRAMETYPE_REF           =0x0040, /*!&lt; This frame or the first field is encoded as a reference. */\n    MFX_FRAMETYPE_IDR           =0x0080, /*!&lt; This frame or the first field is encoded as an IDR. */\n\n    MFX_FRAMETYPE_xI            =0x0100, /*!&lt; The second field is encoded as an I-field. */\n    MFX_FRAMETYPE_xP            =0x0200, /*!&lt; The second field is encoded as an P-field. */\n    MFX_FRAMETYPE_xB            =0x0400, /*!&lt; The second field is encoded as an S-field. */\n    MFX_FRAMETYPE_xS            =0x0800, /*!&lt; The second field is an SI- or SP-field. */\n\n    MFX_FRAMETYPE_xREF          =0x4000, /*!&lt; The second field is encoded as a reference. */\n    MFX_FRAMETYPE_xIDR          =0x8000  /*!&lt; The second field is encoded as an IDR. */\n};\n\n/*!\n   The MfxNalUnitType enumerator specifies NAL unit types supported by the HEVC encoder.\n*/\nenum {\n    MFX_HEVC_NALU_TYPE_UNKNOWN    =      0, /*!&lt; The encoder will decide what NAL unit type to use. */\n    MFX_HEVC_NALU_TYPE_TRAIL_N    = ( 0+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_TRAIL_R    = ( 1+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_RADL_N     = ( 6+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_RADL_R     = ( 7+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_RASL_N     = ( 8+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_RASL_R     = ( 9+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_IDR_W_RADL = (19+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_IDR_N_LP   = (20+1), /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n    MFX_HEVC_NALU_TYPE_CRA_NUT    = (21+1)  /*!&lt; See Table 7-1 of the ITU-T H.265 specification for the definition of these type. */\n};\n\n/*! The mfxSkipMode enumerator describes the decoder skip-mode options. */\ntypedef enum {\n    MFX_SKIPMODE_NOSKIP=0, /*! Do not skip any frames. */\n    MFX_SKIPMODE_MORE=1,   /*! Skip more frames. */\n    MFX_SKIPMODE_LESS=2    /*! Skip less frames. */\n} mfxSkipMode;\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Attach this structure as part of the extended buffers to configure the encoder during MFXVideoENCODE_Init. The sequence or picture\n   parameters specified by this structure overwrite any parameters specified by the structure or any other attached extended buffers attached.\n\n   For H.264, SPSBuffer and PPSBuffer must point to valid bitstreams that contain the sequence parameter set and picture parameter set,\n   respectively.\n\n   For MPEG-2, SPSBuffer must point to valid bitstreams that contain the sequence header followed by any sequence header extension. The PPSBuffer pointer is ignored.\n\n   The encoder imports parameters from these buffers. If the encoder does not support the specified parameters,\n   the encoder does not initialize and returns the status code MFX_ERR_INCOMPATIBLE_VIDEO_PARAM.\n\n   Check with the MFXVideoENCODE_Query function for the support of this multiple segment encoding feature. If this feature is not supported,\n   the query returns MFX_ERR_UNSUPPORTED.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;     /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CODING_OPTION_SPSPPS. */\n    mfxU8           *SPSBuffer; /*!&lt; Pointer to a valid bitstream that contains the SPS (sequence parameter set for H.264 or sequence header\n                                     followed by any sequence header extension for MPEG-2) buffer. Can be NULL to skip specifying the SPS. */\n    mfxU8           *PPSBuffer; /*!&lt; Pointer to a valid bitstream that contains the PPS (picture parameter set for H.264 or picture header\n                                     followed by any picture header extension for MPEG-2) buffer. Can be NULL to skip specifying the PPS. */\n    mfxU16          SPSBufSize; /*!&lt; Size of the SPS in bytes. */\n    mfxU16          PPSBufSize; /*!&lt; Size of the PPS in bytes. */\n    mfxU16          SPSId;      /*!&lt; SPS identifier. The value is reserved and must be zero. */\n    mfxU16          PPSId;      /*!&lt; PPS identifier. The value is reserved and must be zero. */\n} mfxExtCodingOptionSPSPPS;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Attach this structure as part of the extended buffers to configure the encoder during MFXVideoENCODE_Init. The sequence or picture\n   parameters specified by this structure overwrite any parameters specified by the structure or any other attached extended buffers attached.\n\n   If the encoder does not support the specified parameters, the encoder does not initialize and returns the status code\n   MFX_ERR_INCOMPATIBLE_VIDEO_PARAM.\n\n   Check with the MFXVideoENCODE_Query function for the support of this multiple segment encoding feature. If this feature is not supported,\n   the query returns MFX_ERR_UNSUPPORTED.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CODING_OPTION_VPS. */\n\n    union {\n        mfxU8       *VPSBuffer; /*!&lt; Pointer to a valid bitstream that contains the VPS (video parameter set for HEVC) buffer. */\n        mfxU64      reserved1;\n    };\n    mfxU16          VPSBufSize; /*!&lt; Size of the VPS in bytes. */\n    mfxU16          VPSId;      /*!&lt; VPS identifier; the value is reserved and must be zero. */\n\n    mfxU16          reserved[6];\n} mfxExtCodingOptionVPS;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Defines the video signal information.\n\n   For H.264, see Annex E of the ISO/IEC 14496-10 specification for the definition of these parameters.\n\n   For MPEG-2, see section 6.3.6 of the ITU* H.262 specification for the definition of these parameters. The field VideoFullRange is ignored.\n\n   For VC-1, see section 6.1.14.5 of the SMPTE* 421M specification. The fields VideoFormat and VideoFullRange are ignored.\n\n   @note If ColourDescriptionPresent is zero, the color description information (including ColourPrimaries, TransferCharacteristics,\n         and MatrixCoefficients) does not present in the bitstream.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VIDEO_SIGNAL_INFO. */\n    mfxU16          VideoFormat;\n    mfxU16          VideoFullRange;\n    mfxU16          ColourDescriptionPresent;\n    mfxU16          ColourPrimaries;\n    mfxU16          TransferCharacteristics;\n    mfxU16          MatrixCoefficients;\n} mfxExtVideoSignalInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Tells the VPP to include certain filters in the pipeline.\n\n   Each filter may be included in the pipeline in one of two different ways:\n\n   @li Adding a filter ID to this structure. In this method,\n   the default filter parameters are used.\n\n   @li Attaching a filter configuration structure directly to the mfxVideoParam structure.\n   In this method, adding filter ID to the mfxExtVPPDoUse structure is optional.\n\n   See Table &quot;Configurable VPP filters&quot; for complete list of\n   configurable filters, their IDs, and configuration structures.\n\n   The user can attach this structure to the mfxVideoParam structure when initializing video processing.\n\n   @note MFX_EXTBUFF_VPP_COMPOSITE cannot be enabled using mfxExtVPPDoUse because default parameters are undefined for this filter.\n         The application must attach the appropriate filter configuration structure directly to the mfxVideoParam structure to enable it.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DOUSE. */\n    mfxU32          NumAlg;   /*!&lt; Number of filters (algorithms) to use */\n    mfxU32          *AlgList; /*!&lt; Pointer to a list of filters (algorithms) to use */\n} mfxExtVPPDoUse;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures reference frame options for the H.264 encoder.\n    \\verbatim embed:rst\n    See the :ref:`Reference List Selection &lt;sec_reference_list_selection&gt;` and :ref:`Long Term Reference Frame &lt;sec_long_term_reference_frame&gt;` sections for more details.\n    \\endverbatim\n\n\n   @note Not all implementations of the encoder support LongTermIdx and ApplyLongTermIdx fields in this structure. The application must use\n         query mode 1 to determine if such functionality is supported. To do this, the application must attach this extended buffer to the\n         mfxVideoParam structure and call the MFXVideoENCODE_Query function. If the function returns MFX_ERR_NONE and these fields were set to one,\n         then the functionality is supported. If the function fails or sets fields to zero, then the functionality is not supported.\n\n*/\ntypedef struct {\n    mfxExtBuffer    Header;            /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AVC_REFLIST_CTRL. */\n    mfxU16          NumRefIdxL0Active; /*!&lt; Specify the number of reference frames in the active reference list L0. This number should be less or equal to the NumRefFrame parameter from encoding initialization. */\n    mfxU16          NumRefIdxL1Active; /*!&lt; Specify the number of reference frames in the active reference list L1. This number should be less or equal to the NumRefFrame parameter from encoding initialization. */\n\n    struct {\n        /*! @{\n        @name Reference Lists\n        The following structure members are used by the reference lists contained in the parent structure. */\n        mfxU32      FrameOrder;  /*!&lt; Together FrameOrder and PicStruct fields are used to identify reference picture. Use FrameOrder = MFX_FRAMEORDER_UNKNOWN to mark unused entry. */\n        mfxU16      PicStruct;   /*!&lt; Together FrameOrder and PicStruct fields are used to identify reference picture. Use FrameOrder = MFX_FRAMEORDER_UNKNOWN to mark unused entry. */\n        mfxU16      ViewId;      /*!&lt; Reserved and must be zero. */\n        mfxU16      LongTermIdx; /*!&lt; Index that should be used by the encoder to mark long-term reference frame. */\n        mfxU16      reserved[3]; /*!&lt; Reserved */\n        /*! @} */\n    } PreferredRefList[32], /*!&lt; Reference list that specifies the list of frames that should be used to predict the current frame. */\n    RejectedRefList[16], /*!&lt; Reference list that specifies the list of frames that should not be used for prediction. */\n    LongTermRefList[16]; /*!&lt; Reference list that specifies the list of frames that should be marked as long-term reference frame. */\n\n    mfxU16      ApplyLongTermIdx;/*!&lt; If it is equal to zero, the encoder assigns long-term index according to internal algorithm.\n                                      If it is equal to one, the encoder uses LongTermIdx value as long-term index. */\n    mfxU16      reserved[15];\n} mfxExtAVCRefListCtrl;\nMFX_PACK_END()\n\n/*! The FrcAlgm enumerator itemizes frame rate conversion algorithms. See description of mfxExtVPPFrameRateConversion structure for more details. */\nenum {\n    MFX_FRCALGM_PRESERVE_TIMESTAMP    = 0x0001, /*!&lt; Frame dropping/repetition based frame rate conversion algorithm with preserved original\n                                                     time stamps. Any inserted frames will carry MFX_TIMESTAMP_UNKNOWN. */\n    MFX_FRCALGM_DISTRIBUTED_TIMESTAMP = 0x0002, /*!&lt; Frame dropping/repetition based frame rate conversion algorithm with distributed time stamps.\n                                                     The algorithm distributes output time stamps evenly according to the output frame rate. */\n    MFX_FRCALGM_FRAME_INTERPOLATION   = 0x0004  /*!&lt; Frame rate conversion algorithm based on frame interpolation. This flag may be combined with\n                                                     MFX_FRCALGM_PRESERVE_TIMESTAMP or MFX_FRCALGM_DISTRIBUTED_TIMESTAMP flags. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP frame rate conversion filter. The user can attach this structure to the\n   mfxVideoParam structure when initializing, resetting, or querying capability of video processing.\n\n   On some platforms the advanced frame rate conversion algorithm (the algorithm based on frame interpolation) is not supported. To query its support,\n   the application should add the MFX_FRCALGM_FRAME_INTERPOLATION flag to the Algorithm value in the mfxExtVPPFrameRateConversion structure, attach it to the\n   structure, and call the MFXVideoVPP_Query function. If the filter is supported, the function returns a MFX_ERR_NONE status and copies the content of the\n   input structure to the output structure. If an advanced filter is not supported, then a simple filter will be used and the function returns\n   MFX_WRN_INCOMPATIBLE_VIDEO_PARAM, copies content of the input structure to the output structure, and corrects the Algorithm value.\n\n   If advanced FRC algorithm is not supported, both MFXVideoVPP_Init and MFXVideoVPP_Reset functions return the MFX_WRN_INCOMPATIBLE_VIDEO_PARAM status.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_FRAME_RATE_CONVERSION. */\n    mfxU16      Algorithm;  /*!&lt; See the FrcAlgm enumerator for a list of frame rate conversion algorithms. */\n    mfxU16      reserved;\n    mfxU32      reserved2[15];\n} mfxExtVPPFrameRateConversion;\nMFX_PACK_END()\n\n/*! The ImageStabMode enumerator itemizes image stabilization modes. See description of mfxExtVPPImageStab structure for more details. */\nenum {\n    MFX_IMAGESTAB_MODE_UPSCALE = 0x0001, /*!&lt; Upscale mode. */\n    MFX_IMAGESTAB_MODE_BOXING  = 0x0002  /*!&lt; Boxing mode. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   A hint structure that configures the VPP image stabilization filter.\n\n   On some platforms this filter is not supported. To query its support, the application should use the same approach that it uses\n   to configure VPP filters: adding the filter ID to the mfxExtVPPDoUse structure or by attaching the mfxExtVPPImageStab structure\n   directly to the mfxVideoParam structure and calling the MFXVideoVPP_Query function.\n\n   If this filter is supported, the function returns a MFX_ERR_NONE\n   status and copies the content of the input structure to the output structure. If the filter is not supported, the function returns MFX_WRN_FILTER_SKIPPED, removes the\n   filter from the mfxExtVPPDoUse structure, and zeroes the mfxExtVPPImageStab structure.\n\n   If the image stabilization filter is not supported, both MFXVideoVPP_Init and MFXVideoVPP_Reset functions return a MFX_WRN_FILTER_SKIPPED status.\n\n   The application can retrieve the list of active filters by attaching the mfxExtVPPDoUse structure to the mfxVideoParam structure and calling the\n   MFXVideoVPP_GetVideoParam function. The application must allocate enough memory for the filter list.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_IMAGE_STABILIZATION. */\n    mfxU16  Mode;           /*!&lt; Image stabilization mode. See ImageStabMode enumerator for values. */\n    mfxU16  reserved[11];\n} mfxExtVPPImageStab;\nMFX_PACK_END()\n\n\n/*!\n    The InsertHDRPayload enumerator itemizes HDR payloads insertion rules in the encoder,\n    and indicates if there is valid HDR SEI message in the clip in the decoder.\n*/\nenum {\n    MFX_PAYLOAD_OFF = 0, /*!&lt; Do not insert payload when encoding;\n                              Clip does not have valid HDE SEI when decoding. */\n    MFX_PAYLOAD_IDR = 1  /*!&lt; Insert payload on IDR frames when encoding;\n                              Clip has valid HDE SEI when decoding. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Handle the HDR SEI message.\n\n   During encoding: If the application attaches this structure to the mfxEncodeCtrl structure at runtime,\n   the encoder inserts the HDR SEI message for the current frame and ignores InsertPayloadToggle. If the application attaches this\n   structure to the mfxVideoParam structure during initialization or reset, the encoder inserts the HDR SEI message based on InsertPayloadToggle.\n\n   During video processing: If the application attaches this structure for video processing, InsertPayloadToggle will be ignored.\n   And DisplayPrimariesX[3], DisplayPrimariesY[3] specify the color primaries where 0,1,2 specifies Red, Green, Blue respectively.\n\n   During decoding: If the application attaches this structure to the mfxFrameSurface1 structure at runtime\n   which will seed to the MFXVideoDECODE_DecodeFrameAsync() as surface_work parameter,\n   the decoder will parse the HDR SEI message if the bitstream include HDR SEI message per frame.\n   The parsed HDR SEI will be attached to the ExtendBuffer of surface_out parameter of MFXVideoDECODE_DecodeFrameAsync()\n   with flag `InsertPayloadToggle` to indicate if there is valid HDR SEI message in the clip.\n   `InsertPayloadToggle` will be set to `MFX_PAYLOAD_IDR` if oneAPI Video Processing Library (oneVPL) gets valid HDR SEI, otherwise it will be set \n   to `MFX_PAYLOAD_OFF`.\n   This function is support for HEVC only now.\n\n   Encoding or Decoding, Field semantics are defined in ITU-T* H.265 Annex D, AV1 6.7.4 Metadata OBU semantics.\n\n   Video processing, `DisplayPrimariesX[3]` and `WhitePointX` are in increments of 0.00002, in the range of [5, 37000]. `DisplayPrimariesY[3]`\n   and `WhitePointY` are in increments of 0.00002, in the range of [5, 42000]. `MaxDisplayMasteringLuminance` is in units of 1 candela per square meter.\n   `MinDisplayMasteringLuminance` is in units of 0.0001 candela per square meter.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME. */\n    mfxU16      reserved[15];\n\n    mfxU16 InsertPayloadToggle;  /*!&lt; InsertHDRPayload enumerator value. */\n    mfxU16 DisplayPrimariesX[3]; /*!&lt; Color primaries for a video source. Consist of RGB x coordinates and\n                                       define how to convert colors from RGB color space to CIE XYZ color space. */\n    mfxU16 DisplayPrimariesY[3]; /*!&lt; Color primaries for a video source. Consists of RGB y coordinates and\n                                       defines how to convert colors from RGB color space to CIE XYZ color space.*/\n    mfxU16 WhitePointX;          /*!&lt; White point X coordinate. */\n    mfxU16 WhitePointY;          /*!&lt; White point Y coordinate. */\n    mfxU32 MaxDisplayMasteringLuminance; /*!&lt; Specify maximum luminance of the display on which the content was authored.*/\n    mfxU32 MinDisplayMasteringLuminance; /*!&lt; Specify minimum luminance of the display on which the content was authored. */\n} mfxExtMasteringDisplayColourVolume;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Handle the HDR SEI message.\n\n   During encoding: If the application attaches this structure to the mfxEncodeCtrl structure at runtime,\n   the encoder inserts the HDR SEI message for the current frame and ignores InsertPayloadToggle. If the application\n   attaches this structure to the mfxVideoParam structure during initialization or reset, the encoder inserts\n   the HDR SEI message based on InsertPayloadToggle.\n\n   During video processing: If the application attaches this structure for video processing, InsertPayloadToggle will be ignored.\n\n   During decoding: If the application attaches this structure to the mfxFrameSurface1 structure at runtime\n   which will seed to the MFXVideoDECODE_DecodeFrameAsync() as surface_work parameter,\n   the decoder will parse the HDR SEI message if the bitstream include HDR SEI message per frame.\n   The parsed HDR SEI will be attached to the ExtendBuffer of surface_out parameter of MFXVideoDECODE_DecodeFrameAsync()\n   with flag `InsertPayloadToggle` to indicate if there is valid HDR SEI message in the clip.\n   `InsertPayloadToggle` will be set to `MFX_PAYLOAD_IDR` if oneVPL gets valid HDR SEI, otherwise it will be set to `MFX_PAYLOAD_OFF`.\n   This function is support for HEVC only now.\n\n   Field semantics are defined in ITU-T* H.265 Annex D, AV1 6.7.3 Metadata high dynamic range content light level semantics.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to EXTBUFF_CONTENT_LIGHT_LEVEL_INFO. */\n    mfxU16      reserved[9];\n\n    mfxU16 InsertPayloadToggle;     /*!&lt; InsertHDRPayload enumerator value. */\n    mfxU16 MaxContentLightLevel;    /*!&lt; Maximum luminance level of the content. Field range is 1 to 65535. */\n    mfxU16 MaxPicAverageLightLevel; /*!&lt; Maximum average per-frame luminance level of the content. Field range is 1 to 65535. */\n} mfxExtContentLightLevelInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the H.264 picture timing SEI message. The encoder ignores it if HRD information in\n   the stream is absent and the PicTimingSEI option in the mfxExtCodingOption structure is turned off. See mfxExtCodingOption for details.\n\n   If the application attaches this structure to the mfxVideoParam structure during initialization, the encoder inserts the picture timing\n   SEI message based on provided template in every access unit of coded bitstream.\n\n   If application attaches this structure to the mfxEncodeCtrl structure at runtime, the encoder inserts the picture timing SEI message\n   based on provided template in access unit that represents current frame.\n\n   These parameters define the picture timing information. An invalid value of 0xFFFF indicates that application does not set the value and\n   encoder must calculate it.\n\n   See Annex D of the ISO*\\/IEC* 14496-10 specification for the definition of these parameters.\n*/\ntypedef struct {\n  mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_PICTURE_TIMING_SEI. */\n  mfxU32      reserved[14];\n\n  struct {\n      mfxU16    ClockTimestampFlag;\n      mfxU16    CtType;\n      mfxU16    NuitFieldBasedFlag;\n      mfxU16    CountingType;\n      mfxU16    FullTimestampFlag;\n      mfxU16    DiscontinuityFlag;\n      mfxU16    CntDroppedFlag;\n      mfxU16    NFrames;\n      mfxU16    SecondsFlag;\n      mfxU16    MinutesFlag;\n      mfxU16    HoursFlag;\n      mfxU16    SecondsValue;\n      mfxU16    MinutesValue;\n      mfxU16    HoursValue;\n      mfxU32    TimeOffset;\n  } TimeStamp[3];\n} mfxExtPictureTimingSEI;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the H.264 temporal layers hierarchy.\n\n   If the application attaches it to the mfxVideoParam\n   structure during initialization, the encoder generates the temporal layers and inserts the prefix NAL unit before each slice to\n   indicate the temporal and priority IDs of the layer.\n\n   This structure can be used with the display-order encoding mode only.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AVC_TEMPORAL_LAYERS. */\n    mfxU32          reserved1[4];\n    mfxU16          reserved2;\n    mfxU16          BaseLayerPID; /*!&lt; The priority ID of the base layer. The encoder increases the ID for each temporal layer and writes to the prefix NAL unit. */\n\n    struct {\n        mfxU16 Scale;       /*!&lt; The ratio between the frame rates of the current temporal layer and the base layer. */\n        mfxU16 reserved[3];\n    }Layer[8];\n} mfxExtAvcTemporalLayers;  /*!&lt; The array of temporal layers; Use Scale=0 to specify absent layers. */\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used to retrieve encoder capability. See the description of mode 4 of the MFXVideoENCODE_Query function\n   for details on how to use this structure.\n\n   @note Not all implementations of the encoder support this extended buffer. The application must use query mode 1 to determine\n         if the functionality is supported. To do this, the application must attach this extended buffer to the mfxVideoParam structure and\n         call the MFXVideoENCODE_Query function. If the function returns MFX_ERR_NONE then the  functionality is supported.\n*/\ntypedef struct {\n    mfxExtBuffer Header;  /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODER_CAPABILITY. */\n\n    mfxU32      MBPerSec; /*!&lt; Specify the maximum processing rate in macro blocks per second. */\n    mfxU16      reserved[58];\n} mfxExtEncoderCapability;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used to control the encoder behavior during reset. By using this structure, the application\n   instructs the encoder to start a new coded sequence after reset or to continue encoding of the current sequence.\n\n   This structure is also used in mode 3 of the MFXVideoENCODE_Query function to check for reset outcome before actual reset. The application\n   should set StartNewSequence to the required behavior and call the query function. If the query fails (see status codes below), then reset is not\n   possible in current encoder state. If the application sets StartNewSequence to MFX_CODINGOPTION_UNKNOWN, then the query function replaces the coding option with the\n   actual reset type: MFX_CODINGOPTION_ON if the encoder will begin a new sequence after reset or MFX_CODINGOPTION_OFF if the encoder will continue the current sequence.\n\n   Using this structure may cause one of the following status codes from the MFXVideoENCODE_Reset and MFXVideoENCODE_Queryfunctions:\n\n   @li MFX_ERR_INVALID_VIDEO_PARAM If a reset is not possible. For example, the application sets StartNewSequence to off and requests resolution change.\n\n   @li MFX_ERR_INCOMPATIBLE_VIDEO_PARAM If the application requests change that leads to memory allocation. For example, the application sets StartNewSequence to on and\n                                        requests resolution change to greater than the initialization value.\n\n   @li MFX_ERR_NONE If reset is possible.\n\n   The following limited list of parameters can be changed without starting a new coded sequence:\n\n   @li The bitrate parameters, TargetKbps and MaxKbps, in the mfxInfoMFX structure.\n\n   @li The number of slices, NumSlice, in the mfxInfoMFX structure. Number of slices should be equal to or less than the number of slices during initialization.\n\n   @li The number of temporal layers in the mfxExtAvcTemporalLayers structure. Reset should be called immediately before encoding of frame from base layer and\n     number of reference frames should be large enough for the new temporal layers structure.\n\n   @li The quantization parameters, QPI, QPP and QPB, in the mfxInfoMFX structure.\n\n   The application should retrieve all cached frames before calling reset. When the Query API function\n   checks for reset outcome, it expects that this requirement be satisfied. If it is not true and there are some cached frames inside the\n encoder, then the query result may differ from the reset result, because the encoder may insert an IDR frame to produce valid coded sequence.\n   \\verbatim embed:rst\n   See the :ref:`Configuration Change &lt;config-change&gt;` section for more information.\n   \\endverbatim\n\n   @note Not all implementations of the encoder support this extended buffer. The application must use query mode 1 to determine if the\n         functionality is supported. To do this, the application must attach this extended buffer to the mfxVideoParam structure and call the\n         MFXVideoENCODE_Query function. If the function returns MFX_ERR_NONE, then the functionality is supported.\n\n   \\verbatim embed:rst\n   See the :ref:`Streaming and Video Conferencing Features &lt;stream_vid_conf_features&gt;` section for more information.\n   \\endverbatim\n\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODER_RESET_OPTION. */\n\n    /*!\n       Instructs encoder to start new sequence after reset. Use one of the CodingOptionValue options:\n\n       @li MFX_CODINGOPTION_ON The encoder completely reset internal state and begins new coded sequence after reset, including\n                             insertion of IDR frame, sequence, and picture headers.\n\n       @li MFX_CODINGOPTION_OFF The encoder continues encoding of current coded sequence after reset, without insertion of IDR frame.\n\n       @li MFX_CODINGOPTION_UNKNOWN Depending on the current encoder state and changes in configuration parameters, the encoder may or may not\n                                  start new coded sequence. This value is also used to query reset outcome.\n    */\n    mfxU16      StartNewSequence;\n    mfxU16      reserved[11];\n} mfxExtEncoderResetOption;\nMFX_PACK_END()\n\n/*! The LongTermIdx specifies long term index of picture control. */\nenum {\n    MFX_LONGTERM_IDX_NO_IDX = 0xFFFF /*!&lt; Long term index of picture is undefined. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the encoder to report additional information about the encoded picture. The application can attach\n   this buffer to the mfxBitstream structure before calling MFXVideoENCODE_EncodeFrameAsync function. For interlaced content the encoder\n   requires two such structures. They correspond to fields in encoded order.\n\n   @note Not all implementations of the encoder support this extended buffer. The application must use query mode 1 to determine if\n         the functionality is supported. To do this, the application must attach this extended buffer to the mfxVideoParam structure and\n         call the MFXVideoENCODE_Query function. If the function returns MFX_ERR_NONE then the functionality is supported.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODED_FRAME_INFO. */\n\n    mfxU32          FrameOrder;        /*!&lt; Frame order of encoded picture. */\n    mfxU16          PicStruct;         /*!&lt; Picture structure of encoded picture. */\n    mfxU16          LongTermIdx;       /*!&lt; Long term index of encoded picture if applicable. */\n    mfxU32          MAD;               /*!&lt; Mean Absolute Difference between original pixels of the frame and motion compensated (for inter macroblocks) or\n                                            spatially predicted (for intra macroblocks) pixels. Only luma component, Y plane, is used in calculation. */\n    mfxU16          BRCPanicMode;      /*!&lt; Bitrate control was not able to allocate enough bits for this frame. Frame quality may be unacceptably low. */\n    mfxU16          QP;                /*!&lt; Luma QP. */\n    mfxU32          SecondFieldOffset; /*!&lt; Offset to second field. Second field starts at mfxBitstream::Data + mfxBitstream::DataOffset + mfxExtAVCEncodedFrameInfo::SecondFieldOffset. */\n    mfxU16          reserved[2];\n\n    struct {\n        /*! @{\n        @name Reference Lists\n        The following structure members are used by the reference lists contained in the parent structure. */\n        mfxU32      FrameOrder;        /*!&lt; Frame order of reference picture. */\n        mfxU16      PicStruct;         /*!&lt; Picture structure of reference picture. */\n        mfxU16      LongTermIdx;       /*!&lt; Long term index of reference picture if applicable. */\n        mfxU16      reserved[4];\n        /*! @} */\n    } UsedRefListL0[32], /*!&lt; Reference list that has been used to encode picture. */\n    UsedRefListL1[32]; /*!&lt; Reference list that has been used to encode picture. */\n} mfxExtAVCEncodedFrameInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used to specify input stream details for composition of several input surfaces in the one output.\n*/\ntypedef struct mfxVPPCompInputStream {\n    mfxU32  DstX; /*!&lt; X coordinate of location of input stream in output surface. */\n    mfxU32  DstY; /*!&lt; Y coordinate of location of input stream in output surface. */\n    mfxU32  DstW; /*!&lt; Width of of location of input stream in output surface.*/\n    mfxU32  DstH; /*!&lt; Height of of location of input stream in output surface.*/\n\n    mfxU16  LumaKeyEnable; /*!&lt; Non-zero value enables luma keying for the input stream. Luma keying is used to mark some of the areas\n                                of the frame with specified luma values as transparent. It may, for example, be used for closed captioning. */\n    mfxU16  LumaKeyMin;    /*!&lt; Minimum value of luma key, inclusive. Pixels whose luma values fit in this range are rendered transparent. */\n    mfxU16  LumaKeyMax;    /*!&lt; Maximum value of luma key, inclusive. Pixels whose luma values fit in this range are rendered transparent. */\n\n    mfxU16  GlobalAlphaEnable; /*!&lt; Non-zero value enables global alpha blending for this input stream. */\n    mfxU16  GlobalAlpha;       /*!&lt; Alpha value for this stream. Should be in the range of 0 to 255, where 0 is transparent and 255 is opaque. */\n    mfxU16  PixelAlphaEnable;  /*!&lt; Non-zero value enables per pixel alpha blending for this input stream. The stream should have RGB color format. */\n\n    mfxU16  TileId;        /*!&lt; Specify the tile this video stream is assigned to. Should be in the range of 0 to NumTiles. Valid only if NumTiles &gt; 0. */\n\n    mfxU16  reserved2[17];\n} mfxVPPCompInputStream;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Used to control composition of several input surfaces in one output. In this mode, the VPP skips\n   any other filters. The VPP returns an error if any mandatory filter is specified and returns the filter skipped warning if an optional filter is specified. The only\n   supported filters are deinterlacing and interlaced scaling. The only supported combinations of input and output color formats are:\n\n   - RGB to RGB,\n\n   - NV12 to NV12,\n\n   - RGB and NV12 to NV12, for per the pixel alpha blending use case.\n\n   The VPP returns MFX_ERR_MORE_DATA for additional input until an output is ready. When the output is ready, the VPP returns MFX_ERR_NONE.\n   The application must process the output frame after synchronization.\n\n   The composition process is controlled by:\n\n   - mfxFrameInfo::CropXYWH in the input surface defines the location of the picture in the input frame.\n\n   - InputStream[i].DstXYWH defines the location of the cropped input picture in the output frame.\n\n   - mfxFrameInfo::CropXYWH in the output surface defines the actual part of the output frame. All pixels in the output frame outside this region will be filled by the specified color.\n\n   If the application uses the composition process on video streams with different frame sizes, the application should provide maximum frame size in the\n   mfxVideoParam structure during the initialization, reset, or query operations.\n\n   If the application uses the composition process, the MFXVideoVPP_QueryIOSurf function returns the cumulative number of input surfaces, that is, the number\n   required to process all input video streams. The function sets the frame size in the mfxFrameAllocRequest equal to the size provided by the\n   application in the mfxVideoParam structure.\n\n   The composition process supports all types of surfaces.\n\n   All input surfaces should have the same type and color format, except for the per pixel alpha blending case, where it is allowable to mix NV12 and RGB\n   surfaces.\n\n   There are three different blending use cases:\n\n   - &lt;b&gt;Luma keying.&lt;/b&gt; All input surfaces should have the NV12 color format specified during VPP initialization. Part of each surface, including the\n     first one, may be rendered transparent by using LumaKeyEnable, LumaKeyMin, and LumaKeyMax values.\n\n   - &lt;b&gt;Global alpha blending.&lt;/b&gt; All input surfaces should have the same color format, NV12 or RGB, specified during VPP initialization. Each input surface, including the first one, can be blended with underlying surfaces by using GlobalAlphaEnable and\n     GlobalAlpha values.\n\n   - &lt;b&gt;Per-pixel alpha blending.&lt;/b&gt; It is allowed to mix NV12 and RGB input surfaces. Each RGB input surface, including the first one,\n     can be blended with underlying surfaces by using PixelAlphaEnable value.\n\n   It is not allowed to mix different blending use cases in the same function call.\n\n   In the special case where the destination region of the output surface defined by output crops is fully covered with destination sub-regions of the\n   surfaces, the fast compositing mode can be enabled. The main use case for this mode is a video-wall scenario with a fixed destination surface\n   partition into sub-regions of potentially different size.\n\n   In order to trigger this mode, the application must cluster input surfaces into tiles, defining at least one tile by setting the NumTiles\n   field to be greater than 0, and assigning surfaces to the corresponding tiles by setting the TileId field to the value within the 0 to NumTiles range per\n   input surface. Tiles should also satisfy the following additional constraints:\n\n   - Each tile should not have more than 8 surfaces assigned to it.\n\n   - Tile bounding boxes, as defined by the enclosing rectangles of a union of a surfaces assigned to this tile, should not intersect.\n\n   Background color may be changed dynamically through Reset. There is no default value. YUV black is (0;128;128) or (16;128;128) depending\n   on the sample range. The library uses a YUV or RGB triple depending on output color format.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_COMPOSITE. */\n\n    /* background color*/\n    union {\n        mfxU16   Y; /*!&lt; Y value of the background color. */\n        mfxU16   R; /*!&lt; R value of the background color. */\n    };\n    union {\n        mfxU16   U; /*!&lt; U value of the background color. */\n        mfxU16   G; /*!&lt; G value of the background color. */\n    };\n    union {\n        mfxU16   V; /*!&lt; V value of the background color. */\n        mfxU16   B; /*!&lt; B value of the background color. */\n    };\n    mfxU16       NumTiles;              /*!&lt; Number of input surface clusters grouped together to enable fast compositing. May be changed dynamically\n                                             at runtime through Reset. */\n    mfxU16       reserved1[23];\n\n    mfxU16       NumInputStream;        /*!&lt; Number of input surfaces to compose one output. May be changed dynamically at runtime through Reset. Number of surfaces\n                                             can be decreased or increased, but should not exceed the number specified during initialization. Query mode 2 should be used\n                                             to find the maximum supported number. */\n    mfxVPPCompInputStream *InputStream; /*!&lt; An array of mfxVPPCompInputStream structures that describe composition of input video streams. It should consist of exactly NumInputStream elements. */\n} mfxExtVPPComposite;\nMFX_PACK_END()\n\n/*! The TransferMatrix enumerator itemizes color transfer matrices. */\nenum {\n    MFX_TRANSFERMATRIX_UNKNOWN = 0, /*!&lt; Transfer matrix is not specified */\n    MFX_TRANSFERMATRIX_BT709   = 1, /*!&lt; Transfer matrix from ITU-R BT.709 standard. */\n    MFX_TRANSFERMATRIX_BT601   = 2  /*!&lt; Transfer matrix from ITU-R BT.601 standard. */\n};\n\n/* The NominalRange enumerator itemizes pixel&#x27;s value nominal range. */\nenum {\n    MFX_NOMINALRANGE_UNKNOWN   = 0, /*!&lt; Range is not defined. */\n    MFX_NOMINALRANGE_0_255     = 1, /*!&lt; Range is from  0 to 255. */\n    MFX_NOMINALRANGE_16_235    = 2  /*!&lt; Range is from 16 to 235. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used to control transfer matrix and nominal range of YUV frames. The application\n   should provide this during initialization. Supported for multiple conversions, for example YUV to YUV, YUV to RGB, and RGB to YUV.\n\n   @note This structure is used by VPP only and is not compatible with mfxExtVideoSignalInfo.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_VIDEO_SIGNAL_INFO. */\n    mfxU16          reserved1[4];\n\n    union {\n        struct { // Init\n            struct  {\n                mfxU16  TransferMatrix; /*!&lt; Transfer matrix. */\n                mfxU16  NominalRange;   /*!&lt; Nominal range. */\n                mfxU16  reserved2[6];\n            } In, Out;\n        };\n        struct { // Runtime&lt;\n            mfxU16  TransferMatrix; /*!&lt; Transfer matrix. */\n            mfxU16  NominalRange;   /*!&lt; Nominal range. */\n            mfxU16  reserved3[14];\n        };\n    };\n} mfxExtVPPVideoSignalInfo;\nMFX_PACK_END()\n\n/*! The ROImode enumerator itemizes QP adjustment mode for ROIs. */\nenum {\n    MFX_ROI_MODE_PRIORITY =  0, /*!&lt; Priority mode. */\n    MFX_ROI_MODE_QP_DELTA =  1,  /*!&lt; QP mode */\n    MFX_ROI_MODE_QP_VALUE =  2 /*!&lt; Absolute QP */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the application to specify different Region Of Interests during encoding. It may be used at\n   initialization or at runtime.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODER_ROI. */\n\n    mfxU16  NumROI;  /*!&lt; Number of ROI descriptions in array. The Query API function mode 2 returns maximum supported value (set it to 256 and\n                         query will update it to maximum supported value). */\n    mfxU16  ROIMode; /*!&lt; QP adjustment mode for ROIs. Defines if Priority or DeltaQP is used during encoding. */\n    mfxU16  reserved1[10];\n\n    struct  {\n        /*! @{\n        @name ROI location rectangle\n        The ROI rectangle definition uses end-point exclusive notation. In other words, the pixel with (Right, Bottom)\n        coordinates lies immediately outside of the ROI. Left, Top, Right, Bottom should be aligned by codec-specific block boundaries\n        (should be dividable by 16 for AVC, or by 32 for HEVC). Every ROI with unaligned coordinates will be expanded by the library to minimal-area\n        block-aligned ROI, enclosing the original one. For example (5, 5, 15, 31) ROI will be expanded to (0, 0, 16, 32) for AVC encoder,\n        or to (0, 0, 32, 32) for HEVC.\n         */\n        mfxU32  Left;   /*!&lt; Left ROI&#x27;s coordinate. */\n        mfxU32  Top;    /*!&lt; Top ROI&#x27;s coordinate. */\n        mfxU32  Right;  /*!&lt; Right ROI&#x27;s coordinate. */\n        mfxU32  Bottom; /*!&lt; Bottom ROI&#x27;s coordinate. */\n        union {\n            /*! Priority of ROI. Used if ROIMode = MFX_ROI_MODE_PRIORITY.This is an absolute value in the range of -3 to 3,\n                                  which will be added to the MB QP. Priority is deprecated mode and is used only for backward compatibility.\n                                  Bigger value produces better quality. */\n            mfxI16  Priority;\n            /*! Delta QP of ROI. Used if ROIMode = MFX_ROI_MODE_QP_DELTA. This is an absolute value in the range of -51 to 51,\n                                  which will be added to the MB QP. Lesser value produces better quality. */\n            mfxI16  DeltaQP;\n        };\n        mfxU16  reserved2[7];\n        /*! @} */\n    } ROI[256]; /*!&lt; Array of ROIs. Different ROI may overlap each other. If macroblock belongs to several ROI,\n                     Priority from ROI with lowest index is used. */\n} mfxExtEncoderROI;\nMFX_PACK_END()\n\n/*! The DeinterlacingMode enumerator itemizes VPP deinterlacing modes. */\nenum {\n    MFX_DEINTERLACING_BOB                    =  1, /*!&lt; BOB deinterlacing mode. */\n    MFX_DEINTERLACING_ADVANCED               =  2, /*!&lt; Advanced deinterlacing mode. */\n    MFX_DEINTERLACING_AUTO_DOUBLE            =  3, /*!&lt; Auto mode with deinterlacing double frame rate output. */\n    MFX_DEINTERLACING_AUTO_SINGLE            =  4, /*!&lt; Auto mode with deinterlacing single frame rate output. */\n    MFX_DEINTERLACING_FULL_FR_OUT            =  5, /*!&lt; Deinterlace only mode with full frame rate output. */\n    MFX_DEINTERLACING_HALF_FR_OUT            =  6, /*!&lt; Deinterlace only Mode with half frame rate output. */\n    MFX_DEINTERLACING_24FPS_OUT              =  7, /*!&lt; 24 fps fixed output mode. */\n    MFX_DEINTERLACING_FIXED_TELECINE_PATTERN =  8, /*!&lt; Fixed telecine pattern removal mode. */\n    MFX_DEINTERLACING_30FPS_OUT              =  9, /*!&lt; 30 fps fixed output mode. */\n    MFX_DEINTERLACING_DETECT_INTERLACE       = 10, /*!&lt; Only interlace detection. */\n    MFX_DEINTERLACING_ADVANCED_NOREF         = 11, /*!&lt; Advanced deinterlacing mode without using of reference frames. */\n    MFX_DEINTERLACING_ADVANCED_SCD           = 12, /*!&lt; Advanced deinterlacing mode with scene change detection. */\n    MFX_DEINTERLACING_FIELD_WEAVING          = 13  /*!&lt; Field weaving. */\n};\n\n/*! The TelecinePattern enumerator itemizes telecine patterns. */\nenum {\n    MFX_TELECINE_PATTERN_32           = 0, /*!&lt; 3:2 telecine. */\n    MFX_TELECINE_PATTERN_2332         = 1, /*!&lt; 2:3:3:2 telecine. */\n    MFX_TELECINE_PATTERN_FRAME_REPEAT = 2, /*!&lt; One frame repeat telecine. */\n    MFX_TELECINE_PATTERN_41           = 3, /*!&lt; 4:1 telecine. */\n    MFX_TELECINE_POSITION_PROVIDED    = 4  /*!&lt; User must provide position inside a sequence of 5 frames where the artifacts start. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the application to specify different deinterlacing algorithms.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_DEINTERLACING. */\n    mfxU16  Mode;             /*!&lt; Deinterlacing algorithm. See the DeinterlacingMode enumerator for details. */\n    mfxU16  TelecinePattern;  /*!&lt; Specifies telecine pattern when Mode = MFX_DEINTERLACING_FIXED_TELECINE_PATTERN. See the TelecinePattern enumerator for details.*/\n    mfxU16  TelecineLocation; /*!&lt; Specifies position inside a sequence of 5 frames where the artifacts start when TelecinePattern = MFX_TELECINE_POSITION_PROVIDED*/\n    mfxU16  reserved[9];      /*!&lt; Reserved for future use. */\n} mfxExtVPPDeinterlacing;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Specifies reference lists for the encoder. It may be used together with the mfxExtAVCRefListCtrl\n   structure to create customized reference lists. If both structures are used together, then the encoder takes reference lists from the\n   mfxExtAVCRefLists structure and modifies them according to the mfxExtAVCRefListCtrl instructions. In case of interlaced coding,\n   the first mfxExtAVCRefLists structure affects TOP field and the second - BOTTOM field.\n\n   @note Not all implementations of the encoder support this structure. The application must use the Query API function to determine if it is supported.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;            /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AVC_REFLISTS. */\n    mfxU16          NumRefIdxL0Active; /*!&lt; Specify the number of reference frames in the active reference list L0. This number should be less than or\n                                            equal to the NumRefFrame parameter from encoding initialization. */\n    mfxU16          NumRefIdxL1Active; /*!&lt; Specify the number of reference frames in the active reference list L1. This number should be less than or\n                                            equal to the NumRefFrame parameter from encoding initialization. */\n    mfxU16          reserved[2];\n\n    /*! Used by the reference lists contained in the parent structure. Together these fields are used to identify reference picture. */\n    struct mfxRefPic{\n        mfxU32      FrameOrder; /*!&lt; Use FrameOrder = MFX_FRAMEORDER_UNKNOWN to mark\n                                     unused entry. */\n        mfxU16      PicStruct;  /*!&lt; Use PicStruct = MFX_PICSTRUCT_FIELD_TFF for TOP field, PicStruct = MFX_PICSTRUCT_FIELD_BFF for\n                                     BOTTOM field. */\n        mfxU16      reserved[5];\n    } RefPicList0[32], /*!&lt; Specify L0 reference list. */\n      RefPicList1[32]; /*!&lt; Specify L1 reference list. */\n\n}mfxExtAVCRefLists;\nMFX_PACK_END()\n\n/*! The VPPFieldProcessingMode enumerator is used to control VPP field processing algorithm. */\nenum {\n    MFX_VPP_COPY_FRAME      =0x01, /*!&lt; Copy the whole frame. */\n    MFX_VPP_COPY_FIELD      =0x02, /*!&lt; Copy only one field. */\n    MFX_VPP_SWAP_FIELDS     =0x03  /*!&lt; Swap top and bottom fields. */\n};\n\n/*! The PicType enumerator itemizes picture type. */\nenum {\n    MFX_PICTYPE_UNKNOWN     =0x00, /*!&lt; Picture type is unknown. */\n    MFX_PICTYPE_FRAME       =0x01, /*!&lt; Picture is a frame. */\n    MFX_PICTYPE_TOPFIELD    =0x02, /*!&lt; Picture is a top field. */\n    MFX_PICTYPE_BOTTOMFIELD =0x04  /*!&lt; Picture is a bottom field. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP field processing algorithm. The application can attach this extended buffer to\n   the mfxVideoParam structure to configure initialization and/or to the mfxFrameData during runtime. Runtime configuration has priority\n   over initialization configuration. If the field processing algorithm was activated via the mfxExtVPPDoUse structure and the mfxExtVPPFieldProcessing\n   extended buffer was not provided during initialization, this buffer must be attached to the mfxFrameData structure of each input surface.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_FIELD_PROCESSING. */\n\n    mfxU16          Mode;     /*!&lt; Specifies the mode of the field processing algorithm. See the VPPFieldProcessingMode enumerator for values of this option. */\n    mfxU16          InField;  /*!&lt; When Mode is MFX_VPP_COPY_FIELD, specifies input field. See the PicType enumerator for values of this parameter. */\n    mfxU16          OutField; /*!&lt; When Mode is MFX_VPP_COPY_FIELD, specifies output field. See the PicType enumerator for values of this parameter. */\n    mfxU16          reserved[25];\n} mfxExtVPPFieldProcessing;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   If attached to the mfxVideoParam structure during the Init stage, this buffer will instruct the decoder to resize output frames via the\n   fixed function resize engine (if supported by hardware), utilizing direct pipe connection and bypassing intermediate memory operations.\n   The main benefits of this mode of pipeline operation are offloading resize operation to a dedicated engine, thus reducing power\n   consumption and memory traffic.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_DEC_VIDEO_PROCESSING. */\n\n    /*! Input surface description. */\n    struct mfxIn{\n        mfxU16  CropX; /*!&lt; X coordinate of region of interest of the input surface. */\n        mfxU16  CropY; /*!&lt; Y coordinate of region of interest of the input surface. */\n        mfxU16  CropW; /*!&lt; Width coordinate of region of interest of the input surface. */\n        mfxU16  CropH; /*!&lt; Height coordinate of region of interest of the input surface. */\n        mfxU16  reserved[12];\n    }In; /*!&lt; Input surface description. */\n\n    /*! Output surface description. */\n    struct mfxOut{\n        mfxU32  FourCC;       /*!&lt; FourCC of output surface Note: Should be MFX_FOURCC_NV12. */\n        mfxU16  ChromaFormat; /*!&lt; Chroma Format of output surface.\n                                   @note Should be MFX_CHROMAFORMAT_YUV420 */\n        mfxU16  reserved1;\n\n        mfxU16  Width;        /*!&lt; Width of output surface. */\n        mfxU16  Height;       /*!&lt; Height of output surface. */\n\n        mfxU16  CropX; /*!&lt; X coordinate of region of interest of the output surface. */\n        mfxU16  CropY; /*!&lt; Y coordinate of region of interest of the output surface. */\n        mfxU16  CropW; /*!&lt; Width coordinate of region of interest of the output surface. */\n        mfxU16  CropH; /*!&lt; Height coordinate of region of interest of the output surface. */\n        mfxU16  reserved[22];\n    }Out; /*!&lt; Output surface description. */\n\n    mfxU16  reserved[13];\n} mfxExtDecVideoProcessing;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Members of this structure define the location of chroma samples information.\n\n   See Annex E of the ISO*\\/IEC* 14496-10 specification for the definition of these parameters.\n\n   @note Not all implementations of the encoder support this structure. The application must use the Query API function to determine if it is supported.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_CHROMA_LOC_INFO. */\n\n    mfxU16       ChromaLocInfoPresentFlag;\n    mfxU16       ChromaSampleLocTypeTopField;\n    mfxU16       ChromaSampleLocTypeBottomField;\n    mfxU16       reserved[9];\n} mfxExtChromaLocInfo;\nMFX_PACK_END()\n\n/*! The MBQPMode enumerator itemizes QP update modes. */\nenum {\n    MFX_MBQP_MODE_QP_VALUE = 0, /*!&lt; QP array contains QP values. */\n    MFX_MBQP_MODE_QP_DELTA = 1,  /*!&lt; QP array contains deltas for QP. */\n    MFX_MBQP_MODE_QP_ADAPTIVE = 2 /*!&lt; QP array contains deltas for QP or absolute QP values. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Specifies per-MB or per-CU mode and QP or DeltaQP value depending on the mode type.\n */\ntypedef struct{\n    union {\n          /*!\n           QP for MB or CU. Valid when Mode = MFX_MBQP_MODE_QP_VALUE.\n\n           For AVC, the valid range is 1 to 51.\n\n           For HEVC, the valid range is 1 to 51. The application&#x27;s provided QP values should be valid, otherwise invalid QP values may cause undefined behavior.\n\n           MBQP map should be aligned for 16x16 block size. The align rule is: (width +15 /16) &amp;&amp; (height +15 /16).\n\n           For MPEG2, the valid range is 1 to 112. QP corresponds to quantizer_scale of the ISO*\\/IEC* 13818-2 specification.\n           */\n        mfxU8 QP;\n            /*!\n             Per-macroblock QP delta. Valid when Mode = MFX_MBQP_MODE_QP_DELTA.\n             */\n        mfxI8 DeltaQP;\n    };\n    mfxU16 Mode; /*!&lt; Defines QP update mode. Can be equal to MFX_MBQP_MODE_QP_VALUE or MFX_MBQP_MODE_QP_DELTA. */\n} mfxQPandMode;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Specifies per-macroblock QP for current frame if mfxExtCodingOption3::EnableMBQP was turned ON during\n   encoder initialization. The application can attach this extended buffer to the mfxEncodeCtrl structure during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MBQP. */\n\n    mfxU32 reserved[9];\n    mfxU32 Pitch;       /*!&lt; Distance in bytes between the start of two consecutive rows in the QP array. */\n    mfxU16 Mode;        /*!&lt; Defines QP update mode. See MBQPMode enumerator for more details. */\n    mfxU16 BlockSize;   /*!&lt; QP block size, valid for HEVC only during Init and Runtime. */\n    mfxU32 NumQPAlloc;  /*!&lt; Size of allocated by application QP or DeltaQP array. */\n    union {\n        /*!\n           Pointer to a list of per-macroblock QP in raster scan order. In case of interlaced encoding the first half of QP array affects the top\n           field and the second half of QP array affects the bottom field. Valid when Mode = MFX_MBQP_MODE_QP_VALUE.\n\n           For AVC, the valid range is 1 to 51.\n\n           For HEVC, the valid range is 1 to 51. Application&#x27;s provided QP values should be valid. Otherwise invalid QP values may cause undefined behavior.\n           MBQP map should be aligned for 16x16 block size. The alignment rule is (width +15 /16) &amp;&amp; (height +15 /16).\n\n           For MPEG2, QP corresponds to quantizer_scale of the ISO*\\/IEC* 13818-2 specification and has a valid range of 1 to 112.\n        */\n        mfxU8  *QP;\n        mfxI8  *DeltaQP;    /*!&lt; Pointer to a list of per-macroblock QP deltas in raster scan order.\n                                 For block i: QP[i] = BrcQP[i] + DeltaQP[i]. Valid when Mode = MFX_MBQP_MODE_QP_DELTA. */\n        mfxQPandMode *QPmode; /*!&lt; Block-granularity modes when MFX_MBQP_MODE_QP_ADAPTIVE is set. */\n\n        mfxU64 reserved2;\n    };\n} mfxExtMBQP;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Runtime ctrl buffer for SPS/PPS insertion with current encoding frame.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_INSERT_HEADERS. */\n    mfxU16          SPS;      /*!&lt; Tri-state option to insert SPS. */\n    mfxU16          PPS;      /*!&lt; Tri-state option to insert PPS. */\n    mfxU16          reserved[8];\n} mfxExtInsertHeaders;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n  Specifies rectangle areas for IPCM coding mode.\n*/\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODER_IPCM_AREA. */\n    mfxU16          reserve1[10];\n\n    mfxU16          NumArea;  /*! Number of areas */\n    struct area {\n\n        mfxU32      Left; /*!&lt; Left area coordinate. */\n        mfxU32      Top;  /*!&lt; Top area coordinate. */\n        mfxU32      Right; /*!&lt; Right area coordinate. */\n        mfxU32      Bottom; /*!&lt; Bottom area coordinate. */\n\n        mfxU16      reserved2[8];\n\n    } * Areas; /*!&lt; Array of areas. */\n} mfxExtEncoderIPCMArea;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Specifies macroblock map for current frame which forces specified macroblocks to be encoded as intra\n   if mfxExtCodingOption3::EnableMBForceIntra was turned ON during encoder initialization. The application can attach this extended\n   buffer to the mfxEncodeCtrl structure during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MB_FORCE_INTRA. */\n\n    mfxU32 reserved[11];\n    mfxU32 MapSize;  /*!&lt; Macroblock map size. */\n    union {\n        mfxU8  *Map; /*!&lt; Pointer to a list of force intra macroblock flags in raster scan order. Each flag is one byte in map. Set flag to 1\n                          to force corresponding macroblock to be encoded as intra. In case of interlaced encoding, the first half of map\n                          affects top field and the second half of map affects the bottom field. */\n        mfxU64  reserved2;\n    };\n} mfxExtMBForceIntra;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures tiles options for the HEVC encoder. The application can attach this extended buffer to the\n   mfxVideoParam structure to configure initialization.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_HEVC_TILES. */\n\n    mfxU16 NumTileRows;    /*!&lt; Number of tile rows. */\n    mfxU16 NumTileColumns; /*!&lt; Number of tile columns. */\n    mfxU16 reserved[74];\n}mfxExtHEVCTiles;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Specifies macroblock map for current frame which forces specified macroblocks to be non-skip if\n   mfxExtCodingOption3::MBDisableSkipMap was turned ON during encoder initialization. The application can attach this\n   extended buffer to the mfxEncodeCtrl structure during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MB_DISABLE_SKIP_MAP. */\n\n    mfxU32 reserved[11];\n    mfxU32 MapSize;  /*!&lt; Macroblock map size. */\n    union {\n        mfxU8  *Map; /*!&lt; Pointer to a list of non-skip macroblock flags in raster scan order. Each flag is one byte in map. Set flag to 1 to force\n                          corresponding macroblock to be non-skip. In case of interlaced encoding, the first half of map affects\n                          the top field and the second half of map affects the bottom field. */\n        mfxU64  reserved2;\n    };\n} mfxExtMBDisableSkipMap;\nMFX_PACK_END()\n\n/*! The GeneralConstraintFlags enumerator uses bit-ORed values to itemize HEVC bitstream indications for specific profiles. Each value\n    indicates for format range extensions profiles. \n    To specify HEVC Main 10 Still Picture profile applications have to set mfxInfoMFX::CodecProfile == MFX_PROFILE_HEVC_MAIN10 and \n    mfxExtHEVCParam::GeneralConstraintFlags == MFX_HEVC_CONSTR_REXT_ONE_PICTURE_ONLY. */\nenum {\n    /* REXT Profile constraint flags*/\n    MFX_HEVC_CONSTR_REXT_MAX_12BIT          = (1 &lt;&lt; 0),\n    MFX_HEVC_CONSTR_REXT_MAX_10BIT          = (1 &lt;&lt; 1),\n    MFX_HEVC_CONSTR_REXT_MAX_8BIT           = (1 &lt;&lt; 2),\n    MFX_HEVC_CONSTR_REXT_MAX_422CHROMA      = (1 &lt;&lt; 3),\n    MFX_HEVC_CONSTR_REXT_MAX_420CHROMA      = (1 &lt;&lt; 4),\n    MFX_HEVC_CONSTR_REXT_MAX_MONOCHROME     = (1 &lt;&lt; 5),\n    MFX_HEVC_CONSTR_REXT_INTRA              = (1 &lt;&lt; 6),\n    MFX_HEVC_CONSTR_REXT_ONE_PICTURE_ONLY   = (1 &lt;&lt; 7),\n    MFX_HEVC_CONSTR_REXT_LOWER_BIT_RATE     = (1 &lt;&lt; 8)\n};\n\n\n/*! The SampleAdaptiveOffset enumerator uses bit-ORed values to itemize corresponding HEVC encoding feature. */\nenum {\n    MFX_SAO_UNKNOWN       = 0x00, /*!&lt; Use default value for platform/TargetUsage. */\n    MFX_SAO_DISABLE       = 0x01, /*!&lt; Disable SAO. If set during Init leads to SPS sample_adaptive_offset_enabled_flag = 0.\n                                       If set during Runtime, leads to to slice_sao_luma_flag = 0 and slice_sao_chroma_flag = 0\n                                       for current frame. */\n    MFX_SAO_ENABLE_LUMA   = 0x02, /*!&lt; Enable SAO for luma (slice_sao_luma_flag = 1). */\n    MFX_SAO_ENABLE_CHROMA = 0x04  /*!&lt; Enable SAO for chroma (slice_sao_chroma_flag = 1). */\n};\n\n\n/* This struct has 4-byte alignment for binary compatibility with previously released versions of API */\nMFX_PACK_BEGIN_USUAL_STRUCT()\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_HEVC_PARAM. */\n\n    mfxU16          PicWidthInLumaSamples;  /*!&lt; Specifies the width of each coded picture in units of luma samples. */\n    mfxU16          PicHeightInLumaSamples; /*!&lt; Specifies the height of each coded picture in units of luma samples. */\n    mfxU64          GeneralConstraintFlags; /*!&lt; Additional flags to specify exact profile and constraints. See the GeneralConstraintFlags enumerator for values of this field. */\n    mfxU16          SampleAdaptiveOffset;   /*!&lt; Controls SampleAdaptiveOffset encoding feature. See the SampleAdaptiveOffset enumerator for supported values\n                                                 (bit-ORed). Valid during encoder Init and Runtime. */\n    mfxU16          LCUSize;                /*!&lt; Specifies largest coding unit size (max luma coding block). Valid during encoder Init. */\n    mfxU16          reserved[116];\n} mfxExtHEVCParam;\nMFX_PACK_END()\n\n/*! The ErrorTypes enumerator uses bit-ORed values to itemize bitstream error types. */\nenum {\n    MFX_ERROR_NO                  =        0,  /*!&lt; No error in bitstream. */\n    MFX_ERROR_PPS                 = (1 &lt;&lt; 0),  /*!&lt; Invalid/corrupted PPS. */\n    MFX_ERROR_SPS                 = (1 &lt;&lt; 1),  /*!&lt; Invalid/corrupted SPS. */\n    MFX_ERROR_SLICEHEADER         = (1 &lt;&lt; 2),  /*!&lt; Invalid/corrupted slice header. */\n    MFX_ERROR_SLICEDATA           = (1 &lt;&lt; 3),  /*!&lt; Invalid/corrupted slice data. */\n    MFX_ERROR_FRAME_GAP           = (1 &lt;&lt; 4),  /*!&lt; Missed frames. */\n    MFX_ERROR_JPEG_APP0_MARKER    = (1 &lt;&lt; 5),  /*!&lt; Invalid/corrupted APP0 marker. */\n    MFX_ERROR_JPEG_APP1_MARKER    = (1 &lt;&lt; 6),  /*!&lt; Invalid/corrupted APP1 marker. */\n    MFX_ERROR_JPEG_APP2_MARKER    = (1 &lt;&lt; 7),  /*!&lt; Invalid/corrupted APP2 marker. */\n    MFX_ERROR_JPEG_APP3_MARKER    = (1 &lt;&lt; 8),  /*!&lt; Invalid/corrupted APP3 marker. */\n    MFX_ERROR_JPEG_APP4_MARKER    = (1 &lt;&lt; 9),  /*!&lt; Invalid/corrupted APP4 marker. */\n    MFX_ERROR_JPEG_APP5_MARKER    = (1 &lt;&lt; 10), /*!&lt; Invalid/corrupted APP5 marker. */\n    MFX_ERROR_JPEG_APP6_MARKER    = (1 &lt;&lt; 11), /*!&lt; Invalid/corrupted APP6 marker. */\n    MFX_ERROR_JPEG_APP7_MARKER    = (1 &lt;&lt; 12), /*!&lt; Invalid/corrupted APP7 marker. */\n    MFX_ERROR_JPEG_APP8_MARKER    = (1 &lt;&lt; 13), /*!&lt; Invalid/corrupted APP8 marker. */\n    MFX_ERROR_JPEG_APP9_MARKER    = (1 &lt;&lt; 14), /*!&lt; Invalid/corrupted APP9 marker. */\n    MFX_ERROR_JPEG_APP10_MARKER   = (1 &lt;&lt; 15), /*!&lt; Invalid/corrupted APP10 marker. */\n    MFX_ERROR_JPEG_APP11_MARKER   = (1 &lt;&lt; 16), /*!&lt; Invalid/corrupted APP11 marker. */\n    MFX_ERROR_JPEG_APP12_MARKER   = (1 &lt;&lt; 17), /*!&lt; Invalid/corrupted APP12 marker. */\n    MFX_ERROR_JPEG_APP13_MARKER   = (1 &lt;&lt; 18), /*!&lt; Invalid/corrupted APP13 marker. */\n    MFX_ERROR_JPEG_APP14_MARKER   = (1 &lt;&lt; 19), /*!&lt; Invalid/corrupted APP14 marker. */\n    MFX_ERROR_JPEG_DQT_MARKER     = (1 &lt;&lt; 20), /*!&lt; Invalid/corrupted DQT marker. */\n    MFX_ERROR_JPEG_SOF0_MARKER    = (1 &lt;&lt; 21), /*!&lt; Invalid/corrupted SOF0 marker. */\n    MFX_ERROR_JPEG_DHT_MARKER     = (1 &lt;&lt; 22), /*!&lt; Invalid/corrupted DHT marker. */\n    MFX_ERROR_JPEG_DRI_MARKER     = (1 &lt;&lt; 23), /*!&lt; Invalid/corrupted DRI marker. */\n    MFX_ERROR_JPEG_SOS_MARKER     = (1 &lt;&lt; 24), /*!&lt; Invalid/corrupted SOS marker. */\n    MFX_ERROR_JPEG_UNKNOWN_MARKER = (1 &lt;&lt; 25), /*!&lt; Unknown Marker. */\n};\n\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the decoders to report bitstream error information right after DecodeHeader or DecodeFrameAsync.\n   The application can attach this extended buffer to the mfxBitstream structure at runtime.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;     /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_DECODE_ERROR_REPORT. */\n\n    mfxU32          ErrorTypes; /*!&lt; Bitstream error types (bit-ORed values). See ErrorTypes enumerator for the list of types. */\n    mfxU16          reserved[10];\n} mfxExtDecodeErrorReport;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the decoders to report additional information about a decoded frame. The application can attach this\n   extended buffer to the mfxFrameSurface1::mfxFrameData structure at runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header;    /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_DECODED_FRAME_INFO. */\n\n    mfxU16       FrameType; /*!&lt; Frame type. See FrameType enumerator for the list of types. */\n    mfxU16       reserved[59];\n} mfxExtDecodedFrameInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the library to pass MPEG 2 specific timing information.\n\n   See ISO/IEC 13818-2 and ITU-T H.262, MPEG-2 Part 2 for the definition of these parameters.\n*/\ntypedef struct {\n    mfxExtBuffer Header;           /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_TIME_CODE. */\n\n    mfxU16       DropFrameFlag;    /*!&lt; Indicated dropped frame. */\n    mfxU16       TimeCodeHours;    /*!&lt; Hours. */\n    mfxU16       TimeCodeMinutes;  /*!&lt; Minutes. */\n    mfxU16       TimeCodeSeconds;  /*!&lt; Seconds. */\n    mfxU16       TimeCodePictures; /*!&lt; Pictures. */\n    mfxU16       reserved[7];\n} mfxExtTimeCode;\nMFX_PACK_END()\n\n/*! The HEVCRegionType enumerator itemizes type of HEVC region. */\nenum {\n    MFX_HEVC_REGION_SLICE = 0 /*!&lt; Slice type. */\n};\n\n/*! The HEVCRegionEncoding enumerator itemizes HEVC region&#x27;s encoding. */\nenum {\n    MFX_HEVC_REGION_ENCODING_ON  = 0,\n    MFX_HEVC_REGION_ENCODING_OFF = 1\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Attached to the mfxVideoParam structure during HEVC encoder initialization. Specifies the region to encode.\n\n   @note Not all implementations of the encoder support this structure. The application must use the Query API function to determine if it is supported.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_HEVC_REGION. */\n\n    mfxU32       RegionId;       /*!&lt; ID of region. */\n    mfxU16       RegionType;     /*!&lt; Type of region. See HEVCRegionType enumerator for the list of types. */\n    mfxU16       RegionEncoding; /*!&lt; Set to MFX_HEVC_REGION_ENCODING_ON to encode only specified region. */\n    mfxU16       reserved[24];\n} mfxExtHEVCRegion;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Specifies weighted prediction table for current frame when all of the following conditions are met:\n\n   @li mfxExtCodingOption3::WeightedPred was set to explicit during encoder Init or Reset .\n\n   @li The current frame is P-frame or mfxExtCodingOption3::WeightedBiPred was set to explicit during encoder Init or Reset.\n\n   @li The current frame is B-frame and is attached to the mfxEncodeCtrl structure.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_PRED_WEIGHT_TABLE. */\n\n    mfxU16       LumaLog2WeightDenom;     /*!&lt; Base 2 logarithm of the denominator for all luma weighting factors. Value must be in the range of 0 to 7, inclusive. */\n    mfxU16       ChromaLog2WeightDenom;   /*!&lt; Base 2 logarithm of the denominator for all chroma weighting factors. Value must be in the range of 0 to 7, inclusive. */\n    mfxU16       LumaWeightFlag[2][32];   /*!&lt; LumaWeightFlag[L][R] equal to 1 specifies that the weighting factors for the luma component are specified for R&#x27;s entry of RefPicList L. */\n    mfxU16       ChromaWeightFlag[2][32]; /*!&lt; ChromaWeightFlag[L][R] equal to 1 specifies that the weighting factors for the chroma component are specified for R&#x27;s entry of RefPicList L. */\n    mfxI16       Weights[2][32][3][2];    /*!&lt; The values of the weights and offsets used in the encoding processing. The value of Weights[i][j][k][m] is\n                                               interpreted as: i refers to reference picture list 0 or 1; j refers to reference list entry 0-31;\n                                               k refers to data for the luma component when it is 0, the Cb chroma component when it is 1 and\n                                               the Cr chroma component when it is 2; m refers to weight when it is 0 and offset when it is 1 */\n    mfxU16       reserved[58];\n} mfxExtPredWeightTable;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by encoders to set rounding offset parameters for quantization. It is per-frame based encoding control,\n   and can be attached to some frames and skipped for others. When the extension buffer is set the application can attach it to the mfxEncodeCtrl\n   during runtime.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AVC_ROUNDING_OFFSET. */\n\n    mfxU16       EnableRoundingIntra; /*!&lt; Enable rounding offset for intra blocks. See the CodingOptionValue enumerator for values of this option. */\n    mfxU16       RoundingOffsetIntra; /*!&lt; Intra rounding offset. Value must be in the range of 0 to 7, inclusive. */\n    mfxU16       EnableRoundingInter; /*!&lt; Enable rounding offset for inter blocks. See the CodingOptionValue enumerator for values of this option. */\n    mfxU16       RoundingOffsetInter; /*!&lt; Inter rounding offset. Value must be in the range of 0 to 7, inclusive. */\n\n    mfxU16       reserved[24];\n} mfxExtAVCRoundingOffset;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the application to specify dirty regions within a frame during encoding. It may be used at initialization or at runtime.\n\n   Dirty rectangle definition is using end-point exclusive notation. In other words, the pixel with (Right, Bottom) coordinates lies\n   immediately outside of the dirty rectangle. Left, Top, Right, Bottom should be aligned by codec-specific block boundaries (should be\n   dividable by 16 for AVC, or by block size (8, 16, 32 or 64, depends on platform) for HEVC).\n\n   Every dirty rectangle with unaligned\n   coordinates will be expanded to a minimal-area block-aligned dirty rectangle, enclosing the original one.\n   For example, a (5, 5, 15, 31) dirty rectangle will be expanded to (0, 0, 16, 32) for AVC encoder, or to (0, 0, 32, 32) for HEVC,\n   if block size is 32.\n\n   Dirty rectangle (0, 0, 0, 0) is a valid dirty rectangle and means that the frame is not changed.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_DIRTY_RECTANGLES. */\n\n    mfxU16  NumRect;    /*!&lt; Number of dirty rectangles. */\n    mfxU16  reserved1[11];\n\n    struct {\n        /*! @{\n        @name Dirty rectangle coordinates\n        The following structure members are used by the Rect array contained in the parent structure.\n\n         */\n        mfxU32  Left;   /*!&lt; Dirty region left coordinate. */\n        mfxU32  Top;    /*!&lt; Dirty region top coordinate. */\n        mfxU32  Right;  /*!&lt; Dirty region right coordinate. */\n        mfxU32  Bottom; /*!&lt; Dirty region bottom coordinate. */\n\n        mfxU16  reserved2[8];\n        /*! @} */\n    } Rect[256];        /*!&lt; Array of dirty rectangles. */\n} mfxExtDirtyRect;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by the application to specify moving regions within a frame during encoding.\n\n   Destination rectangle location should be aligned to MB boundaries (should be dividable by 16). If not, the encoder\n   truncates it to MB boundaries, for example, both 17 and 31 will be truncated to 16.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MOVING_RECTANGLE. */\n\n    mfxU16  NumRect;        /*!&lt; Number of moving rectangles. */\n    mfxU16  reserved1[11];\n\n    struct {\n        /*! @{\n        @name Destination and source rectangle location\n        The following structure members are used by the Rect array contained in the parent structure.\n         */\n        mfxU32  DestLeft;   /*!&lt; Destination rectangle location. */\n        mfxU32  DestTop;    /*!&lt; Destination rectangle location. */\n        mfxU32  DestRight;  /*!&lt; Destination rectangle location. */\n        mfxU32  DestBottom; /*!&lt; Destination rectangle location. */\n\n        mfxU32  SourceLeft; /*!&lt; Source rectangle location. */\n        mfxU32  SourceTop;  /*!&lt; Source rectangle location. */\n        mfxU16  reserved2[4];\n        /*! @} */\n    } Rect[256];            /*!&lt; Array of moving rectangles. */\n} mfxExtMoveRect;\nMFX_PACK_END()\n\n/*! The Angle enumerator itemizes valid rotation angles. */\nenum {\n    MFX_ANGLE_0     =   0, /*!&lt; 0 degrees. */\n    MFX_ANGLE_90    =  90, /*!&lt; 90 degrees. */\n    MFX_ANGLE_180   = 180, /*!&lt; 180 degrees. */\n    MFX_ANGLE_270   = 270  /*!&lt; 270 degrees. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP Rotation filter algorithm.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_ROTATION. */\n\n    mfxU16 Angle;        /*!&lt; Rotation angle. See Angle enumerator for supported values. */\n    mfxU16 reserved[11];\n} mfxExtVPPRotation;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   Used by the encoder to report additional information about encoded slices. The application can attach this\n   buffer to the mfxBitstream structure before calling the MFXVideoENCODE_EncodeFrameAsync function.\n\n   @note Not all implementations of the encoder support this extended buffer. The application must use query mode 1 to determine if the\n         functionality is supported. To do this, the application must attach this extended buffer to the mfxVideoParam structure and call the\n         MFXVideoENCODE_Query function. If the function returns MFX_ERR_NONE, then the functionality is supported.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODED_SLICES_INFO. */\n\n    mfxU16  SliceSizeOverflow;   /*!&lt; When mfxExtCodingOption2::MaxSliceSize is used, indicates the requested slice size was not met for one or more generated slices. */\n    mfxU16  NumSliceNonCopliant; /*!&lt; When mfxExtCodingOption2::MaxSliceSize is used, indicates the number of generated slices exceeds specification limits. */\n    mfxU16  NumEncodedSlice;     /*!&lt; Number of encoded slices. */\n    mfxU16  NumSliceSizeAlloc;   /*!&lt; SliceSize array allocation size. Must be specified by application. */\n    union {\n        mfxU16  *SliceSize;      /*!&lt; Slice size in bytes. Array must be allocated by application. */\n        mfxU64  reserved1;\n    };\n\n    mfxU16 reserved[20];\n} mfxExtEncodedSlicesInfo;\nMFX_PACK_END()\n\n/*! The ScalingMode enumerator itemizes variants of scaling filter implementation. */\nenum {\n    MFX_SCALING_MODE_DEFAULT    = 0, /*!&lt; Default scaling mode. The library selects the most appropriate scaling method. */\n    MFX_SCALING_MODE_LOWPOWER   = 1, /*!&lt; Low power scaling mode which is applicable for library implementations.\n                                         The exact scaling algorithm is defined by the library. */\n    MFX_SCALING_MODE_QUALITY    = 2, /*!&lt; The best quality scaling mode. */\n    MFX_SCALING_MODE_VENDOR = 1000, /*!&lt; The enumeration to separate common scaling controls above and vendor specific. */ \n    MFX_SCALING_MODE_INTEL_GEN_COMPUTE  = MFX_SCALING_MODE_VENDOR + 1, /*! The mode to run scaling operation on Execution Units (EUs). */\n    MFX_SCALING_MODE_INTEL_GEN_VDBOX = MFX_SCALING_MODE_VENDOR + 2, /*! The special optimization mode where scaling operation running on SFC (Scaler &amp; Format Converter) is coupled with VDBOX (also known as Multi-Format Codec Engines). This mode is applicable for DECODE_VPP domain functions. */ \n    MFX_SCALING_MODE_INTEL_GEN_VEBOX = MFX_SCALING_MODE_VENDOR + 3 /*! The special optimization mode where scaling operation running on SFC is coupled with VEBOX (HW video processing pipe). */ \n};\n\n/*! The InterpolationMode enumerator specifies type of interpolation method used by VPP scaling filter. */\nenum {\n    MFX_INTERPOLATION_DEFAULT                = 0, /*!&lt; Default interpolation mode for scaling. Library selects the most appropriate\n                                                    scaling method. */\n    MFX_INTERPOLATION_NEAREST_NEIGHBOR       = 1, /*!&lt; Nearest neighbor interpolation method. */\n    MFX_INTERPOLATION_BILINEAR               = 2, /*!&lt; Bilinear interpolation method. */\n    MFX_INTERPOLATION_ADVANCED               = 3  /*!&lt; Advanced interpolation method is defined by each implementation and usually gives best                                                          quality. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP Scaling filter algorithm.\n   Not all combinations of ScalingMode and InterpolationMethod are supported in the library. The application must use the Query API function to determine if a combination is supported.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_SCALING. */\n\n    mfxU16 ScalingMode;  /*!&lt; Scaling mode. See ScalingMode for values. */\n    mfxU16 InterpolationMethod; /*!&lt; Interpolation mode for scaling algorithm. See InterpolationMode for values. */\n    mfxU16 reserved[10];\n} mfxExtVPPScaling;\nMFX_PACK_END()\n\ntypedef mfxExtAVCRefListCtrl mfxExtHEVCRefListCtrl;\ntypedef mfxExtAVCRefLists mfxExtHEVCRefLists;\ntypedef mfxExtAvcTemporalLayers mfxExtHEVCTemporalLayers;\n\ntypedef mfxExtAVCRefListCtrl mfxExtRefListCtrl;\ntypedef mfxExtAVCEncodedFrameInfo mfxExtEncodedFrameInfo;\n\n/* The MirroringType enumerator itemizes mirroring types. */\nenum\n{\n    MFX_MIRRORING_DISABLED   = 0,\n    MFX_MIRRORING_HORIZONTAL = 1,\n    MFX_MIRRORING_VERTICAL   = 2\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP Mirroring filter algorithm.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_MIRRORING. */\n\n    mfxU16 Type;         /*!&lt; Mirroring type. See MirroringType for values. */\n    mfxU16 reserved[11];\n} mfxExtVPPMirroring;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Instructs encoder to use or not use samples over specified picture border for inter prediction. Attached to the mfxVideoParam structure.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_MV_OVER_PIC_BOUNDARIES. */\n\n    mfxU16 StickTop;     /*!&lt; When set to OFF, one or more samples outside corresponding picture boundary may be used in inter prediction.\n                              See the CodingOptionValue enumerator for values of this option. */\n    mfxU16 StickBottom;  /*!&lt; When set to OFF, one or more samples outside corresponding picture boundary may be used in inter prediction.\n                              See the CodingOptionValue enumerator for values of this option. */\n    mfxU16 StickLeft;    /*!&lt; When set to OFF, one or more samples outside corresponding picture boundary may be used in inter prediction.\n                              See the CodingOptionValue enumerator for values of this option. */\n    mfxU16 StickRight;   /*!&lt; When set to OFF, one or more samples outside corresponding picture boundary may be used in inter prediction.\n                              See the CodingOptionValue enumerator for values of this option. */\n    mfxU16 reserved[8];\n} mfxExtMVOverPicBoundaries;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Configures the VPP ColorFill filter algorithm.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_COLORFILL. */\n\n    mfxU16 Enable;       /*!&lt; Set to ON makes VPP fill the area between Width/Height and Crop borders.\n                              See the CodingOptionValue enumerator for values of this option. */\n    mfxU16 reserved[11];\n} mfxExtVPPColorFill;\nMFX_PACK_END()\n\n\n/*! The ChromaSiting enumerator defines chroma location. Use bit-OR&#x27;ed values to specify the desired location. */\nenum {\n    MFX_CHROMA_SITING_UNKNOWN             = 0x0000, /*!&lt; Unspecified. */\n    MFX_CHROMA_SITING_VERTICAL_TOP        = 0x0001, /*!&lt; Chroma samples are co-sited vertically on the top with the luma samples. */\n    MFX_CHROMA_SITING_VERTICAL_CENTER     = 0x0002, /*!&lt; Chroma samples are not co-sited vertically with the luma samples. */\n    MFX_CHROMA_SITING_VERTICAL_BOTTOM     = 0x0004, /*!&lt; Chroma samples are co-sited vertically on the bottom with the luma samples. */\n    MFX_CHROMA_SITING_HORIZONTAL_LEFT     = 0x0010, /*!&lt; Chroma samples are co-sited horizontally on the left with the luma samples. */\n    MFX_CHROMA_SITING_HORIZONTAL_CENTER   = 0x0020  /*!&lt; Chroma samples are not co-sited horizontally with the luma samples. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   A hint structure that tunes the VPP Color Conversion algorithm when\n   attached to the mfxVideoParam structure during VPP Init.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_COLOR_CONVERSION. */\n\n    mfxU16 ChromaSiting; /*!&lt; See ChromaSiting enumerator for details. */\n    mfxU16 reserved[27];\n} mfxExtColorConversion;\nMFX_PACK_END()\n\n\n/*! The VP9ReferenceFrame enumerator itemizes reference frame type by mfxVP9SegmentParam::ReferenceFrame parameter.  */\nenum {\n    MFX_VP9_REF_INTRA   = 0, /*!&lt; Intra. */\n    MFX_VP9_REF_LAST    = 1, /*!&lt; Last. */\n    MFX_VP9_REF_GOLDEN  = 2, /*!&lt; Golden. */\n    MFX_VP9_REF_ALTREF  = 3  /*!&lt; Alternative reference. */\n};\n\n/*!\n   The SegmentIdBlockSize enumerator indicates the block size represented by each segment_id in segmentation map.\n   These values are used with the mfxExtVP9Segmentation::SegmentIdBlockSize parameter.\n*/\nenum {\n    MFX_VP9_SEGMENT_ID_BLOCK_SIZE_UNKNOWN =  0, /*!&lt; Unspecified block size. */\n    MFX_VP9_SEGMENT_ID_BLOCK_SIZE_8x8     =  8, /*!&lt;  8x8  block size. */\n    MFX_VP9_SEGMENT_ID_BLOCK_SIZE_16x16   = 16, /*!&lt; 16x16 block size. */\n    MFX_VP9_SEGMENT_ID_BLOCK_SIZE_32x32   = 32, /*!&lt; 32x32 block size. */\n    MFX_VP9_SEGMENT_ID_BLOCK_SIZE_64x64   = 64, /*!&lt; 64x64 block size. */\n};\n\n/*!\n   The SegmentFeature enumerator indicates features enabled for the segment.\n   These values are used with the mfxVP9SegmentParam::FeatureEnabled parameter.\n*/\nenum {\n    MFX_VP9_SEGMENT_FEATURE_QINDEX      = 0x0001, /*!&lt; Quantization index delta. */\n    MFX_VP9_SEGMENT_FEATURE_LOOP_FILTER = 0x0002, /*!&lt; Loop filter level delta. */\n    MFX_VP9_SEGMENT_FEATURE_REFERENCE   = 0x0004, /*!&lt; Reference frame. */\n    MFX_VP9_SEGMENT_FEATURE_SKIP        = 0x0008  /*!&lt; Skip. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Contains features and parameters for the segment.\n*/\ntypedef struct {\n    mfxU16  FeatureEnabled;       /*!&lt; Indicates which features are enabled for the segment. See the SegmentFeature enumerator for values for this\n                                       option. Values from the enumerator can be bit-OR&#x27;ed. Support of a particular feature depends on underlying\n                                       hardware platform. Application can check which features are supported by calling Query. */\n    mfxI16  QIndexDelta;          /*!&lt; Quantization index delta for the segment. Ignored if MFX_VP9_SEGMENT_FEATURE_QINDEX isn&#x27;t set in FeatureEnabled.\n                                       Valid range for this parameter is [-255, 255]. If QIndexDelta is out of this range, it will be ignored.\n                                       If QIndexDelta is within valid range, but sum of base quantization index and QIndexDelta is out of [0, 255],\n                                       QIndexDelta will be clamped. */\n    mfxI16  LoopFilterLevelDelta; /*!&lt; Loop filter level delta for the segment. Ignored if MFX_VP9_SEGMENT_FEATURE_LOOP_FILTER is not set in\n                                       FeatureEnabled. Valid range for this parameter is [-63, 63]. If LoopFilterLevelDelta is out of this range,\n                                       it will be ignored. If LoopFilterLevelDelta is within valid range, but sum of base loop filter level and\n                                       LoopFilterLevelDelta is out of [0, 63], LoopFilterLevelDelta will be clamped. */\n    mfxU16  ReferenceFrame;       /*!&lt; Reference frame for the segment. See VP9ReferenceFrame enumerator for values for this option. Ignored\n                                       if MFX_VP9_SEGMENT_FEATURE_REFERENCE isn&#x27;t set in FeatureEnabled. */\n    mfxU16  reserved[12];\n} mfxVP9SegmentParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   In the VP9 encoder it is possible to divide a frame into up to 8 segments and apply particular features (like delta for quantization index or for\n   loop filter level) on a per-segment basis. &quot;Uncompressed header&quot; of every frame indicates if segmentation is enabled for the current frame,\n   and (if segmentation enabled) contains full information about features applied to every segment. Every &quot;Mode info block&quot; of a coded\n   frame has segment_id in the range of 0 to 7.\n\n   To enable Segmentation, the mfxExtVP9Segmentation structure with correct settings should be passed to the encoder. It can be attached to the\n   mfxVideoParam structure during initialization or the MFXVideoENCODE_Reset call (static configuration). If the mfxExtVP9Segmentation buffer isn&#x27;t\n   attached during initialization, segmentation is disabled for static configuration. If the buffer isn&#x27;t attached for the Reset call, the encoder\n   continues to use static configuration for segmentation which was the default before this Reset call. If the mfxExtVP9Segmentation buffer with\n   NumSegments=0 is provided during initialization or Reset call, segmentation becomes disabled for static configuration.\n\n   The buffer can be attached to the mfxEncodeCtrl structure during runtime (dynamic configuration). Dynamic configuration is applied to the\n   current frame only. After encoding of the current frame, the encoder will switch to the next dynamic configuration or to static configuration if dynamic configuration\n   is not provided for next frame).\n\n   The SegmentIdBlockSize, NumSegmentIdAlloc, and SegmentId parameters represent a segmentation map. Here, the segmentation map is an array of segment_ids (one\n   byte per segment_id) for blocks of size NxN in raster scan order. The size NxN is specified by the application and is constant for the whole frame.\n   If mfxExtVP9Segmentation is attached during initialization and/or during runtime, all three parameters should be set to proper values that do not\n   conflict with each other and with NumSegments. If any of the parameters are not set or any conflict or error in these parameters is detected by the library, the segmentation\n   map will be discarded.\n*/\ntypedef struct {\n    mfxExtBuffer        Header;             /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VP9_SEGMENTATION. */\n    mfxU16              NumSegments;        /*!&lt; Number of segments for frame. Value 0 means that segmentation is disabled. Sending 0 for a\n                                                 particular frame will disable segmentation for this frame only. Sending 0 to the Reset API function will\n                                                 disable segmentation permanently. Segmentation can be enabled again by a subsequent Reset call. */\n    mfxVP9SegmentParam  Segment[8];         /*!&lt; Array of mfxVP9SegmentParam structures containing features and parameters for every segment.\n                                                 Entries with indexes bigger than NumSegments-1 are ignored. See the mfxVP9SegmentParam structure for\n                                                 definitions of segment features and their parameters. */\n    mfxU16              SegmentIdBlockSize; /*!&lt; Size of block (NxN) for segmentation map. See SegmentIdBlockSize enumerator for values for this\n                                                 option. An encoded block that is bigger than SegmentIdBlockSize uses segment_id taken from it&#x27;s\n                                                 top-left sub-block from the segmentation map. The application can check if a particular block size is\n                                                 supported by calling Query. */\n    mfxU32              NumSegmentIdAlloc;  /*!&lt; Size of buffer allocated for segmentation map (in bytes). Application must assure that\n                                                 NumSegmentIdAlloc is large enough to cover frame resolution with blocks of size SegmentIdBlockSize.\n                                                 Otherwise the segmentation map will be discarded. */\n    union {\n        mfxU8           *SegmentId;         /*!&lt; Pointer to the segmentation map buffer which holds the array of segment_ids in raster scan order. The application\n                                                 is responsible for allocation and release of this memory. The buffer pointed to by SegmentId, provided during\n                                                 initialization or Reset call should be considered in use until another SegmentId is provided via Reset\n                                                 call (if any), or until MFXVideoENCODE_Close is called. The buffer pointed to by SegmentId provided with\n                                                 mfxEncodeCtrl should be considered in use while the input surface is locked by the library. Every segment_id in the\n                                                 map should be in the range of 0 to NumSegments-1. If some segment_id is out of valid range, the\n                                                 segmentation map cannot be applied. If the mfxExtVP9Segmentation buffer is attached to the mfxEncodeCtrl structure in\n                                                 runtime, SegmentId can be zero. In this case, the segmentation map from static configuration will be used. */\n        mfxU64          reserved1;\n    };\n    mfxU16  reserved[52];\n} mfxExtVP9Segmentation;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Specifies temporal layer.\n*/\ntypedef struct {\n    mfxU16 FrameRateScale;  /*!&lt; The ratio between the frame rates of the current temporal layer and the base layer. The library treats a particular\n                                 temporal layer as &quot;defined&quot; if it has FrameRateScale &gt; 0. If the base layer is defined, it must have FrameRateScale = 1. FrameRateScale of each subsequent layer (if defined) must be a multiple of and greater than the\n                                 FrameRateScale value of previous layer. */\n    mfxU16 TargetKbps;      /*!&lt; Target bitrate for the current temporal layer. Ignored if RateControlMethod is CQP. If RateControlMethod is not CQP, the\n                                 application must provide TargetKbps for every defined temporal layer. TargetKbps of each subsequent layer (if defined)\n                                 must be greater than the TargetKbps value of the previous layer. */\n    mfxU16 reserved[14];\n} mfxVP9TemporalLayer;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   API allows the encoding of VP9 bitstreams that contain several subset bitstreams that differ in frame rates, also called &quot;temporal layers&quot;.\n\n   When decoding, each temporal layer can be extracted from the coded stream and decoded separately. The mfxExtVP9TemporalLayers structure\n   configures the temporal layers for the VP9 encoder. It can be attached to the mfxVideoParam structure during initialization or the\n   MFXVideoENCODE_Reset call. If the mfxExtVP9TemporalLayers buffer isn&#x27;t attached during initialization, temporal scalability is disabled. If the buffer isn&#x27;t attached for the Reset call, the encoder continues to use the temporal scalability configuration that was defined before the Reset call.\n\n   In the API, temporal layers are ordered by their frame rates in ascending order. Temporal layer 0 (having the lowest frame rate) is called the base layer.\n   Each subsequent temporal layer includes all previous layers.\n\n   The temporal scalability feature requires a minimum number of allocated reference\n   frames (controlled by the NumRefFrame parameter). If the NumRefFrame value set by the application isn&#x27;t enough to build the reference structure for the requested\n   number of temporal layers, the library corrects the NumRefFrame value. The temporal layer structure is reset (re-started) after key-frames.\n*/\ntypedef struct {\n    mfxExtBuffer        Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VP9_TEMPORAL_LAYERS. */\n    /*!\n       The array of temporal layers. Layer[0] specifies the base layer.\n\n       The library reads layers from the array when they are defined (FrameRateScale &gt; 0).\n       All layers starting from first layer with FrameRateScale = 0 are ignored. The last layer that is not ignored is considered the &quot;highest layer&quot;.\n\n       The frame rate of the highest layer is specified in the mfxVideoParam structure. Frame rates of lower layers are calculated using their FrameRateScale.\n\n       TargetKbps of the highest layer should be equal to the TargetKbps value specified in the mfxVideoParam structure. If it is not true, TargetKbps of highest temporal layers has priority.\n\n       If there are no defined layers in the Layer array, the temporal scalability feature is disabled. For example, to disable temporal scalability in runtime, the application should\n       pass mfxExtVP9TemporalLayers buffer to Reset with all FrameRateScales set to 0.\n    */\n    mfxVP9TemporalLayer Layer[8];\n    mfxU16              reserved[60];\n} mfxExtVP9TemporalLayers;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Structure attached to the mfxVideoParam structure. Extends the mfxVideoParam structure with VP9-specific parameters. Used by both decoder and encoder.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VP9_PARAM. */\n\n    mfxU16  FrameWidth;      /*!&lt; Width of the coded frame in pixels. */\n    mfxU16  FrameHeight;     /*!&lt; Height of the coded frame in pixels. */\n\n    mfxU16  WriteIVFHeaders; /*!&lt; Set this option to ON to make the encoder insert IVF container headers to the output stream. The NumFrame field of the IVF\n                                  sequence header will be zero. It is the responsibility of the application to update the NumFrame field  with the correct value. See the\n                                  CodingOptionValue enumerator for values of this option. */\n\n    mfxI16  reserved1[6];\n    mfxI16  QIndexDeltaLumaDC;   /*!&lt; Specifies an offset for a particular quantization parameter. */\n    mfxI16  QIndexDeltaChromaAC; /*!&lt; Specifies an offset for a particular quantization parameter. */\n    mfxI16  QIndexDeltaChromaDC; /*!&lt; Specifies an offset for a particular quantization parameter. */\n    /*!\n       Number of tile rows. Should be power of two. The maximum number of tile rows is 4, per the VP9 specification. In addition, the maximum supported number\n       of tile rows may depend on the underlying library implementation.\n\n       Use the Query API function to check if a particular pair of values (NumTileRows, NumTileColumns)\n       is supported. In VP9, tile rows have dependencies and cannot be encoded or decoded in parallel. Therefore, tile rows are always encoded by the library in\n       serial mode (one-by-one).\n    */\n    mfxU16  NumTileRows;\n    /*!\n       Number of tile columns. Should be power of two. Restricted with maximum and minimum tile width in luma pixels, as defined in the VP9\n       specification (4096 and 256 respectively). In addition, the maximum supported number of tile columns may depend on the underlying library\n       implementation.\n\n       Use the Query API function to check if a particular pair of values (NumTileRows, NumTileColumns) is supported. In VP9,  tile columns do not have\n       dependencies and can be encoded/decoded in parallel. Therefore, tile columns can be encoded by the library in both parallel and serial modes.\n\n       Parallel mode is automatically utilized by the library when NumTileColumns exceeds 1 and does not exceed the number of tile coding engines on the\n       platform. In other cases, serial mode is used. Parallel mode is capable of encoding more than 1 tile row (within limitations provided by VP9\n       specification and particular platform). Serial mode supports only tile grids 1xN and Nx1.\n    */\n    mfxU16  NumTileColumns;\n    mfxU16  reserved[110];\n} mfxExtVP9Param;\nMFX_PACK_END()\n\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used to report encoded unit information.\n*/\ntypedef struct {\n    mfxU16 Type;      /*!&lt; Codec-dependent coding unit type (NALU type for AVC/HEVC, start_code for MPEG2 etc). */\n    mfxU16 reserved1;\n    mfxU32 Offset;    /*!&lt; Offset relative to the associated mfxBitstream::DataOffset. */\n    mfxU32 Size;      /*!&lt; Unit size, including delimiter. */\n    mfxU32 reserved[5];\n} mfxEncodedUnitInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_L_TYPE()\n/*!\n   If mfxExtCodingOption3::EncodedUnitsInfo was set to MFX_CODINGOPTION_ON during encoder initialization, the mfxExtEncodedUnitsInfo structure is\n   attached to the mfxBitstream structure during encoding. It is used to report information about coding units in the resulting bitstream.\n\n   The number of filled items in UnitInfo is min(NumUnitsEncoded, NumUnitsAlloc).\n\n   For counting a minimal amount of encoded units you can use the following algorithm:\n   @code\n      nSEI = amountOfApplicationDefinedSEI;\n      if (CodingOption3.NumSlice[IPB] != 0 || mfxVideoParam.mfx.NumSlice != 0)\n        ExpectedAmount = 10 + nSEI + Max(CodingOption3.NumSlice[IPB], mfxVideoParam.mfx.NumSlice);\n      else if (CodingOption2.NumMBPerSlice != 0)\n        ExpectedAmount = 10 + nSEI + (FrameWidth * FrameHeight) / (256 * CodingOption2.NumMBPerSlice);\n      else if (CodingOption2.MaxSliceSize != 0)\n        ExpectedAmount = 10 + nSEI + Round(MaxBitrate / (FrameRate*CodingOption2.MaxSliceSize));\n      else\n        ExpectedAmount = 10 + nSEI;\n\n      if (mfxFrameInfo.PictStruct != MFX_PICSTRUCT_PROGRESSIVE)\n        ExpectedAmount = ExpectedAmount * 2;\n\n      if (temporalScaleabilityEnabled)\n        ExpectedAmount = ExpectedAmount * 2;\n    @endcode\n    @note Only supported by the AVC encoder.\n*/\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_ENCODED_UNITS_INFO. */\n\n    union {\n        mfxEncodedUnitInfo *UnitInfo; /*!&lt; Pointer to an array of mfxEncodedUnitsInfo structures whose size is equal to or greater than NumUnitsAlloc. */\n        mfxU64  reserved1;\n    };\n    mfxU16 NumUnitsAlloc;             /*!&lt; UnitInfo array size. */\n    mfxU16 NumUnitsEncoded;           /*!&lt; Output field. Number of coding units to report. If NumUnitsEncoded is greater than NumUnitsAlloc, the UnitInfo\n                                           array will contain information only for the first NumUnitsAlloc units. User may consider reallocating the\n                                           UnitInfo array to avoid this for subsequent frames. */\n\n    mfxU16 reserved[22];\n} mfxExtEncodedUnitsInfo;\nMFX_PACK_END()\n\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Provides setup for the Motion-Compensated Temporal Filter (MCTF) during the VPP initialization and for control\n   parameters at runtime. By default, MCTF is off. An application may enable it by adding MFX_EXTBUFF_VPP_MCTF to the mfxExtVPPDoUse buffer or by\n   attaching mfxExtVppMctf to the mfxVideoParam structure during initialization or reset.\n*/\ntypedef struct {\n    mfxExtBuffer Header;         /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_MCTF. */\n    mfxU16       FilterStrength; /*!&lt; Value in range of 0 to 20 (inclusive) to indicate the filter strength of MCTF.\n\n                                    The strength of the MCTF process controls the degree of possible change of pixel values eligible for MCTF - the greater the strength value, the larger the change. It is a dimensionless quantity - values in the range of 1 to 20 inclusively imply strength; value 0 stands for AUTO mode and is\n                                      valid during initialization or reset only\n\n                                    If an invalid value is given, it is fixed to the default value of 0.\n                                      If the field value is in the range of 1 to 20 inclusive, MCTF operates in fixed-strength mode with the given strength of MCTF process.\n\n                                      At runtime, values of 0 and greater than 20 are ignored. */\n    mfxU16       reserved[27];\n} mfxExtVppMctf;\nMFX_PACK_END()\n\n/*! Describes type of workload passed to MFXQueryAdapters. */\ntypedef enum\n{\n    MFX_COMPONENT_ENCODE = 1, /*!&lt; Encode workload. */\n    MFX_COMPONENT_DECODE = 2, /*!&lt; Decode workload. */\n    MFX_COMPONENT_VPP    = 3  /*!&lt; VPP workload. */\n} mfxComponentType;\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Contains workload description, which is accepted by MFXQueryAdapters function.\n*/\ntypedef struct\n{\n    mfxComponentType Type;         /*!&lt; Type of workload: Encode, Decode, VPP. See mfxComponentType enumerator for values. */\n    mfxVideoParam    Requirements; /*!&lt; Detailed description of workload. See mfxVideoParam for details. */\n\n    mfxU16           reserved[4];\n} mfxComponentInfo;\nMFX_PACK_END()\n\n/* Adapter description */\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Contains a description of the graphics adapter for the Legacy mode.\n*/\ntypedef struct\n{\n    mfxPlatform Platform; /*!&lt; Platform type description. See mfxPlatform for details. */\n    mfxU32      Number;   /*!&lt; Value which uniquely characterizes media adapter. On Windows* this number can be used for initialization through\n                               DXVA interface (see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgifactory1-enumadapters1&quot;&gt;example&lt;/a&gt;). */\n\n    mfxU16      reserved[14];\n} mfxAdapterInfo;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   Contains description of all graphics adapters available on the current system.\n*/\ntypedef struct\n{\n    mfxAdapterInfo * Adapters;  /*!&lt; Pointer to array of mfxAdapterInfo structs allocated by user. */\n    mfxU32           NumAlloc;  /*!&lt; Length of Adapters array. */\n    mfxU32           NumActual; /*!&lt; Number of Adapters entries filled by MFXQueryAdapters. */\n\n    mfxU16           reserved[4];\n} mfxAdaptersInfo;\nMFX_PACK_END()\n\n\n/*! The PartialBitstreamOutput enumerator indicates flags of partial bitstream output type. */\nenum {\n    MFX_PARTIAL_BITSTREAM_NONE    = 0, /*!&lt; Do not use partial output */\n    MFX_PARTIAL_BITSTREAM_SLICE   = 1, /*!&lt; Partial bitstream output will be aligned to slice granularity */\n    MFX_PARTIAL_BITSTREAM_BLOCK   = 2, /*!&lt; Partial bitstream output will be aligned to user-defined block size granularity */\n    MFX_PARTIAL_BITSTREAM_ANY     = 3  /*!&lt; Partial bitstream output will be return any coded data available at the end of SyncOperation timeout */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n   Used by an encoder to output parts of the bitstream as soon as they are ready. The application can attach this extended buffer to the\n   mfxVideoParam structure at initialization. If this option is turned ON (Granularity != MFX_PARTIAL_BITSTREAM_NONE), then the encoder can output\n   bitstream by part based on the required granularity.\n\n   This parameter is valid only during initialization and reset. Absence of this buffer means default or previously configured bitstream output\n   behavior.\n\n   @note Not all codecs and implementations support this feature. Use the Query API function to check if this feature is supported.\n*/\ntypedef struct {\n    mfxExtBuffer    Header;      /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_PARTIAL_BITSTREAM_PARAM. */\n    mfxU32          BlockSize;   /*!&lt; Output block granularity for PartialBitstreamGranularity. Valid only for MFX_PARTIAL_BITSTREAM_BLOCK. */\n    mfxU16          Granularity; /*!&lt; Granularity of the partial bitstream: slice/block/any, all types of granularity state in PartialBitstreamOutput enum. */\n    mfxU16          reserved[8];\n} mfxExtPartialBitstreamParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n   The mfxExtDeviceAffinityMask structure is used by the application to specify\n   affinity mask for the device with given device ID. See mfxDeviceDescription\n   for the device ID definition and sub device indexes. If the implementation\n   manages CPU threads for some purpose, the user can set the CPU thread affinity\n   mask by using this structure with DeviceID set to &quot;CPU&quot;.\n*/\ntypedef struct {\n    /*! Extension buffer header. Header.BufferId must be equal to\n        MFX_EXTBUFF_DEVICE_AFFINITY_MASK. */\n    mfxExtBuffer    Header;\n    /*! Null terminated string with device ID. In case of CPU affinity mask\n        it must be equal to &quot;CPU&quot;. */\n    mfxChar         DeviceID[MFX_STRFIELD_LEN];\n    /*! Number of sub devices or threads in case of CPU in the mask. */\n    mfxU32          NumSubDevices;\n    /*! Mask array. Every bit represents sub-device (or thread for CPU).\n        &quot;1&quot; means execution is allowed. &quot;0&quot; means that execution is prohibited on\n        this sub-device (or thread). Length of the array is equal to the:\n        &quot;NumSubDevices / 8&quot; and rounded to the closest (from the right) integer.\n        Bits order within each entry of the mask array is LSB: bit 0 holds data\n        for sub device with index 0 and bit 8 for sub device with index 8.\n        Index of sub device is defined by the mfxDeviceDescription structure. */\n    mfxU8           *Mask;\n    mfxU32           reserved[4]; /*! Reserved for future use. */\n} mfxExtDeviceAffinityMask;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used by AV1 encoder with more parameter control to encode frame. */\ntypedef struct {\n    mfxExtBuffer Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AV1_BITSTREAM_PARAM. */\n\n    mfxU16 WriteIVFHeaders; /*!&lt; Tri-state option to control IVF headers insertion, default is ON.\n                                Writing IVF headers is enabled in the encoder when mfxExtAV1BitstreamParam is attached and its value is ON or zero.\n                                Writing IVF headers is disabled by default in the encoder when mfxExtAV1BitstreamParam is not attached. */\n\n    mfxU16 reserved[31];\n} mfxExtAV1BitstreamParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used by AV1 encoder with more parameter control to encode frame. */\ntypedef struct {\n    mfxExtBuffer Header; /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AV1_RESOLUTION_PARAM. */\n\n    mfxU32 FrameWidth;   /*!&lt; Width of the coded frame in pixels, default value is from mfxFrameInfo. */\n    mfxU32 FrameHeight;  /*!&lt; Height of the coded frame in pixels, default value is from mfxFrameInfo. */\n\n    mfxU32 reserved[6];\n} mfxExtAV1ResolutionParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n  /*! The structure is used by AV1 encoder with more parameter control to encode frame. */\ntypedef struct {\n    mfxExtBuffer Header;   /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AV1_TILE_PARAM. */\n\n    mfxU16 NumTileRows;    /*!&lt; Number of tile rows, default value is 1. */\n    mfxU16 NumTileColumns; /*!&lt; Number of tile columns, default value is 1. */\n    mfxU16 NumTileGroups;  /*!&lt; Number of tile groups, it will be ignored if the tile groups num is invalid, default value is 1. */\n\n    mfxU16 reserved[5];\n} mfxExtAV1TileParam;\nMFX_PACK_END()\n\n/*!\n    The AV1 SegmentIdBlockSize enumerator indicates the block size represented by each segment_id in segmentation map.\n    These values are used with the mfxExtAV1Segmentation::SegmentIdBlockSize parameter.\n*/\ntypedef enum {\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_UNSPECIFIED = 0,  /*!&lt; Unspecified block size. */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_4x4         = 4,  /*!&lt; block size 4x4 */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_8x8         = 8,  /*!&lt; block size 8x8 */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_16x16       = 16, /*!&lt; block size 16x16 */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_32x32       = 32, /*!&lt; block size 32x32 */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_64x64       = 64, /*!&lt; block size 64x64 */\n    MFX_AV1_SEGMENT_ID_BLOCK_SIZE_128x128     = 128 /*!&lt; block size 128x128 */\n} mfxAV1SegmentIdBlockSize;\n\n/*!\n    The AV1 SegmentFeature enumerator indicates features enabled for the segment.\n    These values are used with the mfxAV1SegmentParam::FeatureEnabled parameter.\n*/\nenum {\n    MFX_AV1_SEGMENT_FEATURE_ALT_QINDEX    = 0x0001, /*!&lt; use alternate Quantizer. */\n    MFX_AV1_SEGMENT_FEATURE_ALT_LF_Y_VERT = 0x0002, /*!&lt; use alternate loop filter value on y plane vertical. */\n    MFX_AV1_SEGMENT_FEATURE_ALT_LF_Y_HORZ = 0x0004, /*!&lt; use alternate loop filter value on y plane horizontal. */\n    MFX_AV1_SEGMENT_FEATURE_ALT_LF_U      = 0x0008, /*!&lt; use alternate loop filter value on u plane. */\n    MFX_AV1_SEGMENT_FEATURE_ALT_LF_V      = 0x0010, /*!&lt; use alternate loop filter value on v plane. */\n    MFX_AV1_SEGMENT_FEATURE_REFERENCE     = 0x0020, /*!&lt; use segment reference frame. */\n    MFX_AV1_SEGMENT_FEATURE_SKIP          = 0x0040, /*!&lt; use segment (0,0) + skip mode. */\n    MFX_AV1_SEGMENT_FEATURE_GLOBALMV      = 0x0080  /*!&lt; use global motion vector. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*!\n    Contains features and parameters for the segment.\n*/\ntypedef struct {\n    mfxU16 FeatureEnabled;  /*!&lt; Indicates which features are enabled for the segment. See the AV1 SegmentFeature enumerator for values for\n                                this option. Values from the enumerator can be bit-OR&#x27;ed. Support of a particular feature depends on underlying\n                                hardware platform. Application can check which features are supported by calling Query. */\n    mfxI16 AltQIndex;       /*!&lt; Quantization index delta for the segment. Ignored if MFX_AV1_SEGMENT_FEATURE_ALT_QINDEX isn&#x27;t set in FeatureEnabled.\n                                Valid range for this parameter is [-255, 255]. If AltQIndex is out of this range, it will be ignored. If AltQIndex\n                                is within valid range, but sum of base quantization index and AltQIndex is out of [0, 255], AltQIndex will be clamped. */\n    mfxU16 reserved[30];\n} mfxAV1SegmentParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*!\n    In the AV1 encoder it is possible to divide a frame into up to 8 segments and apply particular features (like delta for quantization index or for\n    loop filter level) on a per-segment basis. &quot;Uncompressed header&quot; of every frame indicates if segmentation is enabled for the current frame,\n    and (if segmentation enabled) contains full information about features applied to every segment. Every &quot;Mode info block&quot; of a coded\n    frame has segment_id in the range of 0 to 7.\n    To enable Segmentation, the mfxExtAV1Segmentation structure with correct settings should be passed to the encoder. It can be attached to the\n    mfxVideoParam structure during initialization or the MFXVideoENCODE_Reset call (static configuration). If the mfxExtAV1Segmentation buffer isn&#x27;t\n    attached during initialization, segmentation is disabled for static configuration. If the buffer isn&#x27;t attached for the Reset call, the encoder\n    continues to use static configuration for segmentation which was the default before this Reset call. If the mfxExtAV1Segmentation buffer with\n    NumSegments=0 is provided during initialization or Reset call, segmentation becomes disabled for static configuration.\n    The buffer can be attached to the mfxEncodeCtrl structure during runtime (dynamic configuration). Dynamic configuration is applied to the\n    current frame only. After encoding of the current frame, the encoder will switch to the next dynamic configuration or to static configuration if\n    dynamic configuration is not provided for next frame).\n    The SegmentIdBlockSize, NumSegmentIdAlloc, and SegmentId parameters represent a segmentation map. Here, the segmentation map is an array of\n    segment_ids (one byte per segment_id) for blocks of size NxN in raster scan order. The size NxN is specified by the application and is constant\n    for the whole frame.\n    If mfxExtAV1Segmentation is attached during initialization and/or during runtime, all three parameters should be set to proper values that do not\n    conflict with each other and with NumSegments. If any of the parameters are not set or any conflict or error in these parameters is detected by\n    the library, the segmentation map will be discarded.\n*/\ntypedef struct {\n    mfxExtBuffer       Header;            /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AV1_SEGMENTATION. */\n    mfxU8              NumSegments;       /*!&lt; Number of segments for frame. Value 0 means that segmentation is disabled. Sending 0 for a\n                                                particular frame will disable segmentation for this frame only. Sending 0 to the Reset API function will\n                                                disable segmentation permanently. Segmentation can be enabled again by a subsequent Reset call. */\n    mfxU8              reserved1[3];\n    mfxAV1SegmentParam Segment[8];        /*!&lt; Array of mfxAV1SegmentParam structures containing features and parameters for every segment.\n                                                Entries with indexes bigger than NumSegments-1 are ignored. See the mfxAV1SegmentParam structure for\n                                                definitions of segment features and their parameters. */\n    mfxU16             SegmentIdBlockSize;/*!&lt; Size of block (NxN) for segmentation map. See AV1 SegmentIdBlockSize enumerator for values for this\n                                                option. An encoded block that is bigger than AV1 SegmentIdBlockSize uses segment_id taken from it&#x27;s\n                                                top-left sub-block from the segmentation map. The application can check if a particular block size is\n                                                supported by calling Query. */\n    mfxU16             reserved2;\n    mfxU32             NumSegmentIdAlloc; /*!&lt; Size of buffer allocated for segmentation map (in bytes). Application must assure that\n                                                NumSegmentIdAlloc is large enough to cover frame resolution with blocks of size SegmentIdBlockSize.\n                                                Otherwise the segmentation map will be discarded. */\n    mfxU8 *            SegmentIds;        /*!&lt; Pointer to the segmentation map buffer which holds the array of segment_ids in raster scan order. The application\n                                                is responsible for allocation and release of this memory. The buffer pointed to by SegmentId, provided during\n                                                initialization or Reset call should be considered in use until another SegmentId is provided via Reset\n                                                call (if any), or until MFXVideoENCODE_Close is called. The buffer pointed to by SegmentId provided with\n                                                mfxEncodeCtrl should be considered in use while the input surface is locked by the library. Every segment_id in the\n                                                map should be in the range of 0 to NumSegments-1. If some segment_id is out of valid range, the\n                                                segmentation map cannot be applied. If the mfxExtAV1Segmentation buffer is attached to the mfxEncodeCtrl structure in\n                                                runtime, SegmentId can be zero. In this case, the segmentation map from static configuration will be used. */\n    mfxU16             reserved[36];\n} mfxExtAV1Segmentation;\nMFX_PACK_END()\n\n/*! The FilmGrainFlags enumerator itemizes flags in AV1 film grain parameters.\n    The flags are equivalent to respective syntax elements from film_grain_params() section of uncompressed header. */\nenum {\n    MFX_FILM_GRAIN_NO                       =       0, /*!&lt; Film grain isn&#x27;t added to this frame. */\n    MFX_FILM_GRAIN_APPLY                    = (1 &lt;&lt; 0), /*!&lt; Film grain is added to this frame. */\n    MFX_FILM_GRAIN_UPDATE                   = (1 &lt;&lt; 1), /*!&lt; New set of film grain parameters is sent for this frame. */\n    MFX_FILM_GRAIN_CHROMA_SCALING_FROM_LUMA = (1 &lt;&lt; 2), /*!&lt; Chroma scaling is inferred from luma scaling. */\n    MFX_FILM_GRAIN_OVERLAP                  = (1 &lt;&lt; 3), /*!&lt; Overlap between film grain blocks is applied. */\n    MFX_FILM_GRAIN_CLIP_TO_RESTRICTED_RANGE = (1 &lt;&lt; 4) /*!&lt; Clipping to the restricted (studio) range is applied after adding the film grain. */\n};\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Defines film grain point. */\ntypedef struct {\n    mfxU8 Value; /*!&lt;  The x coordinate for the i-th point of the piece-wise linear scaling function for luma/Cb/Cr component. */\n    mfxU8 Scaling; /*!&lt;  The scaling (output) value for the i-th point of the piecewise linear scaling function for luma/Cb/Cr component. */\n} mfxAV1FilmGrainPoint;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used by AV-1 decoder to report film grain parameters for decoded frame. */\ntypedef struct {\n    mfxExtBuffer Header;    /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_AV1_FILM_GRAIN_PARAM. */\n\n    mfxU16 FilmGrainFlags;  /*!&lt; Bit map with bit-ORed flags from FilmGrainFlags enum. */\n    mfxU16 GrainSeed;       /*!&lt; Starting value for pseudo-random numbers used during film grain synthesis. */\n\n    mfxU8  RefIdx;          /*!&lt; Indicate which reference frame contains the film grain parameters to be used for this frame. */\n    mfxU8  NumYPoints;      /*!&lt; The number of points for the piece-wise linear scaling function of the luma component. */\n    mfxU8  NumCbPoints;     /*!&lt; The number of points for the piece-wise linear scaling function of the Cb component. */\n    mfxU8  NumCrPoints;     /*!&lt; The number of points for the piece-wise linear scaling function of the Cr component.*/\n\n    mfxAV1FilmGrainPoint PointY[14]; /*!&lt; The array of points for luma component. */\n    mfxAV1FilmGrainPoint PointCb[10]; /*!&lt; The array of points for Cb component. */\n    mfxAV1FilmGrainPoint PointCr[10]; /*!&lt; The array of points for Cr component. */\n\n    mfxU8 GrainScalingMinus8; /*!&lt; The shift - 8 applied to the values of the chroma component. The grain_scaling_minus_8 can take values of 0..3 and\n                                   determines the range and quantization step of the standard deviation of film grain.*/\n    mfxU8 ArCoeffLag;         /*!&lt; The number of auto-regressive coefficients for luma and chroma.*/\n\n    mfxU8 ArCoeffsYPlus128[24];  /*!&lt; Auto-regressive coefficients used for the Y plane. */\n    mfxU8 ArCoeffsCbPlus128[25]; /*!&lt; Auto-regressive coefficients used for the Cb plane. */\n    mfxU8 ArCoeffsCrPlus128[25]; /*!&lt; The number of points for the piece-wise linear scaling function of the Cr component.*/\n\n    mfxU8 ArCoeffShiftMinus6;  /*!&lt; The range of the auto-regressive coefficients.\n                                    Values of 0, 1, 2, and 3 correspond to the ranges for auto-regressive coefficients of\n                                    [-2, 2), [-1, 1), [-0.5, 0.5) and [-0.25, 0.25) respectively.*/\n    mfxU8 GrainScaleShift;     /*!&lt; Downscaling factor of the grain synthesis process for the Gaussian random numbers .*/\n\n    mfxU8  CbMult;     /*!&lt; The multiplier for the Cb component used in derivation of the input index to the Cb component scaling function.*/\n    mfxU8  CbLumaMult; /*!&lt; The multiplier for the average luma component used in derivation of the input index to the Cb component scaling function. */\n    mfxU16 CbOffset;   /*!&lt; The offset used in derivation of the input index to the Cb component scaling function.*/\n\n    mfxU8  CrMult;     /*!&lt; The multiplier for the Cr component used in derivation of the input index to the Cr component scaling function.*/\n    mfxU8  CrLumaMult; /*!&lt; The multiplier for the average luma component used in derivation of the input index to the Cr component scaling function.*/\n    mfxU16 CrOffset;   /*!&lt; The offset used in derivation of the input index to the Cr component scaling function.*/\n\n    mfxU16 reserved[43];\n} mfxExtAV1FilmGrainParam;\nMFX_PACK_END()\n\n#define MFX_SURFACEARRAY_VERSION MFX_STRUCT_VERSION(1, 0)\n\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The structure is reference counted object to return array of surfaces allocated and processed by the library. */\ntypedef struct mfxSurfaceArray\n{\n    mfxHDL              Context; /*!&lt; The context of the memory interface. User should not touch (change, set, null) this pointer. */\n    mfxStructVersion    Version; /*!&lt; The version of the structure. */\n    mfxU16 reserved[3];\n    /*! @brief\n    Increments the internal reference counter of the surface. The surface is not destroyed until the surface is released using the mfxSurfaceArray::Release function.\n    mfxSurfaceArray::AddRef should be used each time a new link to the surface is created (for example, copy structure) for proper surface management.\n\n    @param[in]  surface  Valid mfxSurfaceArray.\n\n    @return\n     MFX_ERR_NONE              If no error. \\n\n     MFX_ERR_NULL_PTR          If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE    If mfxSurfaceArray-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN           Any internal error.\n\n    */\n    mfxStatus (MFX_CDECL *AddRef)(struct mfxSurfaceArray*  surface_array);\n    /*! @brief\n    Decrements the internal reference counter of the surface. mfxSurfaceArray::Release should be called after\n    using the mfxSurfaceArray::AddRef function to add a surface or when allocation logic requires it.\n\n    @param[in]  surface_array  Valid mfxSurfaceArray.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxSurfaceArray-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNDEFINED_BEHAVIOR If Reference Counter of surface is zero before call. \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus (MFX_CDECL *Release)(struct mfxSurfaceArray*  surface_array);\n\n    /*! @brief\n    Returns current reference counter of mfxSurfaceArray structure.\n\n    @param[in]   surface  Valid surface_array.\n    @param[out]  counter  Sets counter to the current reference counter value.\n\n    @return\n     MFX_ERR_NONE               If no error. \\n\n     MFX_ERR_NULL_PTR           If surface or counter is NULL. \\n\n     MFX_ERR_INVALID_HANDLE     If mfxSurfaceArray-&gt;Context is invalid (for example NULL). \\n\n     MFX_ERR_UNKNOWN            Any internal error.\n    */\n    mfxStatus (MFX_CDECL *GetRefCounter)(struct mfxSurfaceArray*  surface_array, mfxU32* counter);\n\n    mfxFrameSurface1** Surfaces; /*!&lt; The array of pointers to mfxFrameSurface1. mfxFrameSurface1 surfaces are allocated by the same\n    agent who allocates mfxSurfaceArray. */\n    mfxU32 NumSurfaces; /*!&lt;The size of array of pointers to mfxFrameSurface1. */\n    mfxU32 reserved1;\n} mfxSurfaceArray;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The structure is used for VPP channels initialization in Decode_VPP component.  */\ntypedef struct {\n    mfxFrameInfo  VPP; /*!&lt; The configuration parameters of VPP filters per each channel. */\n    mfxU16  Protected; /*!&lt; Specifies the content protection mechanism. */\n    mfxU16  IOPattern; /*!&lt; Output memory access types for SDK functions. */\n    mfxExtBuffer** ExtParam; /*!&lt; Points to an array of pointers to the extra configuration structures; see the ExtendedBufferID enumerator for a list of extended configurations. */\n    mfxU16  NumExtParam; /*!&lt; The number of extra configuration structures attached to the structure. */\n    mfxU16  reserved1[7];\n} mfxVideoChannelParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure describes rectangle coordinates that can be used for ROI or for Cropping. */\n    typedef struct {\n        mfxU16  Left;   /*!&lt; X coordinate of region of top-left corner of rectangle. */\n        mfxU16  Top;    /*!&lt; Y coordinate of region of top-left corner of rectangle. */\n        mfxU16  Right;  /*!&lt; X coordinate of region of bottom-right corner of rectangle. */\n        mfxU16  Bottom; /*!&lt; Y coordinate of region of bottom-right corner of rectangle. */\n    } mfxRect;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure contains crop parameters which applied by Decode_VPP component to input surfaces before video processing operation.\n    It is used for letterboxing operations.\n*/\ntypedef struct {\n    mfxExtBuffer     Header; /*! Extension buffer header. BufferId must be equal to MFX_EXTBUFF_CROPS. */\n    mfxRect          Crops;  /*!&lt; Crops parameters for letterboxing operations. */\n    mfxU32           reserved[4];\n}mfxExtInCrops;\nMFX_PACK_END()\n\n/*! The mfxHyperMode enumerator describes HyperMode implementation behavior. */\ntypedef enum {\n    MFX_HYPERMODE_OFF = 0x0,        /*!&lt; Don&#x27;t use HyperMode implementation. */\n    MFX_HYPERMODE_ON = 0x1,         /*!&lt; Enable HyperMode implementation and return error if some issue on initialization. */\n    MFX_HYPERMODE_ADAPTIVE = 0x2,   /*!&lt; Enable HyperMode implementation and switch to single fallback if some issue on initialization. */\n} mfxHyperMode;\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used for HyperMode initialization. */\ntypedef struct {\n    mfxExtBuffer    Header; /*!&lt; Extension buffer header. BufferId must be equal to MFX_EXTBUFF_HYPER_MODE_PARAM. */\n    mfxHyperMode    Mode;   /*!&lt; HyperMode implementation behavior. */\n    mfxU16          reserved[19];\n} mfxExtHyperModeParam;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used for universal temporal layer description. */\ntypedef struct {\n    mfxU16 FrameRateScale;  /*!&lt; The ratio between the frame rates of the current temporal layer and the base layer. The library treats a particular\n                                 temporal layer as &quot;defined&quot; if it has FrameRateScale &gt; 0. If the base layer is defined, it must have FrameRateScale = 1. \n                                 FrameRateScale of each subsequent layer (if defined) must be a multiple of and greater than the\n                                 FrameRateScale value of previous layer. */\n    mfxU16  reserved[3]; /*!&lt; Reserved for future use. */\n                                 \n    union {\n          /*!&lt; Type of bitrate controls is currently the same across all temporal layers and inherits from common parameters. */ \n          struct {\n            mfxU32  InitialDelayInKB;/*!&lt; Initial size of the Video Buffering Verifier (VBV) buffer for the current temporal layer.\n                                          @note In this context, KB is 1000 bytes and Kbps is 1000 bps. */\n            mfxU32  BufferSizeInKB; /*!&lt; Represents the maximum possible size of any compressed frames for the current temporal layer. */\n            mfxU32  TargetKbps;  /*!&lt; Target bitrate for the current temporal layer. If RateControlMethod is not CQP, the\n                                      application can provide TargetKbps for every defined temporal layer. If TargetKbps per temporal layer is not set then \n                                      encoder doesn&#x27;t apply any special bitrate limitations for the layer.  */\n            mfxU32  MaxKbps;  /*!&lt; The maximum bitrate at which the encoded data enters the Video Buffering Verifier (VBV) buffer for the current temporal layer. */\n\n            mfxU32  reserved1[16]; /*!&lt; Reserved for future use. */\n            \n          };\n          struct {\n            mfxI32  QPI;  /*!&lt; Quantization Parameter (QP) for I-frames for constant QP mode (CQP) for the current temporal layer. Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPI might be clipped to supported QPI range. \n                    @note Default QPI value is implementation dependent and subject to change without additional notice in this document. */\n            mfxI32  QPP;  /*!&lt; Quantization Parameter (QP) for P-frames for constant QP mode (CQP) for the current temporal layer. Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPP might be clipped to supported QPI range.\n                    @note Default QPP value is implementation dependent and subject to change without additional notice in this document. */\n            mfxI32  QPB; /*!&lt; Quantization Parameter (QP) for B-frames for constant QP mode (CQP) for the current temporal layer. Zero QP is not valid and means that the default value is assigned by the library.\n                    Non-zero QPI might be clipped to supported QPB range.\n                    @note Default QPB value is implementation dependent and subject to change without additional notice in this document. */\n          };\n    };\n    mfxU16  reserved2[4]; /*!&lt; Reserved for future use. */\n    \n} mfxTemporalLayer;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The structure is used for universal temporal layers description. */\ntypedef struct {\n    mfxExtBuffer     Header;     /*! Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_UNIVERSAL_TEMPORAL_LAYERS. */\n    mfxU16           NumLayers; /*!&lt; The  number of temporal layers. */\n    mfxU16           BaseLayerPID; /*!&lt; The priority ID of the base layer. The encoder increases the ID for each temporal layer and writes to the prefix NAL unit for AVC and HEVC. */\n    mfxU16           reserved[2]; /*!&lt; Reserved for future use. */\n    mfxTemporalLayer *Layers; /*!&lt; The array of temporal layers. */\n    \n    mfxU16 reserved1[8]; /*!&lt; Reserved for future use. */\n} mfxExtTemporalLayers;\nMFX_PACK_END()\n\n#ifdef ONEVPL_EXPERIMENTAL\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The structure is used to get a synchronization object which signalizes about submission of a task to GPU.  */\ntypedef struct {\n    mfxExtBuffer     Header;     /*! Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_SYNCSUBMISSION. */\n    mfxSyncPoint     *SubmissionSyncPoint; /*!&lt; SyncPoint object to get a moment of a submission task to GPU.  */\n    mfxU32 reserved1[8]; /*!&lt; Reserved for future use. */\n} mfxExtSyncSubmission;\nMFX_PACK_END()\n#endif\n\n#ifdef ONEVPL_EXPERIMENTAL\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! The structure is used to configure perceptual encoding prefilter in VPP. */\ntypedef struct {\n    mfxExtBuffer Header;         /*! Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_VPP_PERC_ENC_PREFILTER. */\n    mfxU16       reserved[252];\n} mfxExtVPPPercEncPrefilter;\nMFX_PACK_END()\n#endif\n\n#ifdef ONEVPL_EXPERIMENTAL\n/*! The TuneQuality enumerator specifies tuning option for encode. Multiple tuning options can be combined using bit mask. */\nenum {\n    MFX_ENCODE_TUNE_OFF = 0,  /*!&lt; Tuning quality is disabled.  */\n    MFX_ENCODE_TUNE_PSNR    = 0x1, /*!&lt; The encoder optimizes quality according to Peak Signal-to-Noise Ratio (PSNR) metric. */\n    MFX_ENCODE_TUNE_SSIM    = 0x2, /*!&lt; The encoder optimizes quality according to Structural Similarity Index Measure (SSIM) metric. */\n    MFX_ENCODE_TUNE_MS_SSIM = 0x4, /*!&lt; The encoder optimizes quality according to Multi-Scale Structural Similarity Index Measure (MS-SSIM) metric. */\n    MFX_ENCODE_TUNE_VMAF    = 0x8, /*!&lt; The encoder optimizes quality according to Video Multi-Method Assessment Fusion (VMAF) metric. */\n    MFX_ENCODE_TUNE_PERCEPTUAL    = 0x10, /*!&lt; The encoder makes perceptual quality optimization. */\n};\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The structure specifies type of quality optimization used by the encoder. The buffer can also be attached for VPP functions to make correspondent pre-filtering. */\ntypedef struct {\n    mfxExtBuffer   Header;         /*!&lt; Extension buffer header. Header.BufferId must be equal to MFX_EXTBUFF_TUNE_ENCODE_QUALITY. */\n    mfxU32         TuneQuality;    /*!&lt; The control to specify type of encode quality metric(s) to optimize; See correspondent enum. */\n    mfxExtBuffer** ExtParam;       /*!&lt; Points to an array of pointers to the extra configuration structures; see the ExtendedBufferID enumerator for a list of extended configurations. */\n    mfxU16         NumExtParam;    /*!&lt; The number of extra configuration structures attached to the structure. */\n    mfxU16         reserved[11];\n} mfxExtTuneEncodeQuality;\nMFX_PACK_END()\n#endif\n\n#ifdef ONEVPL_EXPERIMENTAL\n/* The mfxAutoSelectImplType enumerator specifies the method for automatically selecting an implementation. */\ntypedef enum {\n    MFX_AUTO_SELECT_IMPL_TYPE_UNKNOWN = 0,         /*!&lt; Unspecified automatic implementation selection. */\n    MFX_AUTO_SELECT_IMPL_TYPE_DEVICE_HANDLE = 1,   /*!&lt; Select implementation corresponding to device handle. */\n} mfxAutoSelectImplType;\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! Specifies that an implementation should be selected which matches the device handle provided by the application. */\ntypedef struct {\n    mfxAutoSelectImplType AutoSelectImplType;      /*!&lt; Must be set to MFX_AUTO_SELECT_IMPL_TYPE_DEVICE_HANDLE. */\n\n    mfxAccelerationMode   AccelMode;               /*!&lt; Hardware acceleration mode of provided device handle. */\n    mfxHandleType         DeviceHandleType;        /*!&lt; Type of provided device handle. */\n    mfxHDL                DeviceHandle;            /*!&lt; System handle to hardware device. */\n\n    mfxU16                reserved[8];             /*!&lt; Reserved for future use. */\n} mfxAutoSelectImplDeviceHandle;\nMFX_PACK_END()\n#endif\n\n#ifdef __cplusplus\n} // extern &quot;C&quot;\n\n#endif\n\n\n#endif\n"}, "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxdefs.h": {"id": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxdefs.h", "filePath": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxdefs.h", "content": "/*############################################################################\n  # Copyright Intel Corporation\n  #\n  # SPDX-License-Identifier: MIT\n  ############################################################################*/\n\n#ifndef __MFXDEFS_H__\n#define __MFXDEFS_H__\n\n#define MFX_VERSION_MAJOR 2\n#define MFX_VERSION_MINOR 10\n\n// MFX_VERSION - version of API that &#x27;assumed&#x27; by build may be provided externally\n// if it omitted then latest stable API derived from Major.Minor is assumed\n\n\n#if !defined(MFX_VERSION)\n    #define MFX_VERSION (MFX_VERSION_MAJOR * 1000 + MFX_VERSION_MINOR)\n#else\n  #undef MFX_VERSION_MAJOR\n  #define MFX_VERSION_MAJOR ((MFX_VERSION) / 1000)\n  \n  #undef MFX_VERSION_MINOR\n  #define MFX_VERSION_MINOR ((MFX_VERSION) % 1000)\n#endif\n\n/*! The corresponding version of the Intel(r) Media SDK legacy API that is used as a basis\n   for the current API. */\n\n#define MFX_LEGACY_VERSION 1035\n\n\n#ifdef __cplusplus\nextern &quot;C&quot;\n{\n#endif /* __cplusplus */\n\n/* In preprocessor syntax # symbol has stringize meaning,\n   so to expand some macro to preprocessor pragma we need to use\n   special compiler dependent construction */\n\n#if defined(_MSC_VER)\n    #define MFX_PRAGMA_IMPL(x) __pragma(x)\n#else\n    #define MFX_PRAGMA_IMPL(x) _Pragma(#x)\n#endif\n\n#define MFX_PACK_BEGIN_X(x) MFX_PRAGMA_IMPL(pack(push, x))\n#define MFX_PACK_END()      MFX_PRAGMA_IMPL(pack(pop))\n\n/* The general rule for alignment is following:\n   - structures with pointers have 4/8 bytes alignment on 32/64 bit systems\n   - structures with fields of type mfxU64/mfxF64 (unsigned long long / double)\n     have alignment 8 bytes on 64 bit and 32 bit Windows, on Linux alignment is 4 bytes\n   - all the rest structures are 4 bytes aligned\n   - there are several exceptions: some structs which had 4-byte alignment were extended\n     with pointer / long type fields; such structs have 4-byte alignment to keep binary\n     compatibility with previously release API */\n\n#define MFX_PACK_BEGIN_USUAL_STRUCT()        MFX_PACK_BEGIN_X(4)\n\n/* 64-bit LP64 data model */\n#if defined(_WIN64) || defined(__LP64__)\n    #define MFX_PACK_BEGIN_STRUCT_W_PTR()    MFX_PACK_BEGIN_X(8)\n    #define MFX_PACK_BEGIN_STRUCT_W_L_TYPE() MFX_PACK_BEGIN_X(8)\n/* 32-bit ILP32 data model Windows* (Intel(r) architecture) */\n#elif defined(_WIN32) || defined(_M_IX86) &amp;&amp; !defined(__linux__)\n    #define MFX_PACK_BEGIN_STRUCT_W_PTR()    MFX_PACK_BEGIN_X(4)\n    #define MFX_PACK_BEGIN_STRUCT_W_L_TYPE() MFX_PACK_BEGIN_X(8)\n/* 32-bit ILP32 data model Linux* */\n#elif defined(__ILP32__) || defined(__arm__)\n    #define MFX_PACK_BEGIN_STRUCT_W_PTR()    MFX_PACK_BEGIN_X(4)\n    #define MFX_PACK_BEGIN_STRUCT_W_L_TYPE() MFX_PACK_BEGIN_X(4)\n#else\n    #error Unknown packing\n#endif\n\n#ifdef _WIN32\n  #define MFX_CDECL __cdecl\n  #define MFX_STDCALL __stdcall\n#else\n  #define MFX_CDECL\n  #define MFX_STDCALL\n#endif /* _WIN32 */\n\n#define MFX_INFINITE 0xFFFFFFFF\n\n#ifndef MFX_DEPRECATED_OFF\n   #if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201402L\n     #define MFX_DEPRECATED [[deprecated]]\n     #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg [[deprecated]]\n     #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n   #elif defined(__clang__)\n     #define MFX_DEPRECATED __attribute__((deprecated))\n     #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg __attribute__((deprecated))\n     #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n   #elif defined(__INTEL_COMPILER)\n     #if (defined(_WIN32) || defined(_WIN64))\n       #define MFX_DEPRECATED __declspec(deprecated)\n       #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg\n       #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg) __pragma(deprecated(arg))\n     #elif defined(__linux__)\n       #define MFX_DEPRECATED __attribute__((deprecated))\n       #if defined(__cplusplus)\n         #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg __attribute__((deprecated))\n       #else\n         #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg\n       #endif\n       #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n     #endif\n   #elif defined(_MSC_VER) &amp;&amp; _MSC_VER &gt; 1200 // VS 6 doesn&#x27;t support deprecation\n     #define MFX_DEPRECATED __declspec(deprecated)\n     #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg\n     #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg) __pragma(deprecated(arg))\n   #elif defined(__GNUC__)\n     #define MFX_DEPRECATED __attribute__((deprecated))\n     #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg __attribute__((deprecated))\n     #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n   #else\n     #define MFX_DEPRECATED\n     #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg\n     #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n   #endif\n #else\n   #define MFX_DEPRECATED\n   #define MFX_DEPRECATED_ENUM_FIELD_INSIDE(arg) arg\n   #define MFX_DEPRECATED_ENUM_FIELD_OUTSIDE(arg)\n #endif\n \ntypedef unsigned char       mfxU8;         /*!&lt; Unsigned integer, 8 bit type. */\ntypedef char                mfxI8;         /*!&lt; Signed integer, 8 bit type. */\ntypedef short               mfxI16;        /*!&lt; Signed integer, 16 bit type. */\ntypedef unsigned short      mfxU16;        /*!&lt; Unsigned integer, 16 bit type. */\ntypedef unsigned int        mfxU32;        /*!&lt; Unsigned integer, 32 bit type. */\ntypedef int                 mfxI32;        /*!&lt; Signed integer, 32 bit type. */\n#if defined( _WIN32 ) || defined ( _WIN64 )\ntypedef unsigned long       mfxUL32;       /*!&lt; Unsigned integer, 32 bit type. */\ntypedef long                mfxL32;        /*!&lt; Signed integer, 32 bit type. */\n#else\ntypedef unsigned int        mfxUL32;       /*!&lt; Unsigned integer, 32 bit type. */\ntypedef int                 mfxL32;        /*!&lt; Signed integer, 32 bit type. */\n#endif\ntypedef float               mfxF32;        /*!&lt; Single-precision floating point, 32 bit type. */\ntypedef double              mfxF64;        /*!&lt; Double-precision floating point, 64 bit type. */\ntypedef unsigned long long  mfxU64;        /*!&lt; Unsigned integer, 64 bit type. */\ntypedef long long           mfxI64;        /*!&lt; Signed integer, 64 bit type. */\ntypedef void*               mfxHDL;        /*!&lt; Handle type. */\ntypedef mfxHDL              mfxMemId;      /*!&lt; Memory ID type. */\ntypedef void*               mfxThreadTask; /*!&lt; Thread task type. */\ntypedef char                mfxChar;       /*!&lt; UTF-8 byte. */\ntypedef unsigned short      mfxFP16;       /*!&lt; Half precision floating point, 16 bit type. */\n\n/* MFX structures version info */\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Introduce the field Version for any structure.\nAssumed that any structure changes are backward binary compatible.\n mfxStructVersion starts from {1,0} for any new API structures. If mfxStructVersion is\n added to the existent legacy structure (replacing reserved fields) it starts from {1, 1}.\n*/\ntypedef union {\n    /*! Structure with Major and Minor fields.  */\n    /*! @struct Anonymous */\n    struct {\n      /*! @{\n      @name Major and Minor fields\n      Anonymous structure with Major and Minor fields. Minor number is incremented when reserved fields are used. Major number is incremented when the size of structure is increased. */\n        mfxU8  Minor; /*!&lt; Minor number of the correspondent structure. */\n        mfxU8  Major; /*!&lt; Major number of the correspondent structure. */\n      /*! @} */\n    };\n    mfxU16  Version;   /*!&lt; Structure version number. */\n} mfxStructVersion;\nMFX_PACK_END()\n\n#define MFX_STRUCT_VERSION(MAJOR, MINOR) (256*(MAJOR) + (MINOR))\n\n#define MFX_VARIANT_VERSION MFX_STRUCT_VERSION(1, 1)\n\n/*! The mfxDataType enumerates data type for mfxDataType. */\ntypedef enum {\n    MFX_DATA_TYPE_UNSET   = 0,            /*!&lt; Undefined type. */\n    MFX_DATA_TYPE_U8,                     /*!&lt; 8-bit unsigned integer. */\n    MFX_DATA_TYPE_I8,                     /*!&lt; 8-bit signed integer. */\n    MFX_DATA_TYPE_U16,                    /*!&lt; 16-bit unsigned integer. */\n    MFX_DATA_TYPE_I16,                    /*!&lt; 16-bit signed integer. */\n    MFX_DATA_TYPE_U32,                    /*!&lt; 32-bit unsigned integer. */\n    MFX_DATA_TYPE_I32,                    /*!&lt; 32-bit signed integer. */\n    MFX_DATA_TYPE_U64,                    /*!&lt; 64-bit unsigned integer. */\n    MFX_DATA_TYPE_I64,                    /*!&lt; 64-bit signed integer. */\n    MFX_DATA_TYPE_F32,                    /*!&lt; 32-bit single precision floating point. */\n    MFX_DATA_TYPE_F64,                    /*!&lt; 64-bit double precision floating point. */\n    MFX_DATA_TYPE_PTR,                    /*!&lt; Generic type pointer. */\n    MFX_DATA_TYPE_FP16,                   /*!&lt; 16-bit half precision floating point. */\n}mfxDataType;\n\n/*! The mfxVariantType enumerator data types for mfxVariantType. */\ntypedef enum {\n    MFX_VARIANT_TYPE_UNSET = MFX_DATA_TYPE_UNSET,                        /*!&lt; Undefined type. */\n    MFX_VARIANT_TYPE_U8    = MFX_DATA_TYPE_U8,                           /*!&lt; 8-bit unsigned integer. */\n    MFX_VARIANT_TYPE_I8    = MFX_DATA_TYPE_I8,                           /*!&lt; 8-bit signed integer. */\n    MFX_VARIANT_TYPE_U16   = MFX_DATA_TYPE_U16,                          /*!&lt; 16-bit unsigned integer. */\n    MFX_VARIANT_TYPE_I16   = MFX_DATA_TYPE_I16,                          /*!&lt; 16-bit signed integer. */\n    MFX_VARIANT_TYPE_U32   = MFX_DATA_TYPE_U32,                          /*!&lt; 32-bit unsigned integer. */\n    MFX_VARIANT_TYPE_I32   = MFX_DATA_TYPE_I32,                          /*!&lt; 32-bit signed integer. */\n    MFX_VARIANT_TYPE_U64   = MFX_DATA_TYPE_U64,                          /*!&lt; 64-bit unsigned integer. */\n    MFX_VARIANT_TYPE_I64   = MFX_DATA_TYPE_I64,                          /*!&lt; 64-bit signed integer. */\n    MFX_VARIANT_TYPE_F32   = MFX_DATA_TYPE_F32,                          /*!&lt; 32-bit single precision floating point. */\n    MFX_VARIANT_TYPE_F64   = MFX_DATA_TYPE_F64,                          /*!&lt; 64-bit double precision floating point. */\n    MFX_VARIANT_TYPE_PTR   = MFX_DATA_TYPE_PTR,                          /*!&lt; Generic type pointer. */\n    MFX_VARIANT_TYPE_FP16  = MFX_DATA_TYPE_FP16,                         /*!&lt; 16-bit half precision floating point. */\n} mfxVariantType;\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! The mfxVariantType enumerator data types for mfxVariant type. */\ntypedef struct {\n    mfxStructVersion Version;    /*!&lt; Version of the structure. */\n    mfxVariantType   Type;       /*!&lt; Value type. */\n    /*! Value data holder. */\n    union data {\n        mfxU8   U8; /*!&lt; mfxU8 data. */\n        mfxI8   I8; /*!&lt; mfxI8 data. */\n        mfxU16 U16; /*!&lt; mfxU16 data. */\n        mfxI16 I16; /*!&lt; mfxI16 data. */\n        mfxU32 U32; /*!&lt; mfxU32 data. */\n        mfxI32 I32; /*!&lt; mfxI32 data. */\n        mfxU64 U64; /*!&lt; mfxU64 data. */\n        mfxI64 I64; /*!&lt; mfxI64 data. */\n        mfxF32 F32; /*!&lt; mfxF32 data. */\n        mfxF64 F64; /*!&lt; mfxF64 data. */\n        mfxFP16 FP16; /*!&lt; mfxFP16 data. */\n        mfxHDL Ptr; /*!&lt; Pointer. When this points to a string the string must be null terminated. */\n    } Data;         /*!&lt; Value data member. */\n} mfxVariant;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Represents a range of unsigned values. */\ntypedef struct {\n    mfxU32 Min;  /*!&lt; Minimal value of the range. */\n    mfxU32 Max;  /*!&lt; Maximal value of the range. */\n    mfxU32 Step; /*!&lt; Value increment. */\n} mfxRange32U;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Represents a pair of numbers of type mfxI16. */\ntypedef struct {\n    mfxI16  x; /*!&lt; First number. */\n    mfxI16  y; /*!&lt; Second number. */\n} mfxI16Pair;\nMFX_PACK_END()\n\nMFX_PACK_BEGIN_STRUCT_W_PTR()\n/*! Represents pair of handles of type mfxHDL. */\ntypedef struct {\n    mfxHDL first;  /*!&lt; First handle. */\n    mfxHDL second; /*!&lt; Second handle. */\n} mfxHDLPair;\nMFX_PACK_END()\n\n/*********************************************************************************\\\nError message\n\\*********************************************************************************/\n/*! @enum mfxStatus Itemizes status codes returned by API functions. */\ntypedef enum\n{\n    /* no error */\n    MFX_ERR_NONE                        = 0,    /*!&lt; No error. */\n    /* reserved for unexpected errors */\n    MFX_ERR_UNKNOWN                     = -1,   /*!&lt; Unknown error. */\n\n    /* error codes &lt;0 */\n    MFX_ERR_NULL_PTR                    = -2,   /*!&lt; Null pointer. */\n    MFX_ERR_UNSUPPORTED                 = -3,   /*!&lt; Unsupported feature. */\n    MFX_ERR_MEMORY_ALLOC                = -4,   /*!&lt; Failed to allocate memory. */\n    MFX_ERR_NOT_ENOUGH_BUFFER           = -5,   /*!&lt; Insufficient buffer at input/output. */\n    MFX_ERR_INVALID_HANDLE              = -6,   /*!&lt; Invalid handle. */\n    MFX_ERR_LOCK_MEMORY                 = -7,   /*!&lt; Failed to lock the memory block. */\n    MFX_ERR_NOT_INITIALIZED             = -8,   /*!&lt; Member function called before initialization. */\n    MFX_ERR_NOT_FOUND                   = -9,   /*!&lt; The specified object is not found. */\n    MFX_ERR_MORE_DATA                   = -10,  /*!&lt; Expect more data at input. */\n    MFX_ERR_MORE_SURFACE                = -11,  /*!&lt; Expect more surface at output. */\n    MFX_ERR_ABORTED                     = -12,  /*!&lt; Operation aborted. */\n    MFX_ERR_DEVICE_LOST                 = -13,  /*!&lt; Lose the hardware acceleration device. */\n    MFX_ERR_INCOMPATIBLE_VIDEO_PARAM    = -14,  /*!&lt; Incompatible video parameters. */\n    MFX_ERR_INVALID_VIDEO_PARAM         = -15,  /*!&lt; Invalid video parameters. */\n    MFX_ERR_UNDEFINED_BEHAVIOR          = -16,  /*!&lt; Undefined behavior. */\n    MFX_ERR_DEVICE_FAILED               = -17,  /*!&lt; Device operation failure. */\n    MFX_ERR_MORE_BITSTREAM              = -18,  /*!&lt; Expect more bitstream buffers at output. */\n    MFX_ERR_GPU_HANG                    = -21,  /*!&lt; Device operation failure caused by GPU hang. */\n    MFX_ERR_REALLOC_SURFACE             = -22,  /*!&lt; Bigger output surface required. */\n    MFX_ERR_RESOURCE_MAPPED             = -23,  /*!&lt; Write access is already acquired and user requested\n                                                   another write access, or read access with MFX_MEMORY_NO_WAIT flag. */\n    MFX_ERR_NOT_IMPLEMENTED             = -24,   /*!&lt; Feature or function not implemented. */\n\n#ifdef ONEVPL_EXPERIMENTAL\n    MFX_ERR_MORE_EXTBUFFER              = -25,   /*!&lt; Expect additional extended configuration buffer. */\n#endif\n\n    /* warnings &gt;0 */\n    MFX_WRN_IN_EXECUTION                = 1,    /*!&lt; The previous asynchronous operation is in execution. */\n    MFX_WRN_DEVICE_BUSY                 = 2,    /*!&lt; The hardware acceleration device is busy. */\n    MFX_WRN_VIDEO_PARAM_CHANGED         = 3,    /*!&lt; The video parameters are changed during decoding. */\n    MFX_WRN_PARTIAL_ACCELERATION        = 4,    /*!&lt; Software acceleration is used. */\n    MFX_WRN_INCOMPATIBLE_VIDEO_PARAM    = 5,    /*!&lt; Incompatible video parameters. */\n    MFX_WRN_VALUE_NOT_CHANGED           = 6,    /*!&lt; The value is saturated based on its valid range. */\n    MFX_WRN_OUT_OF_RANGE                = 7,    /*!&lt; The value is out of valid range. */\n    MFX_WRN_FILTER_SKIPPED              = 10,   /*!&lt; One of requested filters has been skipped. */\n    /* low-delay partial output */\n    MFX_ERR_NONE_PARTIAL_OUTPUT         = 12,   /*!&lt; Frame is not ready, but bitstream contains partial output. */\n\n    MFX_WRN_ALLOC_TIMEOUT_EXPIRED       = 13,   /*!&lt; Timeout expired for internal frame allocation. */\n\n    /* threading statuses */\n    MFX_TASK_DONE = MFX_ERR_NONE,               /*!&lt; Task has been completed. */\n    MFX_TASK_WORKING                    = 8,    /*!&lt; There is some more work to do. */\n    MFX_TASK_BUSY                       = 9,    /*!&lt; Task is waiting for resources. */\n\n    /* plug-in statuses */\n    MFX_ERR_MORE_DATA_SUBMIT_TASK       = -10000, /*!&lt; Return MFX_ERR_MORE_DATA but submit internal asynchronous task. */\n\n} mfxStatus;\n\n\nMFX_PACK_BEGIN_USUAL_STRUCT()\n/*! Represents Globally Unique Identifier (GUID) with memory layout \n    compliant to RFC 4122. See https://www.rfc-editor.org/info/rfc4122 for details. */\ntypedef struct\n{\n    mfxU8 Data[16]; /*!&lt; Array to keep GUID. */\n} mfxGUID;\nMFX_PACK_END()\n\n\n\n// Application\n#if defined(MFX_DISPATCHER_EXPOSED_PREFIX)\n\n#include &quot;mfxdispatcherprefixedfunctions.h&quot;\n\n#endif // MFX_DISPATCHER_EXPOSED_PREFIX\n\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __MFXDEFS_H__ */\n"}}, "reports": [{"fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/include/sysmem_allocator.h", "reportHash": "0cf6e87094133e52ccef8b3459b4d5a9", "checker": {"name": "cppcoreguidelines-special-member-functions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/special-member-functions.html"}, "analyzerName": "clang-tidy", "line": 42, "column": 7, "message": "class 'SysMemFrameAllocator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "events": [{"message": "class 'SysMemFrameAllocator' defines a non-default destructor but does not define a copy constructor, a copy assignment operator, a move constructor or a move assignment operator", "fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/include/sysmem_allocator.h", "line": 42, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "reportHash": "d811f8dc1fa6baff9bedb7c38ffb7156", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 106, "column": 10, "message": "'MFX_FOURCC_RGB3' is deprecated", "events": [{"message": "'MFX_FOURCC_RGB3' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxstructures.h", "line": 143, "column": 5}, {"message": "expanded from macro 'MFX_DEPRECATED_ENUM_FIELD_INSIDE'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxdefs.h", "line": 91, "column": 58}, {"message": "'MFX_FOURCC_RGB3' is deprecated", "fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "line": 106, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "reportHash": "d811f8dc1fa6baff9bedb7c38ffb7156", "checker": {"name": "clang-diagnostic-deprecated-declarations", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wdeprecated-declarations"}, "analyzerName": "clang-tidy", "line": 248, "column": 10, "message": "'MFX_FOURCC_RGB3' is deprecated", "events": [{"message": "'MFX_FOURCC_RGB3' has been explicitly marked deprecated here", "fileId": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxstructures.h", "line": 143, "column": 5}, {"message": "expanded from macro 'MFX_DEPRECATED_ENUM_FIELD_INSIDE'", "fileId": "/home/misha/nika/nx_open/build/.conan/data/libvpl/2023.4.0/_/_/package/3d6c76bdeaa1ceb112780fb2734daaeca81ea6cc/include/vpl/mfxdefs.h", "line": 91, "column": 58}, {"message": "'MFX_FOURCC_RGB3' is deprecated", "fileId": "/home/misha/nika/nx_open/artifacts/intel_media_sdk/samples/sample_common/src/sysmem_allocator.cpp", "line": 248, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
